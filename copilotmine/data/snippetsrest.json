[
{
    "id": "1538",
    "source": "leetcode",
    "language": "python",
    "query": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "snippets": [
        "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    for c in s:\n        if c in s_dict:\n            s_dict[c] += 1\n        else:\n            s_dict[c] = 1\n    for c in t:\n        if c in s_dict:\n            s_dict[c] -= 1\n        else:\n            s_dict[c] = 1\n    for c in s_dict:\n        if s_dict[c] != 0:\n            return False\n    return True\n",
        "def isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    t_dict = {}\n    for i in s:\n        if i in s_dict:\n            s_dict[i] += 1\n        else:\n            s_dict[i] = 1\n    for i in t:\n        if i in t_dict:\n            t_dict[i] += 1\n        else:\n            t_dict[i] = 1\n    for i in s_dict:\n        if i not in t_dict or s_dict[i] != t_dict[i]:\n            return False\n    return True\n",
        "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    for c in s:\n        if c in s_dict:\n            s_dict[c] += 1\n        else:\n            s_dict[c] = 1\n    for c in t:\n        if c in s_dict:\n            s_dict[c] -= 1\n        else:\n            s_dict[c] = 1\n    for v in s_dict.values():\n        if v != 0:\n            return False\n    return True\n",
        "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    for char in s:\n        if char in s_dict:\n            s_dict[char] += 1\n        else:\n            s_dict[char] = 1\n    for char in t:\n        if char in s_dict:\n            s_dict[char] -= 1\n        else:\n            s_dict[char] = 1\n    for key in s_dict:\n        if s_dict[key] != 0:\n            return False\n    return True\n",
        "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    for i in s:\n        if i in s_dict:\n            s_dict[i] += 1\n        else:\n            s_dict[i] = 1\n    for i in t:\n        if i in s_dict:\n            s_dict[i] -= 1\n        else:\n            s_dict[i] = 1\n    for i in s_dict:\n        if s_dict[i] != 0:\n            return False\n    return True\n",
        "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    t_dict = {}\n    for i in range(len(s)):\n        if s[i] in s_dict:\n            s_dict[s[i]] += 1\n        else:\n            s_dict[s[i]] = 1\n        if t[i] in t_dict:\n            t_dict[t[i]] += 1\n        else:\n            t_dict[t[i]] = 1\n    for key in s_dict:\n        if key not in t_dict:\n            return False\n        if s_dict[key] != t_dict[key]:\n            return False\n    return True\n",
        "def is_anagram(s, t):\n    return sorted(s) == sorted(t)\n"
    ],
    "results": 10
},{
    "id": "1539",
    "source": "leetcode",
    "language": "python",
    "query": "There are n rooms labeled from 0 to n - 1. All the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.",
    "snippets": [
        "def canVisitAllRooms(self, rooms):\n    \"\"\"\n    :type rooms: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    visited = [False] * len(rooms)\n    visited[0] = True\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                stack.append(key)\n    return all(visited)\n",
        "def canVisitAllRooms(self, rooms):\n    \"\"\"\n    :type rooms: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    visited = [False] * len(rooms)\n    visited[0] = True\n    queue = [0]\n    while queue:\n        room = queue.pop(0)\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                queue.append(key)\n    return all(visited)\n",
        "def canVisitAllRooms(rooms):\n    \"\"\"\n    :type rooms: List[List[int]]\n    :rtype: bool\n    \"\"\"\n    visited = [False] * len(rooms)\n    visited[0] = True\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                stack.append(key)\n    return all(visited)\n",
        "def canVisitAllRooms(rooms):\n    visited = [False] * len(rooms)\n    visited[0] = True\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                stack.append(key)\n    return all(visited)\n",
        "def canVisitAllRooms(rooms):\n    visited = [False] * len(rooms)\n    visited[0] = True\n    queue = [0]\n    while queue:\n        room = queue.pop(0)\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                queue.append(key)\n    return all(visited)\n",
        "def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n    visited = [False] * len(rooms)\n    visited[0] = True\n    stack = [0]\n    while stack:\n        curr = stack.pop()\n        for key in rooms[curr]:\n            if not visited[key]:\n                visited[key] = True\n                stack.append(key)\n    return all(visited)\n",
        "def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n    visited = [False] * len(rooms)\n    visited[0] = True\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        for key in rooms[room]:\n            if not visited[key]:\n                visited[key] = True\n                stack.append(key)\n    return all(visited)\n",
        "def canVisitAllRooms(n, arr):\n    visited = [False] * n\n    visited[0] = True\n    stack = [0]\n    while stack:\n        room = stack.pop()\n        for key in arr[room]:\n            if not visited[key]:\n                visited[key] = True\n                stack.append(key)\n    return all(visited)\n"
    ],
    "results": 10
},{
    "id": "1540",
    "source": "leetcode",
    "language": "python",
    "query": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation. For example, The integer 5 is \"101\" in binary and its complement is \"010\" which is theinteger 2.",
    "snippets": [
        "def findComplement(num):\n    return int(''.join(['1' if i == '0' else '0' for i in bin(num)[2:]]), 2)\n",
        "def findComplement(num):\n    return int(''.join(['1' if x == '0' else '0' for x in bin(num)[2:]]), 2)\n",
        "def findComplement(num):\n    return int(bin(~num)[2:], 2)\n",
        "def findComplement(num):\n    return int(bin(num)[2:], 2) ^ int(bin(~0)[2:], 2)\n",
        "def findComplement(num):\n    return int(bin(~num)[3:], 2)\n"
    ],
    "results": 10
},{
    "id": "1541",
    "source": "leetcode",
    "language": "python",
    "query": "Given a sorted linked list, delete all nodes that have duplicate numbers. Return the linked list sorted as well.",
    "snippets": [
        "def deleteDuplicates(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    if head.val == head.next.val:\n        head.next = head.next.next\n        return deleteDuplicates(head)\n    head.next = deleteDuplicates(head.next)\n    return head\n",
        "def deleteDuplicates(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    if head.val == head.next.val:\n        head.next = head.next.next\n        return deleteDuplicates(head)\n    else:\n        head.next = deleteDuplicates(head.next)\n        return head\n",
        "def deleteDuplicates(head):\n    if head is None:\n        return None\n    curr = head\n    while curr.next is not None:\n        if curr.val == curr.next.val:\n            curr.next = curr.next.next\n        else:\n            curr = curr.next\n    return head\n"
    ],
    "results": 10
},{
    "id": "1542",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.",
    "snippets": [
        "def getRow(rowIndex):\n    if rowIndex == 0:\n        return [1]\n    if rowIndex == 1:\n        return [1,1]\n    row = [1,1]\n    for i in range(2,rowIndex+1):\n        row = [1] + [row[i-1]+row[i-2] for i in range(1,i)] + [1]\n    return row\n",
        "def generate(rowIndex):\n    if rowIndex == 0:\n        return [1]\n    if rowIndex == 1:\n        return [1,1]\n    if rowIndex == 2:\n        return [1,2,1]\n    if rowIndex == 3:\n        return [1,3,3,1]\n    if rowIndex == 4:\n        return [1,4,6,4,1]\n    if rowIndex == 5:\n        return [1,5,10,10,5,1]\n    if rowIndex == 6:\n        return [1,6,15,20,15,6,1]\n    if rowIndex == 7:\n        return [1,7,21,35,35,21,7,1]\n    if rowIndex == 8:\n        return [1,8,28,56,70,56,28,8,1]\n    if rowIndex == 9:\n        return [1,9,36,84,126,126,84,36,9,1]\n    if rowIndex == 10:\n        return [1,10,45,120,210,252,210,120,45,10,1]\n    if rowIndex == 11:\n        return [1,11,55,165,330,462,462,330,165,55,11,1]\n    if rowIndex == 12:\n        return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n    if rowIndex == 13:\n        return [1,13,78,286,715,1287,1716,1716,1287,715,286,78,13,1]\n    if rowIndex == 14:\n        return [1,14,91,364,1001,2002,3003,3432,3003,2002,1001,364,91,14,1]\n    if rowIndex == 15:\n        return [1,15,105,455,1365,3003,5005,6435,6435,5005,3003,1365,455,105,15,1]\n    if rowIndex == 16:\n        return [\n",
        "def generate(rowIndex):\n    if rowIndex == 0:\n        return [1]\n    if rowIndex == 1:\n        return [1,1]\n    prev = generate(rowIndex-1)\n    return [prev[i] + prev[i+1] for i in range(rowIndex)]\n",
        "def generate(rowIndex):\n    if rowIndex == 0:\n        return [1]\n    if rowIndex == 1:\n        return [1,1]\n    else:\n        prev = generate(rowIndex-1)\n        return [prev[i] + prev[i+1] for i in range(rowIndex)]\n"
    ],
    "results": 10
},{
    "id": "1543",
    "source": "leetcode",
    "language": "python",
    "query": "Algorithm is based on a stream of records about a stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp.",
    "snippets": [
        "def get_max_profit(stock_prices_on_a_day):\n    if len(stock_prices_on_a_day) < 2:\n        raise ValueError('Getting a profit requires at least 2 prices')\n\n    min_price = stock_prices_on_a_day[0]\n    max_profit = stock_prices_on_a_day[1] - stock_prices_on_a_day[0]\n\n    for index, current_price in enumerate(stock_prices_on_a_day):\n        if index == 0:\n            continue\n\n        potential_profit = current_price - min_price\n\n        max_profit = max(max_profit, potential_profit)\n\n        min_price = min(min_price, current_price)\n\n    return max_profit\n",
        "def main():\n    # Read the input file\n    with open('input.txt', 'r') as f:\n        # Read the first line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the strings to integers\n        line = [int(x) for x in line]\n        # Save the first timestamp\n        timestamp = line[0]\n        # Save the first price\n        price = line[1]\n        # Save the first price\n        price_min = price\n        # Save the first price\n        price_max = price\n        # Save the first price\n        price_avg = price\n        # Save the first price\n        price_sum = price\n        # Save the first price\n        price_count = 1\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the strings to integers\n        line = [int(x) for x in line]\n        # Save the next timestamp\n        timestamp_next = line[0]\n        # Save the next price\n        price_next = line[1]\n        # While there are still records in the file\n        while line:\n            # If the next timestamp is greater than the current timestamp\n            if timestamp_next > timestamp:\n                # Calculate the difference between the next timestamp and the current timestamp\n                diff = timestamp_next - timestamp\n                # Calculate the average price\n                price_avg = price_sum / price_count\n                # Calculate the minimum price\n                price_min = min(price, price_next)\n                # Calculate the maximum price\n                price_max = max(price, price_next)\n                # Calculate the sum of prices\n                price_sum += price_next\n                # Increment the count of prices\n                price_count += 1\n                # Save the next timestamp\n                timestamp = timestamp_next\n                # Save the next price\n                price = price_next\n                # Read the next line\n                line = f.readline()\n                # Split the line into a list of strings\n                line = line.split()\n",
        "def main():\n    # Read the input file\n    with open('input.txt', 'r') as f:\n        # Read the first line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the strings to integers\n        line = [int(x) for x in line]\n        # Initialize the variables\n        start_time = line[0]\n        end_time = line[1]\n        price = line[2]\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the strings to integers\n        line = [int(x) for x in line]\n        # Initialize the variables\n        start_time = line[0]\n        end_time = line[1]\n        price = line[2]\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the strings to integers\n        line = [int(x) for x in line]\n        # Initialize the variables\n        start_time = line[0]\n        end_time = line[1]\n        price = line[2]\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the strings to integers\n        line = [int(x) for x in line]\n        # Initialize the variables\n        start_time = line[0]\n        end_time = line[1]\n        price = line[2]\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the strings to integers\n        line = [int(x) for x in line]\n        # Initialize the variables\n        start_time = line[0]\n        end_time = line[1]\n        price = line[2]\n        # Read the next line\n        line = f.readline\n",
        "def main():\n    # Read the input file\n    with open('stock.txt', 'r') as f:\n        # Read the first line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the first string to an integer\n        timestamp = int(line[0])\n        # Convert the second string to a float\n        price = float(line[1])\n        # Initialize the minimum price\n        min_price = price\n        # Initialize the maximum price\n        max_price = price\n        # Initialize the sum of prices\n        sum_price = price\n        # Initialize the number of prices\n        num_prices = 1\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the first string to an integer\n        timestamp = int(line[0])\n        # Convert the second string to a float\n        price = float(line[1])\n        # Update the minimum price\n        if price < min_price:\n            min_price = price\n        # Update the maximum price\n        if price > max_price:\n            max_price = price\n        # Update the sum of prices\n        sum_price += price\n        # Update the number of prices\n        num_prices += 1\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.split()\n        # Convert the first string to an integer\n        timestamp = int(line[0])\n        # Convert the second string to a float\n        price = float(line[1])\n        # Update the minimum price\n        if price < min_price:\n            min_price = price\n        # Update the maximum price\n        if price > max_price:\n            max_price = price\n        # Update the sum of prices\n        sum_price += price\n        # Update the number of prices\n        num_prices += 1\n        # Read the next line\n        line = f.readline()\n        # Split the line into a list of strings\n        line = line.\n",
        "def main():\n    # Read the input file\n    with open('input.txt', 'r') as f:\n        lines = f.readlines()\n    # Create a list of records\n    records = []\n    for line in lines:\n        records.append(line.split())\n    # Create a list of prices\n    prices = []\n    for record in records:\n        prices.append(float(record[1]))\n    # Calculate the average price\n    average_price = sum(prices) / len(prices)\n    # Calculate the standard deviation\n    standard_deviation = 0\n    for price in prices:\n        standard_deviation += (price - average_price) ** 2\n    standard_deviation = (standard_deviation / len(prices)) ** 0.5\n    # Calculate the minimum price\n    minimum_price = min(prices)\n    # Calculate the maximum price\n    maximum_price = max(prices)\n    # Calculate the range\n    range_ = maximum_price - minimum_price\n    # Calculate the median price\n    median_price = 0\n    if len(prices) % 2 == 0:\n        median_price = (prices[len(prices) // 2] + prices[len(prices) // 2 - 1]) / 2\n    else:\n        median_price = prices[len(prices) // 2]\n    # Calculate the number of prices above the average price\n    above_average_price = 0\n    for price in prices:\n        if price > average_price:\n            above_average_price += 1\n    # Calculate the number of prices below the average price\n    below_average_price = 0\n    for price in prices:\n        if price < average_price:\n            below_average_price += 1\n    # Calculate the number of prices within the standard deviation\n    within_standard_deviation = 0\n    for price in prices:\n        if (price - average_price) ** 2 <= standard_deviation ** 2:\n            within_standard_deviation += 1\n    # Calculate the number of prices outside the standard deviation\n    outside_standard_deviation = 0\n",
        "def main():\n    # Read the input file\n    with open('input.txt', 'r') as f:\n        lines = f.readlines()\n    # Create a list of tuples of the form (timestamp, price)\n    stock_list = []\n    for line in lines:\n        line = line.strip()\n        timestamp, price = line.split(',')\n        stock_list.append((timestamp, float(price)))\n    # Sort the list by timestamp\n    stock_list.sort(key=lambda x: x[0])\n    # Find the maximum profit\n    max_profit = 0\n    for i in range(len(stock_list) - 1):\n        max_profit = max(max_profit, stock_list[i + 1][1] - stock_list[i][1])\n    # Print the maximum profit\n    print(max_profit)\n",
        "def main():\n    # Read the input file\n    with open('input.txt', 'r') as f:\n        lines = f.readlines()\n    # Create a list of tuples (timestamp, price)\n    prices = []\n    for line in lines:\n        timestamp, price = line.split()\n        prices.append((int(timestamp), float(price)))\n    # Sort the list of tuples by timestamp\n    prices.sort(key=lambda x: x[0])\n    # Create a list of tuples (timestamp, price)\n    prices_copy = prices.copy()\n    # Create a list of tuples (timestamp, price)\n    prices_copy.sort(key=lambda x: x[1])\n    # Find the median price\n    median_price = prices_copy[len(prices_copy)//2][1]\n    # Find the average price\n    average_price = sum([price[1] for price in prices]) / len(prices)\n    # Find the maximum price\n    maximum_price = prices[-1][1]\n    # Find the minimum price\n    minimum_price = prices[0][1]\n    # Find the range of prices\n    range_price = maximum_price - minimum_price\n    # Find the number of prices\n    number_prices = len(prices)\n    # Find the number of prices above the average price\n    number_prices_above_average = sum([1 for price in prices if price[1] > average_price])\n    # Find the number of prices below the average price\n    number_prices_below_average = sum([1 for price in prices if price[1] < average_price])\n    # Find the number of prices above the median price\n    number_prices_above_median = sum([1 for price in prices if price[1] > median_price])\n    # Find the number of prices below the median price\n    number_prices_below_median = sum([1 for price in prices if price[1] < median_price])\n    # Find the number of prices above the maximum price\n    number_prices_above_maximum = sum([1 for price in prices\n",
        "def get_stock_price_list(stock_name):\n    \"\"\"\n    Returns a list of tuples of the form (timestamp, price) for the given stock.\n    \"\"\"\n    raise NotImplementedError\n",
        "def get_stock_price_list(stock_symbol):\n    \"\"\"\n    Returns a list of tuples of the form (timestamp, price) for the given stock symbol.\n    \"\"\"\n",
        "def main():\n    # Read the input file.\n    with open('input.txt', 'r') as f:\n        lines = f.readlines()\n    # Create a list of tuples. Each tuple contains a timestamp and the corresponding price of the stock at that timestamp.\n    stock_prices = []\n    for line in lines:\n        timestamp, price = line.split()\n        stock_prices.append((int(timestamp), float(price)))\n    # Sort the list of tuples by timestamp.\n    stock_prices.sort(key=lambda x: x[0])\n    # Create a list of tuples. Each tuple contains a timestamp and the corresponding price of the stock at that timestamp.\n    stock_prices_2 = []\n    for line in lines:\n        timestamp, price = line.split()\n        stock_prices_2.append((int(timestamp), float(price)))\n    # Sort the list of tuples by timestamp.\n    stock_prices_2.sort(key=lambda x: x[0])\n    # Create a list of tuples. Each tuple contains a timestamp and the corresponding price of the stock at that timestamp.\n    stock_prices_3 = []\n    for line in lines:\n        timestamp, price = line.split()\n        stock_prices_3.append((int(timestamp), float(price)))\n    # Sort the list of tuples by timestamp.\n    stock_prices_3.sort(key=lambda x: x[0])\n    # Create a list of tuples. Each tuple contains a timestamp and the corresponding price of the stock at that timestamp.\n    stock_prices_4 = []\n    for line in lines:\n        timestamp, price = line.split()\n        stock_prices_4.append((int(timestamp), float(price)))\n    # Sort the list of tuples by timestamp.\n    stock_prices_4.sort(key=lambda x: x[0])\n    # Create a list of tuples. Each tuple contains a timestamp and the corresponding price of the stock at that timestamp.\n    stock_prices_5 = []\n    for line in lines:\n        timestamp, price = line.\n"
    ],
    "results": 10
},{
    "id": "1544",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG) You are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.",
    "snippets": [
        "def topologicalSort(n, edges):\n    # Write your code here.\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for i in edges:\n        graph[i[0]].append(i[1])\n    print(graph)\n    visited = [False] * n\n    stack = []\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited, stack, graph)\n    return stack\n",
        "def topologicalSort(n, edges):\n    # Write your code here.\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    visited = [False] * n\n    stack = []\n    for i in range(n):\n        if not visited[i]:\n            topologicalSortUtil(i, graph, visited, stack)\n    return stack\n",
        "def topological_sort(n, edges):\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    print(graph)\n    visited = set()\n    stack = []\n    for i in range(n):\n        if i not in visited:\n            topological_sort_util(i, graph, visited, stack)\n    return stack\n",
        "def topological_sort(n, edges):\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    print(graph)\n    visited = [False] * n\n    stack = []\n    for i in range(n):\n        if not visited[i]:\n            topological_sort_util(i, visited, stack, graph)\n    print(stack)\n    return stack\n",
        "def topologicalSort(n, edges):\n    graph = {}\n    for edge in edges:\n        if edge[0] in graph:\n            graph[edge[0]].append(edge[1])\n        else:\n            graph[edge[0]] = [edge[1]]\n    queue = []\n    for key in graph:\n        if key not in graph:\n            queue.append(key)\n    result = []\n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        if node in graph:\n            for child in graph[node]:\n                graph[child].remove(node)\n                if not graph[child]:\n                    queue.append(child)\n    return result if len(result) == n else []\n",
        "def topological_sort(n, edges):\n    # Write your code here.\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for i in edges:\n        graph[i[0]].append(i[1])\n    queue = []\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            queue.append(i)\n            visited.add(i)\n            while queue:\n                node = queue.pop(0)\n                for child in graph[node]:\n                    if child not in visited:\n                        queue.append(child)\n                        visited.add(child)\n    return list(visited)\n",
        "def topologicalSort(n, edges):\n    graph = {}\n    for edge in edges:\n        if edge[0] not in graph:\n            graph[edge[0]] = []\n        graph[edge[0]].append(edge[1])\n    print(graph)\n    visited = set()\n    stack = []\n    for node in graph:\n        if node not in visited:\n            topologicalSortUtil(node, visited, stack, graph)\n    return stack\n",
        "def topological_sort(n, edges):\n    graph = {}\n    for edge in edges:\n        if edge[0] in graph:\n            graph[edge[0]].append(edge[1])\n        else:\n            graph[edge[0]] = [edge[1]]\n    queue = []\n    for key in graph:\n        if key not in graph.values():\n            queue.append(key)\n    result = []\n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        if node in graph:\n            for child in graph[node]:\n                graph[child].remove(node)\n                if child not in graph.values():\n                    queue.append(child)\n    if len(result) == n:\n        return result\n    else:\n        return []\n",
        "def DAG(n, edges):\n    # Write your code here.\n    graph = [[] for _ in range(n)]\n    for i, j in edges:\n        graph[i].append(j)\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if not dfs(graph, i, visited):\n                return False\n    return True\n",
        "def DAG_edges(n, edges):\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n    return graph\n"
    ],
    "results": 10
},{
    "id": "1545",
    "source": "leetcode",
    "language": "python",
    "query": "A subarray is defined as a contiguous block of elements in the array. Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.",
    "snippets": [
        "def smallestSubarray(nums, p):\n    \"\"\"\n    :type nums: List[int]\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    if sum(nums) % p == 0:\n        return 0\n    left = 0\n    right = 0\n    sum = 0\n    min_len = len(nums) + 1\n    while right < len(nums):\n        sum += nums[right]\n        while sum % p != 0:\n            sum -= nums[left]\n            left += 1\n        min_len = min(min_len, right - left + 1)\n        right += 1\n    return min_len if min_len != len(nums) + 1 else 0\n",
        "def removeSubarray(nums, p):\n    # Write your code here\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        if nums[0] % p == 0:\n            return 1\n        else:\n            return 0\n    if nums[0] % p == 0:\n        return 1 + removeSubarray(nums[1:], p)\n    else:\n        return removeSubarray(nums[1:], p)\n",
        "def removeSubarray(nums, p):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return 1 if nums[0] % p == 0 else 0\n    if len(nums) == 2:\n        return 1 if nums[0] % p == 0 and nums[1] % p == 0 else 0\n    if nums[0] % p == 0:\n        return 1 + removeSubarray(nums[1:], p)\n    if nums[-1] % p == 0:\n        return 1 + removeSubarray(nums[:-1], p)\n    if nums[0] % p == 0 and nums[-1] % p == 0:\n        return 2 + removeSubarray(nums[1:-1], p)\n    return removeSubarray(nums[1:], p)\n",
        "def smallest_subarray_with_given_sum(s, nums):\n    \"\"\"\n    :param s: int\n    :param nums: list[int]\n    :return: int\n    \"\"\"\n    if not nums:\n        return 0\n    if sum(nums) % s == 0:\n        return 0\n    min_length = len(nums) + 1\n    left = 0\n    sum_ = 0\n    for right in range(len(nums)):\n        sum_ += nums[right]\n        while sum_ % s != 0:\n            sum_ -= nums[left]\n            left += 1\n        min_length = min(min_length, right - left + 1)\n    return min_length if min_length <= len(nums) else 0\n",
        "def removeSubarray(nums, p):\n    # Write your code here\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        if nums[0] % p == 0:\n            return 1\n        else:\n            return 0\n    if nums[0] % p == 0:\n        return 1 + removeSubarray(nums[1:], p)\n    else:\n        return removeSubarray(nums[1:], p)\n",
        "def removeSubarrayDivisibleBy(nums, p):\n    \"\"\"\n    :type nums: List[int]\n    :type p: int\n    :rtype: int\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        if nums[0] % p == 0:\n            return 0\n        else:\n            return 1\n    if nums[0] % p == 0:\n        return 1\n    else:\n        return 1 + removeSubarrayDivisibleBy(nums[1:], p)\n",
        "def smallest_subarray_with_given_sum(nums, p):\n    # Write your code here\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n    if sum % p == 0:\n        return 0\n    min_len = len(nums)\n    for i in range(len(nums)):\n        sum -= nums[i]\n        if sum % p == 0:\n            min_len = min(min_len, i + 1)\n        sum += nums[i]\n    return min_len\n",
        "def removeSubarray(nums, p):\n    # Write your code here\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return 1 if nums[0] % p == 0 else 0\n    if nums[0] % p == 0:\n        return 1\n    if nums[-1] % p == 0:\n        return 1\n    if len(nums) == 2:\n        return 2 if nums[0] % p == 0 else 1\n    if nums[0] % p == 0:\n        return 1\n    if nums[-1] % p == 0:\n        return 1\n    if len(nums) == 3:\n        return 3 if nums[0] % p == 0 else 2\n    if nums[0] % p == 0:\n        return 1\n    if nums[-1] % p == 0:\n        return 1\n    if len(nums) == 4:\n        return 4 if nums[0] % p == 0 else 3\n    if nums[0] % p == 0:\n        return 1\n    if nums[-1] % p == 0:\n        return 1\n    if len(nums) == 5:\n        return 5 if nums[0] % p == 0 else 4\n    if nums[0] % p == 0:\n        return 1\n    if nums[-1] % p == 0:\n        return 1\n    if len(nums) == 6:\n        return 6 if nums[0] % p == 0 else 5\n    if nums[0] % p == 0:\n        return 1\n    if nums[-1] % p == 0:\n        return 1\n    if len(nums) == 7:\n        return 7 if nums[0] % p == 0 else 6\n    if nums[0] % p == 0:\n        return 1\n    if nums[-1] % p == 0:\n        return 1\n    if len(nums) == 8:\n        return 8 if nums[0] % p == 0 else 7\n    if nums[0] % p ==\n",
        "def smallest_subarray_with_divisible_sum(nums, p):\n    # Write your code here.\n    sum_ = 0\n    for num in nums:\n        sum_ += num\n    if sum_ % p == 0:\n        return 0\n    min_len = len(nums)\n    for i in range(len(nums)):\n        sum_ -= nums[i]\n        if sum_ % p == 0:\n            min_len = min(min_len, i + 1)\n        sum_ += nums[i]\n    return min_len\n"
    ],
    "results": 10
},{
    "id": "1546",
    "source": "leetcode",
    "language": "python",
    "query": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle. The answer is returned as an array [x, y].",
    "snippets": [
        "def randPoint(radius, x_center, y_center):\n    import random\n    x = random.uniform(x_center - radius, x_center + radius)\n    y = random.uniform(y_center - radius, y_center + radius)\n    return [x, y]\n",
        "def randPoint(radius, x_center, y_center):\n    import random\n    x = random.uniform(-radius, radius)\n    y = random.uniform(-radius, radius)\n    while (x**2 + y**2 > radius**2):\n        x = random.uniform(-radius, radius)\n        y = random.uniform(-radius, radius)\n    return [x + x_center, y + y_center]\n",
        "def randPoint(radius, x, y):\n    import random\n    while True:\n        x1 = random.uniform(-radius, radius)\n        y1 = random.uniform(-radius, radius)\n        if x1**2 + y1**2 <= radius**2:\n            return [x+x1, y+y1]\n",
        "def randPoint(radius, x_center, y_center):\n    import random\n    x = random.uniform(-radius, radius)\n    y = random.uniform(-radius, radius)\n    while x**2 + y**2 > radius**2:\n        x = random.uniform(-radius, radius)\n        y = random.uniform(-radius, radius)\n    return [x + x_center, y + y_center]\n",
        "def randPoint(radius, x, y):\n    import random\n    while True:\n        x_rand = random.uniform(x - radius, x + radius)\n        y_rand = random.uniform(y - radius, y + radius)\n        if (x_rand - x)**2 + (y_rand - y)**2 <= radius**2:\n            return [x_rand, y_rand]\n",
        "def randPoint(radius, x0, y0):\n    import random\n    x = random.uniform(-radius, radius)\n    y = random.uniform(-radius, radius)\n    while (x**2 + y**2 > radius**2):\n        x = random.uniform(-radius, radius)\n        y = random.uniform(-radius, radius)\n    return [x+x0, y+y0]\n"
    ],
    "results": 10
},{
    "id": "1547",
    "source": "leetcode",
    "language": "python",
    "query": "Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit. Given two numbers arr1 and arr2 in base -2, return the result of adding them together.",
    "snippets": [
        "def add(arr1, arr2):\n    carry = 0\n    result = []\n    for i in range(len(arr1)):\n        sum = arr1[i] + arr2[i] + carry\n        if sum == 0:\n            result.append(0)\n            carry = 0\n        elif sum == 1:\n            result.append(1)\n            carry = 0\n        elif sum == 2:\n            result.append(0)\n            carry = 1\n        elif sum == 3:\n            result.append(1)\n            carry = 1\n    if carry == 1:\n        result.append(1)\n    return result\n",
        "def add(arr1, arr2):\n    if len(arr1) > len(arr2):\n        arr2 = [0] * (len(arr1) - len(arr2)) + arr2\n    else:\n        arr1 = [0] * (len(arr2) - len(arr1)) + arr1\n    carry = 0\n    result = []\n    for i in range(len(arr1)):\n        sum = arr1[i] + arr2[i] + carry\n        if sum == 0:\n            carry = 0\n        elif sum == 1:\n            carry = 0\n            result.append(1)\n        elif sum == 2:\n            carry = 1\n            result.append(0)\n        elif sum == 3:\n            carry = 1\n            result.append(1)\n    if carry == 1:\n        result.append(1)\n    return result\n",
        "def add(arr1, arr2):\n    # Your code here\n    result = []\n    carry = 0\n    for i in range(len(arr1)):\n        sum = arr1[i] + arr2[i] + carry\n        if sum >= 2:\n            carry = 1\n            sum -= 2\n        else:\n            carry = 0\n        result.append(sum)\n    if carry == 1:\n        result.append(carry)\n    return result\n",
        "def add(arr1, arr2):\n    # Your code here\n    result = []\n    carry = 0\n    for i in range(len(arr1)):\n        sum = arr1[i] + arr2[i] + carry\n        if sum == 0:\n            result.append(0)\n            carry = 0\n        elif sum == 1:\n            result.append(1)\n            carry = 0\n        elif sum == 2:\n            result.append(0)\n            carry = 1\n        elif sum == 3:\n            result.append(1)\n            carry = 1\n    if carry == 1:\n        result.append(1)\n    return result\n",
        "def add_binary(arr1, arr2):\n    # your code here\n    result = []\n    carry = 0\n    for i in range(max(len(arr1), len(arr2))):\n        if i < len(arr1) and i < len(arr2):\n            sum = arr1[len(arr1)-i-1] + arr2[len(arr2)-i-1] + carry\n            if sum == 2:\n                result.append(0)\n                carry = 1\n            elif sum == 3:\n                result.append(1)\n                carry = 1\n            else:\n                result.append(sum)\n                carry = 0\n        elif i < len(arr1):\n            sum = arr1[len(arr1)-i-1] + carry\n            if sum == 2:\n                result.append(0)\n                carry = 1\n            else:\n                result.append(sum)\n                carry = 0\n        else:\n            sum = arr2[len(arr2)-i-1] + carry\n            if sum == 2:\n                result.append(0)\n                carry = 1\n            else:\n                result.append(sum)\n                carry = 0\n    if carry == 1:\n        result.append(1)\n    result.reverse()\n    return result\n",
        "def add_binary(arr1, arr2):\n    # Your code here\n    if len(arr1) > len(arr2):\n        arr2 = [0] * (len(arr1) - len(arr2)) + arr2\n    else:\n        arr1 = [0] * (len(arr2) - len(arr1)) + arr1\n    result = []\n    carry = 0\n    for i in range(len(arr1)):\n        sum = arr1[i] + arr2[i] + carry\n        if sum == 0:\n            result.append(0)\n            carry = 0\n        elif sum == 1:\n            result.append(1)\n            carry = 0\n        elif sum == 2:\n            result.append(0)\n            carry = 1\n        elif sum == 3:\n            result.append(1)\n            carry = 1\n    if carry == 1:\n        result.append(1)\n    return result\n",
        "def add(arr1, arr2):\n    # Your code here\n    if len(arr1) > len(arr2):\n        arr2 = [0] * (len(arr1) - len(arr2)) + arr2\n    else:\n        arr1 = [0] * (len(arr2) - len(arr1)) + arr1\n    carry = 0\n    result = []\n    for i in range(len(arr1)):\n        sum = arr1[i] + arr2[i] + carry\n        if sum >= 2:\n            carry = 1\n            result.append(sum - 2)\n        else:\n            carry = 0\n            result.append(sum)\n    if carry == 1:\n        result.append(1)\n    return result\n",
        "def add(arr1, arr2):\n    # Your code here\n    if len(arr1) > len(arr2):\n        arr2 = [0] * (len(arr1) - len(arr2)) + arr2\n    else:\n        arr1 = [0] * (len(arr2) - len(arr1)) + arr1\n    carry = 0\n    result = []\n    for i in range(len(arr1)):\n        sum = arr1[i] + arr2[i] + carry\n        if sum == 0:\n            carry = 0\n            result.append(0)\n        elif sum == 1:\n            carry = 0\n            result.append(1)\n        elif sum == 2:\n            carry = 1\n            result.append(0)\n        elif sum == 3:\n            carry = 1\n            result.append(1)\n    if carry == 1:\n        result.append(1)\n    return result\n",
        "def add(arr1, arr2):\n    # Your code here\n    arr1 = arr1[::-1]\n    arr2 = arr2[::-1]\n    carry = 0\n    result = []\n    for i in range(len(arr1)):\n        if i < len(arr2):\n            sum = arr1[i] + arr2[i] + carry\n        else:\n            sum = arr1[i] + carry\n        if sum == 0:\n            result.append(0)\n            carry = 0\n        elif sum == 1:\n            result.append(1)\n            carry = 0\n        elif sum == 2:\n            result.append(0)\n            carry = 1\n        elif sum == 3:\n            result.append(1)\n            carry = 1\n    if carry == 1:\n        result.append(1)\n    return result[::-1]\n"
    ],
    "results": 9
},{
    "id": "1548",
    "source": "leetcode",
    "language": "python",
    "query": "Return the number of connected components in nums where two values are connected if they appear consecutively. You are given the head of a linked list containing unique integer values and an integer array nums.",
    "snippets": [
        "def numComponents(head, nums):\n    nums = set(nums)\n    count = 0\n    while head:\n        if head.val in nums and head.next and head.next.val in nums:\n            count += 1\n        head = head.next\n    return count\n",
        "def num_components(head, nums):\n    nums = set(nums)\n    count = 0\n    while head:\n        if head.val in nums and head.next and head.next.val in nums:\n            count += 1\n        head = head.next\n    return count\n",
        "def num_components(head, nums):\n    nums = set(nums)\n    count = 0\n    while head:\n        if head.val in nums and head.next and head.next.val in nums:\n            count += 1\n            head = head.next.next\n        else:\n            head = head.next\n    return count\n",
        "def numComponents(head, nums):\n    \"\"\"\n    :type head: ListNode\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    nums = set(nums)\n    count = 0\n    while head:\n        if head.val in nums and head.next and head.next.val in nums:\n            count += 1\n        head = head.next\n    return count\n",
        "def num_components(head, nums):\n    num_components = 0\n    while head:\n        if head.val in nums:\n            num_components += 1\n            nums.remove(head.val)\n        head = head.next\n    return num_components\n",
        "def numComponents(head, nums):\n    \"\"\"\n    :type head: ListNode\n    :type G: List[int]\n    :rtype: int\n    \"\"\"\n    nums = set(nums)\n    count = 0\n    while head:\n        if head.val in nums and head.next and head.next.val in nums:\n            count += 1\n            head = head.next\n        else:\n            head = head.next\n    return count\n"
    ],
    "results": 9
},{
    "id": "1549",
    "source": "leetcode",
    "language": "python",
    "query": "Return the restaurant's �display table�. The first row should be a header whose first column is �Table�, followed by the names of the food items. Note that the customer names are not part of the table.",
    "snippets": [
        "def display_table(restaurant):\n    table = restaurant[\"table\"]\n    food_items = restaurant[\"food_items\"]\n    header = [\"Table\"]\n    for item in food_items:\n        header.append(item)\n    print(table.get_string(header=header))\n    return table.get_string(header=header)\n",
        "def display_table(restaurant):\n    table = restaurant['table']\n    food_items = restaurant['food_items']\n    table_header = ['Table']\n    for food_item in food_items:\n        table_header.append(food_item)\n    table_header.append('Total')\n    table_header.append('Status')\n    table_header.append('Customer')\n    table_header.append('Time')\n    table_header.append('Notes')\n    table_header.append('Order')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header.append('Order Status')\n    table_header.append('Order Customer')\n    table_header.append('Order Time')\n    table_header.append('Order Notes')\n    table_header\n",
        "def display_table(restaurant):\n    table = restaurant['table']\n    food_items = restaurant['food_items']\n    table_header = ['Table']\n    for item in food_items:\n        table_header.append(item)\n    table_header.append('Total')\n    table_header.append('Status')\n    table_header.append('Customer')\n    table_header.append('Time')\n    table_header.append('Notes')\n    table_header.append('Waiter')\n    table_header.append('Waiter Notes')\n    table_header.append('Waiter Time')\n    table_header.append('Waiter Status')\n    table_header.append('Waiter Customer')\n    table_header.append('Waiter Table')\n    table_header.append('Waiter Food')\n    table_header.append('Waiter Food Count')\n    table_header.append('Waiter Food Total')\n    table_header.append('Waiter Food Status')\n    table_header.append('Waiter Food Notes')\n    table_header.append('Waiter Food Waiter')\n    table_header.append('Waiter Food Waiter Notes')\n    table_header.append('Waiter Food Waiter Time')\n    table_header.append('Waiter Food Waiter Status')\n    table_header.append('Waiter Food Waiter Customer')\n    table_header.append('Waiter Food Waiter Table')\n    table_header.append('Waiter Food Waiter Food')\n    table_header.append('Waiter Food Waiter Food Count')\n    table_header.append('Waiter Food Waiter Food Total')\n    table_header.append('Waiter Food Waiter Food Status')\n    table_header.append('Waiter Food Waiter Food Notes')\n    table_header.append('Waiter Food Waiter Food Waiter')\n    table_header.append('Waiter Food Waiter Food Waiter Notes')\n    table_header.append('Waiter Food Waiter Food Waiter Time')\n    table_header.append('Waiter Food Waiter Food Waiter Status')\n    table_header.append('Waiter Food Waiter Food Waiter Customer')\n",
        "def restaurant_table(restaurant):\n    \"\"\"\n    restaurant_table(restaurant)\n    \"\"\"\n    table = [[\"Table\"]]\n    for item in restaurant:\n        table.append([item])\n    return table\n",
        "def restaurant_table(restaurant):\n    \"\"\"\n    :param restaurant:\n    :return:\n    \"\"\"\n    table = restaurant['table']\n    food_items = restaurant['food_items']\n    table_list = []\n    for i in range(len(table)):\n        table_list.append(table[i][0])\n    table_list.append('Food Items')\n    for i in range(len(food_items)):\n        table_list.append(food_items[i][0])\n    return table_list\n",
        "def display_table(restaurant):\n    \"\"\"\n    :param restaurant:\n    :return:\n    \"\"\"\n    table = restaurant['table']\n    food_items = restaurant['food_items']\n    print('Table\\t', end='')\n    for food_item in food_items:\n        print(food_item, end='\\t')\n    print()\n    for table_number in table:\n        print(table_number, end='\\t')\n        for food_item in food_items:\n            print(table[table_number][food_item], end='\\t')\n        print()\n    return None\n",
        "def restaurant_table(restaurant):\n    \"\"\"\n    restaurant_table(restaurant) -> str\n    \"\"\"\n    table = restaurant[\"table\"]\n    table_str = \"Table\"\n    for item in table:\n        table_str += \" | \" + item\n    return table_str\n",
        "def restaurant_menu(restaurant):\n    \"\"\"\n    restaurant_menu(restaurant) -> str\n    \"\"\"\n    return '\\n'.join(['Table', *restaurant['food']])\n",
        "def restaurant_table(restaurant):\n    \"\"\"\n    restaurant_table(restaurant) -> str\n    \"\"\"\n    # Header\n    table = \"Table\"\n    for item in restaurant[\"menu\"]:\n        table += \" \" + item\n    table += \"\\n\"\n    # Table\n    for table_number in restaurant[\"tables\"]:\n        table += str(table_number)\n        for item in restaurant[\"menu\"]:\n            table += \" \" + str(restaurant[\"tables\"][table_number][item])\n        table += \"\\n\"\n    return table\n",
        "def restaurant_table(restaurant):\n    table = restaurant['food']\n    table.insert(0, 'Table')\n    return table\n"
    ],
    "results": 10
},{
    "id": "1550",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count where count[k] is the number of times that k appears in the sample.Calculate the following statistics:",
    "snippets": [
        "def main():\n    count = [0] * 256\n    with open('input.txt', 'r') as f:\n        for line in f:\n            for c in line:\n                count[ord(c)] += 1\n    with open('output.txt', 'w') as f:\n        for i in range(256):\n            f.write(f'{i} {count[i]}\\n')\n",
        "def main():\n    count = [0] * 256\n    with open(\"input.txt\", \"r\") as f:\n        for line in f:\n            for c in line:\n                count[ord(c)] += 1\n    with open(\"output.txt\", \"w\") as f:\n        f.write(\"Min: {}\\n\".format(min(count)))\n        f.write(\"Max: {}\\n\".format(max(count)))\n        f.write(\"Sum: {}\\n\".format(sum(count)))\n        f.write(\"Mean: {}\\n\".format(sum(count) / len(count)))\n        f.write(\"Median: {}\\n\".format(median(count)))\n        f.write(\"Mode: {}\\n\".format(mode(count)))\n        f.write(\"Variance: {}\\n\".format(variance(count)))\n        f.write(\"Std. Deviation: {}\\n\".format(std_deviation(count)))\n        f.write(\"\\n\".join([\"{}: {}\".format(i, count[i]) for i in range(256)]))\n",
        "def main():\n    count = [0] * 256\n    with open('count.txt', 'r') as f:\n        for line in f:\n            count[int(line)] += 1\n    print('Min:', min(count))\n    print('Max:', max(count))\n    print('Sum:', sum(count))\n    print('Mean:', sum(count) / len(count))\n    print('Median:', sorted(count)[len(count) // 2])\n    print('Mode:', max(count), count.index(max(count)))\n    print('Variance:', sum([(x - sum(count) / len(count)) ** 2 for x in count]) / len(count))\n    print('Std. Dev.:', (sum([(x - sum(count) / len(count)) ** 2 for x in count]) / len(count)) ** 0.5)\n",
        "def main():\n    count = [0] * 256\n    with open('count.txt', 'r') as f:\n        for line in f:\n            count[int(line)] += 1\n    print(count)\n    print(sum(count))\n    print(max(count))\n    print(min(count))\n    print(count[int(input('Enter a number: '))])\n",
        "def main():\n    count = [0] * 256\n    with open('count.txt', 'r') as f:\n        for line in f:\n            count[int(line)] += 1\n    print('Min:', min(count))\n    print('Max:', max(count))\n    print('Sum:', sum(count))\n    print('Mean:', sum(count) / len(count))\n    print('Median:', count[128])\n    print('Mode:', count[count.index(max(count))])\n    print('Range:', max(count) - min(count))\n    print('Variance:', sum([(x - sum(count) / len(count)) ** 2 for x in count]) / len(count))\n    print('Standard Deviation:', (sum([(x - sum(count) / len(count)) ** 2 for x in count]) / len(count)) ** 0.5)\n    print('Skewness:', sum([(x - sum(count) / len(count)) ** 3 for x in count]) / len(count))\n    print('Kurtosis:', sum([(x - sum(count) / len(count)) ** 4 for x in count]) / len(count))\n    print('Quartile 1:', count[int(len(count) / 4)])\n    print('Quartile 2:', count[int(len(count) / 2)])\n    print('Quartile 3:', count[int(len(count) * 3 / 4)])\n    print('IQR:', count[int(len(count) * 3 / 4)] - count[int(len(count) / 4)])\n    print('Range:', count[int(len(count) * 3 / 4)] - count[int(len(count) / 4)])\n    print('Skewness:', sum([(x - sum(count) / len(count)) ** 3 for x in count]) / len(count))\n    print('Kurtosis:', sum([(x - sum(count) / len(count)) ** 4 for x in count]) / len(count))\n    print('Quartile 1\n",
        "def main():\n    count = [0] * 256\n    with open('count.txt', 'r') as f:\n        for line in f:\n            count[int(line)] += 1\n    print('Min:', min(count))\n    print('Max:', max(count))\n    print('Sum:', sum(count))\n    print('Mean:', sum(count) / len(count))\n    print('Median:', median(count))\n    print('Mode:', mode(count))\n    print('Variance:', variance(count))\n    print('Std. Deviation:', std_dev(count))\n    print('Quartile 1:', quartile(count, 1))\n    print('Quartile 2:', quartile(count, 2))\n    print('Quartile 3:', quartile(count, 3))\n    print('Quartile 4:', quartile(count, 4))\n    print('Quartile 5:', quartile(count, 5))\n    print('Quartile 6:', quartile(count, 6))\n    print('Quartile 7:', quartile(count, 7))\n    print('Quartile 8:', quartile(count, 8))\n    print('Quartile 9:', quartile(count, 9))\n    print('Quartile 10:', quartile(count, 10))\n    print('Quartile 11:', quartile(count, 11))\n    print('Quartile 12:', quartile(count, 12))\n    print('Quartile 13:', quartile(count, 13))\n    print('Quartile 14:', quartile(count, 14))\n    print('Quartile 15:', quartile(count, 15))\n    print('Quartile 16:', quartile(count, 16))\n    print('Quartile 17:', quartile(count, 17))\n    print('Quartile 18:', quartile(count, 18))\n    print('Quartile 19:', quartile(count, 19))\n    print('Quartile 20:', quartile(count, 20))\n    print('Quartile 21:', quartile(count\n",
        "def main():\n    count = [0] * 256\n    with open('input.txt', 'r') as f:\n        for line in f:\n            for i in line:\n                count[ord(i)] += 1\n    with open('output.txt', 'w') as f:\n        for i in range(256):\n            f.write(f'{i}: {count[i]}\\n')\n"
    ],
    "results": 7
},{
    "id": "1551",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard.",
    "snippets": [
        "def findWords(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    result = []\n    for word in words:\n        if set(word.lower()).issubset(row1) or set(word.lower()).issubset(row2) or set(word.lower()).issubset(row3):\n            result.append(word)\n    return result\n",
        "def findWords(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    result = []\n    for word in words:\n        if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n            result.append(word)\n    return result\n",
        "def findWords(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    result = []\n    for word in words:\n        word = word.lower()\n        if len(word) == 1:\n            result.append(word)\n        elif len(word) == 2:\n            if word[0] in row1 or word[1] in row1:\n                result.append(word)\n            elif word[0] in row2 or word[1] in row2:\n                result.append(word)\n            elif word[0] in row3 or word[1] in row3:\n                result.append(word)\n        else:\n            if word[0] in row1 or word[1] in row1 or word[2] in row1:\n                result.append(word)\n            elif word[0] in row2 or word[1] in row2 or word[2] in row2:\n                result.append(word)\n            elif word[0] in row3 or word[1] in row3 or word[2] in row3:\n                result.append(word)\n    return result\n",
        "def findWords(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    result = []\n    for word in words:\n        word = word.lower()\n        if set(word).issubset(row1) or set(word).issubset(row2) or set(word).issubset(row3):\n            result.append(word)\n    return result\n",
        "def findWords(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    res = []\n    for word in words:\n        if all(char in row1 or char in row2 or char in row3 for char in word):\n            res.append(word)\n    return res\n",
        "def findWords(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    res = []\n    for word in words:\n        word = word.lower()\n        if len(word) == 1:\n            res.append(word)\n        elif len(word) == 2:\n            if word[0] in row1 and word[1] in row1:\n                res.append(word)\n            elif word[0] in row2 and word[1] in row2:\n                res.append(word)\n            elif word[0] in row3 and word[1] in row3:\n                res.append(word)\n        else:\n            if word[0] in row1:\n                if all(c in row1 for c in word):\n                    res.append(word)\n            elif word[0] in row2:\n                if all(c in row2 for c in word):\n                    res.append(word)\n            elif word[0] in row3:\n                if all(c in row3 for c in word):\n                    res.append(word)\n    return res\n",
        "def findWords(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    res = []\n    for word in words:\n        if all(char in row1 or char in row2 or char in row3 for char in word.lower()):\n            res.append(word)\n    return res\n",
        "def find_words(words):\n    row1 = set('qwertyuiop')\n    row2 = set('asdfghjkl')\n    row3 = set('zxcvbnm')\n    result = []\n    for word in words:\n        if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n            result.append(word)\n    return result\n"
    ],
    "results": 10
},{
    "id": "1552",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, find a sequence that satisfies all of the following. The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|",
    "snippets": [
        "def find_sequence(n):\n    sequence = []\n    for i in range(n):\n        sequence.append(i)\n    return sequence\n",
        "def find_sequence(n):\n    sequence = []\n    for i in range(1, n + 1):\n        sequence.append(i)\n    return sequence\n",
        "def find_sequence(n):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3, 2]\n    if n == 4:\n        return [1, 4, 3, 2]\n    if n == 5:\n        return [1, 5, 4, 3, 2]\n    if n == 6:\n        return [1, 6, 5, 4, 3, 2]\n    if n == 7:\n        return [1, 7, 6, 5, 4, 3, 2]\n    if n == 8:\n        return [1, 8, 7, 6, 5, 4, 3, 2]\n    if n == 9:\n        return [1, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 10:\n        return [1, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 11:\n        return [1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 12:\n        return [1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 13:\n        return [1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 14:\n        return [1, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 15:\n        return [1, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 16:\n        return [1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 17:\n        return [1, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n"
    ],
    "results": 10
},{
    "id": "1553",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a large integer represented as an integer array digits. The digits are ordered from most significant to least significant in left-to-right order.",
    "snippets": [
        "def plusOne(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    carry = 1\n    for i in range(len(digits) - 1, -1, -1):\n        digits[i] += carry\n        if digits[i] >= 10:\n            digits[i] -= 10\n            carry = 1\n        else:\n            carry = 0\n    if carry == 1:\n        digits.insert(0, 1)\n    return digits\n",
        "def plus_one(digits):\n    for i in range(len(digits)-1, -1, -1):\n        if digits[i] == 9:\n            digits[i] = 0\n        else:\n            digits[i] += 1\n            return digits\n    digits.insert(0, 1)\n    return digits\n",
        "def digits_to_int(digits):\n    result = 0\n    for i in range(len(digits)):\n        result += digits[i] * 10 ** (len(digits) - i - 1)\n    return result\n",
        "def sum_of_digits(digits):\n    sum = 0\n    for i in digits:\n        sum += i\n    return sum\n",
        "def sum_digits(digits):\n    sum = 0\n    for digit in digits:\n        sum += digit\n    return sum\n",
        "def digits_to_int(digits):\n    result = 0\n    for digit in digits:\n        result = result * 10 + digit\n    return result\n",
        "def largest_number(digits):\n    digits = [str(i) for i in digits]\n    digits = sorted(digits, key=lambda x: x+x, reverse=True)\n    return ''.join(digits)\n",
        "def reverse(digits):\n    digits.reverse()\n    return digits\n",
        "def plusOne(digits):\n    \"\"\"\n    :type digits: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # Your runtime beats 98.00 % of python3 submissions\n    # Your memory usage beats 100 % of python3 submissions (13.8 MB)\n    digits[-1] += 1\n    for i in range(len(digits)-1, -1, -1):\n        if digits[i] == 10:\n            digits[i] = 0\n            if i == 0:\n                digits.insert(0, 1)\n        else:\n            break\n    return digits\n"
    ],
    "results": 9
},{
    "id": "1554",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an array of network towers towers. All the coordinates are integral coordinates on the X-Y plane. The distance between the two coordinates is the Euclidean distance. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers.",
    "snippets": [
        "def network_quality(towers):\n    # Write your code here\n    quality = 0\n    for i in range(len(towers)):\n        for j in range(len(towers)):\n            if i != j:\n                quality += abs(towers[i][0] - towers[j][0]) + abs(towers[i][1] - towers[j][1])\n    return quality\n",
        "def network_quality(towers):\n    # Write your code here\n    quality = 0\n    for i in range(len(towers)):\n        for j in range(i+1, len(towers)):\n            quality += abs(towers[i][0] - towers[j][0]) + abs(towers[i][1] - towers[j][1])\n    return quality\n",
        "def network_quality(towers):\n    quality = 0\n    for i in range(len(towers)):\n        for j in range(i+1, len(towers)):\n            quality += abs(towers[i][0] - towers[j][0]) + abs(towers[i][1] - towers[j][1])\n    return quality\n",
        "def networkQuality(n, towers):\n    # Write your code here\n    towers = sorted(towers, key=lambda x: x[0])\n    towers = sorted(towers, key=lambda x: x[1])\n    towers = sorted(towers, key=lambda x: x[2])\n    towers = sorted(towers, key=lambda x: x[3])\n    towers = sorted(towers, key=lambda x: x[4])\n    towers = sorted(towers, key=lambda x: x[5])\n    towers = sorted(towers, key=lambda x: x[6])\n    towers = sorted(towers, key=lambda x: x[7])\n    towers = sorted(towers, key=lambda x: x[8])\n    towers = sorted(towers, key=lambda x: x[9])\n    towers = sorted(towers, key=lambda x: x[10])\n    towers = sorted(towers, key=lambda x: x[11])\n    towers = sorted(towers, key=lambda x: x[12])\n    towers = sorted(towers, key=lambda x: x[13])\n    towers = sorted(towers, key=lambda x: x[14])\n    towers = sorted(towers, key=lambda x: x[15])\n    towers = sorted(towers, key=lambda x: x[16])\n    towers = sorted(towers, key=lambda x: x[17])\n    towers = sorted(towers, key=lambda x: x[18])\n    towers = sorted(towers, key=lambda x: x[19])\n    towers = sorted(towers, key=lambda x: x[20])\n    towers = sorted(towers, key=lambda x: x[21])\n    towers = sorted(towers, key=lambda x: x[22])\n    towers = sorted(towers, key=lambda x: x[23])\n    towers = sorted(towers, key=lambda x: x[24])\n    towers = sorted(towers, key=lambda x: x[25])\n    towers = sorted(towers, key=lambda x: x[26\n",
        "def network_quality(towers):\n    # Write your code here\n    return sum(tower[0]**2 + tower[1]**2 for tower in towers)\n",
        "def network_quality(towers):\n    # Write your code here\n    return 0\n",
        "def network_quality(towers):\n    # Write your code here\n    # return the network quality\n    return 0\n"
    ],
    "results": 10
},{
    "id": "1555",
    "source": "leetcode",
    "language": "python",
    "query": "A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s. Return the number of good splits you can make in s.",
    "snippets": [
        "def countSplits(s):\n    count = 0\n    for i in range(1, len(s)):\n        if s[:i] == s[i:]:\n            count += 1\n    return count\n",
        "def split(s):\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    if s[0] == s[-1]:\n        return split(s[1:-1]) + 1\n    else:\n        return split(s[1:])\n",
        "def split(s):\n    if len(s) == 1:\n        return 1\n    elif len(s) == 2:\n        if s[0] == s[1]:\n            return 1\n        else:\n            return 0\n    else:\n        if s[0] == s[-1]:\n            return split(s[1:-1]) + 1\n        else:\n            return split(s[1:])\n",
        "def split(s):\n    if len(s) == 1:\n        return 1\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return 1\n        else:\n            return 0\n    if s[0] == s[-1]:\n        return split(s[1:-1]) + 1\n    else:\n        return split(s[1:])\n",
        "def split(s):\n    if len(s) == 1:\n        return 1\n    if len(s) == 2:\n        return 1 if s[0] == s[1] else 0\n    if s[0] == s[-1]:\n        return split(s[1:-1]) + 1\n    else:\n        return split(s[1:])\n",
        "def countSplits(s):\n    if len(s) == 1:\n        return 0\n    if s[0] == s[-1]:\n        return countSplits(s[1:-1]) + 1\n    else:\n        return countSplits(s[1:])\n",
        "def split_good(s):\n    if len(s) == 1:\n        return 0\n    if s[0] == s[-1]:\n        return split_good(s[1:-1]) + 1\n    else:\n        return split_good(s[1:])\n"
    ],
    "results": 10
},{
    "id": "1556",
    "source": "leetcode",
    "language": "python",
    "query": "implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree. Initialize the pointer to a non-existent smallest number. The first call to next() will return the smallest element in the BST.",
    "snippets": [
        "def inorder_traversal(root):\n    if root is None:\n        return []\n    return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right)\n",
        "def inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.val)\n        inorder(root.right)\n",
        "def inorder_traversal(root):\n    if root:\n        inorder_traversal(root.left)\n        print(root.val)\n        inorder_traversal(root.right)\n",
        "def inorder_traversal(root):\n    if root is None:\n        return\n    inorder_traversal(root.left)\n    print(root.val)\n    inorder_traversal(root.right)\n"
    ],
    "results": 10
},{
    "id": "1557",
    "source": "leetcode",
    "language": "python",
    "query": "A uni-value grid is a grid where all the elements of it are equal. You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.",
    "snippets": [
        "def univalue_grid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if i > 0 and grid[i][j] == grid[i - 1][j]:\n                grid[i][j] += x\n            if j > 0 and grid[i][j] == grid[i][j - 1]:\n                grid[i][j] += x\n            if i < len(grid) - 1 and grid[i][j] == grid[i + 1][j]:\n                grid[i][j] += x\n            if j < len(grid[i]) - 1 and grid[i][j] == grid[i][j + 1]:\n                grid[i][j] += x\n    return grid\n",
        "def univalueGrid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if i > 0 and grid[i][j] == grid[i-1][j]:\n                grid[i][j] += x\n            if i < len(grid)-1 and grid[i][j] == grid[i+1][j]:\n                grid[i][j] += x\n            if j > 0 and grid[i][j] == grid[i][j-1]:\n                grid[i][j] += x\n            if j < len(grid[i])-1 and grid[i][j] == grid[i][j+1]:\n                grid[i][j] += x\n    return grid\n",
        "def univalue_grid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[i]) - 1:\n                grid[i][j] += x\n            else:\n                if grid[i][j] == grid[i - 1][j] == grid[i + 1][j] == grid[i][j - 1] == grid[i][j + 1]:\n                    grid[i][j] += x\n    return grid\n",
        "def univalue_grid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if i == 0:\n                grid[i][j] += x\n            elif i == len(grid) - 1:\n                grid[i][j] -= x\n            else:\n                if grid[i][j] == grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                elif grid[i][j] == grid[i - 1][j] and grid[i][j] != grid[i + 1][j]:\n                    grid[i][j] -= x\n                elif grid[i][j] != grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                else:\n                    grid[i][j] -= x\n    return grid\n",
        "def univalueGrid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if i == 0:\n                grid[i][j] += x\n            elif i == len(grid) - 1:\n                grid[i][j] -= x\n            else:\n                if grid[i][j] == grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                elif grid[i][j] == grid[i - 1][j] and grid[i][j] != grid[i + 1][j]:\n                    grid[i][j] -= x\n                elif grid[i][j] != grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                else:\n                    return False\n    return True\n",
        "def univalueGrid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if i == 0:\n                grid[i][j] += x\n            elif i == len(grid) - 1:\n                grid[i][j] -= x\n            else:\n                if grid[i][j] == grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                elif grid[i][j] == grid[i - 1][j] and grid[i][j] != grid[i + 1][j]:\n                    grid[i][j] -= x\n                elif grid[i][j] != grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                elif grid[i][j] != grid[i - 1][j] and grid[i][j] != grid[i + 1][j]:\n                    grid[i][j] -= x\n    return grid\n",
        "def uni_value_grid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] + x in grid:\n                return True\n            if grid[i][j] - x in grid:\n                return True\n    return False\n",
        "def univalue_grid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if i == 0:\n                grid[i][j] += x\n            elif i == len(grid) - 1:\n                grid[i][j] -= x\n            else:\n                if grid[i][j] == grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                elif grid[i][j] == grid[i - 1][j] and grid[i][j] != grid[i + 1][j]:\n                    grid[i][j] -= x\n                elif grid[i][j] != grid[i - 1][j] and grid[i][j] == grid[i + 1][j]:\n                    grid[i][j] += x\n                elif grid[i][j] != grid[i - 1][j] and grid[i][j] != grid[i + 1][j]:\n                    grid[i][j] -= x\n    return grid\n",
        "def univalueGrid(grid, x):\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if i == 0 or j == 0 or i == len(grid)-1 or j == len(grid[i])-1:\n                grid[i][j] += x\n            else:\n                if grid[i][j] == grid[i-1][j] and grid[i][j] == grid[i+1][j] and grid[i][j] == grid[i][j-1] and grid[i][j] == grid[i][j+1]:\n                    grid[i][j] += x\n    return grid\n"
    ],
    "results": 10
},{
    "id": "1558",
    "source": "leetcode",
    "language": "python",
    "query": "A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val. A preorder traversal of a Binary Tree displays the value of the node first, then traverses Node.right.",
    "snippets": [
        "def binary_search_tree(arr):\n    if len(arr) == 0:\n        return True\n    if len(arr) == 1:\n        return True\n    if len(arr) == 2:\n        return arr[0] < arr[1]\n    if len(arr) == 3:\n        return arr[0] < arr[1] and arr[1] < arr[2]\n    if len(arr) == 4:\n        return arr[0] < arr[1] and arr[1] < arr[2] and arr[2] < arr[3]\n    if len(arr) == 5:\n        return arr[0] < arr[1] and arr[1] < arr[2] and arr[2] < arr[3] and arr[3] < arr[4]\n    if len(arr) == 6:\n        return arr[0] < arr[1] and arr[1] < arr[2] and arr[2] < arr[3] and arr[3] < arr[4] and arr[4] < arr[5]\n    if len(arr) == 7:\n        return arr[0] < arr[1] and arr[1] < arr[2] and arr[2] < arr[3] and arr[3] < arr[4] and arr[4] < arr[5] and arr[5] < arr[6]\n    if len(arr) == 8:\n        return arr[0] < arr[1] and arr[1] < arr[2] and arr[2] < arr[3] and arr[3] < arr[4] and arr[4] < arr[5] and arr[5] < arr[6] and arr[6] < arr[7]\n    if len(arr) == 9:\n        return arr[0] < arr[1] and arr[1] < arr[2] and arr[2] < arr[3] and arr[3] < arr[4] and arr[4] < arr[5] and arr[5] < arr[6] and arr[6] < arr[7] and arr[7] < arr[8]\n    if len(arr)\n",
        "def binary_search_tree(arr):\n    if len(arr) == 0:\n        return True\n    if len(arr) == 1:\n        return True\n    if len(arr) == 2:\n        return arr[0] < arr[1]\n    for i in range(len(arr)):\n        if i == 0:\n            if arr[i] > arr[i+1]:\n                return False\n        elif i == len(arr)-1:\n            if arr[i] < arr[i-1]:\n                return False\n        else:\n            if arr[i] < arr[i-1] or arr[i] > arr[i+1]:\n                return False\n    return True\n",
        "def binary_search_tree(root):\n    if root is None:\n        return True\n    if root.left is not None and root.left.val >= root.val:\n        return False\n    if root.right is not None and root.right.val <= root.val:\n        return False\n    return binary_search_tree(root.left) and binary_search_tree(root.right)\n",
        "def binary_search_tree(tree):\n    if tree is None:\n        return True\n    if tree.left is not None and tree.left.val >= tree.val:\n        return False\n    if tree.right is not None and tree.right.val <= tree.val:\n        return False\n    return binary_search_tree(tree.left) and binary_search_tree(tree.right)\n"
    ],
    "results": 10
},{
    "id": "1559",
    "source": "leetcode",
    "language": "python",
    "query": "The game involves two players playing a game of chess. The game is won if one of the players wins the game.",
    "snippets": [
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the\n",
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"\n",
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if one of the players loses the game.\")\n    print(\"The game is drawn if the game is won by neither player.\")\n    print(\"The game is drawn if the game is lost by neither player.\")\n    print(\"The game is drawn if the game is lost by both players.\")\n    print(\"The game is drawn if the game is won by both players.\")\n    print(\"The game is drawn if the game is won by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if\n",
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if the game is drawn.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is won by a draw.\")\n    print(\"The game is drawn if the game is lost by a draw.\")\n    print(\"The game is drawn if the game is\n",
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if the game is a draw.\")\n    print(\"The game is a draw if the game is won by neither player.\")\n    print(\"The game is a draw if the game is lost by neither player.\")\n    print(\"The game is a draw if the game is lost by both players.\")\n    print(\"The game is a draw if the game is won by both players.\")\n    print(\"The game is a draw if the game is won by one player and lost by the other.\")\n    print(\"The game is a draw if the game is lost by one player and won by the other.\")\n    print(\"The game is a draw if the game is lost by one player and lost by the other.\")\n    print(\"The game is a draw if the game is won by one player and won by the other.\")\n    print(\"The game is a draw if the game is won by one player and lost by the other.\")\n    print(\"The game is a draw if the game is lost by one player and won by the other.\")\n    print(\"The game is a draw if the game is lost by one player and lost by the other.\")\n    print(\"The game is a draw if the game is won by one player and lost by the other.\")\n    print(\"The game is a draw if the game is lost by one player and won by the other.\")\n    print(\"The game is a draw if the game is lost by one player and lost by the other.\")\n    print(\"The game is a draw if the game is won by one player and lost by the other.\")\n    print(\"The game is a draw if the game is lost by one player and won by the other.\")\n    print(\"The game is a draw if the game is lost by one player and lost by the other.\")\n    print(\"The game is a draw if the game is won by one player and lost by the other.\")\n    print(\"The game is a draw if the game is lost by one player and won by the other.\")\n    print(\"The game is a draw if the game is lost by one player and lost by the other.\")\n    print(\"The game is a draw if the game is\n",
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is drawn if both players draw the game.\")\n    print(\"The game is won if one of the players wins the\n",
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"The game is drawn if neither player wins the game.\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if both players lose the game.\")\n    print(\"The game is tied if both players tie the game.\")\n    print(\"\n",
        "def main():\n    print(\"Welcome to the game of chess!\")\n    print(\"The game is won if one of the players wins the game.\")\n    print(\"The game is lost if one of the players loses the game.\")\n    print(\"The game is drawn if the game is won by neither player.\")\n    print(\"The game is drawn if the game is lost by neither player.\")\n    print(\"The game is drawn if the game is lost by both players.\")\n    print(\"The game is drawn if the game is won by both players.\")\n    print(\"The game is drawn if the game is won by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if the game is lost by one player and won by the other.\")\n    print(\"The game is drawn if the game is lost by one player and lost by the other.\")\n    print(\"The game is drawn if\n"
    ],
    "results": 5
},{
    "id": "1560",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.",
    "snippets": [
        "def validateStackSequences(pushed, popped):\n    \"\"\"\n    :type pushed: List[int]\n    :type popped: List[int]\n    :rtype: bool\n    \"\"\"\n    stack = []\n    i = 0\n    for num in pushed:\n        stack.append(num)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return i == len(popped)\n",
        "def validateStackSequences(pushed, popped):\n    stack = []\n    i = 0\n    for num in pushed:\n        stack.append(num)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return i == len(popped)\n",
        "def validateStackSequences(pushed, popped):\n    if len(pushed) != len(popped):\n        return False\n    stack = []\n    for i in range(len(pushed)):\n        if pushed[i] == popped[i]:\n            continue\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n        stack.append(pushed[i])\n    return len(stack) == 0\n",
        "def validateStackSequences(pushed, popped):\n    # Write your code here\n    stack = []\n    i = 0\n    for num in pushed:\n        stack.append(num)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return True if not stack else False\n",
        "def validateStackSequences(pushed, popped):\n    # Write your code here\n    stack = []\n    i = 0\n    for num in pushed:\n        stack.append(num)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return i == len(popped)\n",
        "def validateStackSequences(pushed, popped):\n    # Write your code here.\n    stack = []\n    i = 0\n    for num in pushed:\n        stack.append(num)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return i == len(popped)\n",
        "def validateStackSequences(pushed, popped):\n    # Write your code here\n    stack = []\n    i = 0\n    for j in range(len(pushed)):\n        stack.append(pushed[j])\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return i == len(popped)\n",
        "def validateStackSequences(pushed, popped):\n    if len(pushed) != len(popped):\n        return False\n    stack = []\n    i = 0\n    for num in pushed:\n        stack.append(num)\n        while stack and stack[-1] == popped[i]:\n            stack.pop()\n            i += 1\n    return not stack\n"
    ],
    "results": 10
},{
    "id": "1561",
    "source": "leetcode",
    "language": "python",
    "query": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones) If middleIndex is 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum has the same value.",
    "snippets": [
        "def findMiddleIndex(nums):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n",
        "def findMiddleIndex(nums):\n    leftSum = 0\n    rightSum = sum(nums)\n    for i in range(len(nums)):\n        rightSum -= nums[i]\n        if leftSum == rightSum:\n            return i\n        leftSum += nums[i]\n    return -1\n",
        "def findMiddleIndex(nums):\n    leftSum = 0\n    rightSum = 0\n    for i in range(len(nums)):\n        leftSum += nums[i]\n        if i == len(nums) - 1:\n            rightSum = leftSum\n        else:\n            rightSum += nums[i + 1]\n        if leftSum == rightSum:\n            return i\n    return -1\n",
        "def leftmost_middle_index(nums):\n    left_sum = 0\n    right_sum = 0\n    for i in range(len(nums)):\n        left_sum += nums[i]\n        if left_sum == 0:\n            return i\n    for i in range(len(nums)):\n        right_sum += nums[len(nums) - i - 1]\n        if right_sum == 0:\n            return len(nums) - i - 1\n    return -1\n",
        "def findMiddleIndex(nums):\n    leftSum = 0\n    rightSum = 0\n    for i in range(len(nums)):\n        if i == 0:\n            leftSum = 0\n        else:\n            leftSum += nums[i - 1]\n        if i == len(nums) - 1:\n            rightSum = 0\n        else:\n            rightSum += nums[i + 1]\n        if leftSum == rightSum:\n            return i\n    return -1\n",
        "def leftMostMiddle(nums):\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n",
        "def leftmost_middleIndex(nums):\n    if len(nums) == 0:\n        return -1\n    if len(nums) == 1:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n",
        "def leftmostMiddle(nums):\n    if len(nums) == 0:\n        return -1\n    if len(nums) == 1:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n",
        "def leftmost_middleIndex(nums):\n    left_sum = 0\n    right_sum = 0\n    for i in range(len(nums)):\n        left_sum += nums[i]\n        if left_sum == right_sum:\n            return i\n        if i < len(nums) - 1:\n            right_sum += nums[i + 1]\n        else:\n            right_sum = 0\n    return -1\n",
        "def leftmost_middle_index(nums):\n    if len(nums) == 0:\n        return -1\n    if len(nums) == 1:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n"
    ],
    "results": 10
},{
    "id": "1562",
    "source": "leetcode",
    "language": "python",
    "query": "An empty array is considered beautiful. You can delete any number of elements from nums. All elements to the right of the deleted element will be shifted one unit to the left.",
    "snippets": [
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1,2]\n    if n == 3:\n        return [1,3,2]\n    if n == 4:\n        return [1,4,3,2]\n    if n == 5:\n        return [1,5,4,3,2]\n    if n == 6:\n        return [1,6,5,4,3,2]\n    if n == 7:\n        return [1,7,6,5,4,3,2]\n    if n == 8:\n        return [1,8,7,6,5,4,3,2]\n    if n == 9:\n        return [1,9,8,7,6,5,4,3,2]\n    if n == 10:\n        return [1,10,9,8,7,6,5,4,3,2]\n    if n == 11:\n        return [1,11,10,9,8,7,6,5,4,3,2]\n    if n == 12:\n        return [1,12,11,10,9,8,7,6,5,4,3,2]\n    if n == 13:\n        return [1,13,12,11,10,9,8,7,6,5,4,3,2]\n    if n == 14:\n        return [1,14,13,12,11,10,9,8,7,6,5,4,3,2]\n    if n == 15:\n        return [1,15,14,13,12,11,10,9,8,7,6,5,4,3,2]\n    if n == 16:\n        return [1,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2]\n    if n == 17:\n        return [1,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2]\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 2]\n    else:\n        return [1, 2] + beautifulArray(n - 2)\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    else:\n        for i in range(n):\n            if i == 0:\n                if nums[i] == 1:\n                    return [1]\n                else:\n                    return [1,2]\n            else:\n                if nums[i] == 1:\n                    return [1]\n                else:\n                    return [1,2]\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [1,2]\n    else:\n        return [1,2] + beautifulArray(n-2)\n    return beautifulArray(n)\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 2]\n    else:\n        return [1] + beautifulArray(n-1) + [n-1]\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 2]\n    else:\n        return [1] + beautifulArray(n - 1) + [n]\n",
        "def make_beautiful(nums):\n    if len(nums) == 0:\n        return []\n    if len(nums) == 1:\n        return nums\n    if len(nums) == 2:\n        return [nums[0]]\n    if len(nums) == 3:\n        return [nums[0], nums[2]]\n    if len(nums) == 4:\n        return [nums[0], nums[2]]\n    if len(nums) == 5:\n        return [nums[0], nums[2]]\n    if len(nums) == 6:\n        return [nums[0], nums[2]]\n    if len(nums) == 7:\n        return [nums[0], nums[2]]\n    if len(nums) == 8:\n        return [nums[0], nums[2]]\n    if len(nums) == 9:\n        return [nums[0], nums[2]]\n    if len(nums) == 10:\n        return [nums[0], nums[2]]\n    if len(nums) == 11:\n        return [nums[0], nums[2]]\n    if len(nums) == 12:\n        return [nums[0], nums[2]]\n    if len(nums) == 13:\n        return [nums[0], nums[2]]\n    if len(nums) == 14:\n        return [nums[0], nums[2]]\n    if len(nums) == 15:\n        return [nums[0], nums[2]]\n    if len(nums) == 16:\n        return [nums[0], nums[2]]\n    if len(nums) == 17:\n        return [nums[0], nums[2]]\n    if len(nums) == 18:\n        return [nums[0], nums[2]]\n    if len(nums) == 19:\n        return [nums[0], nums[2]]\n    if len(nums) == 20:\n        return [\n"
    ],
    "results": 9
},{
    "id": "1563",
    "source": "leetcode",
    "language": "python",
    "query": "Every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd ' |' make a pair, the 3rd and 4th '|', and so forth.",
    "snippets": [
        "def main():\n    n = int(input())\n    for i in range(n):\n        print('|' * (2 * i + 1))\n",
        "def main():\n    n = int(input())\n    for i in range(n):\n        print(' '.join(['|'] * (2 * i + 1)))\n",
        "def pair_of_bars(s):\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    if s[0] == '|' and s[1] == '|':\n        return 1 + pair_of_bars(s[2:])\n    else:\n        return pair_of_bars(s[1:])\n",
        "def main():\n    n = int(input())\n    for i in range(n):\n        print('|' + ' ' * (n - i - 1) + '\\\\' + ' ' * (i * 2) + '/' + ' ' * (n - i - 1) + '|')\n",
        "def pairs(s):\n    return s.count('|') // 2\n",
        "def solve(s):\n    return s.count('|') // 2\n"
    ],
    "results": 10
},{
    "id": "1564",
    "source": "leetcode",
    "language": "python",
    "query": "A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true: It is (A), where A is a valid parentheses string.",
    "snippets": [
        "def isValid(s):\n    stack = []\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def valid_parentheses(string):\n    if string == '':\n        return False\n    if string == '()':\n        return True\n    if string[0] == '(' and string[-1] == ')':\n        return valid_parentheses(string[1:-1])\n    else:\n        return False\n",
        "def valid_parentheses(string):\n    if string == '':\n        return False\n    if string == '()':\n        return True\n    if string[0] == ')':\n        return False\n    if string[-1] == '(':\n        return False\n    if string[0] == '(' and string[-1] == ')':\n        return valid_parentheses(string[1:-1])\n    if string[0] == '(' and string[-1] != ')':\n        return valid_parentheses(string[1:])\n    if string[0] != '(' and string[-1] == ')':\n        return valid_parentheses(string[:-1])\n    if string[0] != '(' and string[-1] != ')':\n        return valid_parentheses(string[1:-1])\n    return False\n",
        "def isValid(s):\n    if len(s) == 0:\n        return False\n    if len(s) == 1:\n        return False\n    if len(s) == 2:\n        return s[0] == '(' and s[1] == ')'\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    else:\n        return False\n",
        "def isValid(s):\n    if len(s) == 1:\n        return False\n    if len(s) == 2:\n        return s[0] == '(' and s[1] == ')'\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    return False\n",
        "def valid_parentheses(string):\n    if string == '':\n        return False\n    if string == '()':\n        return True\n    if string[0] == ')' or string[-1] == '(':\n        return False\n    if string[0] == '(' and string[-1] == ')':\n        return valid_parentheses(string[1:-1])\n    return valid_parentheses(string[1:]) or valid_parentheses(string[:-1])\n",
        "def isValid(s):\n    if s == '':\n        return True\n    if len(s) % 2 != 0:\n        return False\n    if s[0] == ')' or s[-1] == '(':\n        return False\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[\n",
        "def isValid(s):\n    if len(s) == 0:\n        return True\n    if len(s) % 2 != 0:\n        return False\n    if s[0] == ')' or s[-1] == '(':\n        return False\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid(s[1:-1])\n    if s[0] == '(' and s[-1] == ')':\n        return isValid\n"
    ],
    "results": 10
},{
    "id": "1565",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can find indexes i + 1 < j with (arr[0] + arr[1] + ...)",
    "snippets": [
        "def canPartition(arr):\n    sum = 0\n    for i in arr:\n        sum += i\n    if sum % 3 != 0:\n        return False\n    sum /= 3\n    dp = [[False for i in range(sum + 1)] for j in range(len(arr))]\n    for i in range(len(arr)):\n        dp[i][0] = True\n    for i in range(len(arr)):\n        for j in range(1, sum + 1):\n            if arr[i] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i]]\n    return dp[len(arr) - 1][sum]\n",
        "def canPartition(arr):\n    sum = 0\n    for i in arr:\n        sum += i\n    if sum % 3 != 0:\n        return False\n    sum /= 3\n    dp = [[False for i in range(len(arr))] for j in range(sum + 1)]\n    dp[0][0] = True\n    for i in range(len(arr)):\n        for j in range(sum + 1):\n            if j >= arr[i]:\n                dp[j][i] = dp[j][i - 1] or dp[j - arr[i]][i - 1]\n    return dp[sum][len(arr) - 1]\n",
        "def canPartition(arr):\n    sum = 0\n    for i in arr:\n        sum += i\n    if sum % 3 != 0:\n        return False\n    sum /= 3\n    dp = [[False for i in range(sum + 1)] for j in range(len(arr))]\n    for i in range(len(arr)):\n        dp[i][0] = True\n    for i in range(len(arr)):\n        for j in range(1, sum + 1):\n            if j >= arr[i]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    return dp[len(arr) - 1][sum]\n",
        "def canThreePartsEqualSum(arr):\n    sum = 0\n    for i in arr:\n        sum += i\n    if sum % 3 != 0:\n        return False\n    sum /= 3\n    left = 0\n    right = 0\n    for i in range(len(arr)):\n        right += arr[i]\n        if right == sum:\n            right = 0\n            left += 1\n            if left == 2:\n                return True\n    return False\n",
        "def canThreePartsEqualSum(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: bool\n    \"\"\"\n    if len(arr) < 3:\n        return False\n    sum_arr = sum(arr)\n    if sum_arr % 3 != 0:\n        return False\n    sum_arr = sum_arr // 3\n    left_sum = 0\n    right_sum = 0\n    for i in range(len(arr)):\n        right_sum += arr[i]\n        if left_sum == sum_arr and right_sum == sum_arr:\n            return True\n        left_sum += arr[i]\n    return False\n",
        "def canThreePartsEqualSum(arr):\n    \"\"\"\n    :type arr: List[int]\n    :rtype: bool\n    \"\"\"\n    sum = 0\n    for i in arr:\n        sum += i\n    if sum % 3 != 0:\n        return False\n    sum /= 3\n    left = 0\n    right = 0\n    for i in arr:\n        right += i\n        if right == sum:\n            right = 0\n            left += 1\n    if left == 3:\n        return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1566",
    "source": "leetcode",
    "language": "python",
    "query": "H-index is the number of citations a researcher received for their ith paper. A scientist has an index h if h of their n papers have at least h citations each.",
    "snippets": [
        "def h_index(citations):\n    citations.sort()\n    n = len(citations)\n    for i in range(n):\n        if citations[i] >= n - i:\n            return n - i\n    return 0\n",
        "def h_index(citations):\n    citations.sort()\n    h = 0\n    for i in range(len(citations)):\n        if citations[i] >= len(citations) - i:\n            h = len(citations) - i\n        else:\n            break\n    return h\n",
        "def h_index(citations):\n    citations.sort()\n    for i in range(len(citations)):\n        if citations[i] >= len(citations) - i:\n            return len(citations) - i\n    return 0\n"
    ],
    "results": 10
},{
    "id": "1567",
    "source": "leetcode",
    "language": "python",
    "query": "A string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only. For example, \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2)",
    "snippets": [
        "def isValid(s):\n    stack = []\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def isValid(s):\n    if len(s) % 2 != 0:\n        return False\n    stack = []\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def isValid(s):\n    if s == '':\n        return True\n    if len(s) % 2 != 0:\n        return False\n    stack = []\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def isValid(s):\n    if len(s) % 2 != 0:\n        return False\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def isValid(s):\n    stack = []\n    for i in s:\n        if i == '(' or i == '{' or i == '[':\n            stack.append(i)\n        elif i == ')' or i == '}' or i == ']':\n            if len(stack) == 0:\n                return False\n            else:\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "1568",
    "source": "leetcode",
    "language": "python",
    "query": "You are playing a video game where you are defending your city from a group of n monsters. The speed of each monster is given to you in an integer array speed of size n. You have a weapon that, once fully charged, can eliminate a single monster.",
    "snippets": [
        "def max_killed(speed, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return speed[0]\n    if n == 2:\n        return max(speed[0] + speed[1], speed[1] + speed[0])\n    if n == 3:\n        return max(speed[0] + speed[1] + speed[2], speed[0] + speed[2] + speed[1])\n    if n == 4:\n        return max(speed[0] + speed[1] + speed[2] + speed[3], speed[0] + speed[1] + speed[3] + speed[2])\n    if n == 5:\n        return max(speed[0] + speed[1] + speed[2] + speed[3] + speed[4], speed[0] + speed[1] + speed[3] + speed[4] + speed[2])\n    if n == 6:\n        return max(speed[0] + speed[1] + speed[2] + speed[3] + speed[4] + speed[5], speed[0] + speed[1] + speed[2] + speed[4] + speed[5] + speed[3])\n    if n == 7:\n        return max(speed[0] + speed[1] + speed[2] + speed[3] + speed[4] + speed[5] + speed[6], speed[0] + speed[1] + speed[2] + speed[3] + speed[5] + speed[6] + speed[4])\n    if n == 8:\n        return max(speed[0] + speed[1] + speed[2] + speed[3] + speed[4] + speed[5] + speed[6] + speed[7], speed[0] + speed[1] + speed[2] + speed[3] + speed[4] + speed[5] + speed[6] + speed[7] + speed[2])\n    if n == 9:\n        return max(speed[0] + speed[1] + speed[2] + speed[3] + speed[4] + speed[5]\n",
        "def max_killed(speed):\n    if len(speed) == 0:\n        return 0\n    if len(speed) == 1:\n        return speed[0]\n    if len(speed) == 2:\n        return max(speed[0], speed[1])\n    if len(speed) == 3:\n        return max(speed[0] + speed[2], speed[1])\n    if len(speed) == 4:\n        return max(speed[0] + speed[3], speed[1] + speed[2])\n    if len(speed) == 5:\n        return max(speed[0] + speed[4], speed[1] + speed[3], speed[2])\n    if len(speed) == 6:\n        return max(speed[0] + speed[5], speed[1] + speed[4], speed[2] + speed[3])\n    if len(speed) == 7:\n        return max(speed[0] + speed[6], speed[1] + speed[5], speed[2] + speed[4], speed[3])\n    if len(speed) == 8:\n        return max(speed[0] + speed[7], speed[1] + speed[6], speed[2] + speed[5], speed[3] + speed[4])\n    if len(speed) == 9:\n        return max(speed[0] + speed[8], speed[1] + speed[7], speed[2] + speed[6], speed[3] + speed[5], speed[4])\n    if len(speed) == 10:\n        return max(speed[0] + speed[9], speed[1] + speed[8], speed[2] + speed[7], speed[3] + speed[6], speed[4] + speed[5])\n    if len(speed) == 11:\n        return max(speed[0] + speed[10], speed[1] + speed[9], speed[2] + speed[8], speed[3] + speed[7], speed[4] + speed[6], speed[5])\n    if len(speed) == 12:\n        return max(speed[0] + speed[11\n",
        "def max_killed(speed, n):\n    if n == 1:\n        return speed[0]\n    if n == 2:\n        return max(speed[0], speed[1])\n    if n == 3:\n        return max(speed[0] + speed[2], speed[1])\n    if n == 4:\n        return max(speed[0] + speed[3], speed[1] + speed[2])\n    if n == 5:\n        return max(speed[0] + speed[4], speed[1] + speed[3], speed[2])\n    if n == 6:\n        return max(speed[0] + speed[5], speed[1] + speed[4], speed[2] + speed[3])\n    if n == 7:\n        return max(speed[0] + speed[6], speed[1] + speed[5], speed[2] + speed[4], speed[3])\n    if n == 8:\n        return max(speed[0] + speed[7], speed[1] + speed[6], speed[2] + speed[5], speed[3] + speed[4])\n    if n == 9:\n        return max(speed[0] + speed[8], speed[1] + speed[7], speed[2] + speed[6], speed[3] + speed[5], speed[4])\n    if n == 10:\n        return max(speed[0] + speed[9], speed[1] + speed[8], speed[2] + speed[7], speed[3] + speed[6], speed[4] + speed[5])\n    if n == 11:\n        return max(speed[0] + speed[10], speed[1] + speed[9], speed[2] + speed[8], speed[3] + speed[7], speed[4] + speed[6], speed[5])\n    if n == 12:\n        return max(speed[0] + speed[11], speed[1] + speed[10], speed[2] + speed[9], speed[3] + speed[8], speed[4] + speed[7], speed[5] + speed[6])\n",
        "def canEliminate(speed, weapon):\n    if len(speed) == 0:\n        return False\n    if len(speed) == 1:\n        return True\n    if weapon == 0:\n        return False\n    if weapon == 1:\n        return True\n    if weapon == 2:\n        return True\n    if weapon == 3:\n        return True\n    if weapon == 4:\n        return True\n    if weapon == 5:\n        return True\n    if weapon == 6:\n        return True\n    if weapon == 7:\n        return True\n    if weapon == 8:\n        return True\n    if weapon == 9:\n        return True\n    if weapon == 10:\n        return True\n    if weapon == 11:\n        return True\n    if weapon == 12:\n        return True\n    if weapon == 13:\n        return True\n    if weapon == 14:\n        return True\n    if weapon == 15:\n        return True\n    if weapon == 16:\n        return True\n    if weapon == 17:\n        return True\n    if weapon == 18:\n        return True\n    if weapon == 19:\n        return True\n    if weapon == 20:\n        return True\n    if weapon == 21:\n        return True\n    if weapon == 22:\n        return True\n    if weapon == 23:\n        return True\n    if weapon == 24:\n        return True\n    if weapon == 25:\n        return True\n    if weapon == 26:\n        return True\n    if weapon == 27:\n        return True\n    if weapon == 28:\n        return True\n    if weapon == 29:\n        return True\n    if weapon == 30:\n        return True\n    if weapon == 31:\n        return True\n    if weapon == 32:\n        return True\n    if weapon == 33:\n        return True\n    if weapon == 34:\n        return True\n    if weapon == 35:\n        return True\n    if weapon == 36:\n        return True\n    if weapon == 37:\n        return True\n    if weapon == 38:\n        return True\n    if weapon == 39:\n        return True\n    if weapon == 40:\n        return True\n    if weapon == 41:\n        return True\n",
        "def max_killed(speed):\n    # Write your code here.\n    n = len(speed)\n    if n == 0:\n        return 0\n    if n == 1:\n        return speed[0]\n    if n == 2:\n        return max(speed[0], speed[1])\n    if n == 3:\n        return max(speed[0] + speed[2], speed[1])\n    if n == 4:\n        return max(speed[0] + speed[3], speed[1] + speed[2])\n    if n == 5:\n        return max(speed[0] + speed[4], speed[1] + speed[3], speed[2])\n    if n == 6:\n        return max(speed[0] + speed[5], speed[1] + speed[4], speed[2] + speed[3])\n    if n == 7:\n        return max(speed[0] + speed[6], speed[1] + speed[5], speed[2] + speed[4], speed[3])\n    if n == 8:\n        return max(speed[0] + speed[7], speed[1] + speed[6], speed[2] + speed[5], speed[3] + speed[4])\n    if n == 9:\n        return max(speed[0] + speed[8], speed[1] + speed[7], speed[2] + speed[6], speed[3] + speed[5], speed[4])\n    if n == 10:\n        return max(speed[0] + speed[9], speed[1] + speed[8], speed[2] + speed[7], speed[3] + speed[6], speed[4] + speed[5])\n    if n == 11:\n        return max(speed[0] + speed[10], speed[1] + speed[9], speed[2] + speed[8], speed[3] + speed[7], speed[4] + speed[6], speed[5])\n    if n == 12:\n        return max(speed[0] + speed[11], speed[1] + speed[10], speed[2] + speed[9], speed[3]\n",
        "def max_killed_monsters(speed):\n    \"\"\"\n    :param speed: list of integers\n    :return: int\n    \"\"\"\n    # Your code here\n    return 0\n",
        "def max_killed_monsters(speed, weapon_damage):\n    # Write your code here\n    if len(speed) == 0:\n        return 0\n    if len(speed) == 1:\n        return weapon_damage\n    speed.sort()\n    i = 0\n    j = len(speed) - 1\n    while i < j:\n        if speed[i] + weapon_damage >= speed[j]:\n            i += 1\n        else:\n            j -= 1\n    return len(speed) - j\n",
        "def killMonster(speed):\n    speed.sort()\n    i = 0\n    while i < len(speed):\n        if speed[i] > 1:\n            speed[i] -= 1\n            i += 1\n        else:\n            speed.pop(i)\n    return len(speed)\n",
        "def max_killed(speed, weapon_damage):\n    # Write your code here.\n    if len(speed) == 0:\n        return 0\n    if len(speed) == 1:\n        return weapon_damage * speed[0]\n    speed.sort()\n    total_damage = 0\n    for i in range(len(speed)):\n        total_damage += weapon_damage * speed[i]\n        if i == len(speed) - 1:\n            break\n        if speed[i] == speed[i + 1]:\n            continue\n        else:\n            total_damage += weapon_damage * (speed[i + 1] - speed[i])\n    return total_damage\n"
    ],
    "results": 10
},{
    "id": "1569",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed m x n integer matrix grid. You can move in this matrix from a cell to any other cell in the next row. Note that it is not possible to move from cells in the last row.",
    "snippets": [
        "def minPathSum(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[-1][-1]\n",
        "def minPathSum(grid):\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0 for i in range(n)] for j in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n",
        "def minPathSum(grid):\n    if not grid:\n        return 0\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[-1][-1]\n",
        "def minPathSum(grid):\n    if not grid:\n        return 0\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    return dp[m-1][n-1]\n",
        "def minPathSum(grid):\n    if not grid:\n        return 0\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[m - 1][n - 1]\n"
    ],
    "results": 10
},{
    "id": "1570",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.",
    "snippets": [
        "def dfs(graph, start, visited):\n    visited[start] = True\n    for i in graph[start]:\n        if not visited[i]:\n            dfs(graph, i, visited)\n",
        "def dfs(graph, start, visited):\n    visited[start] = True\n    for i in graph[start]:\n        if not visited[i]:\n            dfs(graph, i, visited)\n    return visited\n",
        "def dfs(graph, start, visited):\n    visited[start] = True\n    for node in graph[start]:\n        if not visited[node]:\n            dfs(graph, node, visited)\n"
    ],
    "results": 10
},{
    "id": "1571",
    "source": "leetcode",
    "language": "python",
    "query": "The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive.",
    "snippets": [
        "def findSubstring(s, words):\n    if not words:\n        return []\n    if not s:\n        return []\n    if len(words) > len(s):\n        return []\n    if len(words[0]) > len(s):\n        return []\n    if len(words) == 1:\n        return [i for i in range(len(s) - len(words[0]) + 1) if s[i:i+len(words[0])] == words[0]]\n    word_set = set(words)\n    word_len = len(words[0])\n    word_num = len(words)\n    result = []\n    for i in range(len(s) - word_len * word_num + 1):\n        if s[i:i+word_len] in word_set:\n            result.append(i)\n    return result\n",
        "def findSubstring(s, words):\n    if not words:\n        return []\n    if not s:\n        return []\n    if len(words) > len(s):\n        return []\n    if len(words[0]) > len(s):\n        return []\n    if len(words) == 1:\n        return [i for i in range(len(s) - len(words[0]) + 1) if s[i:i+len(words[0])] == words[0]]\n    word_set = set(words)\n    word_len = len(words[0])\n    word_num = len(words)\n    res = []\n    for i in range(len(s) - word_len * word_num + 1):\n        if s[i:i+word_len] in word_set:\n            res.append(i)\n    return res\n",
        "def findSubstring(s, words):\n    if not words:\n        return []\n    if not s:\n        return []\n    if len(words) > len(s):\n        return []\n    if len(words[0]) > len(s):\n        return []\n    if len(words) == 1:\n        return [i for i in range(len(s) - len(words[0]) + 1) if s[i:i+len(words[0])] == words[0]]\n    word_dict = {}\n    for word in words:\n        if word in word_dict:\n            word_dict[word] += 1\n        else:\n            word_dict[word] = 1\n    result = []\n    for i in range(len(s) - len(words[0]) + 1):\n        if s[i:i+len(words[0])] in word_dict:\n            word_dict[s[i:i+len(words[0])]] -= 1\n            if word_dict[s[i:i+len(words[0])]] == 0:\n                word_dict.pop(s[i:i+len(words[0])])\n            if len(word_dict) == 0:\n                result.append(i)\n                word_dict = dict(words)\n        else:\n            word_dict = dict(words)\n    return result\n",
        "def findSubstring(s, words):\n    if not words:\n        return []\n    if not s:\n        return []\n    if len(words) > len(s):\n        return []\n    if len(words[0]) > len(s):\n        return []\n    if len(words) == 1:\n        return [i for i in range(len(s) - len(words[0]) + 1) if s[i:i+len(words[0])] == words[0]]\n    words_set = set(words)\n    words_len = len(words[0])\n    words_num = len(words)\n    res = []\n    for i in range(len(s) - words_len * words_num + 1):\n        if s[i:i+words_len] in words_set:\n            res.append(i)\n    return res\n",
        "def findSubstring(s, words):\n    if not s or not words:\n        return []\n    if len(words) == 1:\n        return [i for i in range(len(s)) if s[i:i+len(words[0])] == words[0]]\n    words_set = set(words)\n    words_len = len(words[0])\n    words_num = len(words)\n    res = []\n    for i in range(len(s) - words_len * words_num + 1):\n        if s[i:i+words_len] in words_set:\n            res.append(i)\n    return res\n",
        "def findSubstring(s, words):\n    if not s or not words:\n        return []\n    if len(words) == 1:\n        return [s.find(words[0])]\n    words_len = len(words[0])\n    words_num = len(words)\n    words_dict = {}\n    for word in words:\n        if word in words_dict:\n            words_dict[word] += 1\n        else:\n            words_dict[word] = 1\n    res = []\n    for i in range(len(s) - words_len * words_num + 1):\n        if s[i:i+words_len] in words_dict:\n            words_dict[s[i:i+words_len]] -= 1\n            if words_dict[s[i:i+words_len]] == 0:\n                words_dict.pop(s[i:i+words_len])\n            if len(words_dict) == 0:\n                res.append(i)\n                for j in range(i+words_len, i+words_len*(words_num+1), words_len):\n                    words_dict[s[j:j+words_len]] += 1\n    return res\n",
        "def maxFreq(s, maxLetters, minSize, maxSize):\n    freq = {}\n    for i in range(len(s)):\n        for j in range(i, i + minSize + 1):\n            if j > len(s) - 1:\n                break\n            if j - i + 1 > maxSize:\n                break\n            if j - i + 1 < minSize:\n                continue\n            substr = s[i:j + 1]\n            if len(set(substr)) > maxLetters:\n                continue\n            if substr in freq:\n                freq[substr] += 1\n            else:\n                freq[substr] = 1\n    max_freq = 0\n    for key in freq:\n        if freq[key] > max_freq:\n            max_freq = freq[key]\n    return max_freq\n",
        "def maxFrequncy(s, maxLetters, minSize, maxSize):\n    # Write your code here\n    from collections import Counter\n    c = Counter(s)\n    res = 0\n    for k, v in c.items():\n        if v > res:\n            res = v\n    return res\n",
        "def substr_with_max_unique_chars(s, max_letters, min_size, max_size):\n    substr = ''\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if len(set(s[i:j+1])) <= max_letters and len(s[i:j+1]) >= min_size and len(s[i:j+1]) <= max_size:\n                substr = s[i:j+1]\n                return substr\n    return substr\n",
        "def maxFreq(s, maxLetters, minSize, maxSize):\n    # Write your code here.\n    from collections import Counter\n    from itertools import combinations\n    c = Counter(s)\n    res = 0\n    for i in range(minSize, maxSize+1):\n        for j in combinations(c.keys(), i):\n            if len(set(j)) <= maxLetters:\n                res = max(res, c[j[0]])\n    return res\n"
    ],
    "results": 10
},{
    "id": "1572",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. LCA is defined as the lowest node in T that has both p and q as descendants.",
    "snippets": [
        "def lowestCommonAncestor(root, p, q):\n    if not root:\n        return None\n    if root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left if left else right\n",
        "def lowestCommonAncestor(root, p, q):\n    if root is None:\n        return None\n    if root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left if left else right\n",
        "def lowestCommonAncestor(root, p, q):\n    if root is None:\n        return None\n    if root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left is None:\n        return right\n    if right is None:\n        return left\n    return root\n"
    ],
    "results": 10
},{
    "id": "1573",
    "source": "leetcode",
    "language": "python",
    "query": "The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "snippets": [
        "def is_valid(word):\n    if len(word) == 1:\n        return True\n    if len(word) == 2:\n        return word[0] == word[1]\n    if word[0] == word[1]:\n        return False\n    if word[0] == word[2]:\n        return False\n    if word[1] == word[2]:\n        return False\n    return True\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    for i in range(len(word)):\n        if i == 0:\n            if word[i] == word[i+1]:\n                return False\n        elif i == len(word)-1:\n            if word[i] == word[i-1]:\n                return False\n        else:\n            if word[i] == word[i-1] or word[i] == word[i+1]:\n                return False\n    return True\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    if word[0] == word[1]:\n        return False\n    for i in range(1, len(word)):\n        if word[i] == word[i-1]:\n            return False\n    return True\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    for i in range(len(word)):\n        if word[i] == word[i+1]:\n            return False\n    return True\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    if len(word) > 26:\n        return False\n    if word[0] == word[1]:\n        return False\n    if word[0] == word[-1]:\n        return False\n    if word[-1] == word[-2]:\n        return False\n    return True\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    if len(word) > 26:\n        return False\n    if word == ''.join(sorted(word)):\n        return False\n    return True\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    if len(word) > 26:\n        return False\n    if word.count('Q') > 1:\n        return False\n    if word.count('Z') > 1:\n        return False\n    if word.count('J') > 1:\n        return False\n    if word.count('X') > 1:\n        return False\n    if word.count('S') > 1:\n        return False\n    if word.count('O') > 1:\n        return False\n    if word.count('I') > 1:\n        return False\n    if word.count('L') > 1:\n        return False\n    if word.count('U') > 1:\n        return False\n    if word.count('D') > 1:\n        return False\n    if word.count('G') > 1:\n        return False\n    if word.count('R') > 1:\n        return False\n    if word.count('C') > 1:\n        return False\n    if word.count('P') > 1:\n        return False\n    if word.count('F') > 1:\n        return False\n    if word.count('B') > 1:\n        return False\n    if word.count('M') > 1:\n        return False\n    if word.count('H') > 1:\n        return False\n    if word.count('N') > 1:\n        return False\n    if word.count('T') > 1:\n        return False\n    if word.count('W') > 1:\n        return False\n    if word.count('Y') > 1:\n        return False\n    if word.count('V') > 1:\n        return False\n    if word.count('K') > 1:\n        return False\n    if word.count('Q') > 1:\n        return False\n    if word.count('Z') > 1:\n        return False\n    if word.count('J') > 1:\n        return False\n    if word.count('X') > 1:\n        return False\n    if word.count('S') > 1:\n        return False\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    if len(word) > 26:\n        return False\n    if word[0] == '0':\n        return False\n    if word[0] == '1':\n        return False\n    if word[0] == '2':\n        return False\n    if word[0] == '3':\n        return False\n    if word[0] == '4':\n        return False\n    if word[0] == '5':\n        return False\n    if word[0] == '6':\n        return False\n    if word[0] == '7':\n        return False\n    if word[0] == '8':\n        return False\n    if word[0] == '9':\n        return False\n    if word[0] == 'a':\n        return False\n    if word[0] == 'b':\n        return False\n    if word[0] == 'c':\n        return False\n    if word[0] == 'd':\n        return False\n    if word[0] == 'e':\n        return False\n    if word[0] == 'f':\n        return False\n    if word[0] == 'g':\n        return False\n    if word[0] == 'h':\n        return False\n    if word[0] == 'i':\n        return False\n    if word[0] == 'j':\n        return False\n    if word[0] == 'k':\n        return False\n    if word[0] == 'l':\n        return False\n    if word[0] == 'm':\n        return False\n    if word[0] == 'n':\n        return False\n    if word[0] == 'o':\n        return False\n    if word[0] == 'p':\n        return False\n    if word[0] == 'q':\n        return False\n    if word[0] == 'r':\n        return False\n    if word[0] == 's':\n        return False\n    if word[0] == 't':\n        return False\n    if word[0] == 'u':\n        return False\n",
        "def is_valid(word):\n    if len(word) < 2:\n        return False\n    if len(word) > 26:\n        return False\n    if len(word) == 2:\n        return True\n    if word[0] == word[1]:\n        return False\n    if word[0] == word[2]:\n        return False\n    if word[1] == word[2]:\n        return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1574",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a string s consisting only of characters 'a' and 'b' You can delete any number of characters in s to make s balanced.",
    "snippets": [
        "def balanced(s):\n    if len(s) % 2 == 0:\n        return True\n    else:\n        return False\n",
        "def balanced(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return s == 'a'\n    if s[0] == 'a':\n        return balanced(s[1:])\n    else:\n        return balanced(s[1:]) and balanced(s[:-1])\n",
        "def balanced(s):\n    if len(s) == 0:\n        return True\n    if len(s) % 2 != 0:\n        return False\n    if s[0] == 'a':\n        return balanced(s[1:])\n    else:\n        return balanced(s[1:]) and balanced(s[:-1])\n",
        "def balancedString(s):\n    s = list(s)\n    s.sort()\n    s = ''.join(s)\n    if s == 'aabb':\n        return 0\n    if s == 'aabbb':\n        return 1\n    if s == 'aabbbb':\n        return 2\n    if s == 'aabbbbb':\n        return 3\n    if s == 'aabbbbbb':\n        return 4\n    if s == 'aabbbbbbb':\n        return 5\n    if s == 'aabbbbbbbb':\n        return 6\n    if s == 'aabbbbbbbbb':\n        return 7\n    if s == 'aabbbbbbbbbb':\n        return 8\n    if s == 'aabbbbbbbbbbb':\n        return 9\n    if s == 'aabbbbbbbbbbbb':\n        return 10\n    if s == 'aabbbbbbbbbbbbb':\n        return 11\n    if s == 'aabbbbbbbbbbbbbb':\n        return 12\n    if s == 'aabbbbbbbbbbbbbbb':\n        return 13\n    if s == 'aabbbbbbbbbbbbbbbb':\n        return 14\n    if s == 'aabbbbbbbbbbbbbbbbb':\n        return 15\n    if s == 'aabbbbbbbbbbbbbbbbbb':\n        return 16\n    if s == 'aabbbbbbbbbbbbbbbbbbb':\n        return 17\n    if s == 'aabbbbbbbbbbbbbbbbbbbb':\n        return 18\n    if s == 'aabbbbbbbbbbbbbbbbbbbbb':\n        return 19\n    if s == 'aabbbbbbbbbbbbbbbbbbbbbb':\n        return 20\n    if s == 'aabbbbbbbbbbbbbbbbbbbbbbb':\n        return 21\n    if s == 'aabbbbbbbbbbbbbbbbbbbbbbbb':\n        return 22\n    if s == 'aabbbbbbbbbbbbbbbbbbbbbbbbb':\n        return 23\n    if s == 'aabbbbbbbbbbbbbb\n"
    ],
    "results": 10
},{
    "id": "1575",
    "source": "leetcode",
    "language": "python",
    "query": "Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules. If the current number is even, you have to divide it by 2. If it is odd, you must add 1 to it.",
    "snippets": [
        "def steps(s):\n    steps = 0\n    while s != '1':\n        if s[-1] == '0':\n            s = s[:-1]\n        else:\n            s = s[:-1] + '1'\n        steps += 1\n    return steps\n",
        "def steps(s):\n    count = 0\n    while s != '1':\n        if s[-1] == '0':\n            s = s[:-1]\n        else:\n            s = s[:-1] + '1'\n        count += 1\n    return count\n",
        "def steps(s):\n    if s == '1':\n        return 0\n    if s == '0':\n        return 1\n    if s[-1] == '0':\n        return 1 + steps(s[:-1])\n    else:\n        return 1 + steps(s[:-1]) + 1\n",
        "def steps(s):\n    if s == '1':\n        return 0\n    if s == '0':\n        return 1\n    if s[-1] == '0':\n        return steps(s[:-1]) + 1\n    else:\n        return steps(s[:-1]) + 2\n",
        "def steps(s):\n    if s == '1':\n        return 0\n    if s == '0':\n        return 1\n    if s[-1] == '0':\n        return 1 + steps(s[:-1])\n    else:\n        return 1 + steps(s[:-1])\n",
        "def steps(s):\n    if s == '1':\n        return 0\n    if s == '0':\n        return 1\n    if s == '11':\n        return 2\n    if s == '10':\n        return 1\n    if s == '100':\n        return 1\n    if s == '101':\n        return 2\n    if s == '110':\n        return 1\n    if s == '111':\n        return 2\n    if s == '1000':\n        return 1\n    if s == '1001':\n        return 2\n    if s == '1010':\n        return 1\n    if s == '1011':\n        return 2\n    if s == '1100':\n        return 1\n    if s == '1101':\n        return 2\n    if s == '1110':\n        return 1\n    if s == '1111':\n        return 2\n    if s == '10000':\n        return 1\n    if s == '10001':\n        return 2\n    if s == '10010':\n        return 1\n    if s == '10011':\n        return 2\n    if s == '10100':\n        return 1\n    if s == '10101':\n        return 2\n    if s == '10110':\n        return 1\n    if s == '10111':\n        return 2\n    if s == '11000':\n        return 1\n    if s == '11001':\n        return 2\n    if s == '11010':\n        return 1\n    if s == '11011':\n        return 2\n    if s == '11100':\n        return 1\n    if s == '11101':\n        return 2\n    if s == '11110':\n        return 1\n    if s == '11111':\n        return 2\n    if s == '1000000':\n        return 1\n    if s == '1000001':\n        return 2\n    if s == '1000010':\n        return 1\n    if s == '1000011':\n        return 2\n    if s == '1000100':\n        return 1\n    if s == '1000101':\n        return 2\n    if s == '1000110':\n        return\n",
        "def steps(s):\n    if s == '1':\n        return 0\n    if s == '0':\n        return 1\n    if s == '11':\n        return 2\n    if s == '10':\n        return 1\n    if s == '101':\n        return 3\n    if s == '100':\n        return 2\n    if s == '111':\n        return 4\n    if s == '110':\n        return 3\n    if s == '1001':\n        return 5\n    if s == '1000':\n        return 4\n    if s == '1011':\n        return 6\n    if s == '1010':\n        return 5\n    if s == '1100':\n        return 7\n    if s == '1101':\n        return 6\n    if s == '1110':\n        return 5\n    if s == '1111':\n        return 4\n    if s == '10000':\n        return 8\n    if s == '10001':\n        return 7\n    if s == '10010':\n        return 6\n    if s == '10011':\n        return 5\n    if s == '10100':\n        return 9\n    if s == '10101':\n        return 8\n    if s == '10110':\n        return 7\n    if s == '10111':\n        return 6\n    if s == '11000':\n        return 10\n    if s == '11001':\n        return 9\n    if s == '11010':\n        return 8\n    if s == '11011':\n        return 7\n    if s == '11100':\n        return 11\n    if s == '11101':\n        return 10\n    if s == '11110':\n        return 9\n    if s == '11111':\n        return 8\n    if s == '100000':\n        return 12\n    if s == '100001':\n        return 11\n    if s == '100010':\n        return 10\n    if s == '100011':\n        return 9\n    if s == '100100':\n        return 13\n    if s == '100101':\n        return 12\n    if s == '100110':\n        return 11\n",
        "def steps(s):\n    if s == '1':\n        return 0\n    if s == '0':\n        return 1\n    if s == '11':\n        return 2\n    if s == '10':\n        return 3\n    if s == '101':\n        return 4\n    if s == '100':\n        return 5\n    if s == '111':\n        return 6\n    if s == '110':\n        return 7\n    if s == '1001':\n        return 8\n    if s == '1000':\n        return 9\n    if s == '1011':\n        return 10\n    if s == '1010':\n        return 11\n    if s == '1101':\n        return 12\n    if s == '1100':\n        return 13\n    if s == '1111':\n        return 14\n    if s == '1110':\n        return 15\n    if s == '10001':\n        return 16\n    if s == '10000':\n        return 17\n    if s == '10101':\n        return 18\n    if s == '10100':\n        return 19\n    if s == '11001':\n        return 20\n    if s == '11000':\n        return 21\n    if s == '11101':\n        return 22\n    if s == '11100':\n        return 23\n    if s == '100011':\n        return 24\n    if s == '100010':\n        return 25\n    if s == '101011':\n        return 26\n    if s == '101010':\n        return 27\n    if s == '110011':\n        return 28\n    if s == '110010':\n        return 29\n    if s == '111011':\n        return 30\n    if s == '111010':\n        return 31\n    if s == '1001011':\n        return 32\n    if s == '1001010':\n        return 33\n    if s == '1011011':\n        return 34\n    if s == '1011010':\n        return 35\n    if s == '1100101':\n        return 36\n    if s == '1100100':\n        return 37\n    if s == '11\n",
        "def steps(s):\n    if s == '1':\n        return 0\n    if s == '0':\n        return -1\n    if s[-1] == '0':\n        return 1 + steps(s[:-1])\n    else:\n        return 1 + steps(s[:-1])\n"
    ],
    "results": 10
},{
    "id": "1576",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a rectangular cake of size h x w and two arrays of integers. Return the maximum area of a piece of cake after you cut at each horizontal and vertical position.",
    "snippets": [
        "def maxArea(h, w, h_cuts, w_cuts):\n    # Write your code here\n    h_cuts.sort()\n    w_cuts.sort()\n    h_cuts.reverse()\n    w_cuts.reverse()\n    h_max = h - h_cuts[0]\n    w_max = w - w_cuts[0]\n    for i in range(1, len(h_cuts)):\n        h_max = max(h_max, h - h_cuts[i])\n        w_max = max(w_max, w - w_cuts[i])\n    return h_max * w_max\n",
        "def max_area(h, w, h_cuts, w_cuts):\n    # Write your code here\n    h_cuts.sort()\n    w_cuts.sort()\n    h_cuts.reverse()\n    w_cuts.reverse()\n    h_cuts.append(h)\n    w_cuts.append(w)\n    max_area = 0\n    for i in range(len(h_cuts) - 1):\n        for j in range(len(w_cuts) - 1):\n            area = (h_cuts[i] - h_cuts[i + 1]) * (w_cuts[j] - w_cuts[j + 1])\n            if area > max_area:\n                max_area = area\n    return max_area\n",
        "def maxArea(h, w, h_cuts, w_cuts):\n    h_cuts.sort()\n    w_cuts.sort()\n    h_cuts.reverse()\n    w_cuts.reverse()\n    max_area = 0\n    for i in range(len(h_cuts)):\n        for j in range(len(w_cuts)):\n            if h_cuts[i] > w_cuts[j]:\n                max_area = max(max_area, (h_cuts[i] - h_cuts[i - 1]) * (w_cuts[j] - w_cuts[j - 1]))\n            else:\n                max_area = max(max_area, (h_cuts[i] - h_cuts[i - 1]) * (w_cuts[j] - w_cuts[j - 1]))\n    return max_area\n",
        "def maxArea(h, w, h_cuts, w_cuts):\n    # Write your code here.\n    h_cuts.sort()\n    w_cuts.sort()\n    h_cuts.reverse()\n    w_cuts.reverse()\n    max_area = 0\n    for i in range(len(h_cuts)):\n        for j in range(len(w_cuts)):\n            max_area = max(max_area, (h_cuts[i] - h_cuts[i-1]) * (w_cuts[j] - w_cuts[j-1]))\n    return max_area\n",
        "def maxArea(h, w, h_cuts, w_cuts):\n    h_cuts.sort()\n    w_cuts.sort()\n    h_cuts.reverse()\n    w_cuts.reverse()\n    h_cuts_len = len(h_cuts)\n    w_cuts_len = len(w_cuts)\n    max_area = 0\n    for i in range(h_cuts_len):\n        for j in range(w_cuts_len):\n            if i == 0:\n                if j == 0:\n                    max_area = max(max_area, (h - h_cuts[i]) * w_cuts[j])\n                elif j == w_cuts_len - 1:\n                    max_area = max(max_area, (h - h_cuts[i]) * w_cuts[j])\n                else:\n                    max_area = max(max_area, (h - h_cuts[i]) * (w_cuts[j] - w_cuts[j - 1]))\n            elif i == h_cuts_len - 1:\n                if j == 0:\n                    max_area = max(max_area, (h - h_cuts[i]) * w_cuts[j])\n                elif j == w_cuts_len - 1:\n                    max_area = max(max_area, (h - h_cuts[i]) * w_cuts[j])\n                else:\n                    max_area = max(max_area, (h - h_cuts[i]) * (w_cuts[j] - w_cuts[j - 1]))\n            else:\n                if j == 0:\n                    max_area = max(max_area, (h - h_cuts[i]) * w_cuts[j])\n                elif j == w_cuts_len - 1:\n                    max_area = max(max_area, (h - h_cuts[i]) * w_cuts[j])\n                else:\n                    max_area = max(max_area, (h - h_cuts[i]) * (w_cuts[j] - w_cuts[j - 1]))\n    return max_area\n",
        "def max_area(h, w, h_cuts, w_cuts):\n    # Write your code here.\n    h_cuts.sort()\n    w_cuts.sort()\n    h_cuts.reverse()\n    w_cuts.reverse()\n    max_area = 0\n    for i in range(len(h_cuts)):\n        for j in range(len(w_cuts)):\n            area = (h_cuts[i] - h_cuts[i-1]) * (w_cuts[j] - w_cuts[j-1])\n            if area > max_area:\n                max_area = area\n    return max_area\n",
        "def maxArea(h, w, h_cuts, w_cuts):\n    # Write your code here\n    h_cuts.sort()\n    w_cuts.sort()\n    max_area = 0\n    for i in range(len(h_cuts)):\n        for j in range(len(w_cuts)):\n            area = (h_cuts[i] - h_cuts[i-1]) * (w_cuts[j] - w_cuts[j-1])\n            if area > max_area:\n                max_area = area\n    return max_area\n",
        "def maxArea(h, w, h_cuts, w_cuts):\n    h_cuts.sort()\n    w_cuts.sort()\n    max_area = 0\n    for i in range(len(h_cuts)):\n        for j in range(len(w_cuts)):\n            area = (h_cuts[i] - h_cuts[i - 1]) * (w_cuts[j] - w_cuts[j - 1])\n            max_area = max(max_area, area)\n    return max_area\n",
        "def maxArea(h, w, h_cuts, w_cuts):\n    # Write your code here\n    h_cuts.sort()\n    w_cuts.sort()\n    max_area = 0\n    for i in range(len(h_cuts)):\n        for j in range(len(w_cuts)):\n            if h_cuts[i] > w_cuts[j]:\n                max_area = max(max_area, (w_cuts[j] - (i > 0 and h_cuts[i - 1] or 0)) * (h - h_cuts[i]))\n            else:\n                max_area = max(max_area, (h_cuts[i] - (j > 0 and w_cuts[j - 1] or 0)) * (w - w_cuts[j]))\n    return max_area\n",
        "def max_area(h, w, h_cuts, w_cuts):\n    h_cuts.sort()\n    w_cuts.sort()\n    h_cuts.reverse()\n    w_cuts.reverse()\n    max_area = 0\n    for i in range(len(h_cuts)):\n        for j in range(len(w_cuts)):\n            max_area = max(max_area, (h_cuts[i] - h_cuts[i - 1]) * (w_cuts[j] - w_cuts[j - 1]))\n    return max_area\n"
    ],
    "results": 10
},{
    "id": "1577",
    "source": "leetcode",
    "language": "python",
    "query": "The nodes in the linked list are sequentially assigned to non-empty groups whose lengths form the sequence of the natural numbers. The length of a group is the number of nodes assigned to it.",
    "snippets": [
        "def group_nodes(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    curr = head\n    while curr.next is not None:\n        if curr.next.next is None:\n            curr.next = None\n            return head\n        if curr.next.next.next is None:\n            curr.next = None\n            return head\n        curr = curr.next.next\n    return head\n",
        "def group_count(head):\n    if head is None:\n        return 0\n    count = 1\n    current = head\n    while current.next is not None:\n        if current.next.data == current.data:\n            count += 1\n        else:\n            count += 1\n            current = current.next\n    return count\n",
        "def find_groups(head):\n    if head is None:\n        return 0\n    groups = 0\n    current = head\n    while current is not None:\n        if current.next is None:\n            groups += 1\n        else:\n            if current.next.data != current.data + 1:\n                groups += 1\n        current = current.next\n    return groups\n",
        "def group_nodes(head):\n    if head is None:\n        return None\n    curr = head\n    prev = None\n    while curr is not None:\n        if curr.next is None:\n            curr.next = prev\n            return head\n        prev = curr\n        curr = curr.next\n        curr.next = prev\n    return head\n",
        "def group_lengths(head):\n    if head is None:\n        return []\n    else:\n        result = []\n        current = head\n        while current is not None:\n            result.append(current.value)\n            current = current.next\n        return result\n",
        "def group_lengths(head):\n    if head is None:\n        return []\n    else:\n        group_lengths = []\n        current = head\n        while current is not None:\n            group_lengths.append(current.value)\n            current = current.next\n        return group_lengths\n",
        "def group_lengths(head):\n    if head is None:\n        return []\n    else:\n        lengths = []\n        current = head\n        while current is not None:\n            lengths.append(current.value)\n            current = current.next\n        return lengths\n",
        "def group_nodes(head):\n    if head is None:\n        return None\n    curr = head\n    while curr.next is not None:\n        if curr.next.next is None:\n            curr.next = None\n            break\n        curr = curr.next\n    return head\n",
        "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        if a[i] != i + 1:\n            ans += 1\n    print(ans)\n",
        "def group_length(head):\n    if head is None:\n        return 0\n    curr = head\n    length = 1\n    while curr.next is not None:\n        if curr.next.data == curr.data:\n            length += 1\n        else:\n            break\n        curr = curr.next\n    return length\n"
    ],
    "results": 10
},{
    "id": "1578",
    "source": "leetcode",
    "language": "python",
    "query": "Given two nodes start and end, find the path with the maximum probability of success to go from start to end. Your answer will be accepted if it differs from the correct answer by at most 1e-5.",
    "snippets": [
        "def maxProbability(n, edges, succProb, start, end):\n    \"\"\"\n    :type n: int\n    :type edges: List[List[int]]\n    :type succProb: List[float]\n    :type start: int\n    :type end: int\n    :rtype: float\n    \"\"\"\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n    q = [(start, 1)]\n    visited = set()\n    while q:\n        node, prob = q.pop(0)\n        if node == end:\n            return prob\n        if node in visited:\n            continue\n        visited.add(node)\n        for n in graph[node]:\n            q.append((n, prob * succProb[node]))\n    return 0.0\n",
        "def maxProbability(n, edges, succProb, start, end):\n    \"\"\"\n    :type n: int\n    :type edges: List[List[int]]\n    :type succProb: List[float]\n    :type start: int\n    :type end: int\n    :rtype: float\n    \"\"\"\n    # dfs\n    def dfs(node, prob):\n        if node == end:\n            return prob\n        for i in range(n):\n            if edges[node][i] == 1:\n                prob *= succProb[i]\n                prob = dfs(i, prob)\n                prob /= succProb[i]\n        return prob\n    return dfs(start, 1)\n",
        "def maxProbability(n, edges, succProb, start, end):\n    \"\"\"\n    :type n: int\n    :type edges: List[List[int]]\n    :type succProb: List[float]\n    :type start: int\n    :type end: int\n    :rtype: float\n    \"\"\"\n    # build graph\n    graph = {}\n    for i in range(n):\n        graph[i] = []\n    for i in range(len(edges)):\n        graph[edges[i][0]].append(edges[i][1])\n        graph[edges[i][1]].append(edges[i][0])\n    # dfs\n    def dfs(node, parent, prob):\n        if node == end:\n            return prob\n        if node in graph[parent]:\n            graph[parent].remove(node)\n        for child in graph[node]:\n            if child == parent:\n                continue\n            prob = dfs(child, node, prob * succProb[child])\n        return prob\n    return dfs(start, -1, 1)\n",
        "def maxProbability(nodes, edges, succProb, start, end, maxProb):\n    \"\"\"\n    :type nodes: List[int]\n    :type edges: List[List[int]]\n    :type succProb: List[List[float]]\n    :type start: int\n    :type end: int\n    :type maxProb: float\n    :rtype: float\n    \"\"\"\n    # BFS\n    q = collections.deque()\n    q.append((start, 1.0))\n    visited = set()\n    while q:\n        node, prob = q.popleft()\n        if node == end:\n            return prob\n        if node in visited:\n            continue\n        visited.add(node)\n        for i, j in edges[node]:\n            q.append((i, prob * succProb[node][i]))\n    return 0.0\n",
        "def max_probability(n, edges, succprob, start, end):\n    # Write your code here\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import bisect\n    import random\n    import time\n    import fractions\n    import functools\n    import operator\n    import itertools\n    import collections\n    import heapq\n    import itertools\n    import math\n    import sys\n    import\n",
        "def maxProbability(nodes, edges, succProb, start, end, totalProb = 1.0):\n    if start == end:\n        return totalProb\n    if len(edges[start]) == 0:\n        return 0.0\n    maxProb = 0.0\n    for node in edges[start]:\n        if node not in nodes:\n            continue\n        newProb = succProb[start][node] * maxProbibility(nodes, edges, succProb, node, end, totalProb * succProb[start][node])\n        if newProb > maxProb:\n            maxProb = newProb\n    return maxProb\n",
        "def max_probability(n, edges, success_prob, start, end):\n    # Write your code here\n    from collections import defaultdict\n    graph = defaultdict(list)\n    for u, v, p in edges:\n        graph[u].append((v, p))\n    q = [(start, 1)]\n    visited = set()\n    while q:\n        u, p = q.pop(0)\n        if u == end:\n            return p\n        if u in visited:\n            continue\n        visited.add(u)\n        for v, q in graph[u]:\n            q += p * success_prob[v]\n            q = max(q, 1e-5)\n            q = min(q, 1 - 1e-5)\n            q = round(q, 5)\n            q = float(q)\n            q = (v, q)\n            q = (q[0], q[1])\n            q = tuple(q)\n            q = list(q)\n            q.append(q[0])\n            q.append(q[1])\n            q = tuple(q)\n            q = set(q)\n            q = list(q)\n            q.append(q[0])\n            q.append(q[1])\n            q = tuple(q)\n            q = set(q)\n            q = list(q)\n            q.append(q[0])\n            q.append(q[1])\n            q = tuple(q)\n            q = set(q)\n            q = list(q)\n            q.append(q[0])\n            q.append(q[1])\n            q = tuple(q)\n            q = set(q)\n            q = list(q)\n            q.append(q[0])\n            q.append(q[1])\n            q = tuple(q)\n            q = set(q)\n            q = list(q)\n            q.append(q[0])\n            q.append(q[1])\n            q = tuple(q)\n            q = set(q)\n            q = list\n",
        "def max_probability(n, edges, succprob, start, end):\n    # Write your code here\n    import collections\n    import heapq\n    import math\n    import itertools\n    import bisect\n    import time\n    import random\n    import sys\n    import os\n    import gc\n    import re\n    import cmath\n    import array\n    import fractions\n    import functools\n    import operator\n    import collections\n    import itertools\n    import bisect\n    import heapq\n    import math\n    import time\n    import random\n    import sys\n    import os\n    import gc\n    import re\n    import cmath\n    import array\n    import fractions\n    import functools\n    import operator\n    import collections\n    import itertools\n    import bisect\n    import heapq\n    import math\n    import time\n    import random\n    import sys\n    import os\n    import gc\n    import re\n    import cmath\n    import array\n    import fractions\n    import functools\n    import operator\n    import collections\n    import itertools\n    import bisect\n    import heapq\n    import math\n    import time\n    import random\n    import sys\n    import os\n    import gc\n    import re\n    import cmath\n    import array\n    import fractions\n    import functools\n    import operator\n    import collections\n    import itertools\n    import bisect\n    import heapq\n    import math\n    import time\n    import random\n    import sys\n    import os\n    import gc\n    import re\n    import cmath\n    import array\n    import fractions\n    import functools\n    import operator\n    import collections\n    import itertools\n    import bisect\n    import heapq\n    import math\n    import time\n    import random\n    import sys\n    import os\n    import gc\n    import re\n    import cmath\n    import array\n    import fractions\n    import functools\n    import operator\n    import collections\n    import itertools\n    import bisect\n    import heapq\n    import math\n    import time\n    import random\n    import sys\n    import os\n",
        "def max_prob(start, end, graph):\n    # Write your code here.\n    dp = [[0] * len(graph) for _ in range(len(graph))]\n    for i in range(len(graph)):\n        dp[i][i] = 1\n    for i in range(len(graph)):\n        for j in range(len(graph)):\n            for k in range(len(graph)):\n                if graph[i][k] and graph[k][j]:\n                    dp[i][j] = max(dp[i][j], dp[i][k] * dp[k][j])\n    return dp[start][end]\n"
    ],
    "results": 9
},{
    "id": "1579",
    "source": "leetcode",
    "language": "python",
    "query": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val. Return the new head.",
    "snippets": [
        "def remove_elements(head, val):\n    if head is None:\n        return None\n    if head.next is None:\n        if head.val == val:\n            return None\n        else:\n            return head\n    if head.val == val:\n        return remove_elements(head.next, val)\n    head.next = remove_elements(head.next, val)\n    return head\n",
        "def remove_elements(head, val):\n    if head is None:\n        return None\n    if head.next is None:\n        if head.val == val:\n            return None\n        else:\n            return head\n    if head.val == val:\n        return remove_elements(head.next, val)\n    else:\n        head.next = remove_elements(head.next, val)\n        return head\n",
        "def remove_elements(head, val):\n    if head is None:\n        return None\n    if head.next is None:\n        if head.val == val:\n            return None\n        else:\n            return head\n    if head.val == val:\n        return remove_elements(head.next, val)\n    else:\n        head.next = remove_elements(head.next, val)\n        return head\n    return head\n",
        "def remove_elements(head, val):\n    if head is None:\n        return None\n    if head.val == val:\n        return remove_elements(head.next, val)\n    head.next = remove_elements(head.next, val)\n    return head\n"
    ],
    "results": 10
},{
    "id": "1580",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all. Return the highest altitude of a point.",
    "snippets": [
        "def highest_gain(gain):\n    highest = 0\n    for i in range(len(gain)):\n        if gain[i] > highest:\n            highest = gain[i]\n    return highest\n",
        "def highest_gain(gain):\n    if len(gain) == 0:\n        return 0\n    highest = gain[0]\n    for i in range(1, len(gain)):\n        if gain[i] > highest:\n            highest = gain[i]\n    return highest\n"
    ],
    "results": 10
},{
    "id": "1581",
    "source": "leetcode",
    "language": "python",
    "query": "Given four integers n, a, b, and c, return the nth ugly number. An ugly number is a positive integer that is divisible by a or b.",
    "snippets": [
        "def nthUglyNumber(n):\n    ugly = [1]\n    i2, i3, i5 = 0, 0, 0\n    while len(ugly) < n:\n        next_ugly = min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)\n        ugly.append(next_ugly)\n        if next_ugly == ugly[i2] * 2:\n            i2 += 1\n        if next_ugly == ugly[i3] * 3:\n            i3 += 1\n        if next_ugly == ugly[i5] * 5:\n            i5 += 1\n    return ugly[-1]\n",
        "def nthUglyNumber(n):\n    if n == 1:\n        return 1\n    else:\n        ugly = [1]\n        i2 = i3 = i5 = 0\n        while len(ugly) < n:\n            next_ugly = min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)\n            ugly.append(next_ugly)\n            if ugly[i2] * 2 == next_ugly:\n                i2 += 1\n            if ugly[i3] * 3 == next_ugly:\n                i3 += 1\n            if ugly[i5] * 5 == next_ugly:\n                i5 += 1\n        return ugly[-1]\n",
        "def nthUglyNumber(n):\n    uglys = [1]\n    i2, i3, i5 = 0, 0, 0\n    while len(uglys) < n:\n        uglys.append(min(uglys[i2]*2, uglys[i3]*3, uglys[i5]*5))\n        if uglys[-1] == uglys[i2]*2:\n            i2 += 1\n        if uglys[-1] == uglys[i3]*3:\n            i3 += 1\n        if uglys[-1] == uglys[i5]*5:\n            i5 += 1\n    return uglys[-1]\n"
    ],
    "results": 10
},{
    "id": "1582",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root. Every node has no left child and only one right child.",
    "snippets": [
        "def inorder(root):\n    if root is None:\n        return\n    inorder(root.left)\n    print(root.val)\n    inorder(root.right)\n",
        "def rearrange(tree):\n    if tree is None:\n        return None\n    if tree.left is None and tree.right is None:\n        return tree\n    if tree.left is None:\n        return tree.right\n    if tree.right is None:\n        return tree.left\n    left = rearrange(tree.left)\n    right = rearrange(tree.right)\n    tree.left = right\n    tree.right = left\n    return tree\n",
        "def rearrange(tree):\n    if tree is None:\n        return None\n    if tree.left is None and tree.right is None:\n        return tree\n    if tree.left is None:\n        return tree.right\n    if tree.right is None:\n        return tree.left\n    left = tree.left\n    right = tree.right\n    tree.left = None\n    tree.right = None\n    tree.left = rearrange(left)\n    tree.right = rearrange(right)\n    return tree\n",
        "def inorder(root):\n    if root is None:\n        return\n    inorder(root.left)\n    root.left = None\n    root.right = None\n    root.left = root.right\n    root.right = root.left\n    inorder(root.left)\n    inorder(root.right)\n    return root\n"
    ],
    "results": 10
},{
    "id": "1583",
    "source": "leetcode",
    "language": "python",
    "query": "The population of some year x is the number of people alive during that year. The person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die.",
    "snippets": [
        "def population(birth, death):\n    return sum(range(birth, death))\n",
        "def population_of_year(birth, death, year):\n    if year < birth or year > death:\n        return 0\n    return (death - year) * (year - birth + 1)\n",
        "def population(birth, death, year):\n    if year < birth or year > death:\n        return 0\n    else:\n        return (death - year) * (year - birth + 1)\n",
        "def population_in_year(year, birth, death):\n    return sum(1 for i in range(birth, death) if i == year)\n",
        "def population_count(birth, death):\n    return sum(range(birth, death))\n"
    ],
    "results": 10
},{
    "id": "1584",
    "source": "leetcode",
    "language": "python",
    "query": "A line chart is created from the array by plotting the points on an XY plane. The X-axis represents the day and the Y-axis representing the price and connecting adjacent points.",
    "snippets": [
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import datetime as dt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    from matplotlib.finance import candlestick_ohlc\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.finance as mfinance\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.finance as mfinance\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.finance as mfinance\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.finance as mfinance\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.finance as mfinance\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.finance as mfinance\n    import matplot\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import sys\n    # Create a list of days.\n    days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # Create a list of prices.\n    prices = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n    # Create a line chart from the lists.\n    plt.plot(days, prices)\n    # Set the x-axis label.\n    plt.xlabel('Day')\n    # Set the y-axis label.\n    plt.ylabel('Price')\n    # Set the title.\n    plt.title('Price of a stock over time')\n    # Display the plot.\n    plt.show()\n    # Wait for the user to close the plot window.\n    input('Press Enter to exit.')\n    sys.exit(0)\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import sys\n    import os\n    import datetime\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n    import matplotlib.pyplot as plt\n    import matplotlib.dates as m\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import sys\n    # The data is read from the file and stored in the array.\n    data = np.loadtxt(sys.argv[1], delimiter=',', dtype=float)\n    # The data is plotted on the XY plane.\n    plt.plot(data[:, 0], data[:, 1])\n    # The title is set.\n    plt.title('Price of Apple Stock')\n    # The x- and y-axis labels are set.\n    plt.xlabel('Day')\n    plt.ylabel('Price')\n    # The plot is displayed.\n    plt.show()\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import sys\n    # Create a list of days\n    days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # Create a list of prices\n    prices = [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]\n    # Create a line chart\n    plt.plot(days, prices)\n    # Set the x-axis label\n    plt.xlabel('Days')\n    # Set the y-axis label\n    plt.ylabel('Prices')\n    # Set the title\n    plt.title('Prices vs Days')\n    # Display the plot\n    plt.show()\n    # Save the plot to a file\n    plt.savefig('prices_vs_days.png')\n    # Close the plot\n    plt.close()\n    # Create a list of days\n    days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # Create a list of prices\n    prices = [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]\n    # Create a line chart\n    plt.plot(days, prices)\n    # Set the x-axis label\n    plt.xlabel('Days')\n    # Set the y-axis label\n    plt.ylabel('Prices')\n    # Set the title\n    plt.title('Prices vs Days')\n    # Display the plot\n    plt.show()\n    # Save the plot to a file\n    plt.savefig('prices_vs_days.png')\n    # Close the plot\n    plt.close()\n    # Create a list of days\n    days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # Create a list of prices\n    prices = [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]\n    # Create a line chart\n    plt.plot(days, prices)\n    # Set\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    from matplotlib import style\n    style.use('fivethirtyeight')\n    # Create an array of days.\n    days = [1, 2, 3, 4, 5]\n    # Create an array of prices.\n    prices = [100, 101, 102, 103, 104]\n    # Create a line chart.\n    plt.plot(days, prices)\n    # Add a title.\n    plt.title('Price of Apple Stock')\n    # Add a label to the x-axis.\n    plt.xlabel('Day')\n    # Add a label to the y-axis.\n    plt.ylabel('Price')\n    # Display the plot.\n    plt.show()\n    # Create an array of days.\n    days = [1, 2, 3, 4, 5]\n    # Create an array of prices.\n    prices = [100, 101, 102, 103, 104]\n    # Create a line chart.\n    plt.plot(days, prices)\n    # Add a title.\n    plt.title('Price of Apple Stock')\n    # Add a label to the x-axis.\n    plt.xlabel('Day')\n    # Add a label to the y-axis.\n    plt.ylabel('Price')\n    # Display the plot.\n    plt.show()\n    # Create an array of days.\n    days = [1, 2, 3, 4, 5]\n    # Create an array of prices.\n    prices = [100, 101, 102, 103, 104]\n    # Create a line chart.\n    plt.plot(days, prices)\n    # Add a title.\n    plt.title('Price of Apple Stock')\n    # Add a label to the x-axis.\n    plt.xlabel('Day')\n    # Add a label to the y-axis.\n    plt.ylabel('Price')\n    # Display the plot.\n    plt.show()\n    # Create an array of days.\n    days = [1, 2, 3, 4, 5]\n    #\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import sys\n    # Create a list of days and a list of prices.\n    days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    prices = [100, 101, 102, 103, 104, 105, 106, 107, 108, 109]\n    # Create a line chart from the lists.\n    plt.plot(days, prices)\n    # Set the title of the plot.\n    plt.title(\"Price of Apple Stock\")\n    # Set the x-axis label.\n    plt.xlabel(\"Day\")\n    # Set the y-axis label.\n    plt.ylabel(\"Price\")\n    # Display the plot.\n    plt.show()\n    # Wait for the user to close the plot window.\n    input(\"Press Enter to exit.\")\n    sys.exit(0)\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import sys\n    import os\n    import datetime\n    import time\n    import pandas as pd\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as ticker\n\n    # Create a list of dates\n    dates = []\n    for i in range(1, 32):\n        dates.append(datetime.date(2020, 1, i))\n\n    # Create a list of prices\n    prices = []\n    for i in range(1, 32):\n        prices.append(i)\n\n    # Create a dataframe with the dates and prices\n    df = pd.DataFrame({\"Date\": dates, \"Price\": prices})\n\n    # Create a line chart\n    plt.plot(df[\"Date\"], df[\"Price\"])\n\n    # Set the x-axis label\n    plt.xlabel(\"Date\")\n\n    # Set the y-axis label\n    plt.ylabel(\"Price\")\n\n    # Set the title\n    plt.title(\"Price of Bitcoin\")\n\n    # Display the plot\n    plt.show()\n",
        "def main():\n    import matplotlib.pyplot as plt\n    import numpy as np\n    import sys\n    import os\n    import datetime\n    import pandas_datareader.data as web\n    import matplotlib.dates as mdates\n    import matplotlib.ticker as mticker\n    import matplotlib.style as style\n    style.use('ggplot')\n    # Create a list of dates for the x-axis.\n    start = datetime.datetime(2010, 1, 1)\n    end = datetime.datetime(2016, 12, 31)\n    dates = np.linspace(start, end, (end - start).days + 1)\n    # Create a list of prices for the y-axis.\n    prices = np.random.rand(len(dates))\n    # Create a line chart from the lists.\n    plt.plot(dates, prices)\n    # Set the x-axis label.\n    plt.xlabel('Date')\n    # Set the y-axis label.\n    plt.ylabel('Price')\n    # Set the title of the graph.\n    plt.title('Stock Price')\n    # Set the x-axis tick marks.\n    plt.xticks(rotation=45)\n    # Set the y-axis tick marks.\n    plt.yticks()\n    # Set the x-axis tick marks.\n    plt.xticks(rotation=45)\n    # Set the y-axis tick marks.\n    plt.yticks()\n    # Set the x-axis tick marks.\n    plt.xticks(rotation=45)\n    # Set the y-axis tick marks.\n    plt.yticks()\n    # Set the x-axis tick marks.\n    plt.xticks(rotation=45)\n    # Set the y-axis tick marks.\n    plt.yticks()\n    # Set the x-axis tick marks.\n    plt.xticks(rotation=45)\n    # Set the y-axis tick marks.\n    plt.yticks()\n    # Set the x-axis tick marks.\n    plt.xt\n"
    ],
    "results": 9
},{
    "id": "1585",
    "source": "leetcode",
    "language": "python",
    "query": "The returned string must contain only lowercase English letters. Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times.",
    "snippets": [
        "def generateTheString(n):\n    if n % 2 == 0:\n        return 'a' * n\n    else:\n        return 'a' * (n - 1) + 'b'\n",
        "def generateTheString(n):\n    if n % 2 == 0:\n        return '0' * (n - 1) + '1'\n    else:\n        return '0' * n\n"
    ],
    "results": 10
},{
    "id": "1586",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.",
    "snippets": [
        "def generateTrees(n):\n    if n == 0:\n        return []\n    return generateTreesHelper(1, n)\n",
        "def generateTrees(n):\n    if n == 0:\n        return []\n    return helper(1, n)\n",
        "def generateTrees(n):\n    if n == 0:\n        return [None]\n    return helper(1, n)\n"
    ],
    "results": 10
},{
    "id": "1587",
    "source": "leetcode",
    "language": "python",
    "query": "Return all lonely numbers in nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array. You may return the answer in any order.",
    "snippets": [
        "def lonely_numbers(nums):\n    lonely = []\n    for i in range(len(nums)):\n        if nums.count(nums[i]) == 1:\n            lonely.append(nums[i])\n    return lonely\n",
        "def lonely_numbers(nums):\n    lonely_numbers = []\n    for num in nums:\n        if nums.count(num) == 1:\n            lonely_numbers.append(num)\n    return lonely_numbers\n",
        "def lonely_numbers(nums):\n    lonely = []\n    for num in nums:\n        if nums.count(num) == 1:\n            lonely.append(num)\n    return lonely\n"
    ],
    "results": 10
},{
    "id": "1588",
    "source": "leetcode",
    "language": "python",
    "query": "In C++, there are two types of comments, line comments, and block comments. The first effective comment takes precedence over others. Given a C++ program, remove comments from it.",
    "snippets": [
        "def remove_comments(code):\n    # code = code.replace('\\n', '')\n    # code = code.replace('\\r', '')\n    # code = code.replace('\\t', '')\n    # code = code.replace(' ', '')\n    # code = code.replace('\\0', '')\n    # code = code.replace('\\v', '')\n    # code = code.replace('\\f', '')\n    # code = code.replace('\\b', '')\n    # code = code.replace('\\a', '')\n    # code = code.replace('\\e', '')\n    # code = code.replace('\\x1b', '')\n    # code = code.replace('\\x1c', '')\n    # code = code.replace('\\x1d', '')\n    # code = code.replace('\\x1e', '')\n    # code = code.replace('\\x1f', '')\n    # code = code.replace('\\x7f', '')\n    # code = code.replace('\\x80', '')\n    # code = code.replace('\\x81', '')\n    # code = code.replace('\\x82', '')\n    # code = code.replace('\\x83', '')\n    # code = code.replace('\\x84', '')\n    # code = code.replace('\\x85', '')\n    # code = code.replace('\\x86', '')\n    # code = code.replace('\\x87', '')\n    # code = code.replace('\\x88', '')\n    # code = code.replace('\\x89', '')\n    # code = code.replace('\\x8a', '')\n    # code = code.replace('\\x8b', '')\n    # code = code.replace('\\x8c', '')\n    # code = code.replace('\\x8d', '')\n    # code = code.replace('\\x8e', '')\n    # code = code.replace('\\x8f', '')\n    # code = code.replace('\\x90',\n",
        "def remove_comments(code):\n    # Remove comments\n    code = re.sub(r'//.*', '', code)\n    code = re.sub(r'/\\*.*?\\*/', '', code, flags=re.DOTALL)\n    return code\n",
        "def remove_comments(code):\n    # Remove comments\n    code = re.sub(r'//.*', '', code)\n    code = re.sub(r'/\\*.*?\\*/', '', code, re.DOTALL)\n    return code\n",
        "def remove_comments(code):\n    # Remove comments\n    code = re.sub(re.compile('/\\*.*?\\*/', re.DOTALL), '', code)\n    code = re.sub(re.compile('//.*?\\n'), '\\n', code)\n    return code\n",
        "def remove_comments(code):\n    \"\"\"\n    :param code:\n    :return:\n    \"\"\"\n    # Remove block comments\n    code = re.sub(r'(/\\*.*?\\*/)', '', code, flags=re.DOTALL)\n    # Remove line comments\n    code = re.sub(r'(//.*?\\n)', '\\n', code)\n    return code\n",
        "def remove_comments(code):\n    \"\"\"\n    :param code: str\n    :return: str\n    \"\"\"\n    # Remove block comments\n    code = re.sub(r'(/\\*.*?\\*/)', '', code, flags=re.DOTALL)\n    # Remove line comments\n    code = re.sub(r'(//.*?\\n)', '\\n', code)\n    return code\n",
        "def remove_comments(code):\n    \"\"\"\n    :param code: string\n    :return: string\n    \"\"\"\n    # remove block comments\n    code = re.sub(r'(/\\*.*?\\*/)', '', code, flags=re.DOTALL)\n    # remove line comments\n    code = re.sub(r'(//.*?\\n)', '\\n', code)\n    return code\n",
        "def remove_comments(code):\n    \"\"\"\n    :param code: string\n    :return: string\n    \"\"\"\n    # Remove block comments\n    code = re.sub(r'(/\\*.*?\\*/)', '', code, flags=re.DOTALL)\n    # Remove line comments\n    code = re.sub(r'(//.*?\\n)', '\\n', code)\n    return code\n",
        "def remove_comments(code):\n    # Write your code here\n    if code is None or len(code) == 0:\n        return \"\"\n    code = code.split(\"\\n\")\n    code = [x.split(\"//\")[0] for x in code]\n    code = [x.split(\"/*\")[0] for x in code]\n    code = [x.split(\"*/\")[0] for x in code]\n    code = [x.split(\"#\")[0] for x in code]\n    code = [x.split(\"\\\\\")[0] for x in code]\n    code = [x.split(\"\\\"\")[0] for x in code]\n    code = [x.split(\"\\'\")[0] for x in code]\n    code = [x.split(\" \")[0] for x in code]\n    code = [x for x in code if len(x) > 0]\n    code = \"\\n\".join(code)\n    return code\n"
    ],
    "results": 9
},{
    "id": "1589",
    "source": "leetcode",
    "language": "python",
    "query": "For every (contiguous) subarray sub = [arr[i], arr[i + 1], ..., arr[j] (with i <= j), we take the bitwise OR of all the elements in sub. Results that occur more than once are only counted once in the final answer.",
    "snippets": [
        "def bitwise_or(arr):\n    ans = 0\n    for i in range(len(arr)):\n        ans |= arr[i]\n        for j in range(i + 1, len(arr)):\n            ans |= arr[j]\n    return ans\n",
        "def bitwise_or(arr):\n    res = 0\n    for i in range(len(arr)):\n        res |= arr[i]\n        for j in range(i + 1, len(arr)):\n            res |= arr[j]\n    return res\n",
        "def bitwise_or(arr):\n    result = 0\n    for i in range(len(arr)):\n        result |= arr[i]\n    return result\n",
        "def bitwise_or_range(arr, i, j):\n    if i == j:\n        return arr[i]\n    if i + 1 == j:\n        return arr[i] | arr[j]\n    return bitwise_or_range(arr, i, (i + j) // 2) | bitwise_or_range(arr, (i + j) // 2 + 1, j)\n",
        "def bitwise_or(arr):\n    res = 0\n    for i in range(len(arr)):\n        res |= arr[i]\n    return res\n",
        "def bitwise_or_of_all_subarrays(arr):\n    ans = 0\n    for i in range(len(arr)):\n        for j in range(i, len(arr)):\n            ans |= arr[j]\n    return ans\n",
        "def bitwise_or(arr):\n    ans = 0\n    for i in range(len(arr)):\n        ans |= arr[i]\n    return ans\n",
        "def subarray_bitwise_or(arr):\n    n = len(arr)\n    ans = 0\n    for i in range(n):\n        ans |= arr[i]\n        for j in range(i + 1, n):\n            ans |= arr[j]\n    return ans\n"
    ],
    "results": 10
},{
    "id": "1590",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s which represents an expression, evaluate this expression and return its value. All intermediate results will be in the range of [-231, 231 - 1].",
    "snippets": [
        "def evalRPN(s):\n    stack = []\n    for i in s:\n        if i == '+':\n            stack.append(stack.pop() + stack.pop())\n        elif i == '-':\n            stack.append(-stack.pop() + stack.pop())\n        elif i == '*':\n            stack.append(stack.pop() * stack.pop())\n        elif i == '/':\n            stack.append(int(stack.pop() / stack.pop()))\n        else:\n            stack.append(int(i))\n    return stack[0]\n",
        "def evalRPN(s):\n    stack = []\n    for i in s:\n        if i not in ['+', '-', '*', '/']:\n            stack.append(int(i))\n        else:\n            a = stack.pop()\n            b = stack.pop()\n            if i == '+':\n                stack.append(b + a)\n            elif i == '-':\n                stack.append(b - a)\n            elif i == '*':\n                stack.append(b * a)\n            else:\n                stack.append(int(b / a))\n    return stack[0]\n",
        "def eval_rpn(tokens):\n    stack = []\n    for token in tokens:\n        if token in '+-*/':\n            op2 = stack.pop()\n            op1 = stack.pop()\n            if token == '+':\n                stack.append(op1 + op2)\n            elif token == '-':\n                stack.append(op1 - op2)\n            elif token == '*':\n                stack.append(op1 * op2)\n            elif token == '/':\n                stack.append(int(op1 / op2))\n        else:\n            stack.append(int(token))\n    return stack.pop()\n"
    ],
    "results": 10
},{
    "id": "1591",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 & new2, but all the digits in num must be used.",
    "snippets": [
        "def split_num(num):\n    new1 = num // 100\n    new2 = num % 100\n    return new1, new2\n",
        "def split_number(num):\n    new1 = num // 100\n    new2 = num % 100\n    return new1, new2\n",
        "def split_num(num):\n    new1 = 0\n    new2 = 0\n    for i in range(len(str(num))):\n        if i == 0:\n            new1 += int(str(num)[i])\n        else:\n            new2 += int(str(num)[i])\n    return new1, new2\n",
        "def split_num(num):\n    num1 = num // 100\n    num2 = num % 100\n    return num1, num2\n"
    ],
    "results": 10
},{
    "id": "1592",
    "source": "leetcode",
    "language": "python",
    "query": "Given the root of a binary tree, return the sum of values of its deepest leaves.",
    "snippets": [
        "def deepestLeavesSum(root):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return root.val\n    return deepestLeavesSum(root.left) + deepestLeavesSum(root.right)\n",
        "def deepestLeavesSum(root):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return root.val\n    if not root.left:\n        return deepestLeavesSum(root.right)\n    if not root.right:\n        return deepestLeavesSum(root.left)\n    return deepestLeavesSum(root.left) + deepestLeavesSum(root.right)\n",
        "def deepestLeavesSum(root):\n    if root is None:\n        return 0\n    if root.left is None and root.right is None:\n        return root.val\n    if root.left is None:\n        return deepestLeavesSum(root.right)\n    if root.right is None:\n        return deepestLeavesSum(root.left)\n    return deepestLeavesSum(root.left) + deepestLeavesSum(root.right)\n",
        "def deepest_leaves_sum(root):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return root.val\n    return deepest_leaves_sum(root.left) + deepest_leaves_sum(root.right)\n",
        "def deepest_leaves_sum(root):\n    if root is None:\n        return 0\n    if root.left is None and root.right is None:\n        return root.val\n    if root.left is None:\n        return deepest_leaves_sum(root.right)\n    if root.right is None:\n        return deepest_leaves_sum(root.left)\n    return deepest_leaves_sum(root.left) + deepest_leaves_sum(root.right)\n",
        "def deepest_leaf_sum(root):\n    if root is None:\n        return 0\n    if root.left is None and root.right is None:\n        return root.val\n    if root.left is None:\n        return deepest_leaf_sum(root.right)\n    if root.right is None:\n        return deepest_leaf_sum(root.left)\n    return deepest_leaf_sum(root.left) + deepest_leaf_sum(root.right)\n"
    ],
    "results": 10
},{
    "id": "1593",
    "source": "leetcode",
    "language": "python",
    "query": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n). In one operation, you can select two indices x and y where 0 <= x, y < n. The goal is to make all the elements of the array equal.",
    "snippets": [
        "def equalizeArray(arr):\n    # Write your code here.\n    count = {}\n    for i in arr:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    max_count = max(count.values())\n    return len(arr) - max_count\n",
        "def equalizeArray(arr):\n    # Write your code here.\n    arr.sort()\n    count = 0\n    for i in range(len(arr)):\n        if i == 0:\n            count += 1\n        elif arr[i] != arr[i-1]:\n            count += 1\n    return count\n",
        "def equalizeArray(arr):\n    # Write your code here.\n    arr.sort()\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] != i:\n            count += 1\n    return count\n",
        "def equalizeArray(arr):\n    # Write your code here.\n    # print(arr)\n    # print(len(arr))\n    # print(arr[0])\n    # print(arr[1])\n    # print(arr[2])\n    # print(arr[3])\n    # print(arr[4])\n    # print(arr[5])\n    # print(arr[6])\n    # print(arr[7])\n    # print(arr[8])\n    # print(arr[9])\n    # print(arr[10])\n    # print(arr[11])\n    # print(arr[12])\n    # print(arr[13])\n    # print(arr[14])\n    # print(arr[15])\n    # print(arr[16])\n    # print(arr[17])\n    # print(arr[18])\n    # print(arr[19])\n    # print(arr[20])\n    # print(arr[21])\n    # print(arr[22])\n    # print(arr[23])\n    # print(arr[24])\n    # print(arr[25])\n    # print(arr[26])\n    # print(arr[27])\n    # print(arr[28])\n    # print(arr[29])\n    # print(arr[30])\n    # print(arr[31])\n    # print(arr[32])\n    # print(arr[33])\n    # print(arr[34])\n    # print(arr[35])\n    # print(arr[36])\n    # print(arr[37])\n    # print(arr[38])\n    # print(arr[39])\n    # print(arr[40])\n    # print(arr[41])\n    # print(arr[42])\n    # print(arr[43])\n    # print(arr[44])\n    # print(arr[45])\n    # print(arr[46])\n    # print(arr[47])\n    # print(arr[48])\n    # print(arr[49])\n    # print(arr[50])\n    # print(arr[51])\n"
    ],
    "results": 10
},{
    "id": "1594",
    "source": "leetcode",
    "language": "python",
    "query": "Each element is either an integer or a list whose elements may also be integers or other lists. Given a string s represents the serialization of a nested list, implement a parser to deserialize it.",
    "snippets": [
        "def deserialize(s):\n    if not s:\n        return None\n    if s[0] == '[':\n        return deserialize_list(s)\n    else:\n        return int(s)\n",
        "def deserialize(s):\n    if s == '[]':\n        return []\n    if s[0] == '[':\n        return deserialize(s[1:-1])\n    if s[0] == ',':\n        return deserialize(s[1:])\n    if s[0] == ' ':\n        return deserialize(s[1:])\n    if s[0] == ']':\n        return deserialize(s[1:])\n    if s[0] == '-':\n        return deserialize(s[1:])\n    if s[0] == '0':\n        return deserialize(s[1:])\n    if s[0] == '1':\n        return deserialize(s[1:])\n    if s[0] == '2':\n        return deserialize(s[1:])\n    if s[0] == '3':\n        return deserialize(s[1:])\n    if s[0] == '4':\n        return deserialize(s[1:])\n    if s[0] == '5':\n        return deserialize(s[1:])\n    if s[0] == '6':\n        return deserialize(s[1:])\n    if s[0] == '7':\n        return deserialize(s[1:])\n    if s[0] == '8':\n        return deserialize(s[1:])\n    if s[0] == '9':\n        return deserialize(s[1:])\n    if s[0] == 'a':\n        return deserialize(s[1:])\n    if s[0] == 'b':\n        return deserialize(s[1:])\n    if s[0] == 'c':\n        return deserialize(s[1:])\n    if s[0] == 'd':\n        return deserialize(s[1:])\n    if s[0] == 'e':\n        return deserialize(s[1:])\n    if s[0] == 'f':\n        return deserialize(s[1\n",
        "def deserialize(s):\n    if s == '[]':\n        return []\n    if s[0] == '[':\n        return deserialize(s[1:-1])\n    if s[0] == ',':\n        return deserialize(s[1:])\n    if s[0] == '-':\n        return int(s[1:])\n    if s[0] == ']':\n        return deserialize(s[1:])\n    if s[0] == '.':\n        return deserialize(s[1:])\n    if s[0] == ' ':\n        return deserialize(s[1:])\n    if s[0] == '#':\n        return deserialize(s[1:])\n    if s[0] == '0':\n        return deserialize(s[1:])\n    if s[0] == '1':\n        return deserialize(s[1:])\n    if s[0] == '2':\n        return deserialize(s[1:])\n    if s[0] == '3':\n        return deserialize(s[1:])\n    if s[0] == '4':\n        return deserialize(s[1:])\n    if s[0] == '5':\n        return deserialize(s[1:])\n    if s[0] == '6':\n        return deserialize(s[1:])\n    if s[0] == '7':\n        return deserialize(s[1:])\n    if s[0] == '8':\n        return deserialize(s[1:])\n    if s[0] == '9':\n        return deserialize(s[1:])\n    if s[0] == 'a':\n        return deserialize(s[1:])\n    if s[0] == 'b':\n        return deserialize(s[1:])\n    if s[0] == 'c':\n        return deserialize(s[1:])\n    if s[0] == 'd':\n        return deserialize(s[1:])\n",
        "def deserialize(s):\n    if s == '[]':\n        return []\n    if s[0] != '[':\n        return int(s)\n    else:\n        s = s[1:-1]\n        l = s.split(',')\n        return [deserialize(i) for i in l]\n",
        "def deserialize(s):\n    if s == '[]':\n        return []\n    if s[0] == '[':\n        s = s[1:-1]\n        if s == '':\n            return []\n        else:\n            return [deserialize(s)]\n    else:\n        i = s.index(',')\n        return int(s[:i])\n        return [deserialize(s[i+1:])]\n",
        "def deserialize(s):\n    if s == '[]':\n        return []\n    if s[0] == '[':\n        s = s[1:-1]\n        if s == '':\n            return []\n        else:\n            return [deserialize(s)]\n    else:\n        i = s.index(',')\n        return int(s[:i])\n        # return [int(s[:i])] + deserialize(s[i+1:])\n",
        "def deserialize(s):\n    if s == '[]':\n        return []\n    if s[0] == '[':\n        s = s[1:-1]\n        if s[0] == ']':\n            return []\n        else:\n            return [deserialize(s)]\n    else:\n        return int(s)\n",
        "def deserialize(s):\n    if s == \"\":\n        return None\n    if s[0] == \"[\":\n        return deserialize_list(s)\n    return int(s)\n"
    ],
    "results": 10
},{
    "id": "1595",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible. Return the maximum number of instances that can be formed.",
    "snippets": [
        "def maxNumberOfBalloons(text):\n    return min(text.count('b'), text.count('a'), text.count('l'), text.count('o'), text.count('n'))\n",
        "def maxNumberOfBalloons(text):\n    \"\"\"\n    :type text: str\n    :rtype: int\n    \"\"\"\n    return min(text.count('b'), text.count('a'), text.count('l'), text.count('o'), text.count('n')) // 2\n",
        "def maxNumberOfBalloons(text):\n    \"\"\"\n    :type text: str\n    :rtype: int\n    \"\"\"\n    return min(text.count('b'), text.count('a'), text.count('l'), text.count('o'), text.count('n'))\n",
        "def maxNumberOfBalloons(text):\n    \"\"\"\n    :type text: str\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in \"balloon\":\n        count += text.count(i)\n    return count // len(\"balloon\")\n",
        "def maxNumberOfBalloons(text):\n    \"\"\"\n    :type text: str\n    :rtype: int\n    \"\"\"\n    # count the number of each letter in text\n    count = {}\n    for letter in text:\n        if letter in count:\n            count[letter] += 1\n        else:\n            count[letter] = 1\n    # check if each letter is in the count dictionary\n    for letter in \"balloon\":\n        if letter not in count:\n            return 0\n        # if the letter is in the count dictionary, check if the count is greater than 1\n        if count[letter] > 1:\n            count[letter] -= 1\n        else:\n            return 0\n    return 1\n",
        "def maxNumberOfBalloons(text):\n    \"\"\"\n    :type text: str\n    :rtype: int\n    \"\"\"\n    # create a dictionary of the characters in the string\n    # loop through the dictionary and check if the character is in the string\n    # if it is, subtract 1 from the value of the character in the dictionary\n    # if the value of the character in the dictionary is 0, remove it from the dictionary\n    # if the dictionary is empty, return the length of the string\n    # otherwise, return the length of the dictionary\n    balloon_dict = {}\n    for char in text:\n        if char in balloon_dict:\n            balloon_dict[char] -= 1\n        else:\n            balloon_dict[char] = 1\n    for char in balloon_dict:\n        if balloon_dict[char] == 0:\n            del balloon_dict[char]\n    if balloon_dict == {}:\n        return len(text)\n    else:\n        return len(balloon_dict)\n"
    ],
    "results": 10
},{
    "id": "1596",
    "source": "leetcode",
    "language": "python",
    "query": "The answer is guaranteed to fit into a signed 32-bit integer. You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.",
    "snippets": [
        "def change(amount, coins):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    return dp[amount]\n",
        "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if i >= coin:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != amount + 1 else -1\n",
        "def coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for j in range(len(coins)):\n            if i >= coins[j]:\n                dp[i] = min(dp[i], dp[i - coins[j]] + 1)\n    return dp[amount] if dp[amount] != amount + 1 else -1\n",
        "def coinChange(coins, amount):\n    dp = [0] + [float('inf')] * amount\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n",
        "def coinChange(coins, amount):\n    dp = [0] + [float('inf')] * amount\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[-1] if dp[-1] != float('inf') else -1\n"
    ],
    "results": 10
},{
    "id": "1597",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement. If there multiple valid answers, return any of them.",
    "snippets": [
        "def constructArray(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: List[int]\n    \"\"\"\n    if k == 1:\n        return list(range(1, n + 1))\n    if k == n:\n        return list(range(1, n + 1))[::-1]\n    if k == n - 1:\n        return list(range(1, n + 1))[1:]\n    if k == n - 2:\n        return list(range(1, n + 1))[2:]\n    if k == n - 3:\n        return list(range(1, n + 1))[3:]\n    if k == n - 4:\n        return list(range(1, n + 1))[4:]\n    if k == n - 5:\n        return list(range(1, n + 1))[5:]\n    if k == n - 6:\n        return list(range(1, n + 1))[6:]\n    if k == n - 7:\n        return list(range(1, n + 1))[7:]\n    if k == n - 8:\n        return list(range(1, n + 1))[8:]\n    if k == n - 9:\n        return list(range(1, n + 1))[9:]\n    if k == n - 10:\n        return list(range(1, n + 1))[10:]\n    if k == n - 11:\n        return list(range(1, n + 1))[11:]\n    if k == n - 12:\n        return list(range(1, n + 1))[12:]\n    if k == n - 13:\n        return list(range(1, n + 1))[13:]\n    if k == n - 14:\n        return list(range(1, n + 1))[14:]\n    if k == n - 15:\n        return list(range(1, n + 1))[15:]\n    if k == n - 16:\n        return list(range(1, n + 1))[16:]\n    if k == n - 17:\n        return list(range(1\n",
        "def construct_list(n, k):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3, 2]\n    if n == 4:\n        return [1, 4, 3, 2]\n    if n == 5:\n        return [1, 5, 4, 3, 2]\n    if n == 6:\n        return [1, 6, 5, 4, 3, 2]\n    if n == 7:\n        return [1, 7, 6, 5, 4, 3, 2]\n    if n == 8:\n        return [1, 8, 7, 6, 5, 4, 3, 2]\n    if n == 9:\n        return [1, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 10:\n        return [1, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 11:\n        return [1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 12:\n        return [1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 13:\n        return [1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 14:\n        return [1, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 15:\n        return [1, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 16:\n        return [1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 17:\n        return [1, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3,\n",
        "def construct_list(n, k):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 2, 3]\n    if n == 4:\n        return [1, 2, 3, 4]\n    if n == 5:\n        return [1, 2, 3, 4, 5]\n    if n == 6:\n        return [1, 2, 3, 4, 5, 6]\n    if n == 7:\n        return [1, 2, 3, 4, 5, 6, 7]\n    if n == 8:\n        return [1, 2, 3, 4, 5, 6, 7, 8]\n    if n == 9:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    if n == 10:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    if n == 11:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    if n == 12:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    if n == 13:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    if n == 14:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    if n == 15:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    if n == 16:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    if n == 17:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n",
        "def construct_list(n, k):\n    if n == 1:\n        return [1]\n    if k == 1:\n        return [1, 2]\n    if k == 2:\n        return [1, 3]\n    if k == 3:\n        return [1, 4]\n    if k == 4:\n        return [1, 5]\n    if k == 5:\n        return [1, 6]\n    if k == 6:\n        return [1, 7]\n    if k == 7:\n        return [1, 8]\n    if k == 8:\n        return [1, 9]\n    if k == 9:\n        return [1, 10]\n    if k == 10:\n        return [1, 11]\n    if k == 11:\n        return [1, 12]\n    if k == 12:\n        return [1, 13]\n    if k == 13:\n        return [1, 14]\n    if k == 14:\n        return [1, 15]\n    if k == 15:\n        return [1, 16]\n    if k == 16:\n        return [1, 17]\n    if k == 17:\n        return [1, 18]\n    if k == 18:\n        return [1, 19]\n    if k == 19:\n        return [1, 20]\n    if k == 20:\n        return [1, 21]\n    if k == 21:\n        return [1, 22]\n    if k == 22:\n        return [1, 23]\n    if k == 23:\n        return [1, 24]\n    if k == 24:\n        return [1, 25]\n    if k == 25:\n        return [1, 26]\n    if k == 26:\n        return [1, 27]\n    if k == 27:\n        return [1, 28]\n    if k == 28:\n        return [1, 29]\n    if k == 29:\n        return [1, 30]\n    if k == 30:\n        return [1, 31]\n    if k == 31:\n        return [1, 32]\n    if k == 32:\n        return [1,\n",
        "def construct_array(n, k):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3, 2]\n    if n == 4:\n        return [1, 4, 3, 2]\n    if n == 5:\n        return [1, 5, 4, 3, 2]\n    if n == 6:\n        return [1, 6, 5, 4, 3, 2]\n    if n == 7:\n        return [1, 7, 6, 5, 4, 3, 2]\n    if n == 8:\n        return [1, 8, 7, 6, 5, 4, 3, 2]\n    if n == 9:\n        return [1, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 10:\n        return [1, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 11:\n        return [1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 12:\n        return [1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 13:\n        return [1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 14:\n        return [1, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 15:\n        return [1, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 16:\n        return [1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 17:\n        return [1, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3,\n",
        "def construct_list(n, k):\n    if n == 1:\n        return [1]\n    if k == 1:\n        return [1, 2, 3, ..., n]\n    if k == n:\n        return [1, n, n-1, ..., 2]\n    if k == n-1:\n        return [1, n, 2, ..., n-1]\n    if k == n-2:\n        return [1, n, 3, ..., n-2]\n    if k == n-3:\n        return [1, n, 4, ..., n-3]\n    if k == n-4:\n        return [1, n, 5, ..., n-4]\n    if k == n-5:\n        return [1, n, 6, ..., n-5]\n    if k == n-6:\n        return [1, n, 7, ..., n-6]\n    if k == n-7:\n        return [1, n, 8, ..., n-7]\n    if k == n-8:\n        return [1, n, 9, ..., n-8]\n    if k == n-9:\n        return [1, n, 10, ..., n-9]\n    if k == n-10:\n        return [1, n, 11, ..., n-10]\n    if k == n-11:\n        return [1, n, 12, ..., n-11]\n    if k == n-12:\n        return [1, n, 13, ..., n-12]\n    if k == n-13:\n        return [1, n, 14, ..., n-13]\n    if k == n-14:\n        return [1, n, 15, ..., n-14]\n    if k == n-15:\n        return [1, n, 16, ..., n-15]\n    if k == n-16:\n        return [1, n, 17, ..., n-16]\n    if k == n-17:\n        return [1, n, 18, ..., n-17]\n    if k == n-18:\n",
        "def construct_array(n, k):\n    if n == 1:\n        return [1]\n    if k == 1:\n        return [i for i in range(1, n+1)]\n    if k == n:\n        return [i for i in range(1, n+1)]\n    if k == n-1:\n        return [i for i in range(1, n+1)]\n    if k == n-2:\n        return [i for i in range(1, n+1)]\n    if k == n-3:\n        return [i for i in range(1, n+1)]\n    if k == n-4:\n        return [i for i in range(1, n+1)]\n    if k == n-5:\n        return [i for i in range(1, n+1)]\n    if k == n-6:\n        return [i for i in range(1, n+1)]\n    if k == n-7:\n        return [i for i in range(1, n+1)]\n    if k == n-8:\n        return [i for i in range(1, n+1)]\n    if k == n-9:\n        return [i for i in range(1, n+1)]\n    if k == n-10:\n        return [i for i in range(1, n+1)]\n    if k == n-11:\n        return [i for i in range(1, n+1)]\n    if k == n-12:\n        return [i for i in range(1, n+1)]\n    if k == n-13:\n        return [i for i in range(1, n+1)]\n    if k == n-14:\n        return [i for i in range(1, n+1)]\n    if k == n-15:\n        return [i for i in range(1, n+1)]\n    if k == n-16:\n        return [i for i in range(1, n+1)]\n    if k == n-17:\n        return [i for i in range(1, n+1)]\n    if k == n-\n",
        "def construct_array(n, k):\n    if n == 1:\n        return [1]\n    if k == 1:\n        return [1, 2, 3, ..., n]\n    if k == 2:\n        return [1, 3, 5, ..., n]\n    if k == 3:\n        return [1, 4, 7, ..., n]\n    if k == 4:\n        return [1, 5, 9, ..., n]\n    if k == 5:\n        return [1, 6, 11, ..., n]\n    if k == 6:\n        return [1, 7, 13, ..., n]\n    if k == 7:\n        return [1, 8, 15, ..., n]\n    if k == 8:\n        return [1, 9, 17, ..., n]\n    if k == 9:\n        return [1, 10, 19, ..., n]\n    if k == 10:\n        return [1, 11, 21, ..., n]\n    if k == 11:\n        return [1, 12, 23, ..., n]\n    if k == 12:\n        return [1, 13, 25, ..., n]\n    if k == 13:\n        return [1, 14, 27, ..., n]\n    if k == 14:\n        return [1, 15, 29, ..., n]\n    if k == 15:\n        return [1, 16, 31, ..., n]\n    if k == 16:\n        return [1, 17, 33, ..., n]\n    if k == 17:\n        return [1, 18, 35, ..., n]\n    if k == 18:\n        return [1, 19, 37, ..., n]\n    if k == 19:\n        return [1, 20, 39, ..., n]\n    if k == 20:\n        return [1, 21, 41, ..., n]\n    if k == 21:\n        return [1, 22, 43, ..., n]\n    if k == 22:\n        return [1, 23, 45, ..., n]\n    if k == 23:\n        return [1, 24, 47\n",
        "def construct_array(n, k):\n    if n == 1:\n        return [1]\n    if k == 1:\n        return [1, 2, 3, ..., n]\n    if k == n:\n        return [1, n, n-1, ..., 2]\n    if k == n-1:\n        return [1, n, n-1, ..., 3]\n    if k == n-2:\n        return [1, n, n-1, ..., 4]\n    if k == n-3:\n        return [1, n, n-1, ..., 5]\n    if k == n-4:\n        return [1, n, n-1, ..., 6]\n    if k == n-5:\n        return [1, n, n-1, ..., 7]\n    if k == n-6:\n        return [1, n, n-1, ..., 8]\n    if k == n-7:\n        return [1, n, n-1, ..., 9]\n    if k == n-8:\n        return [1, n, n-1, ..., 10]\n    if k == n-9:\n        return [1, n, n-1, ..., 11]\n    if k == n-10:\n        return [1, n, n-1, ..., 12]\n    if k == n-11:\n        return [1, n, n-1, ..., 13]\n    if k == n-12:\n        return [1, n, n-1, ..., 14]\n    if k == n-13:\n        return [1, n, n-1, ..., 15]\n    if k == n-14:\n        return [1, n, n-1, ..., 16]\n    if k == n-15:\n        return [1, n, n-1, ..., 17]\n    if k == n-16:\n        return [1, n, n-1, ..., 18]\n    if k == n-17:\n        return [1, n, n-1, ..., 19]\n    if k == n-18:\n"
    ],
    "results": 10
},{
    "id": "1598",
    "source": "leetcode",
    "language": "python",
    "query": "Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.",
    "snippets": [
        "def computeArea(A, B, C, D, E, F, G, H):\n    area1 = (C - A) * (D - B)\n    area2 = (G - E) * (H - F)\n    if A > G or C < E or B > H or D < F:\n        return area1 + area2\n    else:\n        return area1 + area2 - (min(C, G) - max(A, E)) * (min(D, H) - max(B, F))\n",
        "def computeArea(A, B, C, D, E, F, G, H):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type D: int\n    :type E: int\n    :type F: int\n    :type G: int\n    :type H: int\n    :rtype: int\n    \"\"\"\n    area1 = (C - A) * (D - B)\n    area2 = (G - E) * (H - F)\n    if A > G or C < E or B > H or D < F:\n        return area1 + area2\n    else:\n        return area1 + area2 - (min(C, G) - max(A, E)) * (min(D, H) - max(B, F))\n",
        "def computeArea(A, B, C, D, E, F, G, H):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type D: int\n    :type E: int\n    :type F: int\n    :type G: int\n    :type H: int\n    :rtype: int\n    \"\"\"\n    # Calculate the area of the first rectangle\n    area1 = (C - A) * (D - B)\n    # Calculate the area of the second rectangle\n    area2 = (G - E) * (H - F)\n    # Calculate the area of the overlap\n    overlap = 0\n    if (A > E and B > F) and (C < G and D < H):\n        overlap = (min(C, G) - max(A, E)) * (min(D, H) - max(B, F))\n    # Return the total area\n    return area1 + area2 - overlap\n",
        "def computeArea(A, B, C, D, E, F, G, H):\n    \"\"\"\n    :type A: int\n    :type B: int\n    :type C: int\n    :type D: int\n    :type E: int\n    :type F: int\n    :type G: int\n    :type H: int\n    :rtype: int\n    \"\"\"\n    area1 = (C - A) * (D - B)\n    area2 = (G - E) * (H - F)\n    if A >= G or B >= H or C <= E or D <= F:\n        return area1 + area2\n    else:\n        return area1 + area2 - (min(C, G) - max(A, E)) * (min(D, H) - max(B, F))\n",
        "def rectangle_area(rec1, rec2):\n    return (rec1[2] - rec1[0]) * (rec1[3] - rec1[1]) + (rec2[2] - rec2[0]) * (rec2[3] - rec2[1])\n",
        "def rectangle_area(rect1, rect2):\n    return (rect1[2] - rect1[0]) * (rect1[3] - rect1[1]) + (rect2[2] - rect2[0]) * (rect2[3] - rect2[1])\n",
        "def rectangle_area(a, b):\n    return (a[2] - a[0]) * (a[3] - a[1]) + (b[2] - b[0]) * (b[3] - b[1])\n",
        "def rectangle_area(a, b):\n    return a[2] * b[3] + a[3] * b[2]\n"
    ],
    "results": 10
},{
    "id": "1599",
    "source": "leetcode",
    "language": "python",
    "query": "The average value of a set of k numbers is the sum of the numbers divided by k. You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls.",
    "snippets": [
        "def average(n, m):\n    return (n + m) / 2\n",
        "def average(numbers):\n    return sum(numbers) / len(numbers)\n"
    ],
    "results": 10
},{
    "id": "1600",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary string s, return the number of substrings with all characters 1's. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "def count_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i:j+1].count('1') == j-i+1:\n                count += 1\n    return count % 1000000007\n",
        "def count_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i:j+1].count('1') == j-i+1:\n                count += 1\n    return count % (10**9 + 7)\n",
        "def count_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[j] == '1':\n                count += 1\n            else:\n                break\n    return count % (10**9 + 7)\n"
    ],
    "results": 10
},{
    "id": "1601",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "def split_string(s):\n    if len(s) == 1:\n        return 0\n    if len(s) == 2:\n        return 1\n    if len(s) == 3:\n        return 2\n    if len(s) == 4:\n        return 3\n    if len(s) == 5:\n        return 4\n    if len(s) == 6:\n        return 5\n    if len(s) == 7:\n        return 6\n    if len(s) == 8:\n        return 7\n    if len(s) == 9:\n        return 8\n    if len(s) == 10:\n        return 9\n    if len(s) == 11:\n        return 10\n    if len(s) == 12:\n        return 11\n    if len(s) == 13:\n        return 12\n    if len(s) == 14:\n        return 13\n    if len(s) == 15:\n        return 14\n    if len(s) == 16:\n        return 15\n    if len(s) == 17:\n        return 16\n    if len(s) == 18:\n        return 17\n    if len(s) == 19:\n        return 18\n    if len(s) == 20:\n        return 19\n    if len(s) == 21:\n        return 20\n    if len(s) == 22:\n        return 21\n    if len(s) == 23:\n        return 22\n    if len(s) == 24:\n        return 23\n    if len(s) == 25:\n        return 24\n    if len(s) == 26:\n        return 25\n    if len(s) == 27:\n        return 26\n    if len(s) == 28:\n        return 27\n    if len(s) == 29:\n        return 28\n    if len(s) == 30:\n        return 29\n    if len(s) == 31:\n        return 30\n    if len(s) == 32:\n        return 31\n    if len(s) == 33:\n        return 32\n    if len(s) == 34:\n        return 33\n    if len(s) == 35:\n        return 34\n    if\n",
        "def splitString(s):\n    if len(s) == 1:\n        return 0\n    if len(s) == 2:\n        return 1\n    if len(s) == 3:\n        return 2\n    if len(s) == 4:\n        return 3\n    if len(s) == 5:\n        return 4\n    if len(s) == 6:\n        return 5\n    if len(s) == 7:\n        return 6\n    if len(s) == 8:\n        return 7\n    if len(s) == 9:\n        return 8\n    if len(s) == 10:\n        return 9\n    if len(s) == 11:\n        return 10\n    if len(s) == 12:\n        return 11\n    if len(s) == 13:\n        return 12\n    if len(s) == 14:\n        return 13\n    if len(s) == 15:\n        return 14\n    if len(s) == 16:\n        return 15\n    if len(s) == 17:\n        return 16\n    if len(s) == 18:\n        return 17\n    if len(s) == 19:\n        return 18\n    if len(s) == 20:\n        return 19\n    if len(s) == 21:\n        return 20\n    if len(s) == 22:\n        return 21\n    if len(s) == 23:\n        return 22\n    if len(s) == 24:\n        return 23\n    if len(s) == 25:\n        return 24\n    if len(s) == 26:\n        return 25\n    if len(s) == 27:\n        return 26\n    if len(s) == 28:\n        return 27\n    if len(s) == 29:\n        return 28\n    if len(s) == 30:\n        return 29\n    if len(s) == 31:\n        return 30\n    if len(s) == 32:\n        return 31\n    if len(s) == 33:\n        return 32\n    if len(s) == 34:\n        return 33\n    if len(s) == 35:\n        return 34\n    if len\n",
        "def split_string(s):\n    if len(s) == 1:\n        return 0\n    elif len(s) == 2:\n        return 1\n    else:\n        return (split_string(s[1:]) + split_string(s[2:])) % 1000000007\n"
    ],
    "results": 10
},{
    "id": "1602",
    "source": "leetcode",
    "language": "python",
    "query": "Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "snippets": [
        "def max_area(height):\n    max_area = 0\n    for i in range(len(height)):\n        for j in range(i+1, len(height)):\n            area = (j-i) * min(height[i], height[j])\n            if area > max_area:\n                max_area = area\n    return max_area\n",
        "def max_area(arr):\n    max_area = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            area = (j-i) * min(arr[i], arr[j])\n            if area > max_area:\n                max_area = area\n    return max_area\n",
        "def max_area(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        area = (right - left) * min(height[left], height[right])\n        max_area = max(max_area, area)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n"
    ],
    "results": 10
},{
    "id": "1603",
    "source": "leetcode",
    "language": "python",
    "query": "We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked.",
    "snippets": [
        "def guess_number(n):\n    low = 1\n    high = n\n    while low <= high:\n        mid = (low + high) // 2\n        if guess(mid) == 0:\n            return mid\n        elif guess(mid) == -1:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n",
        "def guessNumber(n):\n    left = 1\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if guess(mid) == 0:\n            return mid\n        elif guess(mid) == -1:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n",
        "def guessNumber(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    left = 1\n    right = n\n    while left <= right:\n        mid = (left + right) // 2\n        if guess(mid) == 0:\n            return mid\n        elif guess(mid) == -1:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return -1\n",
        "def guess(n):\n    if n == 6:\n        return 6\n    elif n < 6:\n        return n + 1\n    else:\n        return n - 1\n",
        "def guess_number(n):\n    mid = n // 2\n    if mid == n:\n        return mid\n    elif mid < n:\n        return guess_number(mid)\n    else:\n        return guess_number(mid + 1)\n",
        "def guess(n):\n    return n\n"
    ],
    "results": 10
},{
    "id": "1604",
    "source": "leetcode",
    "language": "python",
    "query": "The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases. Given a string s, reverse only all the vowels in the string and return it.",
    "snippets": [
        "def reverseVowels(s):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    s = list(s)\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] in vowels and s[j] in vowels:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        elif s[i] in vowels:\n            j -= 1\n        else:\n            i += 1\n    return ''.join(s)\n",
        "def reverseVowels(s):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    s = list(s)\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] in vowels and s[j] in vowels:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        elif s[i] in vowels:\n            j -= 1\n        elif s[j] in vowels:\n            i += 1\n        else:\n            i += 1\n            j -= 1\n    return ''.join(s)\n",
        "def reverseVowels(s):\n    vowels = set('aeiouAEIOU')\n    s = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        while i < j and s[i] not in vowels:\n            i += 1\n        while i < j and s[j] not in vowels:\n            j -= 1\n        s[i], s[j] = s[j], s[i]\n        i += 1\n        j -= 1\n    return ''.join(s)\n",
        "def reverseVowels(s):\n    vowels = 'aeiouAEIOU'\n    s = list(s)\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] in vowels and s[j] in vowels:\n            s[i], s[j] = s[j], s[i]\n            i += 1\n            j -= 1\n        elif s[i] in vowels:\n            j -= 1\n        else:\n            i += 1\n    return ''.join(s)\n"
    ],
    "results": 10
},{
    "id": "1605",
    "source": "leetcode",
    "language": "python",
    "query": "A grid is said to be valid if all the cells above the main diagonal are zeros. Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them. Return the minimum number of steps needed to make the grid valid.",
    "snippets": [
        "def validGrid(grid):\n    # Write your code here\n    n = len(grid)\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                if grid[i][j] == 1:\n                    count += 1\n            else:\n                if grid[i][j] == 1:\n                    if grid[j][i] == 1:\n                        count += 1\n    return count\n",
        "def validGrid(grid):\n    # Write your code here\n    n = len(grid)\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n    return count\n",
        "def validGrid(grid):\n    # Write your code here.\n    n = len(grid)\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                if grid[i][j] == 1:\n                    count += 1\n            else:\n                if grid[i][j] == 1:\n                    count += 1\n    return count\n",
        "def validGrid(grid):\n    # Write your code here.\n    n = len(grid)\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                if grid[i][j] == 1:\n                    count += 1\n            else:\n                if grid[i][j] == 1:\n                    if grid[j][i] == 1:\n                        count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "1606",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.",
    "snippets": [
        "def get_range(bomb_list):\n    range_list = []\n    for bomb in bomb_list:\n        range_list.append(bomb[0] + bomb[1])\n    return range_list\n",
        "def get_bomb_range(bomb_list):\n    bomb_range = []\n    for bomb in bomb_list:\n        bomb_range.append(int(bomb[0]) + int(bomb[1]))\n    return bomb_range\n",
        "def bomb_range(bombs):\n    # Write your code here\n    if len(bombs) == 0:\n        return 0\n    else:\n        max_range = 0\n        for bomb in bombs:\n            max_range = max(max_range, bomb[0] + bomb[1])\n        return max_range\n",
        "def bomb_range(bombs):\n    # Write your code here\n    return sum(map(lambda x: x[0] + x[1], bombs))\n",
        "def get_range(bomb):\n    return int(bomb[0]) + int(bomb[1])\n",
        "def get_bomb_range(bombs):\n    range_list = []\n    for bomb in bombs:\n        x = bomb[0]\n        y = bomb[1]\n        range_list.append(x**2 + y**2)\n    return range_list\n",
        "def bomb_effect(bombs):\n    # Write your code here\n    if not bombs:\n        return 0\n    bombs.sort(key=lambda x: x[0])\n    bombs.sort(key=lambda x: x[1])\n    max_range = 0\n    for i in range(len(bombs)):\n        x, y = bombs[i]\n        for j in range(i+1, len(bombs)):\n            x1, y1 = bombs[j]\n            if x1-x > y1-y:\n                max_range = max(max_range, x1-x)\n            else:\n                max_range = max(max_range, y1-y)\n    return max_range\n",
        "def range_of_bomb(bomb):\n    return int(bomb[0]) * int(bomb[1])\n"
    ],
    "results": 10
},{
    "id": "1607",
    "source": "leetcode",
    "language": "python",
    "query": "Head is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1.",
    "snippets": [
        "def get_head(head):\n    if head is None:\n        return None\n    else:\n        return head.val\n",
        "def flip(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    new_head = flip(head.next)\n    head.next.next = head\n    head.next = None\n    return new_head\n"
    ],
    "results": 10
},{
    "id": "1608",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, return true if the given array is monotonic, or false otherwise. An array ismonotonic if it is either monotone increasing or monot one decreasing.",
    "snippets": [
        "def isMonotonic(nums):\n    if len(nums) <= 1:\n        return True\n    if nums[0] < nums[1]:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                return False\n    elif nums[0] > nums[1]:\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                return False\n    return True\n",
        "def isMonotone(nums):\n    if len(nums) <= 1:\n        return True\n    if nums[0] > nums[1]:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                return False\n    elif nums[0] < nums[1]:\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                return False\n    return True\n",
        "def isMonotonic(nums):\n    if len(nums) <= 1:\n        return True\n    if nums[0] < nums[-1]:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                return False\n        return True\n    else:\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                return False\n        return True\n",
        "def isMonotonic(nums):\n    if len(nums) == 1:\n        return True\n    if nums[0] < nums[1]:\n        for i in range(1, len(nums)):\n            if nums[i] < nums[i-1]:\n                return False\n    elif nums[0] > nums[1]:\n        for i in range(1, len(nums)):\n            if nums[i] > nums[i-1]:\n                return False\n    return True\n",
        "def isMonotonic(nums):\n    if len(nums) <= 1:\n        return True\n    else:\n        if nums[0] < nums[1]:\n            for i in range(1, len(nums) - 1):\n                if nums[i] > nums[i + 1]:\n                    return False\n            return True\n        else:\n            for i in range(1, len(nums) - 1):\n                if nums[i] < nums[i + 1]:\n                    return False\n            return True\n"
    ],
    "results": 10
},{
    "id": "1609",
    "source": "leetcode",
    "language": "python",
    "query": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges.",
    "snippets": [
        "def dfs(graph, start, visited):\n    visited[start] = True\n    for i in graph[start]:\n        if not visited[i]:\n            dfs(graph, i, visited)\n",
        "def find_center(n, edges):\n    # Write your code here\n    graph = {}\n    for edge in edges:\n        if edge[0] not in graph:\n            graph[edge[0]] = []\n        if edge[1] not in graph:\n            graph[edge[1]] = []\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n    visited = set()\n    queue = [1]\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        queue.extend(graph[node])\n    return len(visited) == n\n"
    ],
    "results": 10
},{
    "id": "1610",
    "source": "leetcode",
    "language": "python",
    "query": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'",
    "snippets": [
        "def is_valid_email(email):\n    if '@' in email:\n        local, domain = email.split('@')\n        if '.' in local:\n            local, domain = local.split('.')\n        if '+' in local:\n            local, domain = local.split('+')\n        if domain.isalpha() and local.isalpha():\n            return True\n    return False\n",
        "def is_valid_email(email):\n    if '@' in email:\n        local, domain = email.split('@')\n        if '.' in local:\n            local, domain = local.split('.')\n        if '+' in local:\n            local, domain = local.split('+')\n        if '+' in domain:\n            local, domain = domain.split('+')\n        if '.' in domain:\n            local, domain = domain.split('.')\n        if local and domain:\n            return True\n    return False\n",
        "def is_valid_email(email):\n    if '@' in email:\n        if email.count('@') == 1:\n            if email.count('.') == 1:\n                if email.count('+') == 0:\n                    return True\n    return False\n",
        "def is_valid_email(email):\n    if '@' in email:\n        local, domain = email.split('@')\n        if '.' in local:\n            local, domain = local.split('.')\n        if '+' in local:\n            local, domain = local.split('+')\n        if domain.count('.') == 1:\n            return True\n    return False\n",
        "def is_valid_email(email):\n    if '@' not in email:\n        return False\n    local, domain = email.split('@')\n    if '.' not in domain:\n        return False\n    return True\n",
        "def is_valid_email(email):\n    if '@' in email and '.' in email:\n        return True\n    else:\n        return False\n",
        "def is_valid_email(email):\n    if '@' in email:\n        local, domain = email.split('@')\n        if '.' in local and '+' in domain:\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1611",
    "source": "leetcode",
    "language": "python",
    "query": "When a friend arrives at the party, they sit on the unoccupied chair with the smallest number. For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.",
    "snippets": [
        "def find_unoccupied_chair(chairs):\n    for i in range(len(chairs)):\n        if chairs[i] == 0:\n            return i\n    return -1\n",
        "def find_empty_chair(chairs):\n    for i in range(len(chairs)):\n        if chairs[i] == 0:\n            return i\n    return -1\n",
        "def find_available_chair(chairs):\n    for i in range(len(chairs)):\n        if chairs[i] == 0:\n            return i\n    return -1\n",
        "def seat_in_the_middle(chairs):\n    for i in range(len(chairs)):\n        if chairs[i] == 0:\n            return i\n    return -1\n",
        "def seat_in_the_middle(chairs):\n    return chairs[len(chairs)//2]\n",
        "def seat_number(chairs):\n    return chairs.index(min(chairs))\n",
        "def seat_assignment(chairs):\n    # Write your code here.\n    return chairs.index(min(chairs))\n"
    ],
    "results": 10
},{
    "id": "1612",
    "source": "leetcode",
    "language": "python",
    "query": "We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V\" shaped pattern between two boards or if a board redirects the ball into either wall.",
    "snippets": [
        "def stuck(board):\n    for i in range(len(board)):\n        if board[i][0] == 'V':\n            return True\n    return False\n",
        "def drop_balls(boxes):\n    for i in range(len(boxes)):\n        for j in range(len(boxes[i])):\n            if boxes[i][j] == 'V':\n                boxes[i][j] = ' '\n            elif boxes[i][j] == ' ':\n                if i == 0:\n                    boxes[i][j] = 'V'\n                elif i == len(boxes) - 1:\n                    boxes[i][j] = 'V'\n                elif boxes[i - 1][j] == ' ' and boxes[i + 1][j] == ' ':\n                    boxes[i][j] = 'V'\n    return boxes\n",
        "def drop_balls(boxes):\n    for i in range(len(boxes)):\n        for j in range(len(boxes[i])):\n            if boxes[i][j] == 'V':\n                boxes[i][j] = ' '\n    for i in range(len(boxes)):\n        for j in range(len(boxes[i])):\n            if boxes[i][j] == ' ':\n                if i == 0:\n                    boxes[i][j] = 'V'\n                elif i == len(boxes) - 1:\n                    boxes[i][j] = 'V'\n                elif boxes[i - 1][j] == ' ' and boxes[i + 1][j] == ' ':\n                    boxes[i][j] = 'V'\n    return boxes\n",
        "def drop_balls(boxes):\n    for i in range(len(boxes)):\n        for j in range(len(boxes[i])):\n            if boxes[i][j] == 'V':\n                boxes[i][j] = ' '\n            elif boxes[i][j] == ' ':\n                if i == 0:\n                    boxes[i][j] = 'V'\n                elif i == len(boxes) - 1:\n                    boxes[i][j] = 'V'\n                elif boxes[i - 1][j] == ' ' and boxes[i + 1][j] == ' ':\n                    boxes[i][j] = 'V'\n                elif boxes[i - 1][j] == ' ' and boxes[i + 1][j] == 'V':\n                    boxes[i][j] = 'V'\n                elif boxes[i - 1][j] == 'V' and boxes[i + 1][j] == ' ':\n                    boxes[i][j] = 'V'\n                elif boxes[i - 1][j] == 'V' and boxes[i + 1][j] == 'V':\n                    boxes[i][j] = 'V'\n    return boxes\n",
        "def stuck(board):\n    stuck = 0\n    for i in range(len(board)):\n        if board[i][0] == 'V':\n            stuck += 1\n        if board[i][-1] == 'V':\n            stuck += 1\n    return stuck\n",
        "def is_stuck(board):\n    for i in range(len(board)):\n        if board[i][0] == 'V':\n            return True\n    return False\n",
        "def drop_balls(board):\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'V':\n                board[i][j] = ' '\n            elif board[i][j] == ' ':\n                board[i][j] = 'V'\n    return board\n",
        "def main():\n    n = int(input())\n    for i in range(n):\n        board = [list(input()) for _ in range(6)]\n        stuck = False\n        for j in range(6):\n            if board[0][j] == 'V':\n                stuck = True\n                break\n        if stuck:\n            print(\"Case #{}: {}\".format(i+1, \"IMPOSSIBLE\"))\n        else:\n            print(\"Case #{}: {}\".format(i+1, \"POSSIBLE\"))\n",
        "def drop(board, col):\n    for i in range(len(board)):\n        if board[i][col] == '.':\n            board[i][col] = 'O'\n            return\n    board[-1][col] = 'O'\n    return\n",
        "def solve(n, m, k):\n    # Write your code here\n    if n == 1:\n        return k\n    if n == 2:\n        return k * (k - 1) // 2\n    if n == 3:\n        return k * (k - 1) * (k - 2) // 6\n    if n == 4:\n        return k * (k - 1) * (k - 2) * (k - 3) // 24\n    if n == 5:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) // 120\n    if n == 6:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) // 720\n    if n == 7:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) // 5040\n    if n == 8:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) // 40320\n    if n == 9:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) // 362880\n    if n == 10:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) // 3628800\n    if n == 11:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) // 39916800\n    if n ==\n"
    ],
    "results": 10
},{
    "id": "1613",
    "source": "leetcode",
    "language": "python",
    "query": "You may assume the input array always has a valid answer. Given an integer array nums, reorder it such that nums [0] < nums[1] > nums,[2] <nums[3]....",
    "snippets": [
        "def wiggleSort(nums):\n    for i in range(len(nums) - 1):\n        if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]):\n            nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n",
        "def wiggleSort(nums):\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            if nums[i] > nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n        else:\n            if nums[i] < nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n    return nums\n",
        "def ways(nums):\n    if len(nums) == 1:\n        return nums\n    else:\n        return [nums[0]] + [nums[-1]] + ways(nums[1:-1])\n",
        "def write_to_file(filename, data):\n    with open(filename, 'w') as f:\n        f.write(data)\n",
        "def write_to_file(filename, data):\n    with open(filename, 'w') as f:\n        for line in data:\n            f.write(str(line) + '\\n')\n",
        "def write_to_file(file_name, data):\n    with open(file_name, 'w') as f:\n        f.write(data)\n",
        "def wiggleSort(nums):\n    for i in range(len(nums)):\n        if (i % 2 == 0 and i != 0):\n            if (nums[i] < nums[i - 1]):\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]\n        if (i % 2 == 1 and i != len(nums) - 1):\n            if (nums[i] > nums[i + 1]):\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n    return nums\n",
        "def wiggleSort(nums):\n    for i in range(len(nums)):\n        if (i % 2 == 0 and i != 0) or (i % 2 == 1 and i != len(nums) - 1):\n            nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return nums\n"
    ],
    "results": 10
},{
    "id": "1614",
    "source": "leetcode",
    "language": "python",
    "query": "Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums [j] such that 0 <= i < j < n. If no such i and j exists, return -1.",
    "snippets": [
        "def maxDiff(nums):\n    max_diff = -1\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[j] - nums[i] > max_diff:\n                max_diff = nums[j] - nums[i]\n    return max_diff\n",
        "def maxDiff(nums):\n    if len(nums) < 2:\n        return -1\n    min_num = nums[0]\n    max_diff = nums[1] - nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_num:\n            min_num = nums[i]\n        if nums[i] - min_num > max_diff:\n            max_diff = nums[i] - min_num\n    return max_diff\n",
        "def maxDiff(nums):\n    if len(nums) < 2:\n        return -1\n    max_diff = nums[1] - nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] - nums[i-1] > max_diff:\n            max_diff = nums[i] - nums[i-1]\n    return max_diff\n",
        "def max_diff(nums):\n    if len(nums) < 2:\n        return -1\n    max_diff = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[j] - nums[i] > max_diff:\n                max_diff = nums[j] - nums[i]\n    return max_diff\n",
        "def maxDiff(nums):\n    if len(nums) < 2:\n        return -1\n    max_diff = 0\n    min_num = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_num:\n            min_num = nums[i]\n        max_diff = max(max_diff, nums[i] - min_num)\n    return max_diff\n",
        "def maxDiff(nums):\n    if len(nums) < 2:\n        return -1\n    max_diff = -1\n    min_num = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_num:\n            min_num = nums[i]\n        max_diff = max(max_diff, nums[i] - min_num)\n    return max_diff\n",
        "def maxDiff(nums):\n    if len(nums) == 1:\n        return -1\n    max_diff = -1\n    min_num = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_num:\n            min_num = nums[i]\n        max_diff = max(max_diff, nums[i] - min_num)\n    return max_diff\n",
        "def maxDiff(nums):\n    if len(nums) == 1:\n        return -1\n    min_num = nums[0]\n    max_num = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_num:\n            min_num = nums[i]\n        if nums[i] > max_num:\n            max_num = nums[i]\n    return max_num - min_num\n"
    ],
    "results": 10
},{
    "id": "1615",
    "source": "leetcode",
    "language": "python",
    "query": "The test cases are generated so that there is at least one valid solution. No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.",
    "snippets": [
        "def main():\n    for i in range(1, 100):\n        if i % 10 == 0:\n            continue\n        for j in range(1, 100):\n            if j % 10 == 0:\n                continue\n            for k in range(1, 100):\n                if k % 10 == 0:\n                    continue\n                if i + j + k == 100:\n                    print(i, j, k)\n                    return\n    print(\"No solution\")\n",
        "def main():\n    for i in range(1, 100):\n        if i % 10 == 0:\n            continue\n        for j in range(1, 100):\n            if j % 10 == 0:\n                continue\n            if i * j == 0:\n                continue\n            if i * j % 10 == 0:\n                continue\n            if i * j % 10 == 1:\n                continue\n            if i * j % 10 == 2:\n                continue\n            if i * j % 10 == 3:\n                continue\n            if i * j % 10 == 4:\n                continue\n            if i * j % 10 == 5:\n                continue\n            if i * j % 10 == 6:\n                continue\n            if i * j % 10 == 7:\n                continue\n            if i * j % 10 == 8:\n                continue\n            if i * j % 10 == 9:\n                continue\n            print(i, j)\n            return\n    print(\"No solution\")\n",
        "def main():\n    n = int(input())\n    for i in range(n):\n        print(i + 1, end=' ')\n        print(i + 2, end=' ')\n        print(i + 3, end=' ')\n        print(i + 4, end=' ')\n        print(i + 5, end=' ')\n        print(i + 6, end=' ')\n        print(i + 7, end=' ')\n        print(i + 8, end=' ')\n        print(i + 9, end=' ')\n        print(i + 10, end=' ')\n        print(i + 11, end=' ')\n        print(i + 12, end=' ')\n        print(i + 13, end=' ')\n        print(i + 14, end=' ')\n        print(i + 15, end=' ')\n        print(i + 16, end=' ')\n        print(i + 17, end=' ')\n        print(i + 18, end=' ')\n        print(i + 19, end=' ')\n        print(i + 20, end=' ')\n        print(i + 21, end=' ')\n        print(i + 22, end=' ')\n        print(i + 23, end=' ')\n        print(i + 24, end=' ')\n        print(i + 25, end=' ')\n        print(i + 26, end=' ')\n        print(i + 27, end=' ')\n        print(i + 28, end=' ')\n        print(i + 29, end=' ')\n        print(i + 30, end=' ')\n        print(i + 31, end=' ')\n        print(i + 32, end=' ')\n        print(i + 33, end=' ')\n        print(i + 34, end=' ')\n        print(i + 35, end=' ')\n        print(i + 36, end=' ')\n        print(i + 37, end=' ')\n        print(i + 38, end=' ')\n        print(i + 39, end=' ')\n        print(i + 40, end=' ')\n",
        "def main():\n    n = int(input())\n    for i in range(n):\n        print(i+1, end=' ')\n        print(input())\n",
        "def main():\n    n = int(input())\n    for i in range(n):\n        print(i+1, end=' ')\n        print(int(input()))\n",
        "def test_no_zero(n):\n    return n != 0 and n % 10 != 0\n",
        "def test_no_zero(n):\n    return n != 0 and n != 10**9\n"
    ],
    "results": 7
},{
    "id": "1616",
    "source": "leetcode",
    "language": "python",
    "query": "A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed)",
    "snippets": [
        "def is_special(mat):\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            if mat[i][j] == 1:\n                if mat[i].count(1) != 1 or mat[:][j].count(1) != 1:\n                    return False\n    return True\n",
        "def is_special(mat):\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            if mat[i][j] == 1:\n                if not all(mat[i][k] == 0 for k in range(len(mat[0])) if k != j):\n                    return False\n                if not all(mat[k][j] == 0 for k in range(len(mat)) if k != i):\n                    return False\n    return True\n",
        "def special_positions(mat):\n    res = []\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            if mat[i][j] == 1:\n                res.append((i, j))\n    return res\n"
    ],
    "results": 10
},{
    "id": "1617",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules. The values at even indices 0 and 2 are sorted in non-decreasing order.",
    "snippets": [
        "def rearrange(nums):\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            if nums[i] > nums[i + 1]:\n                nums[i], nums[i + 1] = nums[i + 1], nums[i]\n        else:\n            if nums[i] < nums[i - 1]:\n                nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return nums\n",
        "def rearrange(nums):\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            if nums[i] > nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n        else:\n            if nums[i] < nums[i+1]:\n                nums[i], nums[i+1] = nums[i+1], nums[i]\n    return nums\n",
        "def rearrange_digits(arr):\n    # Write your code here\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        return [arr[1], arr[0]]\n    if len(arr) == 3:\n        return [arr[2], arr[0], arr[1]]\n    if len(arr) == 4:\n        return [arr[3], arr[0], arr[1], arr[2]]\n    if len(arr) == 5:\n        return [arr[4], arr[0], arr[1], arr[2], arr[3]]\n    if len(arr) == 6:\n        return [arr[5], arr[0], arr[1], arr[2], arr[3], arr[4]]\n    if len(arr) == 7:\n        return [arr[6], arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]]\n    if len(arr) == 8:\n        return [arr[7], arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6]]\n    if len(arr) == 9:\n        return [arr[8], arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7]]\n    if len(arr) == 10:\n        return [arr[9], arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8]]\n    if len(arr) == 11:\n        return [arr[10], arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[9]]\n    if len(arr) == 12:\n        return [arr[11], arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[\n",
        "def rearrange_digits(arr):\n    # Write your code here\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    arr.sort()\n    return [arr[i] for i in range(0, len(arr), 2)] + [arr[i] for i in range(1, len(arr), 2)]\n",
        "def rearrange_nums(nums):\n    even_nums = sorted(nums[::2])\n    odd_nums = sorted(nums[1::2])\n    return even_nums + odd_nums\n",
        "def rearrange_numbers(nums):\n    # Write your code here.\n    nums.sort()\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            nums[i] = nums[i] * 10 + nums[i+1]\n            nums[i+1] = 0\n    return nums\n",
        "def rearrange_nums(nums):\n    for i in range(0, len(nums), 2):\n        if nums[i] > nums[i+1]:\n            nums[i], nums[i+1] = nums[i+1], nums[i]\n    for i in range(1, len(nums), 2):\n        if nums[i] < nums[i-1]:\n            nums[i], nums[i-1] = nums[i-1], nums[i]\n    return nums\n",
        "def rearrange_digits(input_list):\n    \"\"\"\n    Rearrange positive integers in ascending order.\n    For example, [2, 6, 4, 8, 10, 9, 15] is sorted to [2, 4, 6, 8, 9, 10, 15].\n    Return the sorted array.\n    \"\"\"\n    # Your code here\n    if len(input_list) == 0:\n        return []\n    else:\n        input_list.sort()\n        return [int(str(input_list[i]) + str(input_list[i+1])) for i in range(0, len(input_list)-1, 2)] + [input_list[-1]]\n"
    ],
    "results": 10
},{
    "id": "1618",
    "source": "leetcode",
    "language": "python",
    "query": "24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23. The earliest 24-hour time is 00:00, and the latest is 23:59.",
    "snippets": [
        "def is_valid_time(time):\n    if time[0] == '0' and len(time) == 2:\n        return True\n    elif time[0] == '1' and time[1] == '2' and len(time) == 3:\n        return True\n    elif time[0] == '2' and time[1] == '3' and len(time) == 3:\n        return True\n    elif time[0] == '3' and time[1] == '4' and len(time) == 3:\n        return True\n    elif time[0] == '4' and time[1] == '5' and len(time) == 3:\n        return True\n    elif time[0] == '5' and time[1] == '6' and len(time) == 3:\n        return True\n    elif time[0] == '6' and time[1] == '7' and len(time) == 3:\n        return True\n    elif time[0] == '7' and time[1] == '8' and len(time) == 3:\n        return True\n    elif time[0] == '8' and time[1] == '9' and len(time) == 3:\n        return True\n    elif time[0] == '9' and time[1] == '0' and len(time) == 3:\n        return True\n    else:\n        return False\n",
        "def valid_time(time):\n    if len(time) != 5:\n        return False\n    if time[0] == '0':\n        return False\n    if time[2] == '0':\n        return False\n    if time[0] == '2' and time[1] == '4':\n        return False\n    if time[0] == '2' and time[1] == '3' and time[2] == '9':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '0':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '1':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '2':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '3':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '4':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '5':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '6':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '7':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '8':\n        return False\n    if time[0] == '2' and time[1] == '4' and time[2] == '9':\n        return False\n    if time[0] == '2' and time[1] == '5' and time[2] == '0':\n        return False\n    if time[0] == '2' and time[1] == '5' and time[2] == '1':\n",
        "def is_valid_time(time):\n    return time.split(':')[0] in range(24) and time.split(':')[1] in range(60)\n",
        "def is_valid_time(time):\n    if time[0] == '0':\n        time = time[1:]\n    if time[0] == '2' and time[1] == '4':\n        return True\n    return False\n",
        "def is_valid_time(time):\n    if time[0] == '0' and len(time) == 2:\n        return True\n    elif time[0] == '2' and time[1] == '4' and len(time) == 3:\n        return True\n    else:\n        return False\n",
        "def is_valid_time(time):\n    return time.split(\":\")[0] in range(24) and time.split(\":\")[1] in range(60)\n",
        "def main():\n    print(\"This program converts a 24-hour time to 12-hour time.\")\n    time = input(\"Enter a 24-hour time, such as 16:45: \")\n    convert_to_12_hour_time(time)\n",
        "def is_valid_time(time):\n    # your code here\n    if time[0] == '0':\n        time = time[1:]\n    if time[0] == '2':\n        if time[1] == '4':\n            if time[2] == ':':\n                if time[3] == '0':\n                    if time[4] == '0':\n                        return True\n    return False\n"
    ],
    "results": 8
},{
    "id": "1619",
    "source": "leetcode",
    "language": "python",
    "query": "Alice starts with 0 points and draws numbers while she has less than k points. Each draw is independent and the outcomes have equal probabilities.",
    "snippets": [
        "def max_points(n, k):\n    if k == 0:\n        return 0\n    if n == 0:\n        return k\n    if k == 1:\n        return n\n    if n == 1:\n        return k\n    if n == 2:\n        return k * (k - 1) // 2\n    if k == 2:\n        return n * (n - 1) // 2\n    if n == 3:\n        return k * (k - 1) * (k - 2) // 6\n    if k == 3:\n        return n * (n - 1) * (n - 2) // 6\n    if n == 4:\n        return k * (k - 1) * (k - 2) * (k - 3) // 24\n    if k == 4:\n        return n * (n - 1) * (n - 2) * (n - 3) // 24\n    if n == 5:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) // 120\n    if k == 5:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) // 120\n    if n == 6:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) // 720\n    if k == 6:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) // 720\n    if n == 7:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) // 5040\n    if k == 7:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) // 5040\n    if n == 8:\n        return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (\n",
        "def draw(k):\n    return random.randint(1, k)\n",
        "def alice(k):\n    return sum(1 for _ in range(k))\n"
    ],
    "results": 10
},{
    "id": "1620",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n.",
    "snippets": [
        "def simplify_fraction(n):\n    result = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i * j <= n:\n                result.append((i, j))\n    return result\n",
        "def simplifyFraction(n):\n    result = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i * j <= n:\n                result.append([i, j])\n    return result\n",
        "def simplify_fractions(n):\n    result = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i * j <= n:\n                result.append((i, j))\n    return result\n",
        "def simplifiedFractions(n):\n    \"\"\"\n    :type n: int\n    :rtype: List[str]\n    \"\"\"\n    res = []\n    for i in range(1, n):\n        for j in range(i, n):\n            if gcd(i, j) == 1:\n                res.append(str(i) + '/' + str(j))\n    return res\n"
    ],
    "results": 10
},{
    "id": "1621",
    "source": "leetcode",
    "language": "python",
    "query": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr1 are also in arr2. Elements that do not appear inarr2 should be placed at the end of arr1 in ascending order.",
    "snippets": [
        "def sortArray(arr1, arr2):\n    # Fill this in.\n    arr1.sort()\n    for i in range(len(arr2)):\n        for j in range(len(arr1)):\n            if arr1[j] == arr2[i]:\n                arr1.pop(j)\n                break\n    arr1.extend(arr2)\n    return arr1\n",
        "def sortArray(arr1, arr2):\n    # Write your code here.\n    arr1.sort()\n    for i in range(len(arr2)):\n        for j in range(len(arr1)):\n            if arr1[j] == arr2[i]:\n                arr1.insert(j, arr1.pop(arr1.index(arr2[i])))\n    return arr1\n",
        "def sortArray(arr1, arr2):\n    arr1.sort()\n    for i in range(len(arr2)):\n        for j in range(len(arr1)):\n            if arr2[i] == arr1[j]:\n                arr1.pop(j)\n                break\n    arr1.extend(arr2)\n    return arr1\n",
        "def customSort(arr1, arr2):\n    arr1.sort(key=lambda x: arr2.index(x))\n    return arr1\n",
        "def sortArray(arr1, arr2):\n    # Write your code here.\n    arr1.sort()\n    arr2.sort()\n    for i in range(len(arr2)):\n        if arr2[i] not in arr1:\n            arr1.append(arr2[i])\n    return arr1\n",
        "def customSort(arr1, arr2):\n    # Fill this in.\n    arr1.sort()\n    arr2.sort()\n    for i in range(len(arr2)):\n        for j in range(len(arr1)):\n            if arr2[i] == arr1[j]:\n                arr1.insert(j, arr2[i])\n                arr1.pop(j+1)\n                break\n    return arr1\n",
        "def customSort(arr1, arr2):\n    # Write your code here.\n    arr1.sort()\n    arr2.sort()\n    arr1.extend(arr2)\n    return arr1\n    # return sorted(arr1 + arr2)\n    # return sorted(arr1 + arr2, key=arr2.index)\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x))\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x) if x in arr2 else len(arr2))\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x) if x in arr2 else len(arr2) + 1)\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x) if x in arr2 else len(arr2) + 1 if x in arr2 else len(arr2) + 2)\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x) if x in arr2 else len(arr2) + 1 if x in arr2 else len(arr2) + 2 if x in arr2 else len(arr2) + 3)\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x) if x in arr2 else len(arr2) + 1 if x in arr2 else len(arr2) + 2 if x in arr2 else len(arr2) + 3 if x in arr2 else len(arr2) + 4)\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x) if x in arr2 else len(arr2) + 1 if x in arr2 else len(arr2) + 2 if x in arr2 else len(arr2) + 3 if x in arr2 else len(arr2) + 4 if x in arr2 else len(arr2) + 5)\n    # return sorted(arr1 + arr2, key=lambda x: arr2.index(x) if x in arr2 else len(arr2) + 1 if x in arr2\n",
        "def customSortString(S, T):\n    \"\"\"\n    :type S: str\n    :type T: str\n    :rtype: str\n    \"\"\"\n    # Create a dictionary of the characters in S\n    S_dict = {}\n    for char in S:\n        if char in S_dict:\n            S_dict[char] += 1\n        else:\n            S_dict[char] = 1\n    # Create a dictionary of the characters in T\n    T_dict = {}\n    for char in T:\n        if char in T_dict:\n            T_dict[char] += 1\n        else:\n            T_dict[char] = 1\n    # Create a list of the characters in T that are not in S\n    T_not_in_S = []\n    for char in T_dict:\n        if char not in S_dict:\n            T_not_in_S.append(char)\n    # Create a list of the characters in S that are not in T\n    S_not_in_T = []\n    for char in S_dict:\n        if char not in T_dict:\n            S_not_in_T.append(char)\n    # Create a list of the characters in S that are in T\n    S_in_T = []\n    for char in S_dict:\n        if char in T_dict:\n            S_in_T.append(char)\n    # Sort the characters in S_in_T\n    S_in_T.sort()\n    # Create a list of the characters in T that are not in S\n    T_not_in_S.sort()\n    # Create a list of the characters in S that are not in T\n    S_not_in_T.sort()\n    # Create a list of the characters in T that are in S\n    S_in_T.sort()\n    # Create a list of the characters in T that are not in S\n    T_not_in_S.sort()\n    # Create a list of the characters in S that are not in T\n    S_not_in_T.sort()\n    # Create a list of the characters in S that are in T\n",
        "def custom_sort_array(arr1, arr2):\n    # Fill this in.\n    arr1_dict = {}\n    for i in arr1:\n        arr1_dict[i] = arr1.count(i)\n    for i in arr2:\n        if i in arr1_dict:\n            arr1_dict[i] -= 1\n    arr1_dict = sorted(arr1_dict.items(), key=lambda x: x[1])\n    arr1_dict = [i[0] for i in arr1_dict]\n    return arr1_dict\n",
        "def custom_sort(arr1, arr2):\n    arr1_dict = {}\n    for i in arr1:\n        arr1_dict[i] = arr1.index(i)\n    arr1_dict = sorted(arr1_dict.items(), key=lambda x: x[1])\n    arr1_dict = [i[0] for i in arr1_dict]\n    arr1_dict.extend(arr2)\n    return arr1_dict\n"
    ],
    "results": 10
},{
    "id": "1622",
    "source": "leetcode",
    "language": "python",
    "query": "Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples).",
    "snippets": [
        "def serialize(root):\n    if root is None:\n        return '#'\n    return str(root.val) + ' ' + serialize(root.left) + ' ' + serialize(root.right)\n"
    ],
    "results": 10
},{
    "id": "1623",
    "source": "leetcode",
    "language": "python",
    "query": "A magical string s consists of only '1' and '2' and obeys the following rules. The string s is magical because concatenating the number of contiguous occurrences of characters '1', '2', generates the string s itself.",
    "snippets": [
        "def magicalString(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 7\n    if n == 5:\n        return 13\n    if n == 6:\n        return 24\n    if n == 7:\n        return 44\n    if n == 8:\n        return 81\n    if n == 9:\n        return 149\n    if n == 10:\n        return 274\n    if n == 11:\n        return 504\n    if n == 12:\n        return 927\n    if n == 13:\n        return 1705\n    if n == 14:\n        return 2904\n    if n == 15:\n        return 4739\n    if n == 16:\n        return 7692\n    if n == 17:\n        return 12341\n    if n == 18:\n        return 19764\n    if n == 19:\n        return 31609\n    if n == 20:\n        return 50804\n    if n == 21:\n        return 83511\n    if n == 22:\n        return 135699\n    if n == 23:\n        return 211544\n    if n == 24:\n        return 347322\n    if n == 25:\n        return 573156\n    if n == 26:\n        return 927689\n    if n == 27:\n        return 1500543\n    if n == 28:\n        return 2480951\n    if n == 29:\n        return 3972284\n    if n == 30:\n        return 6461690\n    if n == 31:\n        return 10368031\n    if n == 32:\n        return 16777214\n    if n == 33:\n        return 27487790\n    if n == 34:\n        return 43046721\n    if n == 35:\n        return 68458976\n    if n == 36:\n        return 109614124\n    if n == 37:\n        return 173407253\n    if n == 38:\n        return 282475249\n    if n == 39:\n        return 44\n",
        "def magicalString(n):\n    s = '122'\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 7\n    if n == 5:\n        return 13\n    if n == 6:\n        return 24\n    if n == 7:\n        return 44\n    if n == 8:\n        return 81\n    if n == 9:\n        return 149\n    if n == 10:\n        return 274\n    if n == 11:\n        return 504\n    if n == 12:\n        return 927\n    if n == 13:\n        return 1705\n    if n == 14:\n        return 2904\n    if n == 15:\n        return 4739\n    if n == 16:\n        return 7692\n    if n == 17:\n        return 11661\n    if n == 18:\n        return 17576\n    if n == 19:\n        return 25918\n    if n == 20:\n        return 39366\n    if n == 21:\n        return 57568\n    if n == 22:\n        return 85499\n    if n == 23:\n        return 130939\n    if n == 24:\n        return 203490\n    if n == 25:\n        return 312759\n    if n == 26:\n        return 489096\n    if n == 27:\n        return 726666\n    if n == 28:\n        return 1084152\n    if n == 29:\n        return 1576247\n    if n == 30:\n        return 2395690\n    if n == 31:\n        return 3712247\n    if n == 32:\n        return 5757575\n    if n == 33:\n        return 8673869\n    if n == 34:\n        return 13108421\n    if n == 35:\n        return 20349034\n    if n == 36:\n        return 31275952\n    if n == 37:\n        return 48909637\n    if n == 38:\n        return 72666675\n    if n == 39:\n        return 108415234\n    if\n",
        "def magicalString(n):\n    s = '122'\n    for i in range(3, n + 1):\n        s += str(3 - s[i - 1])\n    return s[:n]\n",
        "def magicalString(n):\n    s = '122'\n    for i in range(3, n + 1):\n        s += str(3 - int(s[i]))\n    return s[:n]\n",
        "def magicalString(n):\n    s = '122'\n    if n <= 3:\n        return s[:n]\n    else:\n        for i in range(3, n):\n            s += str(3 - int(s[i]))\n        return s\n",
        "def magicalString(n):\n    s = [1, 2]\n    for i in range(2, n):\n        s.append(s[i - 1] + 1)\n        s.append(s[i - 1])\n    return s[:n]\n",
        "def magicalString(n):\n    s = [1, 2]\n    for i in range(2, n):\n        s.append(s[i - 1] + 1)\n        if s[i] == 3:\n            s.append(1)\n    return s[:n]\n",
        "def is_magical(s):\n    if s == '':\n        return True\n    if s[0] != '1' and s[0] != '2':\n        return False\n    if s[0] == '1':\n        return is_magical(s[1:])\n    else:\n        return is_magical(s[1:]) or is_magical(s[1:])\n",
        "def magicalString(n):\n    s = [1, 2]\n    for i in range(2, n):\n        s.append(s[i - 1] % 3)\n    return s[:n]\n"
    ],
    "results": 10
},{
    "id": "1624",
    "source": "leetcode",
    "language": "python",
    "query": "Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. If it is impossible for b​​​​​​ to be a subring of a after repeating it, return -1.Notice: string \"abc\" repeated 0 times is \"\", repeated 1 time is \"ABC\" and repeated 2 times is 'abc'",
    "snippets": [
        "def repeatedString(s, n):\n    if s == \"\":\n        return 0\n    if n == 0:\n        return 0\n    if n == 1:\n        return len(s)\n    if n == 2:\n        return len(s) * 2\n    if n == 3:\n        return len(s) * 3\n    if n == 4:\n        return len(s) * 4\n    if n == 5:\n        return len(s) * 5\n    if n == 6:\n        return len(s) * 6\n    if n == 7:\n        return len(s) * 7\n    if n == 8:\n        return len(s) * 8\n    if n == 9:\n        return len(s) * 9\n    if n == 10:\n        return len(s) * 10\n    if n == 11:\n        return len(s) * 11\n    if n == 12:\n        return len(s) * 12\n    if n == 13:\n        return len(s) * 13\n    if n == 14:\n        return len(s) * 14\n    if n == 15:\n        return len(s) * 15\n    if n == 16:\n        return len(s) * 16\n    if n == 17:\n        return len(s) * 17\n    if n == 18:\n        return len(s) * 18\n    if n == 19:\n        return len(s) * 19\n    if n == 20:\n        return len(s) * 20\n    if n == 21:\n        return len(s) * 21\n    if n == 22:\n        return len(s) * 22\n    if n == 23:\n        return len(s) * 23\n    if n == 24:\n        return len(s) * 24\n    if n == 25:\n        return len(s) * 25\n    if n == 26:\n        return len(s) * 26\n    if n == 27:\n        return len(s) * 27\n    if n == 28:\n        return len(s) * 28\n    if n == 29:\n        return len(s) * 29\n    if n == 30:\n",
        "def repeatedString(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: int\n    \"\"\"\n    if b in a:\n        return b.count(a)\n    else:\n        return -1\n",
        "def repeatedString(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: int\n    \"\"\"\n    if len(b) == 0:\n        return 0\n    if len(a) == 0:\n        return -1\n    if len(a) > len(b):\n        return -1\n    if len(a) == len(b):\n        if a == b:\n            return 1\n        else:\n            return -1\n    if len(a) < len(b):\n        if a in b:\n            return b.count(a)\n        else:\n            return -1\n    if len(a) > len(b):\n        if a in b:\n            return b.count(a)\n        else:\n            return -1\n    return -1\n",
        "def repeatedString(a, b):\n    if b in a:\n        return b.count(a)\n    else:\n        return -1\n",
        "def repeatedString(a, b):\n    if len(b) > len(a):\n        return -1\n    if len(b) == 0:\n        return 0\n    if len(b) == len(a):\n        if b == a:\n            return 1\n        else:\n            return -1\n    if len(b) < len(a):\n        count = 0\n        for i in range(len(a)):\n            if a[i] == b[0]:\n                count += 1\n        if count == len(b):\n            return 1\n        else:\n            return -1\n    if len(b) > len(a):\n        count = 0\n        for i in range(len(a)):\n            if a[i] == b[0]:\n                count += 1\n        if count == len(b):\n            return 1\n        else:\n            return -1\n    return -1\n",
        "def repeatedString(s, n):\n    if n == 0:\n        return 0\n    if n < len(s):\n        return s.count(s[:n])\n    else:\n        return s.count(s) * (n // len(s)) + s.count(s[:n % len(s)])\n",
        "def repeatedString(s, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        if s == \"\":\n            return 0\n        else:\n            return 1\n    if s == \"\":\n        return 0\n    if s == \"a\":\n        return n\n    if s == \"b\":\n        return n // 2\n    if s == \"ab\":\n        return n // 2\n    if s == \"abc\":\n        return n // 3\n    if s == \"abcd\":\n        return n // 4\n    if s == \"abcdabcd\":\n        return n // 8\n    if s == \"abcdabcdabcd\":\n        return n // 12\n    if s == \"abcdabcdabcdabcd\":\n        return n // 16\n    if s == \"abcdabcdabcdabcdabcd\":\n        return n // 24\n    if s == \"abcdabcdabcdabcdabcdabcd\":\n        return n // 32\n    if s == \"abcdabcdabcdabcdabcdabcdabcd\":\n        return n // 40\n    if s == \"abcdabcdabcdabcdabcdabcdabcdabcd\":\n        return n // 48\n    if s == \"abcdabcdabcdabcdabcdabcdabcdabcdabcd\":\n        return n // 56\n    if s == \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\":\n        return n // 64\n    if s == \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\":\n        return n // 72\n    if s == \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\":\n        return n // 80\n    if s == \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\":\n        return n // 88\n    if s == \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd\":\n        return n\n"
    ],
    "results": 10
},{
    "id": "1625",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.",
    "snippets": [
        "def threeConsecutiveOddNumbers(arr):\n    for i in range(len(arr) - 2):\n        if arr[i] % 2 == 1 and arr[i + 1] % 2 == 1 and arr[i + 2] % 2 == 1:\n            return True\n    return False\n",
        "def threeConsecutiveOddNumbers(arr):\n    for i in range(len(arr) - 2):\n        if arr[i] % 2 != 0 and arr[i + 1] % 2 != 0 and arr[i + 2] % 2 != 0:\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1626",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k. Return it modulo 109 + 7.",
    "snippets": [
        "def numTriplets(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[j] * 2 > target:\n                break\n            for k in range(j+1, len(arr)):\n                if arr[k] * 2 > target:\n                    break\n                if arr[i] + arr[j] + arr[k] == target:\n                    count += 1\n    return count % (10**9 + 7)\n",
        "def numTriplets(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    count = 0\n    for i in range(len(arr)):\n        j = i + 1\n        k = len(arr) - 1\n        while j < k:\n            if arr[i] + arr[j] + arr[k] > target:\n                k -= 1\n            elif arr[i] + arr[j] + arr[k] < target:\n                j += 1\n            else:\n                count += k - j\n                j += 1\n                k -= 1\n    return count % (10**9 + 7)\n",
        "def numTriplets(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[j] * 2 > target:\n                break\n            for k in range(j + 1, len(arr)):\n                if arr[k] * 3 > target:\n                    break\n                if arr[i] + arr[j] + arr[k] == target:\n                    count += 1\n    return count % (10 ** 9 + 7)\n",
        "def numTriplets(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    res = 0\n    for i in range(len(arr)):\n        j = i + 1\n        k = len(arr) - 1\n        while j < k:\n            if arr[i] + arr[j] + arr[k] > target:\n                k -= 1\n            elif arr[i] + arr[j] + arr[k] < target:\n                j += 1\n            else:\n                res += k - j + 1\n                j += 1\n                k -= 1\n    return res % (10**9 + 7)\n",
        "def threeSumMulti(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    res = 0\n    for i in range(len(arr)):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        left = i + 1\n        right = len(arr) - 1\n        while left < right:\n            sum = arr[i] + arr[left] + arr[right]\n            if sum < target:\n                left += 1\n            elif sum > target:\n                right -= 1\n            else:\n                res += 1\n                while left < right and arr[left] == arr[left + 1]:\n                    left += 1\n                while left < right and arr[right] == arr[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return res % (1e9 + 7)\n",
        "def threeSumMulti(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    res = 0\n    for i in range(len(arr) - 2):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        j = i + 1\n        k = len(arr) - 1\n        while j < k:\n            if arr[i] + arr[j] + arr[k] > target:\n                k -= 1\n            elif arr[i] + arr[j] + arr[k] < target:\n                j += 1\n            else:\n                res += 1\n                j += 1\n                k -= 1\n                while j < k and arr[j] == arr[j - 1]:\n                    j += 1\n                while j < k and arr[k] == arr[k + 1]:\n                    k -= 1\n    return res % (10**9 + 7)\n",
        "def threeSumMulti(arr, target):\n    \"\"\"\n    :type arr: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    arr.sort()\n    res = 0\n    for i in range(len(arr)):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        l, r = i + 1, len(arr) - 1\n        while l < r:\n            s = arr[i] + arr[l] + arr[r]\n            if s == target:\n                res += 1\n                l += 1\n                r -= 1\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n    return res % (10 ** 9 + 7)\n",
        "def threeSumMulti(arr, target):\n    arr.sort()\n    ans = 0\n    for i in range(len(arr)):\n        if i > 0 and arr[i] == arr[i - 1]:\n            continue\n        l, r = i + 1, len(arr) - 1\n        while l < r:\n            s = arr[i] + arr[l] + arr[r]\n            if s == target:\n                ans += 1\n                l += 1\n                r -= 1\n            elif s < target:\n                l += 1\n            else:\n                r -= 1\n    return ans % (10**9 + 7)\n",
        "def numTriplets(arr, target):\n    d = {}\n    for i in range(len(arr)):\n        d[arr[i]] = d.get(arr[i], 0) + 1\n    res = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] * 2 + arr[j] in d:\n                res += d[arr[i] * 2 + arr[j]]\n            if arr[i] + arr[j] * 2 in d:\n                res += d[arr[i] + arr[j] * 2]\n    return res % (10 ** 9 + 7)\n"
    ],
    "results": 9
},{
    "id": "1627",
    "source": "leetcode",
    "language": "python",
    "query": "Given the circular array code and an integer key k, return the decrypted code to defuse the bomb. All the numbers are replaced simultaneously.",
    "snippets": [
        "def decrypt(code, k):\n    return [code[(i + k) % len(code)] for i in range(len(code))]\n",
        "def decrypt(code, k):\n    return [code[(i - k) % len(code)] for i in range(len(code))]\n",
        "def decrypt(code, k):\n    # your code here\n    return [code[(i + k) % len(code)] for i in range(len(code))]\n",
        "def decrypt(code, k):\n    # your code here\n    return code\n"
    ],
    "results": 10
},{
    "id": "1628",
    "source": "leetcode",
    "language": "python",
    "query": "For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k- Repeating value is the highest value k.",
    "snippets": [
        "def max_repeating(sequence, word):\n    max_repeat = 0\n    for i in range(len(sequence) - len(word) + 1):\n        if sequence[i:i+len(word)] == word:\n            max_repeat = max(max_repeat, i)\n    return max_repeat\n",
        "def max_repeating(sequence, word):\n    max_k = 0\n    for i in range(len(sequence) - len(word) + 1):\n        if sequence[i:i+len(word)] == word:\n            max_k = max(max_k, i)\n    return max_k\n",
        "def k_repeating(sequence, word):\n    for i in range(len(sequence) - len(word) + 1):\n        if sequence[i:i+len(word)] == word * len(word):\n            return len(word)\n    return 0\n",
        "def k_repeating(sequence, word):\n    for i in range(len(sequence)):\n        if sequence[i:i+len(word)] == word:\n            return i\n    return -1\n",
        "def kRepeating(sequence, word):\n    # Your code here\n    max_k = 0\n    for i in range(len(sequence) - len(word) + 1):\n        if sequence[i:i+len(word)] == word:\n            max_k = max(max_k, i + len(word))\n    return max_k\n",
        "def k_repeating(sequence, word):\n    \"\"\"\n    >>> k_repeating('ATCGATCG', 'ATCG')\n    4\n    >>> k_repeating('ATCATGCATGCATGCATGCATGCATGCA', 'ATGCATGCATGCATGCATGCATGCATGCA')\n    9\n    >>> k_repeating('ATCATGCATGCATGCATGCATGCATGCA', 'ATGCATGCATGCATGCATGCATGCAT')\n    0\n    \"\"\"\n    # Your code here\n    max_k = 0\n    for i in range(len(sequence) - len(word) + 1):\n        if sequence[i:i+len(word)] == word:\n            max_k = max(max_k, i)\n    return max_k\n"
    ],
    "results": 10
},{
    "id": "1629",
    "source": "leetcode",
    "language": "python",
    "query": "You must write an algorithm with O(log n) runtime complexity. There is an integer array nums sorted in ascending order (with distinct values).",
    "snippets": [
        "def find_peak_element(nums):\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums)\n    if nums[0] > nums[1]:\n        return nums[0]\n    if nums[-1] > nums[-2]:\n        return nums[-1]\n    mid = len(nums) // 2\n    if nums[mid] > nums[mid - 1] and nums[mid] > nums[mid + 1]:\n        return nums[mid]\n    if nums[mid - 1] > nums[mid]:\n        return find_peak_element(nums[:mid])\n    if nums[mid + 1] > nums[mid]:\n        return find_peak_element(nums[mid:])\n    return -1\n",
        "def find_peak_element(nums):\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums)\n    if len(nums) == 3:\n        return max(nums)\n    if len(nums) == 4:\n        return max(nums)\n    if len(nums) == 5:\n        return max(nums)\n    if len(nums) == 6:\n        return max(nums)\n    if len(nums) == 7:\n        return max(nums)\n    if len(nums) == 8:\n        return max(nums)\n    if len(nums) == 9:\n        return max(nums)\n    if len(nums) == 10:\n        return max(nums)\n    if len(nums) == 11:\n        return max(nums)\n    if len(nums) == 12:\n        return max(nums)\n    if len(nums) == 13:\n        return max(nums)\n    if len(nums) == 14:\n        return max(nums)\n    if len(nums) == 15:\n        return max(nums)\n    if len(nums) == 16:\n        return max(nums)\n    if len(nums) == 17:\n        return max(nums)\n    if len(nums) == 18:\n        return max(nums)\n    if len(nums) == 19:\n        return max(nums)\n    if len(nums) == 20:\n        return max(nums)\n    if len(nums) == 21:\n        return max(nums)\n    if len(nums) == 22:\n        return max(nums)\n    if len(nums) == 23:\n        return max(nums)\n    if len(nums) == 24:\n        return max(nums)\n    if len(nums) == 25:\n        return max(nums)\n    if len(nums) == 26:\n        return max\n",
        "def find_first_greater_than_k(nums, k):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] > k:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return left if left < len(nums) else -1\n",
        "def find_peak(nums):\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums)\n    if len(nums) == 3:\n        return max(nums)\n    if len(nums) == 4:\n        return max(nums)\n    if len(nums) == 5:\n        return max(nums)\n    if len(nums) == 6:\n        return max(nums)\n    if len(nums) == 7:\n        return max(nums)\n    if len(nums) == 8:\n        return max(nums)\n    if len(nums) == 9:\n        return max(nums)\n    if len(nums) == 10:\n        return max(nums)\n    if len(nums) == 11:\n        return max(nums)\n    if len(nums) == 12:\n        return max(nums)\n    if len(nums) == 13:\n        return max(nums)\n    if len(nums) == 14:\n        return max(nums)\n    if len(nums) == 15:\n        return max(nums)\n    if len(nums) == 16:\n        return max(nums)\n    if len(nums) == 17:\n        return max(nums)\n    if len(nums) == 18:\n        return max(nums)\n    if len(nums) == 19:\n        return max(nums)\n    if len(nums) == 20:\n        return max(nums)\n    if len(nums) == 21:\n        return max(nums)\n    if len(nums) == 22:\n        return max(nums)\n    if len(nums) == 23:\n        return max(nums)\n    if len(nums) == 24:\n        return max(nums)\n    if len(nums) == 25:\n        return max(nums)\n    if len(nums) == 26:\n        return max(n\n",
        "def find_first_missing_positive(nums):\n    if not nums:\n        return 1\n    if len(nums) == 1:\n        return nums[0] + 1 if nums[0] != 1 else 2\n    if len(nums) == 2:\n        return nums[1] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 3:\n        return nums[2] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 4:\n        return nums[3] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 5:\n        return nums[4] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 6:\n        return nums[5] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 7:\n        return nums[6] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 8:\n        return nums[7] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 9:\n        return nums[8] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 10:\n        return nums[9] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 11:\n        return nums[10] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 12:\n        return nums[11] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 13:\n        return nums[12] if nums[0] == 1 else nums[0] + 1\n    if len(nums) == 14:\n        return nums[13] if nums[0] ==\n",
        "def find_first_missing_positive(nums):\n    if not nums:\n        return 1\n    if len(nums) == 1:\n        return nums[0] + 1 if nums[0] != 1 else 2\n    if len(nums) == 2:\n        return nums[0] + 1 if nums[0] != 1 else 2 if nums[1] != 2 else 3\n    if len(nums) == 3:\n        return nums[0] + 1 if nums[0] != 1 else 2 if nums[1] != 2 else 3 if nums[2] != 3 else 4\n    if len(nums) == 4:\n        return nums[0] + 1 if nums[0] != 1 else 2 if nums[1] != 2 else 3 if nums[2] != 3 else 4 if nums[3] != 4 else 5\n    if len(nums) == 5:\n        return nums[0] + 1 if nums[0] != 1 else 2 if nums[1] != 2 else 3 if nums[2] != 3 else 4 if nums[3] != 4 else 5 if nums[4] != 5 else 6\n    if len(nums) == 6:\n        return nums[0] + 1 if nums[0] != 1 else 2 if nums[1] != 2 else 3 if nums[2] != 3 else 4 if nums[3] != 4 else 5 if nums[4] != 5 else 6 if nums[5] != 6 else 7\n    if len(nums) == 7:\n        return nums[0] + 1 if nums[0] != 1 else 2 if nums[1] != 2 else 3 if nums[2] != 3 else 4 if nums[3] != 4 else 5 if nums[4] != 5 else 6 if nums[5] != 6 else 7 if nums[6] != 7 else 8\n    if len(nums) == 8:\n        return nums[0] + 1 if nums[0] != 1 else 2 if nums[1] != 2 else 3 if nums[2] != 3 else\n",
        "def find_first_missing_positive(nums):\n    if not nums:\n        return 1\n    if len(nums) == 1:\n        return nums[0] if nums[0] > 0 else 1\n    if nums[0] > 1:\n        return 1\n    for i in range(len(nums)):\n        if nums[i] > 0:\n            break\n    if i == len(nums):\n        return 1\n    if nums[i] > 1:\n        return 1\n    for j in range(i, len(nums)):\n        if nums[j] > 0:\n            break\n    if j == len(nums):\n        return 1\n    if nums[j] > 1:\n        return 1\n    for k in range(j, len(nums)):\n        if nums[k] > 0:\n            break\n    if k == len(nums):\n        return 1\n    if nums[k] > 1:\n        return 1\n    for l in range(k, len(nums)):\n        if nums[l] > 0:\n            break\n    if l == len(nums):\n        return 1\n    if nums[l] > 1:\n        return 1\n    for m in range(l, len(nums)):\n        if nums[m] > 0:\n            break\n    if m == len(nums):\n        return 1\n    if nums[m] > 1:\n        return 1\n    for n in range(m, len(nums)):\n        if nums[n] > 0:\n            break\n    if n == len(nums):\n        return 1\n    if nums[n] > 1:\n        return 1\n    for o in range(n, len(nums)):\n        if nums[o] > 0:\n            break\n    if o == len(nums):\n        return 1\n    if nums[o] > 1:\n        return 1\n    for p in range(o, len(nums)):\n        if nums[p] > 0:\n            break\n",
        "def find_target_sum_ways(nums, target):\n    if not nums:\n        return 0\n    return find_target_sum_ways_helper(nums, target, 0)\n",
        "def find_kth_smallest(nums, k):\n    if not nums:\n        return None\n    if k > len(nums):\n        return None\n    if k == 1:\n        return nums[0]\n    if k == len(nums):\n        return nums[-1]\n    return find_kth_smallest_helper(nums, k, 0, len(nums)-1)\n"
    ],
    "results": 10
},{
    "id": "1630",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0- indexed string s that you must perform k replacement operations on. The replacement operations are given as three 0-indexed parallel arrays, indices, sources, and targets, all of length k.",
    "snippets": [
        "def k_replace(s, indices, sources, targets):\n    for i in range(len(indices)):\n        s = s[:indices[i]] + targets[i] + s[indices[i]+1:]\n    return s\n",
        "def replace(s, indices, sources, targets):\n    for i, j, k in zip(indices, sources, targets):\n        s = s[:i] + k + s[j+1:]\n    return s\n"
    ],
    "results": 10
},{
    "id": "1631",
    "source": "leetcode",
    "language": "python",
    "query": "A ramp in an integer array nums is a pair (i, j) for which i < j. The width of such a ramp is j - i. If there is no ramp in nums, return 0.",
    "snippets": [
        "def findMaxRamp(nums):\n    if len(nums) == 0:\n        return 0\n    maxRamp = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if nums[j] > nums[i]:\n                maxRamp = max(maxRamp, j - i)\n    return maxRamp\n",
        "def find_ramp(nums):\n    if len(nums) < 2:\n        return 0\n    max_width = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] < nums[j]:\n                max_width = max(max_width, j - i)\n    return max_width\n",
        "def find_ramp(nums):\n    if len(nums) < 2:\n        return 0\n    max_width = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[i] < nums[j]:\n                width = j - i\n                if width > max_width:\n                    max_width = width\n    return max_width\n",
        "def findMaxRamp(nums):\n    if len(nums) == 0:\n        return 0\n    maxRamp = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] > nums[i]:\n                maxRamp = max(maxRamp, j - i)\n    return maxRamp\n",
        "def widthOfRamp(nums):\n    if len(nums) == 0:\n        return 0\n    max_width = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[j] > nums[i]:\n                max_width = max(max_width, j-i)\n    return max_width\n",
        "def findMaxRamp(nums):\n    if len(nums) < 2:\n        return 0\n    maxRamp = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] > nums[i]:\n                maxRamp = max(maxRamp, j - i)\n    return maxRamp\n",
        "def findMaxRamp(nums):\n    if not nums:\n        return 0\n    maxRamp = 0\n    for i in range(len(nums)):\n        for j in range(i, len(nums)):\n            if nums[j] > nums[i]:\n                maxRamp = max(maxRamp, j - i)\n    return maxRamp\n",
        "def widthOfBinaryTree(self, root):\n    if not root:\n        return 0\n    queue = [(root, 1)]\n    max_width = 0\n    while queue:\n        node, level = queue.pop(0)\n        if node.left:\n            queue.append((node.left, level + 1))\n        if node.right:\n            queue.append((node.right, level + 1))\n        if len(queue) == 0:\n            max_width = max(max_width, level)\n    return max_width\n"
    ],
    "results": 10
},{
    "id": "1632",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a string s consisting of digits and an integer k. Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters in the second group, and so on. A round can be completed if the length of s is greater than k.",
    "snippets": [
        "def split_string(s, k):\n    if len(s) < k:\n        return [s]\n    else:\n        return [s[:k]] + split_string(s[k:], k)\n",
        "def split_into_groups(s, k):\n    if len(s) < k:\n        return [s]\n    return [s[:k]] + split_into_groups(s[k:], k)\n",
        "def solution(s, k):\n    if len(s) < k:\n        return [s]\n    else:\n        return [s[:k]] + solution(s[k:], k)\n",
        "def split_in_groups(s, k):\n    return [s[i:i+k] for i in range(0, len(s), k)]\n",
        "def split_into_groups(s, k):\n    return [s[i:i+k] for i in range(0, len(s), k)]\n"
    ],
    "results": 10
},{
    "id": "1633",
    "source": "leetcode",
    "language": "python",
    "query": "Return true if the circle and rectangle are overlapped otherwise return false. Check if there is any point (xi, yi) that belongs to the circles and rectangle at the same time.",
    "snippets": [
        "def is_overlapped(circle, rectangle):\n    for i in range(len(circle)):\n        if circle[i] in rectangle:\n            return True\n    return False\n",
        "def is_overlapped(circle, rectangle):\n    for xi, yi in circle:\n        if xi in rectangle[0] and yi in rectangle[1]:\n            return True\n    return False\n",
        "def is_overlapped(circle, rectangle):\n    for xi, yi in circle:\n        if xi in range(rectangle[0], rectangle[0] + rectangle[2]) and yi in range(rectangle[1], rectangle[1] + rectangle[3]):\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1634",
    "source": "leetcode",
    "language": "python",
    "query": "The frequency of a letter x is the number of times it occurs in the string. Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' betweenword1 andword2 is at most 3.",
    "snippets": [
        "def almost_equivalent(word1, word2):\n    word1_dict = {}\n    word2_dict = {}\n    for letter in word1:\n        if letter in word1_dict:\n            word1_dict[letter] += 1\n        else:\n            word1_dict[letter] = 1\n    for letter in word2:\n        if letter in word2_dict:\n            word2_dict[letter] += 1\n        else:\n            word2_dict[letter] = 1\n    for letter in word1_dict:\n        if letter in word2_dict:\n            if abs(word1_dict[letter] - word2_dict[letter]) > 3:\n                return False\n    return True\n",
        "def almost_equivalent(word1, word2):\n    word1_dict = {}\n    word2_dict = {}\n    for letter in word1:\n        if letter in word1_dict:\n            word1_dict[letter] += 1\n        else:\n            word1_dict[letter] = 1\n    for letter in word2:\n        if letter in word2_dict:\n            word2_dict[letter] += 1\n        else:\n            word2_dict[letter] = 1\n    for letter in word1_dict:\n        if letter in word2_dict:\n            if abs(word1_dict[letter] - word2_dict[letter]) > 3:\n                return False\n        else:\n            if word1_dict[letter] > 3:\n                return False\n    for letter in word2_dict:\n        if letter in word1_dict:\n            if abs(word1_dict[letter] - word2_dict[letter]) > 3:\n                return False\n        else:\n            if word2_dict[letter] > 3:\n                return False\n    return True\n",
        "def almost_equivalent(word1, word2):\n    if len(word1) != len(word2):\n        return False\n    else:\n        word1_dict = {}\n        word2_dict = {}\n        for letter in word1:\n            if letter in word1_dict:\n                word1_dict[letter] += 1\n            else:\n                word1_dict[letter] = 1\n        for letter in word2:\n            if letter in word2_dict:\n                word2_dict[letter] += 1\n            else:\n                word2_dict[letter] = 1\n        for letter in word1_dict:\n            if letter in word2_dict:\n                if abs(word1_dict[letter] - word2_dict[letter]) > 3:\n                    return False\n            else:\n                return False\n        for letter in word2_dict:\n            if letter in word1_dict:\n                if abs(word1_dict[letter] - word2_dict[letter]) > 3:\n                    return False\n            else:\n                return False\n        return True\n",
        "def almost_equivalent(word1, word2):\n    if len(word1) != len(word2):\n        return False\n    else:\n        word1_dict = {}\n        word2_dict = {}\n        for i in range(len(word1)):\n            if word1[i] in word1_dict:\n                word1_dict[word1[i]] += 1\n            else:\n                word1_dict[word1[i]] = 1\n            if word2[i] in word2_dict:\n                word2_dict[word2[i]] += 1\n            else:\n                word2_dict[word2[i]] = 1\n        for key in word1_dict:\n            if abs(word1_dict[key] - word2_dict[key]) > 3:\n                return False\n        return True\n",
        "def almost_equivalent(word1, word2):\n    if len(word1) != len(word2):\n        return False\n    else:\n        word1_dict = {}\n        word2_dict = {}\n        for i in range(len(word1)):\n            if word1[i] in word1_dict:\n                word1_dict[word1[i]] += 1\n            else:\n                word1_dict[word1[i]] = 1\n            if word2[i] in word2_dict:\n                word2_dict[word2[i]] += 1\n            else:\n                word2_dict[word2[i]] = 1\n        for key in word1_dict:\n            if key in word2_dict:\n                if abs(word1_dict[key] - word2_dict[key]) > 3:\n                    return False\n            else:\n                return False\n        for key in word2_dict:\n            if key in word1_dict:\n                if abs(word1_dict[key] - word2_dict[key]) > 3:\n                    return False\n            else:\n                return False\n        return True\n",
        "def almost_equivalent(word1, word2):\n    if len(word1) != len(word2):\n        return False\n    else:\n        word1_dict = {}\n        word2_dict = {}\n        for letter in word1:\n            if letter in word1_dict:\n                word1_dict[letter] += 1\n            else:\n                word1_dict[letter] = 1\n        for letter in word2:\n            if letter in word2_dict:\n                word2_dict[letter] += 1\n            else:\n                word2_dict[letter] = 1\n        for key in word1_dict:\n            if key in word2_dict:\n                if abs(word1_dict[key] - word2_dict[key]) > 3:\n                    return False\n            else:\n                return False\n        for key in word2_dict:\n            if key in word1_dict:\n                if abs(word1_dict[key] - word2_dict[key]) > 3:\n                    return False\n            else:\n                return False\n        return True\n",
        "def almost_equivalent(word1, word2):\n    return abs(sum(word1.count(x) - word2.count(x) for x in set(word1)) - sum(word2.count(x) - word1.count(x) for x in set(word2))) <= 3\n",
        "def almost_equivalent(word1, word2):\n    if len(word1) != len(word2):\n        return False\n    else:\n        diff = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff += 1\n        if diff <= 3:\n            return True\n        else:\n            return False\n"
    ],
    "results": 10
},{
    "id": "1635",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.",
    "snippets": [
        "def addDigits(num):\n    if num < 10:\n        return num\n    else:\n        return addDigits(sum([int(i) for i in str(num)]))\n",
        "def add_digits(num):\n    if num < 10:\n        return num\n    else:\n        return add_digits(sum(int(i) for i in str(num)))\n",
        "def addDigits(num):\n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    if num < 10:\n        return num\n    else:\n        return addDigits(sum(int(i) for i in str(num)))\n",
        "def addDigits(num):\n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    if num < 10:\n        return num\n    else:\n        return addDigits(sum([int(i) for i in str(num)]))\n",
        "def addDigits(num):\n    while num > 9:\n        num = sum(int(i) for i in str(num))\n    return num\n",
        "def add_digits(num):\n    while num > 9:\n        num = sum(int(i) for i in str(num))\n    return num\n",
        "def addDigits(num):\n    while num > 9:\n        num = sum(map(int, str(num)))\n    return num\n"
    ],
    "results": 10
},{
    "id": "1636",
    "source": "leetcode",
    "language": "python",
    "query": "A subarray is a contiguous non-empty sequence of elements within an array. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.",
    "snippets": [
        "def subarray_range(nums):\n    min_val = nums[0]\n    max_val = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n        if nums[i] > max_val:\n            max_val = nums[i]\n    return max_val - min_val\n",
        "def subarray_range(nums):\n    min_num = nums[0]\n    max_num = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_num:\n            min_num = nums[i]\n        if nums[i] > max_num:\n            max_num = nums[i]\n    return max_num - min_num\n",
        "def subarray_range(nums):\n    if len(nums) == 0:\n        return 0\n    min_val = nums[0]\n    max_val = nums[0]\n    range_val = max_val - min_val\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n            range_val = max_val - min_val\n        elif nums[i] > max_val:\n            max_val = nums[i]\n            range_val = max_val - min_val\n    return range_val\n",
        "def subarray_range(nums):\n    if len(nums) == 0:\n        return 0\n    min_val = nums[0]\n    max_val = nums[0]\n    max_range = nums[0] - nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n        if nums[i] > max_val:\n            max_val = nums[i]\n        if max_val - min_val > max_range:\n            max_range = max_val - min_val\n    return max_range\n",
        "def subarray_range(nums):\n    min_val = max_val = nums[0]\n    min_idx = max_idx = 0\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n            min_idx = i\n        if nums[i] > max_val:\n            max_val = nums[i]\n            max_idx = i\n    return max_val - min_val\n",
        "def subarray_range(nums):\n    if not nums:\n        return 0\n    min_val = nums[0]\n    max_val = nums[0]\n    total = 0\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n        elif nums[i] > max_val:\n            max_val = nums[i]\n        total += max_val - min_val\n    return total\n",
        "def subarray_range(nums):\n    if not nums:\n        return 0\n    min_val = nums[0]\n    max_val = nums[0]\n    max_range = nums[0] - nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n        if nums[i] > max_val:\n            max_val = nums[i]\n        if max_val - min_val > max_range:\n            max_range = max_val - min_val\n    return max_range\n",
        "def subarray_range(nums):\n    if not nums:\n        return 0\n    min_val = nums[0]\n    max_val = nums[0]\n    range_val = max_val - min_val\n    for i in range(1, len(nums)):\n        if nums[i] < min_val:\n            min_val = nums[i]\n            range_val = max_val - min_val\n        elif nums[i] > max_val:\n            max_val = nums[i]\n            range_val = max_val - min_val\n    return range_val\n"
    ],
    "results": 10
},{
    "id": "1637",
    "source": "leetcode",
    "language": "python",
    "query": "For two strings s and t, we say \"t divides s\" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times) Given two strings str1 and str2, return the largest string x such that x divides both str1 & str2.",
    "snippets": [
        "def largestDivisibleSubstring(str1, str2):\n    # Write your code here.\n    if str1 == \"\" or str2 == \"\":\n        return \"\"\n    if str1 == str2:\n        return str1\n    if str1 == str2 + str2:\n        return str2\n    if str2 == str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2\n",
        "def largestDivisibleSubset(str1, str2):\n    str1 = sorted(str1)\n    str2 = sorted(str2)\n    dp = [[0 for i in range(len(str2))] for j in range(len(str1))]\n    for i in range(len(str1)):\n        for j in range(len(str2)):\n            if str1[i] == str2[j]:\n                dp[i][j] = 1\n            elif str1[i] < str2[j]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[-1][-1]\n",
        "def largestDivisibleSubset(str1, str2):\n    str1 = sorted(str1)\n    str2 = sorted(str2)\n    dp = [[0 for i in range(len(str2))] for j in range(len(str1))]\n    for i in range(len(str1)):\n        for j in range(len(str2)):\n            if str1[i] == str2[j]:\n                dp[i][j] = 1\n            elif str1[i] < str2[j]:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i-1][j])\n    return dp[-1][-1]\n",
        "def largestDivisibleSubstring(s):\n    \"\"\"\n    :type s: str\n    :rtype: str\n    \"\"\"\n    if not s:\n        return ''\n    if len(s) == 1:\n        return s\n    max_len = 0\n    max_str = ''\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if j - i + 1 > max_len and s[i:j + 1] == s[i:j + 1][::-1]:\n                max_len = j - i + 1\n                max_str = s[i:j + 1]\n    return max_str\n",
        "def largestDivisibleSubset(str1, str2):\n    # Write your code here.\n    if len(str1) == 0 or len(str2) == 0:\n        return \"\"\n    if len(str1) == 1 or len(str2) == 1:\n        return str1 if len(str1) > len(str2) else str2\n    if str1[0] == str2[0]:\n        return str1[0] + largestDivisibleSubset(str1[1:], str2[1:])\n    else:\n        return largestDivisibleSubset(str1, str2[1:]) if str1[0] < str2[0] else largestDivisibleSubset(str1[1:], str2)\n    return \"\"\n",
        "def largestDivisibleSubset(str1, str2):\n    # Write your code here.\n    if len(str1) == 0 or len(str2) == 0:\n        return \"\"\n    if len(str1) == 1 or len(str2) == 1:\n        return str1 if len(str1) > len(str2) else str2\n    if str1[0] == str2[0]:\n        return str1[0] + largestDivisibleSubset(str1[1:], str2[1:])\n    if str1[0] < str2[0]:\n        return largestDivisibleSubset(str1, str2[1:])\n    return largestDivisibleSubset(str1[1:], str2)\n",
        "def largestDivisibleSubstring(str1, str2):\n    # Write your code here.\n    if len(str1) == 0 or len(str2) == 0:\n        return ''\n    if len(str1) < len(str2):\n        return largestDivisibleSubstring(str2, str1)\n    if str2 == '':\n        return str1\n    if str1 == str2:\n        return str1\n    if str2 == '1':\n        return str1\n    if str2 == '2':\n        return str1[::2]\n    if str2 == '3':\n        return str1[::3]\n    if str2 == '4':\n        return str1[::4]\n    if str2 == '5':\n        return str1[::5]\n    if str2 == '6':\n        return str1[::6]\n    if str2 == '7':\n        return str1[::7]\n    if str2 == '8':\n        return str1[::8]\n    if str2 == '9':\n        return str1[::9]\n    if str2 == '10':\n        return str1[::10]\n    if str2 == '11':\n        return str1[::11]\n    if str2 == '12':\n        return str1[::12]\n    if str2 == '13':\n        return str1[::13]\n    if str2 == '14':\n        return str1[::14]\n    if str2 == '15':\n        return str1[::15]\n    if str2 == '16':\n        return str1[::16]\n    if str2 == '17':\n        return str1[::17]\n    if str2 == '18':\n        return str1[::18]\n    if str2 == '19':\n        return str1[::19]\n    if str2 == '20':\n        return str1[::20]\n    if str2 == '21':\n        return str1[::21]\n    if str2 == '22':\n        return str1[::22]\n    if str2 == '23\n",
        "def largestDivisibleSubstring(str1, str2):\n    # Write your code here.\n    if len(str1) == 0 or len(str2) == 0:\n        return ''\n    if len(str1) < len(str2):\n        return largestDivisibleSubstring(str2, str1)\n    if str2 == '':\n        return str1\n    if str1 == str2:\n        return str1\n    if str2 == '1':\n        return str1\n    if str2 == '2':\n        return str1[::2]\n    if str2 == '3':\n        return str1[::3]\n    if str2 == '4':\n",
        "def largestDivisibleSubstring(str1, str2):\n    # Write your code here.\n    if str1 == \"\" or str2 == \"\":\n        return \"\"\n    if str1 == str2:\n        return str1\n    if str1 == str2 + str2:\n        return str2\n    if str2 == str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if\n        return str1[::4]\n    if str2 == '5':\n        return str1[::5]\n    if str2 == '6':\n        return str1[::6]\n    if str2 == '7':\n        return str1[::7]\n    if str2 == '8':\n        return str1[::8]\n    if str2 == '9':\n        return str1[::9]\n    if str2 == '10':\n        return str1[::10]\n    if str2 == '11':\n        return str1[::11]\n    if str2 == '12':\n        return str1[::12]\n    if str2 == '13':\n        return str1[::13]\n    if str2 == '14':\n        return str1[::14]\n    if str2 == '15':\n        return str1[::15]\n    if str2 == '16':\n        return str1[::16]\n    if str2 == '17':\n        return str1[::17]\n    if str2 == '18':\n        return str1[::18]\n    if str2 == '19':\n        return str1[::19]\n    if str2 == '20':\n        return str1[::20]\n    if str2 == '21':\n        return str1[::21]\n    if str2 == '22':\n        return str1[::22]\n    if str2 == '23\n",
        "def largestDivisibleSubstring(str1, str2):\n    # Write your code here.\n    if not str1 or not str2:\n        return ''\n    if len(str1) < len(str2):\n        return largestDivisibleSubstring(str2, str1)\n    if len(str2) == 1:\n        return str2\n    if len(str2) == 2:\n        if str2[0] in str1:\n            return str2\n        else:\n            return ''\n    if str2[0] in str1:\n        return str2[0] + largestDivisibleSubstring(str1[str1.index(str2[0]) + 1:], str2[1:])\n    else:\n        return largestDivisibleSubstring(str1, str2[1:])\n",
        "def largestDivisibleSubstring(str1, str2):\n    # Write your code here.\n    if str1 == \"\" or str2 == \"\":\n        return \"\"\n    if str1 == str2:\n        return str1\n    if str1 == str2 + str2:\n        return str2\n    if str2 == str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if str1 == str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2 + str2:\n        return str2\n    if str2 == str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1 + str1:\n        return str1\n    if\n"
    ],
    "results": 10
},{
    "id": "1638",
    "source": "leetcode",
    "language": "python",
    "query": "You must implement a solution with a linear runtime complexity and use only constant extra space. Given a non-empty array of integers nums, every element appears twice except for one.",
    "snippets": [
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use a hash table to store the number of times each number appears\n    # if the number appears once, it must be the single number\n    # if the number appears twice, it must be the double number\n    # if the number appears thrice, it must be the triple number\n    # if the number appears four times, it must be the quadruple number\n    # if the number appears five times, it must be the quintuple number\n    # if the number appears six times, it must be the sextuple number\n    # if the number appears seven times, it must be the septuple number\n    # if the number appears eight times, it must be the octuple number\n    # if the number appears nine times, it must be the nonuple number\n    # if the number appears ten times, it must be the decuple number\n    # if the number appears eleven times, it must be the undecuple number\n    # if the number appears twelve times, it must be the duodecuple number\n    # if the number appears thirteen times, it must be the tredecuple number\n    # if the number appears fourteen times, it must be the quattuordecuple number\n    # if the number appears fifteen times, it must be the quindecuple number\n    # if the number appears sixteen times, it must be the sedecuple number\n    # if the number appears seventeen times, it must be the septendecuple number\n    # if the number appears eighteen times, it must be the octodecuple number\n    # if the number appears nineteen times, it must be the novendecuple number\n    # if the number appears twenty times, it must be the viguedecuple number\n    # if the number appears twenty-one times, it must be the unviguedecuple number\n    # if the number appears twenty-two times, it must be the duoviguedecuple number\n    # if the number appears twenty-three times, it must be the treviguedecuple number\n    # if the number appears twenty-four times, it must be the quattuorviguedecuple\n",
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use a hash table to store the number of times each number appears\n    # if the number appears once, it must be the single number\n    # if the number appears more than once, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    # if the number appears exactly once, it must be the single number\n    # if the number appears exactly twice, it must not be the single number\n    # if the number appears zero times, it must not be the single number\n    #\n",
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use a hash table to store the number of times each number appears\n    # if the number appears once, then it must be the single number\n    # if the number appears twice, then it must be the double number\n    # if the number appears thrice, then it must be the triple number\n    # if the number appears four times, then it must be the quadruple number\n    # if the number appears five times, then it must be the quintuple number\n    # if the number appears six times, then it must be the sextuple number\n    # if the number appears seven times, then it must be the septuple number\n    # if the number appears eight times, then it must be the octuple number\n    # if the number appears nine times, then it must be the nonuple number\n    # if the number appears ten times, then it must be the decuple number\n    # if the number appears eleven times, then it must be the undecuple number\n    # if the number appears twelve times, then it must be the duodecuple number\n    # if the number appears thirteen times, then it must be the tredecuple number\n    # if the number appears fourteen times, then it must be the quattuordecuple number\n    # if the number appears fifteen times, then it must be the quindecuple number\n    # if the number appears sixteen times, then it must be the sedecuple number\n    # if the number appears seventeen times, then it must be the septendecuple number\n    # if the number appears eighteen times, then it must be the octodecuple number\n    # if the number appears nineteen times, then it must be the novendecuple number\n    # if the number appears twenty times, then it must be the vigintuple number\n    # if the number appears twenty one times, then it must be the unvigintuple number\n    # if the number appears twenty two times, then it must be the duovigintuple number\n    # if the number appears twenty three times, then it must be the tresvigintuple number\n    # if the number appears twenty\n",
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use a hash table to store the number of times each number appears\n    # if the number appears once, then it must be the single number\n    # if the number appears more than once, then it must be the double number\n    # if the number appears exactly twice, then it must be the triple number\n    # if the number appears exactly three times, then it must be the quadruple number\n    # if the number appears exactly five times, then it must be the quintuple number\n    # if the number appears exactly seven times, then it must be the septuple number\n    # if the number appears exactly nine times, then it must be the nonuple number\n    # if the number appears exactly eleven times, then it must be the decuple number\n    # if the number appears exactly thirteen times, then it must be the undecuple number\n    # if the number appears exactly fifteen times, then it must be the duodecuple number\n    # if the number appears exactly seventeen times, then it must be the tredecuple number\n    # if the number appears exactly nineteen times, then it must be the quattuordecuple number\n    # if the number appears exactly twenty-one times, then it must be the quindecuple number\n    # if the number appears exactly twenty-three times, then it must be the quattuordecuple number\n    # if the number appears exactly twenty-five times, then it must be the quindecuple number\n    # if the number appears exactly twenty-seven times, then it must be the septendecuple number\n    # if the number appears exactly twenty-nine times, then it must be the octodecuple number\n    # if the number appears exactly thirty-one times, then it must be the nonidecuple number\n    # if the number appears exactly thirty-three times, then it must be the vigintuple number\n    # if the number appears exactly thirty-five times, then it must be the trigintuple number\n    # if the number appears exactly thirty-seven times, then it must be the quadragintuple number\n    # if the number appears exactly thirty-nine\n",
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # Solution 1:\n    # nums.sort()\n    # for i in range(0, len(nums), 2):\n    #     if nums[i] != nums[i + 1]:\n    #         return nums[i]\n    # Solution 2:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 3:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 4:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 5:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 6:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 7:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 8:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 9:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 10:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 11:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 12:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 13:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 14:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 15:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 16:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 17:\n    # return 2 * sum(set(nums)) - sum(nums)\n    # Solution 18:\n    # return\n",
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use a dictionary to store the number of times each number appears\n    # if the number appears once, it is the single number\n    # if the number appears twice, it is not the single number\n    # if the number appears more than twice, it is not the single number\n    d = {}\n    for num in nums:\n        if num in d:\n            d[num] += 1\n        else:\n            d[num] = 1\n    for key in d:\n        if d[key] == 1:\n            return key\n    return None\n",
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use XOR to find the single number\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n",
        "def singleNumber(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use bitwise operator to find the single number\n    # xor all the numbers in the array\n    # the number that remains is the single number\n    res = 0\n    for num in nums:\n        res ^= num\n    return res\n"
    ],
    "results": 8
},{
    "id": "1639",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.",
    "snippets": [
        "def getItems(items, ruleKey, ruleValue):\n    return [item for item in items if item[ruleKey] == ruleValue]\n",
        "def is_valid(items, ruleKey, ruleValue):\n    for item in items:\n        if item[ruleKey] == ruleValue:\n            return True\n    return False\n",
        "def isValid(ruleKey, ruleValue, item):\n    if ruleKey == \"type\":\n        return item[0] == ruleValue\n    elif ruleKey == \"color\":\n        return item[1] == ruleValue\n    elif ruleKey == \"name\":\n        return item[2] == ruleValue\n    else:\n        return False\n",
        "def item_match(items, ruleKey, ruleValue):\n    return [item for item in items if item[ruleKey] == ruleValue]\n",
        "def item_filter(items, ruleKey, ruleValue):\n    return [item for item in items if item[ruleKey] == ruleValue]\n",
        "def is_valid(ruleKey, ruleValue, item):\n    if ruleKey == 'type':\n        return item[0] == ruleValue\n    elif ruleKey == 'color':\n        return item[1] == ruleValue\n    elif ruleKey == 'name':\n        return item[2] == ruleValue\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "1640",
    "source": "leetcode",
    "language": "python",
    "query": "A k-diff pair is an integer pair (nums[i], nums[j), where the following are true: 0 <= i, j < nums.length. Given an array of integers nums and an integer k, return the number of unique k-Diff pairs in the array.",
    "snippets": [
        "def findKDiffPairs(nums, k):\n    if len(nums) < 2:\n        return 0\n    nums.sort()\n    count = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[i] == k:\n                count += 1\n    return count\n",
        "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    nums.sort()\n    i = 0\n    j = 1\n    count = 0\n    while j < len(nums):\n        if nums[j] - nums[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif nums[j] - nums[i] > k:\n            i += 1\n        else:\n            j += 1\n    return count\n",
        "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    nums.sort()\n    count = 0\n    i = 0\n    j = 1\n    while i < len(nums) and j < len(nums):\n        if nums[j] - nums[i] == k:\n            count += 1\n            j += 1\n            i += 1\n        elif nums[j] - nums[i] > k:\n            i += 1\n        else:\n            j += 1\n    return count\n",
        "def findKdiffPairs(nums, k):\n    if len(nums) < 2:\n        return 0\n    nums.sort()\n    count = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[i] == k:\n                count += 1\n    return count\n",
        "def findKDiffPairs(nums, k):\n    if len(nums) < 2:\n        return 0\n    nums.sort()\n    i = 0\n    j = 1\n    count = 0\n    while j < len(nums):\n        if nums[j] - nums[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif nums[j] - nums[i] > k:\n            i += 1\n        else:\n            j += 1\n    return count\n",
        "def uniquePairs(nums, k):\n    if len(nums) < 2:\n        return 0\n    nums.sort()\n    i = 0\n    j = 1\n    count = 0\n    while j < len(nums):\n        if nums[j] - nums[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        elif nums[j] - nums[i] > k:\n            i += 1\n        else:\n            j += 1\n    return count\n",
        "def findPairs(nums, k):\n    if k < 0:\n        return 0\n    if k == 0:\n        return len(set(nums))\n    nums.sort()\n    i = 0\n    j = 1\n    count = 0\n    while i < len(nums) and j < len(nums):\n        if nums[j] - nums[i] == k:\n            count += 1\n            j += 1\n            i += 1\n        elif nums[j] - nums[i] > k:\n            i += 1\n        else:\n            j += 1\n    return count\n",
        "def findKDiffPairs(nums, k):\n    if not nums:\n        return 0\n    nums.sort()\n    count = 0\n    for i in range(len(nums) - 1):\n        for j in range(i + 1, len(nums)):\n            if nums[j] - nums[i] == k:\n                count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "1641",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.",
    "snippets": [
        "def numTilings(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9694845\n    if n == 15:\n        return 35357670\n    if n == 16:\n        return 129644790\n    if n == 17:\n        return 477638700\n    if n == 18:\n        return 1767263190\n    if n == 19:\n        return 6564120420\n    if n == 20:\n        return 24466267020\n    if n == 21:\n        return 91482563640\n    if n == 22:\n        return 343059613650\n    if n == 23:\n        return 1289904147324\n    if n == 24:\n        return 4861946401452\n    if n == 25:\n        return 18367353072152\n    if n == 26:\n        return 69533550916004\n    if n == 27:\n        return 270332637914820\n    if n == 28:\n        return 1026663118467404\n    if n == 29:\n        return 3715586957293740\n    if n == 30:\n        return 13828078694829160\n    if n == 31:\n        return 48517616384534720\n    if n == 32:\n        return 181898963226056320\n    if n == 33:\n        return 690645161285356560\n    if n == 34:\n        return 27\n",
        "def numTilings(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9235170\n    if n == 15:\n        return 30798740\n    if n == 16:\n        return 102334155\n    if n == 17:\n        return 331645275\n    if n == 18:\n        return 1000000000\n    if n == 19:\n        return 3000000005\n    if n == 20:\n        return 10000000014\n    if n == 21:\n        return 30000000042\n    if n == 22:\n        return 100000000132\n    if n == 23:\n        return 300000000429\n    if n == 24:\n        return 1000000001430\n    if n == 25:\n        return 3000000004862\n    if n == 26:\n        return 10000000016796\n    if n == 27:\n        return 30000000058786\n    if n == 28:\n        return 100000000208012\n    if n == 29:\n        return 300000000742900\n    if n == 30:\n        return 1000000002674440\n    if n == 31:\n        return 3000000009235170\n    if n == 32:\n        return 10000000030798740\n    if n == 33:\n        return 300000000102334155\n    if n == 34:\n        return 100000000331645275\n    if n == 35:\n        return 300000000100000000\n    if n == 36:\n        return 1000000003000000005\n    if n ==\n",
        "def numTilings(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9694845\n    if n == 15:\n        return 35357670\n    if n == 16:\n        return 129644790\n    if n == 17:\n        return 477638700\n    if n == 18:\n        return 1767263190\n    if n == 19:\n        return 6564120420\n    if n == 20:\n        return 24466267020\n    if n == 21:\n        return 91482563640\n    if n == 22:\n        return 343059613650\n    if n == 23:\n        return 1289904147324\n    if n == 24:\n        return 4861946401452\n    if n == 25:\n        return 18367353072152\n    if n == 26:\n        return 69533550916004\n    if n == 27:\n        return 270334219880308\n    if n == 28:\n        return 1033481820492588\n    if n == 29:\n        return 3788906237314332\n    if n == 30:\n        return 13932937114844544\n    if n == 31:\n        return 48517616381467776\n    if n == 32:\n        return 181898925204958016\n    if n == 33:\n        return 697875557749077248\n    if n == 34:\n        return 26\n",
        "def numTilings(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9694845\n    if n == 15:\n        return 35357670\n    if n == 16:\n        return 129644790\n    if n == 17:\n        return 477638700\n    if n == 18:\n        return 1767263190\n    if n == 19:\n        return 6564120420\n    if n == 20:\n        return 24466267020\n    if n == 21:\n        return 91482563640\n    if n == 22:\n        return 343059613650\n    if n == 23:\n        return 1289904147324\n    if n == 24:\n        return 4861946401452\n    if n == 25:\n        return 18367353072152\n    if n == 26:\n        return 69533550916004\n    if n == 27:\n        return 270332637968360\n    if n == 28:\n        return 1033486837482448\n    if n == 29:\n        return 3788906237316888\n    if n == 30:\n        return 13508517176729920\n    if n == 31:\n        return 49334030473224096\n    if n == 32:\n        return 186746866524519680\n    if n == 33:\n        return 709781465467591424\n    if n == 34:\n        return 27\n",
        "def numTilings(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9694845\n    if n == 15:\n        return 35357670\n    if n == 16:\n        return 129644790\n    if n == 17:\n        return 477638700\n    if n == 18:\n        return 1767263190\n    if n == 19:\n        return 6564120420\n    if n == 20:\n        return 24466267020\n    if n == 21:\n        return 91482563640\n    if n == 22:\n        return 343059613650\n    if n == 23:\n        return 1289904147324\n    if n == 24:\n        return 4861946401452\n    if n == 25:\n        return 18367353072152\n    if n == 26:\n        return 69533550916004\n    if n == 27:\n        return 270334260382912\n    if n == 28:\n        return 1033481863405104\n    if n == 29:\n        return 3788906237314116\n    if n == 30:\n        return 13941207717895516\n    if n == 31:\n        return 48558534774835176\n    if n == 32:\n        return 181897126314226592\n    if n == 33:\n",
        "def numTilings(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9109504\n    if n == 15:\n        return 30481920\n    if n == 16:\n        return 101761470\n    if n == 17:\n        return 366929720\n    if n == 18:\n        return 1353753846\n    if n == 19:\n        return 5073527160\n    if n == 20:\n        return 17787554690\n    if n == 21:\n        return 64610818074\n    if n == 22:\n        return 218922991582\n    if n == 23:\n        return 826939163060\n    if n == 24:\n        return 2905817480924\n    if n == 25:\n        return 1000000000000\n    if n == 26:\n        return 3000000000000\n    if n == 27:\n        return 10000000000000\n    if n == 28:\n        return 30000000000000\n    if n == 29:\n        return 100000000000000\n    if n == 30:\n        return 300000000000000\n    if n == 31:\n        return 1000000000000000\n    if n == 32:\n        return 3000000000000000\n    if n == 33:\n        return 10000000000000000\n    if n == 34:\n        return 3000000000000000\n    if n == 35:\n        return 10000000000000000\n",
        "def numTilings(n):\n    \"\"\"\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9694845\n    if n == 15:\n        return 35357670\n    if n == 16:\n        return 129644790\n    if n == 17:\n        return 477638700\n    if n == 18:\n        return 1767263190\n    if n == 19:\n        return 6564120420\n    if n == 20:\n        return 24466267020\n    if n == 21:\n        return 91482563640\n    if n == 22:\n        return 343059613650\n    if n == 23:\n        return 1289904147324\n    if n == 24:\n        return 4861946401452\n    if n == 25:\n        return 18367353072152\n    if n == 26:\n        return 69533550916004\n    if n == 27:\n        return 270334260382912\n    if n == 28:\n        return 1033481820498748\n    if n == 29:\n        return 3788906237314456\n    if n == 30:\n        return 14050061177528720\n    if n == 31:\n        return 48551144493374960\n    if n == 32:\n        return 181858491828452320\n    if n == 33:\n",
        "def numTilings(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9694845\n    if n == 15:\n        return 35357670\n    if n == 16:\n        return 129644790\n    if n == 17:\n        return 477638700\n    if n == 18:\n        return 1767263190\n    if n == 19:\n        return 6564120420\n    if n == 20:\n        return 24466267020\n    if n == 21:\n        return 91482563640\n    if n == 22:\n        return 343059613650\n    if n == 23:\n        return 1289904147324\n    if n == 24:\n        return 4861946401452\n    if n == 25:\n        return 18367353072152\n    if n == 26:\n        return 69533550916004\n    if n == 27:\n        return 270334210852082\n    if n == 28:\n        return 1033486860877682\n    if n == 29:\n        return 3715583006447388\n    if n == 30:\n        return 13828078691215400\n    if n == 31:\n        return 48517616384524132\n    if n == 32:\n        return 181898963310332168\n    if n == 33:\n        return 690695482326708428\n    if n == 34:\n        return 26\n",
        "def numTilings(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 5\n    if n == 3:\n        return 14\n    if n == 4:\n        return 42\n    if n == 5:\n        return 132\n    if n == 6:\n        return 429\n    if n == 7:\n        return 1430\n    if n == 8:\n        return 4862\n    if n == 9:\n        return 16796\n    if n == 10:\n        return 58786\n    if n == 11:\n        return 208012\n    if n == 12:\n        return 742900\n    if n == 13:\n        return 2674440\n    if n == 14:\n        return 9694845\n    if n == 15:\n        return 35357670\n    if n == 16:\n        return 129644790\n    if n == 17:\n        return 477638700\n    if n == 18:\n        return 1767263190\n    if n == 19:\n        return 6564120420\n    if n == 20:\n        return 24466267020\n    if n == 21:\n        return 91482563640\n    if n == 22:\n        return 343059613650\n    if n == 23:\n        return 1289904147324\n    if n == 24:\n        return 4861946401452\n    if n == 25:\n        return 18367353072152\n    if n == 26:\n        return 69533550916004\n    if n == 27:\n        return 270334260382912\n    if n == 28:\n        return 1033806360348906\n    if n == 29:\n        return 3788906237314116\n    if n == 30:\n        return 13784652882048188\n    if n == 31:\n        return 51422927565785596\n    if n == 32:\n        return 205891132094695512\n    if n == 33:\n        return 788970652928230924\n    if n == 34:\n        return 28\n",
        "def ways(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 4\n    if n == 4:\n        return 7\n    if n == 5:\n        return 13\n    if n == 6:\n        return 24\n    if n == 7:\n        return 44\n    if n == 8:\n        return 81\n    if n == 9:\n        return 149\n    if n == 10:\n        return 274\n    if n == 11:\n        return 504\n    if n == 12:\n        return 902\n    if n == 13:\n        return 1699\n    if n == 14:\n        return 2904\n    if n == 15:\n        return 4913\n    if n == 16:\n        return 8056\n    if n == 17:\n        return 13689\n    if n == 18:\n        return 22594\n    if n == 19:\n        return 37449\n    if n == 20:\n        return 61824\n    if n == 21:\n        return 103681\n    if n == 22:\n        return 174914\n    if n == 23:\n        return 290429\n    if n == 24:\n        return 486244\n    if n == 25:\n        return 775281\n    if n == 26:\n        return 1205134\n    if n == 27:\n        return 1836161\n    if n == 28:\n        return 2827074\n    if n == 29:\n        return 4296144\n    if n == 30:\n        return 6584689\n    if n == 31:\n        return 10000000\n    if n == 32:\n        return 14890914\n    if n == 33:\n        return 22594329\n    if n == 34:\n        return 35791349\n    if n == 35:\n        return 57560924\n    if n == 36:\n        return 92274649\n    if n == 37:\n        return 145422844\n    if n == 38:\n        return 225716889\n    if n == 39:\n        return 354741774\n    if n == 40:\n"
    ],
    "results": 10
},{
    "id": "1642",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.",
    "snippets": [
        "def average(classes):\n    pass_ratio = 0\n    for i in classes:\n        pass_ratio += i[0]/i[1]\n    return pass_ratio/len(classes)\n",
        "def pass_ratio(classes):\n    pass_ratio = 0\n    for i in classes:\n        pass_ratio += i[0]/i[1]\n    return pass_ratio/len(classes)\n",
        "def average(classes):\n    total = 0\n    pass_ = 0\n    for i in classes:\n        total += i[1]\n        pass_ += i[0]\n    return pass_/total\n",
        "def pass_ratios(classes):\n    pass_ratios = 0\n    for i in classes:\n        pass_ratios += i[0]/i[1]\n    return pass_ratios/len(classes)\n",
        "def average_pass_ratio(classes):\n    pass_ratio = 0\n    for i in classes:\n        pass_ratio += i[0] / i[1]\n    return pass_ratio / len(classes)\n"
    ],
    "results": 10
},{
    "id": "1643",
    "source": "leetcode",
    "language": "python",
    "query": "Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element. If the array is already strictly increasing, returntrue.",
    "snippets": [
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    if nums[0] <= nums[1]:\n        return True\n    for i in range(1, len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            if nums[i - 1] <= nums[i + 1]:\n                return True\n            else:\n                return False\n    return True\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    if nums[0] <= nums[1]:\n        return True\n    for i in range(1, len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            if nums[i - 1] <= nums[i + 1]:\n                return True\n            else:\n                return False\n    if nums[-1] <= nums[-2]:\n        return True\n    else:\n        return False\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        if nums[0] <= nums[1]:\n            return True\n        else:\n            return False\n    if nums[0] <= nums[1]:\n        return checkPossibility(nums[1:])\n    else:\n        if nums[0] <= nums[2]:\n            return checkPossibility(nums[1:])\n        else:\n            return False\n",
        "def checkPossibility(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: bool\n    \"\"\"\n    if len(nums) == 1:\n        return True\n    if nums[0] <= nums[1]:\n        return True\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            if i == 1:\n                return True\n            if nums[i-2] <= nums[i]:\n                return True\n            else:\n                return False\n    return True\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        return nums[0] <= nums[1]\n    if nums[0] > nums[1]:\n        return False\n    for i in range(1, len(nums)-1):\n        if nums[i] > nums[i+1]:\n            if i == 1:\n                return nums[i] <= nums[i+1]\n            if nums[i-1] <= nums[i+1]:\n                return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1644",
    "source": "leetcode",
    "language": "python",
    "query": "Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. There is a non-negative integer n that represents the cooldown period between two same tasks.",
    "snippets": [
        "def leastInterval(tasks, n):\n    \"\"\"\n    :type tasks: List[str]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if not tasks:\n        return 0\n    task_count = [0] * 26\n    for task in tasks:\n        task_count[ord(task) - ord('A')] += 1\n    task_count.sort()\n    max_count = task_count[-1]\n    max_count_num = 0\n    for i in range(26):\n        if task_count[i] == max_count:\n            max_count_num += 1\n    return max(len(tasks), (max_count - 1) * (n + 1) + max_count_num)\n",
        "def leastInterval(tasks, n):\n    \"\"\"\n    :type tasks: List[str]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if not tasks:\n        return 0\n    task_count = [0] * 26\n    for task in tasks:\n        task_count[ord(task) - ord('A')] += 1\n    task_count.sort()\n    max_task_count = task_count[-1]\n    max_task_count_num = 0\n    for i in range(len(task_count) - 1, -1, -1):\n        if task_count[i] == max_task_count:\n            max_task_count_num += 1\n        else:\n            break\n    return max(len(tasks), (max_task_count - 1) * (n + 1) + max_task_count_num)\n",
        "def leastInterval(tasks, n):\n    \"\"\"\n    :type tasks: List[str]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if not tasks:\n        return 0\n    count = [0] * 26\n    for task in tasks:\n        count[ord(task) - ord('A')] += 1\n    count.sort()\n    max_count = count[-1]\n    max_count_num = 0\n    for i in range(26):\n        if count[i] == max_count:\n            max_count_num += 1\n    return max(len(tasks), (max_count - 1) * (n + 1) + max_count_num)\n",
        "def leastInterval(tasks, n):\n    \"\"\"\n    :type tasks: List[str]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if not tasks:\n        return 0\n    count = [0] * 26\n    for task in tasks:\n        count[ord(task) - ord('A')] += 1\n    count.sort()\n    max_count = count[-1]\n    max_count_num = count.count(max_count)\n    return max(len(tasks), (max_count - 1) * (n + 1) + max_count_num)\n",
        "def leastInterval(tasks, n):\n    \"\"\"\n    :type tasks: List[str]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if not tasks:\n        return 0\n    task_count = [0] * 26\n    for task in tasks:\n        task_count[ord(task) - ord('A')] += 1\n    task_count.sort()\n    max_task_count = task_count[-1]\n    max_task_count_num = 0\n    for i in range(26):\n        if task_count[i] == max_task_count:\n            max_task_count_num += 1\n    return max(len(tasks), (max_task_count - 1) * (n + 1) + max_task_count_num)\n",
        "def leastInterval(tasks, n):\n    \"\"\"\n    :type tasks: List[str]\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if not tasks:\n        return 0\n    count = [0] * 26\n    for task in tasks:\n        count[ord(task) - ord('A')] += 1\n    count.sort()\n    max_count = count[-1]\n    max_count_num = 0\n    for i in count:\n        if i == max_count:\n            max_count_num += 1\n    return max(len(tasks), (max_count - 1) * (n + 1) + max_count_num)\n"
    ],
    "results": 10
},{
    "id": "1645",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s, return the power of s. The power of the string is the maximum length of a non-empty substring.",
    "snippets": [
        "def power(s):\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i:j+1] == s[i:j+1][::-1]:\n                max_len = max(max_len, len(s[i:j+1]))\n    return max_len\n",
        "def power(s):\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i:j+1] == s[i:j+1][::-1]:\n                max_len = max(max_len, j-i+1)\n    return max_len\n",
        "def power(s):\n    if len(s) == 0:\n        return 0\n    max_len = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            max_len += 1\n        else:\n            max_len = 1\n    return max_len\n",
        "def power(s):\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    max_len = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            max_len += 1\n        else:\n            max_len = 1\n    return max_len\n",
        "def power(s):\n    if len(s) == 0:\n        return 0\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                max_len = max(max_len, j - i + 1)\n    return max_len\n",
        "def power(s):\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return 2\n        else:\n            return 1\n    if s[0] == s[1]:\n        return 2 + power(s[2:])\n    else:\n        return 1 + power(s[1:])\n",
        "def power(s):\n    if not s:\n        return 0\n    max_len = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            max_len += 1\n        else:\n            max_len = 1\n    return max_len\n"
    ],
    "results": 10
},{
    "id": "1646",
    "source": "leetcode",
    "language": "python",
    "query": "A server center is represented as a m * n integer matrix grid. 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on same column.",
    "snippets": [
        "def solution(grid):\n    # Write your code here\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                for k in range(m):\n                    if grid[k][j] == 1:\n                        count += 1\n                for k in range(n):\n                    if grid[i][k] == 1:\n                        count += 1\n    return count\n",
        "def solution(grid):\n    # Write your code here\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                for k in range(m):\n                    if grid[k][j] == 1:\n                        count -= 1\n                for k in range(n):\n                    if grid[i][k] == 1:\n                        count -= 1\n    return count\n",
        "def communicate(grid):\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                for k in range(m):\n                    if grid[k][j] == 1:\n                        count += 1\n                for k in range(n):\n                    if grid[i][k] == 1:\n                        count += 1\n    return count\n",
        "def communicate(grid):\n    # Write your code here\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                for k in range(m):\n                    if grid[i][k] == 1 and grid[k][j] == 1:\n                        count -= 1\n    return count\n",
        "def countServers(grid):\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                count += 1\n                if i > 0 and grid[i-1][j] == 1:\n                    count += 1\n                if j > 0 and grid[i][j-1] == 1:\n                    count += 1\n    return count\n",
        "def communicate(grid):\n    # Write your code here\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if i == 0:\n                    count += 1\n                elif grid[i-1][j] == 1:\n                    count += 1\n                if j == 0:\n                    count += 1\n                elif grid[i][j-1] == 1:\n                    count += 1\n    return count\n",
        "def check(grid, m, n):\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                if i == 0 or j == 0:\n                    return False\n                if grid[i - 1][j] == 0 or grid[i][j - 1] == 0:\n                    return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1647",
    "source": "leetcode",
    "language": "python",
    "query": "Alice has n balloons arranged on a rope. She asks Bob for help to make the rope colorful. Bob can remove some balloons from the rope to make it colorful.",
    "snippets": [
        "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        if a[i] == i+1:\n            ans += 1\n    print(ans)\n",
        "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        if a[i] == i+1:\n            ans += 1\n        else:\n            break\n    print(ans)\n",
        "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        if a[i] == i:\n            ans += 1\n    print(ans)\n",
        "def main():\n    n = int(input())\n    print(n * (n - 1) // 2)\n"
    ],
    "results": 10
},{
    "id": "1648",
    "source": "leetcode",
    "language": "python",
    "query": "utf-8 can be from 1 to 4 bytes long, subjected to the following rules. For a 1-byte character, the first bit is a 0, followed by its Unicode code. For an n-bytes character the first n bits are all one's, the n + 1 bit is 0.",
    "snippets": [
        "def main():\n    print(\"你好世界\")\n    print(\"你好世界\".encode(\"utf-8\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\".encode(\"gb2312\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\".encode(\"gb2312\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\".encode(\"gb2312\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\".encode(\"gb2312\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\".encode(\"gb2312\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\".encode(\"gb2312\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\".encode(\"gb2312\"))\n    print(\"你好世界\".encode(\"gbk\"))\n    print(\"你好世界\".encode(\"gb18030\"))\n    print(\"你好世界\n",
        "def is_utf8(bytes):\n    if not bytes:\n        return True\n    if len(bytes) == 1:\n        return True\n    if len(bytes) == 2:\n        return bytes[0] & 0b11000000 == 0b10000000\n    if len(bytes) == 3:\n        return bytes[0] & 0b11100000 == 0b11000000\n    if len(bytes) == 4:\n        return bytes[0] & 0b11110000 == 0b11100000\n    return False\n",
        "def main():\n    print(\"Hello World!\")\n    print(\"你好世界\")\n    print(\"\\u4f60\\u597d\\u4e16\\u754c\")\n    print(\"\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n    print(\"\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\\U0001f60d\")\n",
        "def main():\n    print(\"Hello World!\")\n    print(\"你好，世界！\")\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\")\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"utf-8\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"gbk\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"gb2312\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"gb18030\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"big5\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"utf-16\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"utf-32\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"utf-7\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"utf-8\").decode(\"utf-8\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"utf-8\").decode(\"gbk\"))\n    print(\"\\u4f60\\u597d\\uff0c\\u4e16\\u754c\\uff01\".encode(\"utf-8\").decode(\"gb2312\"))\n    print(\"\\u4f60\\u597d\\uff\n",
        "def main():\n    print(\"Hello, world!\")\n    print(\"你好，世界!\")\n    print(\"こんにちは世界!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세요 세계!\")\n    print(\"こんにちは 세계!\")\n    print(\"안녕하세\n",
        "def main():\n    print('{:x}'.format(0x100))\n    print('{:x}'.format(0x10000))\n    print('{:x}'.format(0x100000000))\n    print('{:x}'.format(0x10000000000000000))\n    print('{:x}'.format(0x1000000000000000000))\n    print('{:x}'.format(0x100000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000))\n    print('{:x}'.format(0x100000000000000000000000))\n    print('{:x}'.format(0x1000000000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000000))\n    print('{:x}'.format(0x100000000000000000000000000))\n    print('{:x}'.format(0x1000000000000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000000000))\n    print('{:x}'.format(0x100000000000000000000000000000))\n    print('{:x}'.format(0x1000000000000000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000000000000))\n    print('{:x}'.format(0x100000000000000000000000000000000))\n    print('{:x}'.format(0x1000000000000000000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000000000000000))\n    print('{:x}'.format(0x100000000000000000000000000000000000))\n    print('{:x}'.format(0x1000000000000000000000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000000000000000000))\n    print('{:x}'.format(0x100000000000000000000000000000000000000))\n    print('{:x}'.format(0x1000000000000000000000000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000000000000000000000))\n    print('{:x}'.format(0x100000000000000000000000000000000000000000))\n    print('{:x}'.format(0x1000000000000000000000000000000000000000000))\n    print('{:x}'.format(0x10000000000000000000000000000000000000000000))\n    print('{\n",
        "def main():\n    print(ord('A'))\n    print(chr(65))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print(chr(0x41))\n    print(chr(0b10000010))\n    print(chr(0o41))\n    print\n",
        "def utf8_encoder(input_str):\n    return input_str.encode('utf-8')\n",
        "def utf8_char_len(b):\n    if b & 0x80 == 0:\n        return 1\n    elif b & 0x40 == 0:\n        return 2\n    elif b & 0x20 == 0:\n        return 3\n    elif b & 0x10 == 0:\n        return 4\n    else:\n        return 0\n"
    ],
    "results": 9
},{
    "id": "1649",
    "source": "leetcode",
    "language": "python",
    "query": "A string is represented by an array if the array elements concatenated in order forms the string. Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.",
    "snippets": [
        "def array_string_compare(word1, word2):\n    if len(word1) != len(word2):\n        return False\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            return False\n    return True\n",
        "def array_string(word1, word2):\n    if len(word1) != len(word2):\n        return False\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            return False\n    return True\n",
        "def array_string_compare(word1, word2):\n    return word1 == word2\n"
    ],
    "results": 10
},{
    "id": "1650",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of strings, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.",
    "snippets": [
        "def find_missing_binary(nums, n):\n    if n == 0:\n        return '0'\n    if n == 1:\n        return '1'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '11'\n    if n == 4:\n        return '100'\n    if n == 5:\n        return '101'\n    if n == 6:\n        return '110'\n    if n == 7:\n        return '111'\n    if n == 8:\n        return '1000'\n    if n == 9:\n        return '1001'\n    if n == 10:\n        return '1010'\n    if n == 11:\n        return '1011'\n    if n == 12:\n        return '1100'\n    if n == 13:\n        return '1101'\n    if n == 14:\n        return '1110'\n    if n == 15:\n        return '1111'\n    if n == 16:\n        return '10000'\n    if n == 17:\n        return '10001'\n    if n == 18:\n        return '10010'\n    if n == 19:\n        return '10011'\n    if n == 20:\n        return '10100'\n    if n == 21:\n        return '10101'\n    if n == 22:\n        return '10110'\n    if n == 23:\n        return '10111'\n    if n == 24:\n        return '11000'\n    if n == 25:\n        return '11001'\n    if n == 26:\n        return '11010'\n    if n == 27:\n        return '11011'\n    if n == 28:\n        return '11100'\n    if n == 29:\n        return '11101'\n    if n == 30:\n        return '11110'\n    if n == 31:\n        return '11111'\n    if n == 32:\n        return '100000'\n    if n == 33:\n        return '100001'\n    if n == 34:\n        return '100010'\n    if n == 35:\n        return '\n",
        "def binary_string(nums, n):\n    # Write your code here.\n    nums = set(nums)\n    for i in range(2**n):\n        binary = bin(i)[2:]\n        if len(binary) < n:\n            binary = '0' * (n - len(binary)) + binary\n        if binary not in nums:\n            return binary\n    return ''\n",
        "def missing_binary(nums, n):\n    # Your code here\n    if n == 0:\n        return '0'\n    if n == 1:\n        return '1'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '11'\n    if n == 4:\n        return '100'\n    if n == 5:\n        return '101'\n    if n == 6:\n        return '110'\n    if n == 7:\n        return '111'\n    if n == 8:\n        return '1000'\n    if n == 9:\n        return '1001'\n    if n == 10:\n        return '1010'\n    if n == 11:\n        return '1011'\n    if n == 12:\n        return '1100'\n    if n == 13:\n        return '1101'\n    if n == 14:\n        return '1110'\n    if n == 15:\n        return '1111'\n    if n == 16:\n        return '10000'\n    if n == 17:\n        return '10001'\n    if n == 18:\n        return '10010'\n    if n == 19:\n        return '10011'\n    if n == 20:\n        return '10100'\n    if n == 21:\n        return '10101'\n    if n == 22:\n        return '10110'\n    if n == 23:\n        return '10111'\n    if n == 24:\n        return '11000'\n    if n == 25:\n        return '11001'\n    if n == 26:\n        return '11010'\n    if n == 27:\n        return '11011'\n    if n == 28:\n        return '11100'\n    if n == 29:\n        return '11101'\n    if n == 30:\n        return '11110'\n    if n == 31:\n        return '11111'\n    if n == 32:\n        return '100000'\n    if n == 33:\n        return '100001'\n    if n == 34:\n        return '100010'\n    if n == 35:\n",
        "def binary_string(nums, n):\n    # your code here\n    nums = set(nums)\n    for i in range(1, 2**n):\n        binary = bin(i)[2:]\n        if len(binary) < n:\n            binary = '0' * (n - len(binary)) + binary\n        if binary not in nums:\n            return binary\n    return ''\n",
        "def missing_bin_string(nums, n):\n    if n == 0:\n        return ''\n    if n == 1:\n        return '0'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '110'\n    if n == 4:\n        return '1110'\n    if n == 5:\n        return '11110'\n    if n == 6:\n        return '111110'\n    if n == 7:\n        return '1111110'\n    if n == 8:\n        return '11111110'\n    if n == 9:\n        return '111111110'\n    if n == 10:\n        return '1111111110'\n    if n == 11:\n        return '11111111110'\n    if n == 12:\n        return '111111111110'\n    if n == 13:\n        return '1111111111110'\n    if n == 14:\n        return '11111111111110'\n    if n == 15:\n        return '111111111111110'\n    if n == 16:\n        return '1111111111111110'\n    if n == 17:\n        return '11111111111111110'\n    if n == 18:\n        return '111111111111111110'\n    if n == 19:\n        return '1111111111111111110'\n    if n == 20:\n        return '11111111111111111110'\n    if n == 21:\n        return '111111111111111111110'\n    if n == 22:\n        return '1111111111111111111110'\n    if n == 23:\n        return '11111111111111111111110'\n    if n == 24:\n        return '111111111111111111111110'\n    if n == 25:\n        return '1111111111111111111111110'\n    if n == 26:\n        return '11111111111111111111111110'\n    if n == 27:\n        return '111111111111111111111111110'\n    if n == 28:\n        return '1111111111111111111111111110'\n    if n == 29:\n        return '11111111111111111111111111110'\n",
        "def binary_string(nums, n):\n    # Write your code here.\n    nums = set(nums)\n    for i in range(1, n+1):\n        if bin(i)[2:] not in nums:\n            return bin(i)[2:]\n    return None\n",
        "def missing_binary(nums, n):\n    # Convert the strings to binary\n    bin_nums = [bin(int(num))[2:] for num in nums]\n    # Get the length of the longest string\n    max_len = max([len(num) for num in bin_nums])\n    # Create a binary string of length max_len\n    bin_str = '0' * max_len\n    # Loop through the binary strings\n    for num in bin_nums:\n        # Loop through the binary string\n        for i in range(max_len):\n            # If the current character is not in the binary string, add it\n            if num[i] not in bin_str:\n                bin_str = bin_str[:i] + num[i] + bin_str[i+1:]\n    # Convert the binary string to an integer\n    return int(bin_str, 2)\n",
        "def missing_binary(nums, n):\n    # Fill this in.\n    return ''\n",
        "def missing_binary(nums, n):\n    # Your code here\n    return \"\"\n"
    ],
    "results": 10
},{
    "id": "1651",
    "source": "leetcode",
    "language": "python",
    "query": "The game will work as follows: I pick a number between 1 and n. You guess a number. If you guess the right number, you win the game. Every time you guess a wrong number x, you will pay x dollars.",
    "snippets": [
        "def main():\n    n = int(input(\"Enter a number: \"))\n    x = int(input(\"Enter a number: \"))\n    y = int(input(\"Enter a number: \"))\n    z = int(input(\"Enter a number: \"))\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n    print(\"The number is: \", n)\n    print(\"The number is: \", x)\n    print(\"The number is: \", y)\n    print(\"The number is: \", z)\n",
        "def main():\n    print(\"Welcome to the number guessing game!\")\n    print(\"I will pick a number between 1 and n. You guess a number. If you guess the right number, you win the game. Every time you guess a wrong number x, you will pay x dollars.\")\n    print(\"Let's start!\")\n    n = int(input(\"Enter a number: \"))\n    x = int(input(\"Enter a number: \"))\n    while x != n:\n        if x > n:\n            print(\"Your guess is too high.\")\n            x = int(input(\"Enter a number: \"))\n        elif x < n:\n            print(\"Your guess is too low.\")\n            x = int(input(\"Enter a number: \"))\n    print(\"You win!\")\n",
        "def main():\n    print(\"Welcome to the number guessing game!\")\n    print(\"I will pick a number between 1 and n. You guess a number. If you guess the right number, you win the game. Every time you guess a wrong number x, you will pay x dollars.\")\n    n = int(input(\"Please enter a number: \"))\n    print(\"I have picked a number between 1 and \" + str(n) + \".\")\n    money = int(input(\"Please enter your starting money: \"))\n    while money > 0:\n        guess = int(input(\"Please enter your guess: \"))\n        if guess == n:\n            print(\"You win!\")\n            break\n        else:\n            print(\"You lose!\")\n            money = money - guess\n    print(\"You are out of money!\")\n",
        "def main():\n    print(\"Welcome to the number guessing game!\")\n    print(\"I will pick a number between 1 and n. You guess a number. If you guess the right number, you win the game. Every time you guess a wrong number x, you will pay x dollars.\")\n    n = int(input(\"Enter a number between 1 and n: \"))\n    print(\"I have picked a number. Now, guess it!\")\n    x = int(input(\"Enter your guess: \"))\n    if x == n:\n        print(\"You win!\")\n    else:\n        print(\"You lose!\")\n        print(\"You paid\", x, \"dollars.\")\n        print(\"The number was\", n)\n        print(\"Goodbye!\")\n",
        "def main():\n    print(\"Welcome to the number guessing game!\")\n    print(\"I will pick a number between 1 and n. You will have to guess it.\")\n    print(\"If you guess the right number, you win the game.\")\n    print(\"If you guess the wrong number, you will pay x dollars.\")\n    print(\"Good luck!\")\n    n = int(input(\"Enter a number: \"))\n    x = int(input(\"Enter the cost of each wrong guess: \"))\n    guess = int(input(\"Enter your guess: \"))\n    if guess == n:\n        print(\"You win!\")\n    else:\n        print(\"You lose!\")\n        print(\"You paid\", x, \"dollars.\")\n"
    ],
    "results": 5
},{
    "id": "1652",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "snippets": [
        "def levelOrder(root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res\n",
        "def levelOrder(root):\n    if root is None:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res\n",
        "def levelOrder(root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res\n",
        "def levelOrder(root):\n    if root is None:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res\n",
        "def levelOrder(self, root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res\n",
        "def levelOrder(root):\n    if root == None:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res\n"
    ],
    "results": 10
},{
    "id": "1653",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position.",
    "snippets": [
        "def jump(nums):\n    if len(nums) == 1:\n        return 0\n    max_jump = 0\n    for i in range(len(nums)):\n        if i + nums[i] >= max_jump:\n            max_jump = i + nums[i]\n    return max_jump\n",
        "def jump(nums):\n    if len(nums) == 1:\n        return 0\n    max_jump = 0\n    for i in range(len(nums)):\n        if i + nums[i] >= max_jump:\n            max_jump = i + nums[i]\n    return max_jump + 1\n",
        "def jump(nums):\n    if len(nums) == 1:\n        return 0\n    max_jump = 0\n    for i in range(len(nums)):\n        if i + nums[i] > max_jump:\n            max_jump = i + nums[i]\n    return max_jump\n",
        "def jump(nums):\n    if len(nums) == 1:\n        return 0\n    max_jump = 0\n    cur_jump = 0\n    for i in range(len(nums)):\n        if i > max_jump:\n            return -1\n        if i == len(nums) - 1:\n            return cur_jump\n        max_jump = max(max_jump, i + nums[i])\n        cur_jump += 1\n    return cur_jump\n",
        "def jump(nums):\n    if len(nums) == 1:\n        return 0\n    max_jump = 0\n    max_index = 0\n    for i in range(len(nums)):\n        if i > max_index:\n            return -1\n        if i + nums[i] > max_index:\n            max_index = i + nums[i]\n            max_jump += 1\n    return max_jump\n"
    ],
    "results": 10
},{
    "id": "1654",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed 1-dimensional integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original.",
    "snippets": [
        "def create2DArray(original, m, n):\n    newArray = []\n    for i in range(m):\n        newArray.append([])\n        for j in range(n):\n            newArray[i].append(original[i*n+j])\n    return newArray\n",
        "def create_2d_array(original, m, n):\n    return [[original[i] for i in range(n)] for j in range(m)]\n",
        "def create_2d_array(original, m, n):\n    return [[original[i] for i in range(j, j + n)] for j in range(0, len(original), n)]\n"
    ],
    "results": 10
},{
    "id": "1655",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an n x n grid where you have placed some 1 x 1x 1 cubes. Each value v = grid[i] represents a tower of v cubes placed on top of cell (i, j)",
    "snippets": [
        "def tower_builder(n):\n    tower = []\n    for i in range(n):\n        tower.append([])\n        for j in range(n):\n            tower[i].append(0)\n    for i in range(n):\n        for j in range(n):\n            if i == 0:\n                tower[i][j] = 1\n            elif j == 0:\n                tower[i][j] = 1\n            else:\n                tower[i][j] = tower[i-1][j] + tower[i][j-1]\n    return tower\n",
        "def tower_builder(n):\n    return [[\"*\" * (i + 1) for i in range(n)] for j in range(n)]\n",
        "def tower_builder(n):\n    # Write your code here\n    tower = []\n    for i in range(n):\n        tower.append([])\n        for j in range(n):\n            tower[i].append(0)\n    for i in range(n):\n        for j in range(n):\n            if i == 0:\n                tower[i][j] = 1\n            elif j == 0:\n                tower[i][j] = 1\n            else:\n                tower[i][j] = tower[i-1][j] + tower[i][j-1]\n    return tower\n",
        "def tower_builder(n):\n    tower = []\n    for i in range(n):\n        tower.append([])\n        for j in range(n):\n            tower[i].append(1)\n    return tower\n",
        "def tower_builder(n):\n    return [[\"*\"*(i+1)]*n for i in range(n)]\n",
        "def tower_builder(n):\n    # your code here\n    return [[\"*\" * (i + 1) for i in range(n)] for j in range(n)]\n"
    ],
    "results": 10
},{
    "id": "1656",
    "source": "leetcode",
    "language": "python",
    "query": "Find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.",
    "snippets": [
        "def maxAncestorDiff(self, root):\n    def dfs(node, min_val, max_val):\n        if not node:\n            return max_val - min_val\n        left = dfs(node.left, min(min_val, node.val), max(max_val, node.val))\n        right = dfs(node.right, min(min_val, node.val), max(max_val, node.val))\n        return max(left, right)\n    return dfs(root, float('inf'), float('-inf'))\n",
        "def maxAncestorDiff(self, root):\n    def dfs(node, min_val, max_val):\n        if not node:\n            return max_val - min_val\n        left = dfs(node.left, min(min_val, node.val), max(max_val, node.val))\n        right = dfs(node.right, min(min_val, node.val), max(max_val, node.val))\n        return max(left, right)\n    return dfs(root, root.val, root.val)\n",
        "def find_max_diff(root):\n    if not root:\n        return 0\n    max_diff = 0\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n        if node.left and node.right:\n            max_diff = max(max_diff, abs(node.left.val - node.right.val))\n    return max_diff\n",
        "def maxDiff(root):\n    if not root:\n        return 0\n    max_diff = 0\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n        if node.left and node.right:\n            max_diff = max(max_diff, abs(node.left.val - node.right.val))\n    return max_diff\n",
        "def maxDiff(root):\n    if not root:\n        return 0\n    return max(maxDiff(root.left), maxDiff(root.right), abs(root.val - root.left.val), abs(root.val - root.right.val))\n",
        "def find_max_value(root):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return root.val\n    left = find_max_value(root.left)\n    right = find_max_value(root.right)\n    return max(left, right, abs(root.val - left), abs(root.val - right))\n",
        "def find_max_diff(root):\n    if not root:\n        return 0\n    max_diff = 0\n    stack = [(root, root.val)]\n    while stack:\n        node, val = stack.pop()\n        if node.left:\n            stack.append((node.left, node.left.val))\n        if node.right:\n            stack.append((node.right, node.right.val))\n        max_diff = max(max_diff, abs(val - node.val))\n    return max_diff\n",
        "def maxAncestorDiff(self, root):\n    def dfs(node, min_val, max_val):\n        if not node:\n            return 0\n        if node.val < min_val:\n            min_val = node.val\n        if node.val > max_val:\n            max_val = node.val\n        return max(dfs(node.left, min_val, max_val), dfs(node.right, min_val, max_val))\n    return dfs(root, root.val, root.val)\n"
    ],
    "results": 10
},{
    "id": "1657",
    "source": "leetcode",
    "language": "python",
    "query": "In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups.",
    "snippets": [
        "def can_split(cards):\n    if len(cards) % 2 == 1:\n        return False\n    else:\n        for i in range(len(cards)):\n            if cards[i] == cards[i + 1]:\n                return True\n        return False\n",
        "def can_split(cards):\n    if len(cards) % 2 != 0:\n        return False\n    else:\n        for i in range(len(cards)):\n            if cards[i] == cards[i+1]:\n                return True\n        return False\n",
        "def can_split(arr):\n    if len(arr) % 2 == 1:\n        return False\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[i + len(arr) // 2]:\n            return False\n    return True\n",
        "def hasGroupsSizeX(deck):\n    if len(deck) < 2:\n        return False\n    deck.sort()\n    count = [0] * (len(deck) + 1)\n    for i in deck:\n        count[i] += 1\n    for i in range(2, len(deck) + 1):\n        if count[i] > 0:\n            if count[i] * 2 >= len(deck):\n                return True\n            for j in range(i + 1, len(deck) + 1):\n                if count[j] > 0:\n                    if count[i] * 2 >= len(deck) - count[j]:\n                        return True\n    return False\n",
        "def can_split(nums):\n    if len(nums) % 2 == 1:\n        return False\n    for i in range(len(nums) // 2):\n        if nums[i] != nums[i + len(nums) // 2]:\n            return False\n    return True\n",
        "def is_splittable(deck):\n    deck.sort()\n    for i in range(len(deck)):\n        if i == 0:\n            if deck[i] != deck[i+1]:\n                return False\n        elif i == len(deck)-1:\n            if deck[i] != deck[i-1]:\n                return False\n        else:\n            if deck[i] != deck[i-1] and deck[i] != deck[i+1]:\n                return False\n    return True\n",
        "def can_split(cards):\n    return sum(cards) % 2 == 0\n",
        "def split_deck_into_two_groups(deck):\n    # Write your code here.\n    deck_set = set(deck)\n    if len(deck_set) == 1:\n        return False\n    for i in range(2, len(deck_set) + 1):\n        if len(deck_set) % i == 0:\n            return True\n    return False\n",
        "def split_deck_into_two(cards):\n    cards = sorted(cards)\n    for i in range(len(cards)):\n        if cards[i] != cards[i+1]:\n            if i+1 == len(cards):\n                return False\n            if cards[i+1] - cards[i] == 1:\n                return True\n            else:\n                return False\n    return False\n"
    ],
    "results": 10
},{
    "id": "1658",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer n, the number of teams in a tournament that has strange rules. If the current number is even, each team gets paired with another team. A total of (n - 1) / 2 matches are played, and n / 2 teams advance to the next round.",
    "snippets": [
        "def tournament(n):\n    if n == 1:\n        return 1\n    if n % 2 == 0:\n        return tournament(n - 1) + tournament(n - 2)\n    else:\n        return tournament(n - 1) + tournament(n - 2) + 1\n",
        "def tournament(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return tournament(n - 1) + tournament(n - 2)\n    else:\n        return tournament(n - 1) + tournament(n - 2) + tournament(n - 3)\n",
        "def tournament(n):\n    if n == 1:\n        return 1\n    elif n % 2 == 0:\n        return tournament(n - 1) + tournament(n - 2)\n    else:\n        return tournament(n - 1) + tournament(n - 2) + 1\n",
        "def tournament(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return tournament(n - 1) + tournament(n - 2)\n",
        "def tournament(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return (n - 1) // 2\n"
    ],
    "results": 10
},{
    "id": "1659",
    "source": "leetcode",
    "language": "python",
    "query": "A substring is a contiguous sequence of characters within a string. Given a string s, return the length of the longest substring between two equal characters. If there is no such substring return -1.",
    "snippets": [
        "def longest_substring(s):\n    longest = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                if j-i > longest:\n                    longest = j-i\n    return longest\n",
        "def longest_substring(s):\n    longest = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                longest = max(longest, j - i)\n    return longest\n",
        "def longest_substring(s):\n    if len(s) < 2:\n        return -1\n    max_length = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                max_length = max(max_length, j-i)\n    return max_length\n",
        "def longest_substring(s):\n    if len(s) < 2:\n        return -1\n    longest = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                longest = max(longest, j-i)\n    return longest\n",
        "def longest_substring(s):\n    if len(s) < 2:\n        return -1\n    max_len = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if s[i] == s[j]:\n                max_len = max(max_len, j-i)\n    return max_len\n"
    ],
    "results": 10
},{
    "id": "1660",
    "source": "leetcode",
    "language": "python",
    "query": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
    "snippets": [
        "def smallest_integer(num, k):\n    num = list(num)\n    for i in range(k):\n        num.remove(min(num))\n    return ''.join(num)\n",
        "def removeKdigits(num, k):\n    if k == len(num):\n        return '0'\n    stack = []\n    for i in range(len(num)):\n        while k and stack and stack[-1] > num[i]:\n            stack.pop()\n            k -= 1\n        stack.append(num[i])\n    return ''.join(stack[:-k or None]).lstrip('0') or '0'\n",
        "def smallest_integer(num, k):\n    num = list(str(num))\n    for i in range(k):\n        num.remove(min(num))\n    return int(''.join(num))\n",
        "def smallest_integer(num, k):\n    num = list(num)\n    for i in range(k):\n        num.remove(num[0])\n    return ''.join(num)\n",
        "def removeKdigits(num, k):\n    if k == len(num):\n        return \"0\"\n    stack = []\n    for digit in num:\n        while k and stack and stack[-1] > digit:\n            stack.pop()\n            k -= 1\n        stack.append(digit)\n    return \"\".join(stack[:-k or None]).lstrip(\"0\") or \"0\"\n"
    ],
    "results": 10
},{
    "id": "1661",
    "source": "leetcode",
    "language": "python",
    "query": "You have a convex n-sided polygon where each vertex has an integer value. You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices.",
    "snippets": [
        "def polygon_value(polygon):\n    if len(polygon) < 3:\n        return 0\n    if len(polygon) == 3:\n        return polygon[0] * polygon[1] * polygon[2]\n    return polygon[0] * polygon[1] * polygon[2] + polygon_value(polygon[3:])\n",
        "def triangulate(polygon):\n    if len(polygon) < 3:\n        return []\n    if len(polygon) == 3:\n        return [polygon]\n    return [polygon[:i] + polygon[i+1:] for i in range(len(polygon) - 1)]\n",
        "def triangulate(polygon):\n    if len(polygon) < 3:\n        return []\n    if len(polygon) == 3:\n        return [polygon]\n    return [polygon[:3]] + triangulate(polygon[1:])\n",
        "def triangulate(n, polygon):\n    if n == 3:\n        return polygon[0] * polygon[1] * polygon[2]\n    else:\n        return triangulate(n - 2, polygon) * polygon[n - 1]\n",
        "def get_triangle_value(a, b, c):\n    return a * b * c\n",
        "def solution(A):\n    # write your code in Python 3.6\n    A.sort()\n    n = len(A)\n    if n < 3:\n        return 0\n    res = 1\n    for i in range(n - 2):\n        res *= A[i]\n    return res\n",
        "def triangle(a, b, c):\n    return a * b * c\n"
    ],
    "results": 10
},{
    "id": "1662",
    "source": "leetcode",
    "language": "python",
    "query": "An island is a maximal 4-directionally connected group of 0s. A closed island is an island totally (all left, top, right, bottom) surrounded by 1s.",
    "snippets": [
        "def island(grid):\n    if not grid:\n        return 0\n    if not grid[0]:\n        return 0\n    if not grid[0][0]:\n        return 0\n    if not grid[-1]:\n        return 0\n    if not grid[-1][0]:\n        return 0\n    if not grid[-1][-1]:\n        return 0\n    if not grid[0][-1]:\n        return 0\n    return 1\n",
        "def island(grid):\n    if not grid:\n        return 0\n    if not grid[0]:\n        return 0\n    if not grid[0][0]:\n        return 0\n    if not grid[-1]:\n        return 0\n    if not grid[-1][0]:\n        return 0\n    if not grid[-1][-1]:\n        return 0\n    if not grid[0][-1]:\n        return 0\n    if grid[0][0] == 1:\n        return 0\n    if grid[-1][0] == 1:\n        return 0\n    if grid[-1][-1] == 1:\n        return 0\n    if grid[0][-1] == 1:\n        return 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                if i == 0 or j == 0 or i == len(grid) - 1 or j == len(grid[0]) - 1:\n                    return 0\n                if grid[i - 1][j] == 0:\n                    return 0\n                if grid[i + 1][j] == 0:\n                    return 0\n                if grid[i][j - 1] == 0:\n                    return 0\n                if grid[i][j + 1] == 0:\n                    return 0\n    return 1\n",
        "def island(grid):\n    if not grid:\n        return 0\n    if not grid[0]:\n        return 0\n    if not grid[0][0]:\n        return 0\n    if not grid[-1]:\n        return 0\n    if not grid[-1][-1]:\n        return 0\n    islands = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                islands += 1\n                dfs(grid, i, j)\n    return islands\n",
        "def island(grid):\n    if not grid:\n        return 0\n    if not grid[0]:\n        return 0\n    if not grid[0][0]:\n        return 0\n    if not grid[-1]:\n        return 0\n    if not grid[-1][-1]:\n        return 0\n    if len(grid) == 1:\n        return 1\n    if len(grid[0]) == 1:\n        return 1\n    if len(grid) == 2:\n        return 2\n    if len(grid[0]) == 2:\n        return 2\n    if len(grid) == 3:\n        return 3\n    if len(grid[0]) == 3:\n        return 3\n    if len(grid) == 4:\n        return 4\n    if len(grid[0]) == 4:\n        return 4\n    if len(grid) == 5:\n        return 5\n    if len(grid[0]) == 5:\n        return 5\n    if len(grid) == 6:\n        return 6\n    if len(grid[0]) == 6:\n        return 6\n    if len(grid) == 7:\n        return 7\n    if len(grid[0]) == 7:\n        return 7\n    if len(grid) == 8:\n        return 8\n    if len(grid[0]) == 8:\n        return 8\n    if len(grid) == 9:\n        return 9\n    if len(grid[0]) == 9:\n        return 9\n    if len(grid) == 10:\n        return 10\n    if len(grid[0]) == 10:\n        return 10\n    if len(grid) == 11:\n        return 11\n    if len(grid[0]) == 11:\n        return 11\n    if len(grid) == 12:\n        return 12\n    if len(grid[0]) == 12:\n        return 12\n    if len(grid) == 13:\n        return 13\n    if len(grid[0]) == 13:\n        return 13\n    if len(grid) == 14:\n        return 14\n    if len(grid[0]) == 14:\n        return 14\n    if len(grid) == 15:\n",
        "def island(grid):\n    if not grid:\n        return 0\n    if not grid[0]:\n        return 0\n    if not grid[0][0]:\n        return 0\n    if not grid[-1]:\n        return 0\n    if not grid[-1][-1]:\n        return 0\n    if len(grid) == 1:\n        return 1\n    if len(grid[0]) == 1:\n        return 1\n    if len(grid) == 2:\n        return 1\n    if len(grid[0]) == 2:\n        return 1\n    if len(grid) == 3:\n        return 1\n    if len(grid[0]) == 3:\n        return 1\n    if len(grid) == 4:\n        return 1\n    if len(grid[0]) == 4:\n        return 1\n    if len(grid) == 5:\n        return 1\n    if len(grid[0]) == 5:\n        return 1\n    if len(grid) == 6:\n        return 1\n    if len(grid[0]) == 6:\n        return 1\n    if len(grid) == 7:\n        return 1\n    if len(grid[0]) == 7:\n        return 1\n    if len(grid) == 8:\n        return 1\n    if len(grid[0]) == 8:\n        return 1\n    if len(grid) == 9:\n        return 1\n    if len(grid[0]) == 9:\n        return 1\n    if len(grid) == 10:\n        return 1\n    if len(grid[0]) == 10:\n        return 1\n    if len(grid) == 11:\n        return 1\n    if len(grid[0]) == 11:\n        return 1\n    if len(grid) == 12:\n        return 1\n    if len(grid[0]) == 12:\n        return 1\n    if len(grid) == 13:\n        return 1\n    if len(grid[0]) == 13:\n        return 1\n    if len(grid) == 14:\n        return 1\n    if len(grid[0]) == 14:\n        return 1\n    if len(grid) == 15:\n",
        "def island(grid):\n    if not grid:\n        return 0\n    if not grid[0]:\n        return 0\n    if not grid[0][0]:\n        return 0\n    if not grid[-1]:\n        return 0\n    if not grid[-1][0]:\n        return 0\n    if not grid[-1][-1]:\n        return 0\n    if not grid[0][-1]:\n        return 0\n    if grid[0][0] == 1:\n        return 0\n    if grid[-1][0] == 1:\n        return 0\n    if grid[-1][-1] == 1:\n        return 0\n    if grid[0][-1] == 1:\n        return 0\n    if grid[0][0] == 0:\n        return 1\n    if grid[-1][0] == 0:\n        return 1\n    if grid[-1][-1] == 0:\n        return 1\n    if grid[0][-1] == 0:\n        return 1\n    return 0\n",
        "def island(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1 and not visited[i][j]:\n                count += 1\n                dfs(grid, visited, i, j)\n    return count\n",
        "def island(grid):\n    if len(grid) == 0:\n        return 0\n    if len(grid[0]) == 0:\n        return 0\n    if len(grid) == 1:\n        return len(grid[0])\n    if len(grid[0]) == 1:\n        return len(grid)\n    islands = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 0:\n                islands += 1\n                islands += dfs(grid, i, j)\n    return islands\n"
    ],
    "results": 10
},{
    "id": "1663",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.",
    "snippets": [
        "def maxNonOverlapping(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    dp = [0] * len(nums)\n    dp[0] = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j] and dp[j] + 1 > dp[i]:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "def maxNonOverlapping(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    dp = [0] * len(nums)\n    dp[0] = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n",
        "def maxSubArrayLen(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    d = {0: -1}\n    s = 0\n    for i in range(len(nums)):\n        s += nums[i]\n        if s not in d:\n            d[s] = i\n        if s - target in d:\n            return max(i - d[s - target], maxSubArrayLen(nums[d[s - target] + 1:], target))\n    return 0\n",
        "def maxNonOverlapping(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    dp = [0] * len(nums)\n    dp[0] = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n",
        "def maxSubArrayLen(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    d = {}\n    d[0] = -1\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum in d:\n            d[sum] = i\n        else:\n            d[sum] = i\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum - target in d:\n            return i - d[sum - target]\n    return 0\n",
        "def maxSubArrayLen(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    d = {}\n    d[0] = -1\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum in d:\n            d[sum] = i\n        else:\n            d[sum] = i\n    sum = 0\n    max_len = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum - target in d:\n            max_len = max(max_len, i - d[sum - target])\n    return max_len\n",
        "def maxNonOverlapping(nums, target):\n    # Write your code here\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for i in range(1, target + 1):\n        for j in range(len(nums)):\n            if i >= nums[j]:\n                dp[i] = max(dp[i], dp[i - nums[j]] + 1)\n    return dp[target]\n",
        "def maxSubArrayLen(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    # use a dictionary to store the sum of the subarray\n    # key is the sum of the subarray, value is the index of the first element in the subarray\n    dic = {0:-1}\n    sum = 0\n    res = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum in dic:\n            res = max(res, i-dic[sum])\n        if sum-target in dic:\n            res = max(res, i-dic[sum-target])\n        if sum not in dic:\n            dic[sum] = i\n    return res\n",
        "def maxSubArrayLen(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    # nums = [1, -1, 5, -2, 3]\n    # target = 3\n    # nums = [1, -1, 5, -2, 3]\n    # target = -3\n    # nums = [1, -1, 5, -2, 3]\n    # target = -1\n    # nums = [1, -1, 5, -2, 3]\n    # target = 2\n    # nums = [1, -1, 5, -2, 3]\n    # target = 4\n    # nums = [1, -1, 5, -2, 3]\n    # target = 6\n    # nums = [1, -1, 5, -2, 3]\n    # target = 7\n    # nums = [1, -1, 5, -2, 3]\n    # target = 8\n    # nums = [1, -1, 5, -2, 3]\n    # target = 9\n    # nums = [1, -1, 5, -2, 3]\n    # target = 10\n    # nums = [1, -1, 5, -2, 3]\n    # target = 11\n    # nums = [1, -1, 5, -2, 3]\n    # target = 12\n    # nums = [1, -1, 5, -2, 3]\n    # target = 13\n    # nums = [1, -1, 5, -2, 3]\n    # target = 14\n    # nums = [1, -1, 5, -2, 3]\n    # target = 15\n    # nums = [1, -1, 5, -2, 3]\n    # target = 16\n    # nums = [1, -1, 5, -2, 3]\n    # target = 17\n    # nums = [1, -1, 5, -2, 3]\n    # target = 18\n    # nums =\n"
    ],
    "results": 10
},{
    "id": "1664",
    "source": "leetcode",
    "language": "python",
    "query": "A node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit. Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root.",
    "snippets": [
        "def delete_insufficient_nodes(root, limit):\n    if root is None:\n        return None\n    root.left = delete_insufficient_nodes(root.left, limit)\n    root.right = delete_insufficient_nodes(root.right, limit)\n    if root.left is None and root.right is None and root.val < limit:\n        return None\n    return root\n",
        "def delete_insufficient_nodes(root, limit):\n    if root is None:\n        return None\n    root.left = delete_insufficient_nodes(root.left, limit)\n    root.right = delete_insufficient_nodes(root.right, limit)\n    if root.val < limit and root.left is None and root.right is None:\n        return None\n    return root\n",
        "def delete_insufficient_nodes(root, limit):\n    if root is None:\n        return None\n    root.left = delete_insufficient_nodes(root.left, limit)\n    root.right = delete_insufficient_nodes(root.right, limit)\n    if root.val < limit:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            return root.left\n    else:\n        return root\n",
        "def delete_insufficient_nodes(root, limit):\n    if not root:\n        return None\n    root.left = delete_insufficient_nodes(root.left, limit)\n    root.right = delete_insufficient_nodes(root.right, limit)\n    if not root.left and not root.right and root.val < limit:\n        return None\n    return root\n",
        "def delete_insufficient(root, limit):\n    if root is None:\n        return None\n    root.left = delete_insufficient(root.left, limit)\n    root.right = delete_insufficient(root.right, limit)\n    if root.val < limit and root.left is None and root.right is None:\n        return None\n    return root\n",
        "def delete_insufficient_nodes(root, limit):\n    if not root:\n        return None\n    root.left = delete_insufficient_nodes(root.left, limit)\n    root.right = delete_insufficient_nodes(root.right, limit)\n    if root.val < limit:\n        if root.left:\n            root.val += root.left.val\n        if root.right:\n            root.val += root.right.val\n        if root.left and root.right:\n            root.val += root.left.val + root.right.val\n        if root.left:\n            root.left = None\n        if root.right:\n            root.right = None\n    return root\n",
        "def delete_insufficient_nodes(root, limit):\n    if not root:\n        return None\n    root.left = delete_insufficient_nodes(root.left, limit)\n    root.right = delete_insufficient_nodes(root.right, limit)\n    if not root.left and not root.right:\n        if root.val < limit:\n            return None\n        else:\n            return root\n    if root.left:\n        if root.left.val < limit:\n            root.left = None\n    if root.right:\n        if root.right.val < limit:\n            root.right = None\n    return root\n",
        "def delete_insufficient(root, limit):\n    if root is None:\n        return None\n    root.left = delete_insufficient(root.left, limit)\n    root.right = delete_insufficient(root.right, limit)\n    if root.val < limit:\n        if root.left is None and root.right is None:\n            return None\n        elif root.left is None:\n            return root.right\n        elif root.right is None:\n            return root.left\n        else:\n            root.left = delete_insufficient(root.left, limit)\n            root.right = delete_insufficient(root.right, limit)\n            return root\n    else:\n        return root\n"
    ],
    "results": 10
},{
    "id": "1665",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return a binary string representing its representation in base -2.Note that the returned string should not have leading zeros unless the string is \"0\".",
    "snippets": [
        "def baseNeg2(n):\n    if n == 0:\n        return \"0\"\n    if n < 0:\n        return \"-\" + baseNeg2(-n)\n    if n % 2 == 0:\n        return baseNeg2(n // 2)\n    return baseNeg2(n // 2) + \"1\"\n",
        "def baseNeg2(n):\n    if n == 0:\n        return \"0\"\n    if n < 0:\n        return \"-\" + baseNeg2(-n)\n    return baseNeg2(n // -2) + str(n % -2)\n",
        "def baseNeg2(n):\n    if n == 0:\n        return \"0\"\n    if n < 0:\n        return \"-\" + baseNeg2(-n)\n    return baseNeg2(n // -2) + str(n % 2)\n",
        "def baseNeg2(n):\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    if n == -1:\n        return \"11\"\n    if n == -2:\n        return \"10\"\n    if n == -3:\n        return \"101\"\n    if n == -4:\n        return \"100\"\n    if n == -5:\n        return \"111\"\n    if n == -6:\n        return \"110\"\n    if n == -7:\n        return \"1001\"\n    if n == -8:\n        return \"1000\"\n    if n == -9:\n        return \"1111\"\n    if n == -10:\n        return \"1010\"\n    if n == -11:\n        return \"1011\"\n    if n == -12:\n        return \"1100\"\n    if n == -13:\n        return \"1101\"\n    if n == -14:\n        return \"1110\"\n    if n == -15:\n        return \"1111\"\n    if n == -16:\n        return \"10000\"\n    if n == -17:\n        return \"10001\"\n    if n == -18:\n        return \"10010\"\n    if n == -19:\n        return \"10011\"\n    if n == -20:\n        return \"10100\"\n    if n == -21:\n        return \"10101\"\n    if n == -22:\n        return \"10110\"\n    if n == -23:\n        return \"10111\"\n    if n == -24:\n        return \"11000\"\n    if n == -25:\n        return \"11001\"\n    if n == -26:\n        return \"11010\"\n    if n == -27:\n        return \"11011\"\n    if n == -28:\n        return \"11100\"\n    if n == -29:\n        return \"11101\"\n    if n == -30:\n        return \"11110\"\n    if n == -31:\n        return \"11111\"\n    if n == -32:\n        return \"100000\n",
        "def baseNeg2(n):\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    if n < 0:\n        return \"-\" + baseNeg2(-n)\n    return baseNeg2(n // -2) + str(n % 2)\n",
        "def baseNeg2(n):\n    if n == 0:\n        return '0'\n    if n < 0:\n        return '-' + baseNeg2(-n)\n    return baseNeg2(n // -2) + str(n % -2)\n",
        "def baseNeg2(n):\n    if n == 0:\n        return '0'\n    result = ''\n    while n != 0:\n        result += str(n % -2)\n        n = n // -2\n    return result[::-1]\n"
    ],
    "results": 10
},{
    "id": "1666",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element.",
    "snippets": [
        "def count_pairs(nums):\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] < nums[j] and nums[i+1] > nums[j]:\n                count += 1\n    return count\n",
        "def solution(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] < nums[j] and nums[j] < nums[i+1]:\n                count += 1\n    return count\n",
        "def numSmallerByFrequency(nums):\n    nums.sort(key=lambda x: x.count(min(x)))\n    return sum(nums[i].count(nums[i][0]) > nums[i+1].count(nums[i+1][0]) for i in range(len(nums)-1))\n",
        "def count_semi_sorted(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] > nums[j] and nums[i - 1] < nums[j]:\n                count += 1\n            if nums[i] < nums[j] and nums[i + 1] > nums[j]:\n                count += 1\n    return count\n",
        "def count_semistrict_smaller(nums):\n    if not nums:\n        return 0\n    count = [0] * len(nums)\n    for i in range(len(nums) - 1, -1, -1):\n        count[i] = sum(count[j] for j in range(i + 1, len(nums)))\n        for j in range(i + 1, len(nums)):\n            if nums[j] > nums[i]:\n                count[i] += 1\n    return count\n",
        "def count_smaller(nums):\n    if not nums:\n        return []\n    result = [0] * len(nums)\n    sorted_nums = sorted(nums)\n    for i in range(len(nums)):\n        result[i] = sorted_nums.index(nums[i])\n    return result\n",
        "def count_semiprimes(nums):\n    nums.sort()\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] + 1 == nums[j] or nums[i] - 1 == nums[j]:\n                count += 1\n    return count\n",
        "def count_semistrictly_smaller(nums):\n    if not nums:\n        return []\n    result = [0] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[j] > nums[i]:\n                result[i] += 1\n    return result\n"
    ],
    "results": 10
},{
    "id": "1667",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning.",
    "snippets": [
        "def maxSumAfterPartitioning(A, K):\n    n = len(A)\n    dp = [0] * n\n    for i in range(n):\n        max_val = 0\n        for j in range(1, min(i + 1, K) + 1):\n            max_val = max(max_val, A[i - j + 1])\n            dp[i] = max(dp[i], max_val * j + (i - j + 1) * A[i])\n    return dp[-1]\n",
        "def partition(arr, k):\n    if not arr:\n        return 0\n    if k == 1:\n        return max(arr)\n    if k == len(arr):\n        return sum(arr)\n    if k > len(arr):\n        return 0\n    dp = [0] * (len(arr) + 1)\n    for i in range(1, len(arr) + 1):\n        dp[i] = max(dp[i - 1], dp[i - k] + arr[i - 1])\n    return dp[-1]\n",
        "def maxSubarray(arr, k):\n    if len(arr) < k:\n        return sum(arr)\n    max_sum = 0\n    for i in range(len(arr) - k + 1):\n        max_sum = max(max_sum, sum(arr[i:i+k]))\n    return max_sum\n",
        "def maxSubarray(arr, k):\n    # Write your code here.\n    if len(arr) < k:\n        return sum(arr)\n    else:\n        max_sum = 0\n        for i in range(len(arr) - k + 1):\n            max_sum = max(max_sum, sum(arr[i:i+k]))\n        return max_sum\n",
        "def maxSubarray(arr, k):\n    # Write your code here.\n    if len(arr) < k:\n        return sum(arr)\n    max_sum = 0\n    for i in range(len(arr) - k + 1):\n        max_sum = max(max_sum, sum(arr[i:i + k]))\n    return max_sum\n",
        "def maxSum(arr, k):\n    if len(arr) < k:\n        return sum(arr)\n    max_sum = 0\n    for i in range(len(arr) - k + 1):\n        max_sum = max(max_sum, sum(arr[i:i+k]))\n    return max_sum\n",
        "def maxSubarray(arr, k):\n    if len(arr) < k:\n        return sum(arr)\n    if k == 1:\n        return max(arr)\n    if k == len(arr):\n        return sum(arr)\n    if k == 2:\n        return max(arr[0], arr[1])\n    if k == 3:\n        return max(arr[0], arr[1], arr[2])\n    if k == 4:\n        return max(arr[0], arr[1], arr[2], arr[3])\n    if k == 5:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4])\n    if k == 6:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5])\n    if k == 7:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6])\n    if k == 8:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7])\n    if k == 9:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8])\n    if k == 10:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[9])\n    if k == 11:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[9], arr[10])\n    if k == 12:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[9], arr[10], arr[11])\n    if k\n",
        "def maxSum(arr, k):\n    if len(arr) < k:\n        return 0\n    if len(arr) == k:\n        return max(arr)\n    if len(arr) == k + 1:\n        return sum(arr)\n    if len(arr) == k + 2:\n        return max(arr[0], arr[1])\n    if len(arr) == k + 3:\n        return max(arr[0], arr[1], arr[2])\n    if len(arr) == k + 4:\n        return max(arr[0], arr[1], arr[2], arr[3])\n    if len(arr) == k + 5:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4])\n    if len(arr) == k + 6:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5])\n    if len(arr) == k + 7:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6])\n    if len(arr) == k + 8:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7])\n    if len(arr) == k + 9:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8])\n    if len(arr) == k + 10:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[9])\n    if len(arr) == k + 11:\n        return max(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8], arr[9], arr[10])\n    if len(arr) == k + 12:\n",
        "def maxSubarray(arr, k):\n    max_sum = 0\n    for i in range(k):\n        max_sum += arr[i]\n    max_sum_end = max_sum\n    for i in range(k, len(arr)):\n        max_sum_end = max(max_sum_end + arr[i], arr[i])\n        max_sum = max(max_sum, max_sum_end)\n    return max_sum\n"
    ],
    "results": 10
},{
    "id": "1668",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integers num and k, consider a set of positive integers with the following properties: The units digit of each integer is k. The sum of the integers is num.",
    "snippets": [
        "def sum_of_k(num, k):\n    if num == 0:\n        return 0\n    return k + sum_of_k(num // 10, k)\n",
        "def sum_of_k(num, k):\n    if num == 0:\n        return 0\n    else:\n        return k + sum_of_k(num // 10, k)\n",
        "def sum_of_k(num, k):\n    if num == 0:\n        return 0\n    if num % 10 == k:\n        return num % 10 + sum_of_k(num // 10, k)\n    else:\n        return sum_of_k(num // 10, k)\n",
        "def k_digit_sum(num, k):\n    if num == 0:\n        return 0\n    return k + k_digit_sum(num // 10, k)\n",
        "def sum_of_k(num, k):\n    return sum(int(x) for x in str(num) if int(x) == k)\n",
        "def sum_of_k_units(num, k):\n    if num == 0:\n        return 0\n    return k + sum_of_k_units(num//10, k)\n",
        "def sum_of_k(num, k):\n    return sum([int(x) for x in str(num) if int(x) == k])\n"
    ],
    "results": 10
},{
    "id": "1669",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, return true if any value appears at least twice in the array. Return false if every element is distinct.",
    "snippets": [
        "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))\n"
    ],
    "results": 10
},{
    "id": "1670",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array bloomDay, an integer m and an integer k. To make a bouquet, you need to use k adjacent flowers from the garden. If it is impossible to make m bouquets return -1.",
    "snippets": [
        "def bouquet(bloomDay, m, k):\n    if m > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    i = 0\n    while i < len(bloomDay):\n        if bloomDay[i] + k > bloomDay[i+1]:\n            i += 1\n        else:\n            return -1\n    return bloomDay[i]\n",
        "def bouquet(bloomDay, m, k):\n    if m > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    i = 0\n    while i < len(bloomDay):\n        if bloomDay[i] + k - 1 >= bloomDay[i + 1]:\n            i += 1\n        else:\n            return -1\n    return bloomDay[i]\n",
        "def bouquet(bloomDay, m, k):\n    if m > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    count = 0\n    for i in range(len(bloomDay)):\n        if bloomDay[i] == i + 1:\n            count += 1\n        if count == k:\n            count = 0\n            m -= 1\n        if m == 0:\n            return i + 1\n    return -1\n",
        "def bouquet(bloomDay, m, k):\n    if m > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    count = 0\n    for i in range(len(bloomDay)):\n        if bloomDay[i] >= k:\n            count += 1\n        if count == m:\n            return bloomDay[i] - k + 1\n    return -1\n",
        "def bouquet(bloomDay, m, k):\n    if m * k > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    for i in range(m):\n        if bloomDay[i * k] != bloomDay[i * k + k - 1]:\n            return -1\n    return bloomDay[m * k - 1]\n",
        "def bouquet(bloomDay, m, k):\n    if m > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    for i in range(len(bloomDay) - m + 1):\n        if bloomDay[i + m - 1] - bloomDay[i] < k:\n            return -1\n    return bloomDay[m - 1]\n",
        "def bouquet(bloomDay, m, k):\n    if m * k > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    for i in range(m):\n        if bloomDay[i * k] != bloomDay[i * k + k - 1]:\n            return -1\n    return bloomDay[0]\n",
        "def bouquet(bloomDay, m, k):\n    if m > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    for i in range(len(bloomDay) - m * k + 1):\n        if bloomDay[i + m * k - 1] - bloomDay[i] >= k:\n            return bloomDay[i]\n    return -1\n",
        "def bouquet(bloomDay, m, k):\n    if m > len(bloomDay):\n        return -1\n    if m == 1:\n        return max(bloomDay)\n    if k == 1:\n        return max(bloomDay)\n    if k == 2:\n        return max(bloomDay)\n    if k == 3:\n        return max(bloomDay)\n    if k == 4:\n        return max(bloomDay)\n    if k == 5:\n        return max(bloomDay)\n    if k == 6:\n        return max(bloomDay)\n    if k == 7:\n        return max(bloomDay)\n    if k == 8:\n        return max(bloomDay)\n    if k == 9:\n        return max(bloomDay)\n    if k == 10:\n        return max(bloomDay)\n    if k == 11:\n        return max(bloomDay)\n    if k == 12:\n        return max(bloomDay)\n    if k == 13:\n        return max(bloomDay)\n    if k == 14:\n        return max(bloomDay)\n    if k == 15:\n        return max(bloomDay)\n    if k == 16:\n        return max(bloomDay)\n    if k == 17:\n        return max(bloomDay)\n    if k == 18:\n        return max(bloomDay)\n    if k == 19:\n        return max(bloomDay)\n    if k == 20:\n        return max(bloomDay)\n    if k == 21:\n        return max(bloomDay)\n    if k == 22:\n        return max(bloomDay)\n    if k == 23:\n        return max(bloomDay)\n    if k == 24:\n        return max(bloomDay)\n    if k == 25:\n        return max(bloomDay)\n    if k == 26:\n        return max(bloomDay)\n    if k == 27:\n        return max(bloomDay)\n    if k == 28:\n        return max(bloomDay)\n    if k == 29:\n",
        "def bouquets(bloomDay, m, k):\n    if m * k > len(bloomDay):\n        return -1\n    bloomDay.sort()\n    count = 0\n    for i in range(0, len(bloomDay), k):\n        if bloomDay[i] == bloomDay[i + k - 1]:\n            count += 1\n        else:\n            count = 0\n        if count == m:\n            return bloomDay[i]\n    return -1\n"
    ],
    "results": 10
},{
    "id": "1671",
    "source": "leetcode",
    "language": "python",
    "query": "You are trying to write s across several lines, where each line is no longer than 100 pixels. You are given a string s and an array widths denoting how many pixels wide each lowercase English letter is.",
    "snippets": [
        "def widths(s, widths):\n    result = []\n    for c in s:\n        result.append(widths[ord(c) - ord('a')])\n    return result\n",
        "def widths(s, widths):\n    result = []\n    for i in s:\n        result.append(widths[ord(i) - ord('a')])\n    return result\n",
        "def split_string(s, widths):\n    result = []\n    current_line = \"\"\n    for i in range(len(s)):\n        if len(current_line) + widths[ord(s[i]) - ord('a')] > 100:\n            result.append(current_line)\n            current_line = \"\"\n        current_line += s[i]\n    result.append(current_line)\n    return result\n",
        "def solution(s, widths):\n    # Your code here\n    answer = []\n    for i in range(len(s)):\n        answer.append(widths[ord(s[i]) - ord('a')])\n    return [answer[i:i+100] for i in range(0, len(answer), 100)]\n",
        "def print_snowflake(s, widths):\n    for i in range(len(s)):\n        print(s[i] * widths[ord(s[i]) - ord('a')], end='')\n    print()\n",
        "def equal_width(s, widths):\n    result = []\n    for i in range(len(s)):\n        result.append(widths[ord(s[i]) - 97])\n    return result\n",
        "def draw_line(tick_length, tick_label):\n    line = '-' * tick_length\n    if tick_label:\n        line += ' ' + tick_label\n    print(line)\n"
    ],
    "results": 10
},{
    "id": "1672",
    "source": "leetcode",
    "language": "python",
    "query": "Find the number that occurs twice and theNumber that is missing and return them in the form of an array.",
    "snippets": [
        "def find_duplicate(numbers):\n    for i in range(len(numbers)):\n        if numbers[i] != i + 1:\n            return [i + 1, numbers[i]]\n    return None\n",
        "def find_duplicate(numbers):\n    # Your code here\n    for i in range(len(numbers)):\n        if numbers[i] > len(numbers):\n            return [numbers[i], numbers[i-1]]\n    return [0,0]\n",
        "def find_duplicate(numbers):\n    for i in range(len(numbers)):\n        if numbers[i] != i:\n            return [i, numbers[i]]\n    return [-1, -1]\n",
        "def find_duplicate(numbers):\n    # Your code here\n    for i in range(len(numbers)):\n        if numbers[i] != i+1:\n            return [i+1, numbers[i]]\n    return [0, 0]\n",
        "def find_duplicate(numbers):\n    # Write your code here\n    for i in range(len(numbers)):\n        if numbers[i] != i + 1:\n            return [i + 1, numbers[i]]\n    return [0, 0]\n",
        "def find_duplicate_missing(arr):\n    # Find the duplicate\n    for i in range(len(arr)):\n        if arr[abs(arr[i])] >= 0:\n            arr[abs(arr[i])] = -arr[abs(arr[i])]\n        else:\n            return [abs(arr[i]), i]\n    return [-1, -1]\n",
        "def find_duplicate_and_missing(array):\n    # Find the duplicate\n    for i in range(len(array)):\n        if array[abs(array[i])] >= 0:\n            array[abs(array[i])] *= -1\n        else:\n            return abs(array[i])\n    # Find the missing number\n    for i in range(len(array)):\n        if array[i] >= 0:\n            return i\n    return None\n",
        "def find_duplicate_and_missing(arr):\n    # Find the duplicate number\n    for i in range(len(arr)):\n        if arr[abs(arr[i])] >= 0:\n            arr[abs(arr[i])] = -arr[abs(arr[i])]\n        else:\n            duplicate = abs(arr[i])\n    # Find the missing number\n    for i in range(len(arr)):\n        if arr[i] >= 0:\n            missing = i\n    return [duplicate, missing]\n",
        "def find_duplicate_and_missing(numbers):\n    # Your code here\n    # Find the duplicate and missing number\n    # Return an array of the two numbers in the form of [duplicate, missing]\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If there is only one number, return an array with that number\n    # If there is no duplicate or missing number, return an empty array []\n    # If\n",
        "def find_duplicate_and_missing(array):\n    # Find the duplicate and missing number\n    # 1. Find the sum of all the numbers in the array\n    # 2. Find the sum of all the numbers from 1 to the length of the array\n    # 3. Subtract the sum of all the numbers from the sum of all the numbers from 1 to the length of the array\n    # 4. The duplicate number is the number that occurs twice\n    # 5. The missing number is the number that occurs once\n    # 6. Return the duplicate and missing number in an array\n    # 7. If the array is empty, return an empty array\n    # 8. If the array is not empty, return an array with the duplicate and missing number\n    # 9. If the array is not empty and the duplicate and missing number are not found, return an empty array\n    # 10. If the array is not empty and the duplicate and missing number are found, return an array with the duplicate and missing number\n    # 11. If the array is not empty and the duplicate and missing number are not found, return an empty array\n    # 12. If the array is not empty and the duplicate and missing number are found, return an array with the duplicate and missing number\n    # 13. If the array is not empty and the duplicate and missing number are not found, return an empty array\n    # 14. If the array is not empty and the duplicate and missing number are found, return an array with the duplicate and missing number\n    # 15. If the array is not empty and the duplicate and missing number are not found, return an empty array\n    # 16. If the array is not empty and the duplicate and missing number are found, return an array with the duplicate and missing number\n    # 17. If the array is not empty and the duplicate and missing number are not found, return an empty array\n    # 18. If the array is not empty and the duplicate and missing number are found, return an array with the duplicate and missing number\n    # 19. If the array is not empty and the duplicate and missing number are not found, return an empty array\n    # 20. If the array is not empty and the duplicate and missing number are found, return an array with the duplicate and missing number\n    # 21. If the array is not empty and\n"
    ],
    "results": 10
},{
    "id": "1673",
    "source": "leetcode",
    "language": "python",
    "query": "Return an array [L, W] where L and W are the length and width of the web page you designed.",
    "snippets": [
        "def web_page_length_and_width(url):\n    import requests\n    from bs4 import BeautifulSoup\n    r = requests.get(url)\n    soup = BeautifulSoup(r.text, 'html.parser')\n    return [soup.find('body').find('div', {'class': 'container'}).find('div', {'class': 'row'}).find('div', {'class': 'col-md-8'}).find('div', {'class': 'post-content'}).find('div', {'class': 'post-content-body'}).find('div', {'class': 'row'}).find('div', {'class': 'col-md-12'}).find('div', {'class': 'post-content'}).find('div', {'class': 'post-content-body'}).find('div', {'class': 'row'}).find('div', {'class': 'col-md-12'}).find('div', {'class': 'post-content'}).find('div', {'class': 'post-content-body'}).find('div', {'class': 'row'}).find('div', {'class': 'col-md-12'}).find('div', {'class': 'post-content'}).find('div', {'class': 'post-content-body'}).find('div', {'class': 'row'}).find('div', {'class': 'col-md-12'}).find('div', {'class': 'post-content'}).find('div', {'class': 'post-content-body'}).find('div', {'class': 'row'}).find('div', {'class': 'col-md-12'}).find('div', {'class': 'post-content'}).find('div', {'class': 'post-content-body'}).find('div', {'class': 'row'}).find('div', {'class': 'col-md-12'}).find('div', {'class': 'post-content'}).find('div', {\n",
        "def web_page(n):\n    if n == 1:\n        return [1, 1]\n    else:\n        L, W = web_page(n-1)\n        return [L+W, L]\n",
        "def get_page_size(page_width, page_height, margin):\n    return [page_width - margin * 2, page_height - margin * 2]\n",
        "def web_page(url):\n    if url == 'www.google.com':\n        return [10, 10]\n    elif url == 'www.facebook.com':\n        return [10, 20]\n    elif url == 'www.youtube.com':\n        return [20, 10]\n    elif url == 'www.amazon.com':\n        return [20, 20]\n    elif url == 'www.wikipedia.org':\n        return [20, 20]\n    elif url == 'www.linkedin.com':\n        return [20, 20]\n    elif url == 'www.instagram.com':\n        return [20, 20]\n    elif url == 'www.twitter.com':\n        return [20, 20]\n    elif url == 'www.pinterest.com':\n        return [20, 20]\n    elif url == 'www.snapchat.com':\n        return [20, 20]\n    elif url == 'www.reddit.com':\n        return [20, 20]\n    elif url == 'www.quora.com':\n        return [20, 20]\n    elif url == 'www.tumblr.com':\n        return [20, 20]\n    elif url == 'www.twitch.tv':\n        return [20, 20]\n    elif url == 'www.craigslist.org':\n        return [20, 20]\n    elif url == 'www.ebay.com':\n        return [20, 20]\n    elif url == 'www.yelp.com':\n        return [20, 20]\n    elif url == 'www.quora.com':\n        return [20, 20]\n    elif url == 'www.imdb.com':\n        return [20, 20]\n    elif url == 'www.espn.com':\n        return [20, 20]\n    elif url == 'www.cnn.com':\n        return [20, 20]\n    elif url == 'www.nytimes.com':\n        return [20, 20]\n    elif url == 'www.bbc.com':\n        return\n",
        "def web_page_length_and_width(text):\n    # Your code here\n    return [len(text), len(text)]\n",
        "def web_page_length_width(text):\n    # Your code here\n    return [len(text), len(text)]\n",
        "def web_page(url):\n    return [len(url), len(url)]\n"
    ],
    "results": 8
},{
    "id": "1674",
    "source": "leetcode",
    "language": "python",
    "query": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei. If there is no such route, return -1.",
    "snippets": [
        "def findCheapestPrice(n, flights, src, dst, K):\n    \"\"\"\n    :type n: int\n    :type flights: List[List[int]]\n    :type src: int\n    :type dst: int\n    :type K: int\n    :rtype: int\n    \"\"\"\n    # build graph\n    graph = collections.defaultdict(list)\n    for u, v, w in flights:\n        graph[u].append((v, w))\n    # dp[i][k][j] = min(dp[i-1][k][j], dp[i-1][k][u] + w)\n    dp = [[float('inf')] * n for _ in range(K + 1)]\n    dp[0][src] = 0\n    for k in range(K + 1):\n        for u, v, w in flights:\n            dp[k][v] = min(dp[k][v], dp[k][u] + w)\n    return dp[K][dst] if dp[K][dst] != float('inf') else -1\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    \"\"\"\n    :type n: int\n    :type flights: List[List[int]]\n    :type src: int\n    :type dst: int\n    :type K: int\n    :rtype: int\n    \"\"\"\n    # 创建一个图，用于存储所有的边\n    graph = [[] for _ in range(n)]\n    for flight in flights:\n        graph[flight[0]].append([flight[1], flight[2]])\n    # 创建一个队列，用于存储起始点的路径\n    queue = [[src, 0, -1]]\n    # 创建一个集合，用于存储已经访问过的点\n    visited = set()\n    while queue:\n        # 取出队列的第一个元素\n        node, cost, pre = queue.pop(0)\n        # 如果该点已经访问过，则跳过\n        if node in visited:\n            continue\n        # 如果该点是目标点，则返回该点的花费\n        if node == dst:\n            return cost\n        # 将该点标记为已经访问过\n        visited.add(node)\n        # 对该点的所有邻居点进行遍历\n        for neighbor, price in graph[node]:\n            # 如果该点的邻居点已经\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    \"\"\"\n    :type n: int\n    :type flights: List[List[int]]\n    :type src: int\n    :type dst: int\n    :type K: int\n    :rtype: int\n    \"\"\"\n    if src == dst:\n        return 0\n    if K == 0:\n        return -1\n    dp = [float('inf')] * n\n    dp[src] = 0\n    for _ in range(K + 1):\n        dp_tmp = dp.copy()\n        for f in flights:\n            if dp[f[0]] != float('inf'):\n                dp_tmp[f[1]] = min(dp_tmp[f[1]], dp[f[0]] + f[2])\n        dp = dp_tmp\n    return dp[dst] if dp[dst] != float('inf') else -1\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    \"\"\"\n    :type n: int\n    :type flights: List[List[int]]\n    :type src: int\n    :type dst: int\n    :type K: int\n    :rtype: int\n    \"\"\"\n    # dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n    dp = [[float('inf')] * n for _ in range(n)]\n    for f in flights:\n        dp[f[0]][f[1]] = f[2]\n    for k in range(K + 1):\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n    return dp[src][dst] if dp[src][dst] != float('inf') else -1\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    # Write your code here.\n    if src == dst:\n        return 0\n    if K < 0:\n        return -1\n    prices = [float('inf')] * n\n    prices[src] = 0\n    for i in range(K + 1):\n        for flight in flights:\n            if prices[flight[0]] + flight[2] < prices[flight[1]]:\n                prices[flight[1]] = prices[flight[0]] + flight[2]\n    return prices[dst] if prices[dst] != float('inf') else -1\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    # Write your code here.\n    if src == dst:\n        return 0\n    if K < 0:\n        return -1\n    prices = [float('inf') for _ in range(n)]\n    prices[src] = 0\n    for _ in range(K + 1):\n        newPrices = prices.copy()\n        for i, j, p in flights:\n            if prices[i] == float('inf'):\n                continue\n            newPrices[j] = min(newPrices[j], prices[i] + p)\n        prices = newPrices\n        if prices[dst] != float('inf'):\n            return prices[dst]\n    return -1\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    # Write your code here.\n    if src == dst:\n        return 0\n    if K < 0:\n        return -1\n    prices = [float('inf') for i in range(n)]\n    prices[src] = 0\n    for i in range(K+1):\n        for j in flights:\n            if prices[j[0]] + j[2] < prices[j[1]]:\n                prices[j[1]] = prices[j[0]] + j[2]\n    if prices[dst] == float('inf'):\n        return -1\n    return prices[dst]\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    # Write your code here.\n    if src == dst:\n        return 0\n    if K < 0:\n        return -1\n    dp = [float('inf')] * n\n    dp[src] = 0\n    for i in range(K + 1):\n        for f in flights:\n            if dp[f[0]] + f[2] < dp[f[1]]:\n                dp[f[1]] = dp[f[0]] + f[2]\n    return dp[dst] if dp[dst] != float('inf') else -1\n",
        "def findCheapestPrice(n, flights, src, dst, K):\n    if src == dst:\n        return 0\n    if K < 0:\n        return -1\n    dp = [float('inf')] * n\n    dp[src] = 0\n    for _ in range(K + 1):\n        dp_next = dp.copy()\n        for i, j, k in flights:\n            if dp[i] != float('inf') and dp[i] + k < dp_next[j]:\n                dp_next[j] = dp[i] + k\n        dp = dp_next\n    return dp[dst] if dp[dst] != float('inf') else -1\n"
    ],
    "results": 9
},{
    "id": "1675",
    "source": "leetcode",
    "language": "python",
    "query": "An Anagram is a word or phrase formed by rearranging the letters of a different word. Given an array of strings strs, group the anagrams together.",
    "snippets": [
        "def groupAnagrams(strs):\n    d = {}\n    for s in strs:\n        key = ''.join(sorted(s))\n        if key in d:\n            d[key].append(s)\n        else:\n            d[key] = [s]\n    return list(d.values())\n",
        "def groupAnagrams(strs):\n    d = {}\n    for s in strs:\n        key = \"\".join(sorted(s))\n        if key in d:\n            d[key].append(s)\n        else:\n            d[key] = [s]\n    return list(d.values())\n",
        "def groupAnagrams(strs):\n    dic = {}\n    for i in strs:\n        key = ''.join(sorted(i))\n        if key in dic:\n            dic[key].append(i)\n        else:\n            dic[key] = [i]\n    return list(dic.values())\n"
    ],
    "results": 10
},{
    "id": "1676",
    "source": "leetcode",
    "language": "python",
    "query": "Your solution must run in O(log n) time and O(1) space. Return the single element that appears only once.",
    "snippets": [
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        if arr[0] == arr[1]:\n            return None\n        else:\n            return arr[0]\n    else:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        if left[0] == right[0]:\n            return single_element(left[1:])\n        else:\n            return single_element(left)\n",
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        if arr[0] == arr[1]:\n            return None\n        else:\n            return arr[0]\n    else:\n        mid = len(arr)//2\n        left = arr[:mid]\n        right = arr[mid:]\n        if left == right:\n            return None\n        else:\n            left_single = single_element(left)\n            right_single = single_element(right)\n            if left_single == None:\n                return right_single\n            elif right_single == None:\n                return left_single\n            else:\n                return left_single\n",
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        if arr[0] == arr[1]:\n            return None\n        else:\n            return arr[0]\n    else:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        if left == right:\n            return single_element(arr[:mid])\n        else:\n            return single_element(left)\n",
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        if arr[0] == arr[1]:\n            return None\n        else:\n            return arr[0]\n    if len(arr) == 3:\n        if arr[0] == arr[1] and arr[1] == arr[2]:\n            return None\n        elif arr[0] == arr[1]:\n            return arr[2]\n        elif arr[1] == arr[2]:\n            return arr[0]\n        else:\n            return arr[0]\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    if len(left) == 1:\n        return left[0]\n    if len(right) == 1:\n        return right[0]\n    if len(left) == 2:\n        if left[0] == left[1]:\n            return single_element(right)\n        else:\n            return left[0]\n    if len(right) == 2:\n        if right[0] == right[1]:\n            return single_element(left)\n        else:\n            return right[0]\n    if len(left) == 3:\n        if left[0] == left[1] and left[1] == left[2]:\n            return single_element(right)\n        elif left[0] == left[1]:\n            return left[2]\n        elif left[1] == left[2]:\n            return left[0]\n        else:\n            return left[0]\n    if len(right) == 3:\n        if right[0] == right[1] and right[1] == right[2]:\n            return single_element(left)\n        elif right[0] == right[1]:\n            return right[2]\n        elif right[1] == right[2]:\n            return right[0]\n        else:\n            return right[0]\n    if left[0] == right[0]:\n        return single_\n",
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        if arr[0] == arr[1]:\n            return None\n        else:\n            return arr[0]\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    if left == right:\n        return single_element(arr[:mid])\n    if left != right:\n        return single_element(arr[:mid])\n    return single_element(arr[mid:])\n",
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    elif len(arr) == 2:\n        return arr[0] if arr[0] != arr[1] else arr[1]\n    else:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        if len(left) == 1:\n            return left[0]\n        elif len(left) == 2:\n            return left[0] if left[0] != left[1] else left[1]\n        elif len(right) == 1:\n            return right[0]\n        elif len(right) == 2:\n            return right[0] if right[0] != right[1] else right[1]\n        else:\n            return single_element(left) if single_element(left) != single_element(right) else single_element(right)\n",
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return arr[0] if arr[0] != arr[1] else arr[1]\n    mid = len(arr) // 2\n    if arr[mid] == arr[mid + 1]:\n        return single_element(arr[:mid])\n    else:\n        return single_element(arr[mid + 1:])\n",
        "def single_element(arr):\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        mid = len(arr) // 2\n        if arr[mid] == arr[mid + 1]:\n            return single_element(arr[:mid])\n        else:\n            return single_element(arr[mid + 1:])\n",
        "def find_unique(arr):\n    \"\"\"\n    :param arr: list of integers\n    :return: unique integer\n    \"\"\"\n    # Your code here\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n        if left == right:\n            return find_unique(left)\n        else:\n            return find_unique(left) if left.count(left[0]) == 1 else find_unique(right)\n"
    ],
    "results": 10
},{
    "id": "1677",
    "source": "leetcode",
    "language": "python",
    "query": "circular track consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector round[i].",
    "snippets": [
        "def circularTrack(n, rounds):\n    # Write your code here\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n        return 41\n    if n == 42:\n        return 42\n    if n == 43:\n        return 43\n    if n == 44:\n        return 44\n",
        "def circularTrack(n, m, rounds):\n    # write your code here\n    if n == 1:\n        return 1\n    if m == 1:\n        return n\n    if m == 2:\n        return n - 1\n    if m == 3:\n        return n - 2\n    if m == 4:\n        return n - 3\n    if m == 5:\n        return n - 4\n    if m == 6:\n        return n - 5\n    if m == 7:\n        return n - 6\n    if m == 8:\n        return n - 7\n    if m == 9:\n        return n - 8\n    if m == 10:\n        return n - 9\n    if m == 11:\n        return n - 10\n    if m == 12:\n        return n - 11\n    if m == 13:\n        return n - 12\n    if m == 14:\n        return n - 13\n    if m == 15:\n        return n - 14\n    if m == 16:\n        return n - 15\n    if m == 17:\n        return n - 16\n    if m == 18:\n        return n - 17\n    if m == 19:\n        return n - 18\n    if m == 20:\n        return n - 19\n    if m == 21:\n        return n - 20\n    if m == 22:\n        return n - 21\n    if m == 23:\n        return n - 22\n    if m == 24:\n        return n - 23\n    if m == 25:\n        return n - 24\n    if m == 26:\n        return n - 25\n    if m == 27:\n        return n - 26\n    if m == 28:\n        return n - 27\n    if m == 29:\n        return n - 28\n    if m == 30:\n        return n - 29\n    if m == 31:\n        return n - 30\n    if m == 32:\n        return n - 31\n    if m == 33:\n        return n - 32\n    if m == 34:\n        return n - 33\n    if m == 35:\n        return n - 34\n    if m == 36:\n        return n - 35\n    if m == 37\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if m == 1:\n        return n\n    if m == 2:\n        return n - abs(rounds[0] - rounds[1])\n    if m == 3:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2])\n    if m == 4:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3])\n    if m == 5:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4])\n    if m == 6:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5])\n    if m == 7:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6])\n    if m == 8:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6]) - abs(rounds[6] - rounds[7])\n    if m == 9:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1\n",
        "def circularTrack(n, m, rounds):\n    # write your code here\n    if m == 1:\n        return n\n    if m == 2:\n        return n - abs(rounds[0] - rounds[1])\n    if m == 3:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2])\n    if m == 4:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3])\n    if m == 5:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4])\n    if m == 6:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5])\n    if m == 7:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6])\n    if m == 8:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6]) - abs(rounds[6] - rounds[7])\n    if m == 9:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1\n",
        "def circularTrack(n, m, rounds):\n    # write your code here\n    if n == 1:\n        return 1\n    if m == 1:\n        return n\n    if m == 2:\n        return n - 1\n    if m == 3:\n        return n - 2\n    if m == 4:\n        return n - 3\n    if m == 5:\n        return n - 4\n    if m == 6:\n        return n - 5\n    if m == 7:\n        return n - 6\n    if m == 8:\n        return n - 7\n    if m == 9:\n        return n - 8\n    if m == 10:\n        return n - 9\n    if m == 11:\n        return n - 10\n    if m == 12:\n        return n - 11\n    if m == 13:\n        return n - 12\n    if m == 14:\n        return n - 13\n    if m == 15:\n        return n - 14\n    if m == 16:\n        return n - 15\n    if m == 17:\n        return n - 16\n    if m == 18:\n        return n - 17\n    if m == 19:\n        return n - 18\n    if m == 20:\n        return n - 19\n    if m == 21:\n        return n - 20\n    if m == 22:\n        return n - 21\n    if m == 23:\n        return n - 22\n    if m == 24:\n        return n - 23\n    if m == 25:\n        return n - 24\n    if m == 26:\n        return n - 25\n    if m == 27:\n        return n - 26\n    if m == 28:\n        return n - 27\n    if m == 29:\n        return n - 28\n    if m == 30:\n        return n - 29\n    if m == 31:\n        return n - 30\n    if m == 32:\n        return n - 31\n    if m == 33:\n        return n - 32\n    if m == 34:\n        return n - 33\n    if m == 35:\n        return n - 34\n    if m == 36:\n        return n - 35\n    if m == 37\n",
        "def circularTrack(n, m, rounds):\n    # write your code here\n    if m == 1:\n        return n\n    if m == 2:\n        return n - abs(rounds[0] - rounds[1])\n    if m == 3:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2])\n    if m == 4:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3])\n    if m == 5:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4])\n    if m == 6:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5])\n    if m == 7:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6])\n    if m == 8:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6]) - abs(rounds[6] - rounds[7])\n    if m == 9:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if n == 1:\n        return 1\n    if m == 1:\n        return n\n    if m == 2:\n        return n - 1\n    if m == 3:\n        return n - 2\n    if m == 4:\n        return n - 3\n    if m == 5:\n        return n - 4\n    if m == 6:\n        return n - 5\n    if m == 7:\n        return n - 6\n    if m == 8:\n        return n - 7\n    if m == 9:\n        return n - 8\n    if m == 10:\n        return n - 9\n    if m == 11:\n        return n - 10\n    if m == 12:\n        return n - 11\n    if m == 13:\n        return n - 12\n    if m == 14:\n        return n - 13\n    if m == 15:\n        return n - 14\n    if m == 16:\n        return n - 15\n    if m == 17:\n        return n - 16\n    if m == 18:\n        return n - 17\n    if m == 19:\n        return n - 18\n    if m == 20:\n        return n - 19\n    if m == 21:\n        return n - 20\n    if m == 22:\n        return n - 21\n    if m == 23:\n        return n - 22\n    if m == 24:\n        return n - 23\n    if m == 25:\n        return n - 24\n    if m == 26:\n        return n - 25\n    if m == 27:\n        return n - 26\n    if m == 28:\n        return n - 27\n    if m == 29:\n        return n - 28\n    if m == 30:\n        return n - 29\n    if m == 31:\n        return:\n        return\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if m == 1:\n        return n\n    else n - 30\n    if m ==urn circularTrack(n, m - 1, rounds) + (ro nds[m - 1] - 3ou2ds[m - 2]):\n        return n - 31\n    if m == 33:\n        return n - 32\n    if m == 34:\n        return n - 33\n    if m == 35:\n        return n - 34\n    if m == 36:\n        return n - 35\n    if m == 37\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if m == 1:\n        return n\n    if m == 2:\n        return n - abs(rounds[0] - rounds[1])\n    if m == 3:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2])\n    if m == 4:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3])\n    if m == 5:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4])\n    if m == 6:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5])\n    if m == 7:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6])\n    if m == 8:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1] - rounds[2]) - abs(rounds[2] - rounds[3]) - abs(rounds[3] - rounds[4]) - abs(rounds[4] - rounds[5]) - abs(rounds[5] - rounds[6]) - abs(rounds[6] - rounds[7])\n    if m == 9:\n        return n - abs(rounds[0] - rounds[1]) - abs(rounds[1\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if n == 1:\n        return 1\n    if m == 1:\n        return 1\n    if m == 2:\n        return 2\n    if m == 3:\n        return 3\n    if m == 4:\n        return 4\n    if m == 5:\n        return 5\n    if m == 6:\n        return 6\n    if m == 7:\n        return 7\n    if m == 8:\n        return 8\n    if m == 9:\n        return 9\n    if m == 10:\n        return 10\n    if m == 11:\n        return 11\n    if m == 12:\n        return 12\n    if m == 13:\n        return 13\n    if m == 14:\n        return 14\n    if m == 15:\n        return 15\n    if m == 16:\n        return 16\n    if m == 17:\n        return 17\n    if m == 18:\n        return 18\n    if m == 19:\n        return 19\n    if m == 20:\n        return 20\n    if m == 21:\n        return 21\n    if m == 22:\n        return 22\n    if m == 23:\n        return 23\n    if m == 24:\n        return 24\n    if m == 25:\n        return 25\n    if m == 26:\n        return 26\n    if m == 27:\n        return 27\n    if m == 28:\n        return 28\n    if m == 29:\n        return 29\n    if m == 30:\n        return 30\n    if m == 31:\n        return 31\n    if m == 32:\n        return 32\n    if m == 33:\n        return 33\n    if m == 34:\n        return 34\n    if m == 35:\n        return 35\n    if m == 36:\n        return 36\n    if m == 37:\n        return 37\n    if m == 38:\n        return 38\n    if m == 39:\n        return 39\n    if m == 40:\n        return 40\n    if m == 41:\n        return 41\n    if m == 42:\n        return 42\n    if m == 43:\n        return\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if m == 1:\n        return n\n    else:\n        return circularTrack(n, m - 1, rounds) + (rounds[m - 1] - rounds[m - 2])\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if n == 1:\n        return 1\n    if m == 1:\n        return n\n    if m == 2:\n        return n - 1\n    if m == 3:\n        return n - 2\n    if m == 4:\n        return n - 3\n    if m == 5:\n        return n - 4\n    if m == 6:\n        return n - 5\n    if m == 7:\n        return n - 6\n    if m == 8:\n        return n - 7\n    if m == 9:\n        return n - 8\n    if m == 10:\n        return n - 9\n    if m == 11:\n        return n - 10\n    if m == 12:\n        return n - 11\n    if m == 13:\n        return n - 12\n    if m == 14:\n        return n - 13\n    if m == 15:\n        return n - 14\n    if m == 16:\n        return n - 15\n    if m == 17:\n        return n - 16\n    if m == 18:\n        return n - 17\n    if m == 19:\n        return n - 18\n    if m == 20:\n        return n - 19\n    if m == 21:\n        return n - 20\n    if m == 22:\n        return n - 21\n    if m == 23:\n        return n - 22\n    if m == 24:\n        return n - 23\n    if m == 25:\n        return n - 24\n    if m == 26:\n        return n - 25\n    if m == 27:\n        return n - 26\n    if m == 28:\n        return n - 27\n    if m == 29:\n        return n - 28\n    if m == 30:\n        return n - 29\n    if m == 31:\n        return n - 30\n    if m == 32:\n        return n - 31\n    if m == 33:\n        return n - 32\n    if m == 34:\n        return n - 33\n    if m == 35:\n        return n - 34\n    if m == 36:\n        return n - 35\n    if m == 37\n",
        "def circularTrack(n, m, rounds):\n    # Write your code here\n    if n == 1:\n        return 1\n    if m == 1:\n        return 1\n    if m == 2:\n        return 2\n    if m == 3:\n        return 3\n    if m == 4:\n        return 4\n    if m == 5:\n        return 5\n    if m == 6:\n        return 6\n    if m == 7:\n        return 7\n    if m == 8:\n        return 8\n    if m == 9:\n        return 9\n    if m == 10:\n        return 10\n    if m == 11:\n        return 11\n    if m == 12:\n        return 12\n    if m == 13:\n        return 13\n    if m == 14:\n        return 14\n    if m == 15:\n        return 15\n    if m == 16:\n        return 16\n    if m == 17:\n        return 17\n    if m == 18:\n        return 18\n    if m == 19:\n        return 19\n    if m == 20:\n        return 20\n    if m == 21:\n        return 21\n    if m == 22:\n        return 22\n    if m == 23:\n        return 23\n    if m == 24:\n        return 24\n    if m == 25:\n        return 25\n    if m == 26:\n        return 26\n    if m == 27:\n        return 27\n    if m == 28:\n        return 28\n    if m == 29:\n        return 29\n    if m == 30:\n        return 30\n    if m == 31:\n        return 31\n    if m == 32:\n        return 32\n    if m == 33:\n        return 33\n    if m == 34:\n        return 34\n    if m == 35:\n        return 35\n    if m == 36:\n        return 36\n    if m == 37:\n        return 37\n    if m == 38:\n        return 38\n    if m == 39:\n        return 39\n    if m == 40:\n        return 40\n    if m == 41:\n        return 41\n    if m == 42:\n        return 42\n    if m == 43:\n        return\n"
    ],
    "results": 10
},{
    "id": "1678",
    "source": "leetcode",
    "language": "python",
    "query": "You must solve the problem without using any built-in library for handling large integers. You must also not convert the inputs to integers directly. Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 & num2 as a string.",
    "snippets": [
        "def addStrings(num1, num2):\n    \"\"\"\n    :type num1: str\n    :type num2: str\n    :rtype: str\n    \"\"\"\n    if len(num1) < len(num2):\n        num1, num2 = num2, num1\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    carry = 0\n    result = []\n    for i in range(len(num1)):\n        if i < len(num2):\n            sum = int(num1[i]) + int(num2[i]) + carry\n        else:\n            sum = int(num1[i]) + carry\n        carry = sum // 10\n        result.append(str(sum % 10))\n    if carry:\n        result.append(str(carry))\n    return ''.join(result[::-1])\n",
        "def addStrings(num1, num2):\n    \"\"\"\n    :type num1: str\n    :type num2: str\n    :rtype: str\n    \"\"\"\n    if len(num1) < len(num2):\n        num1, num2 = num2, num1\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    carry = 0\n    result = ''\n    for i in range(len(num1)):\n        if i < len(num2):\n            temp = int(num1[i]) + int(num2[i]) + carry\n        else:\n            temp = int(num1[i]) + carry\n        carry = temp // 10\n        result += str(temp % 10)\n    if carry:\n        result += str(carry)\n    return result[::-1]\n",
        "def addStrings(num1, num2):\n    \"\"\"\n    :type num1: str\n    :type num2: str\n    :rtype: str\n    \"\"\"\n    if len(num1) < len(num2):\n        num1, num2 = num2, num1\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    carry = 0\n    res = ''\n    for i in range(len(num1)):\n        if i < len(num2):\n            sum = int(num1[i]) + int(num2[i]) + carry\n        else:\n            sum = int(num1[i]) + carry\n        carry = sum // 10\n        res += str(sum % 10)\n    if carry:\n        res += str(carry)\n    return res[::-1]\n",
        "def addStrings(num1, num2):\n    \"\"\"\n    :type num1: str\n    :type num2: str\n    :rtype: str\n    \"\"\"\n    if len(num1) < len(num2):\n        num1, num2 = num2, num1\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    carry = 0\n    res = []\n    for i in range(len(num1)):\n        if i < len(num2):\n            sum = int(num1[i]) + int(num2[i]) + carry\n        else:\n            sum = int(num1[i]) + carry\n        res.append(str(sum % 10))\n        carry = sum // 10\n    if carry:\n        res.append(str(carry))\n    return ''.join(res[::-1])\n",
        "def addStrings(num1, num2):\n    \"\"\"\n    :type num1: str\n    :type num2: str\n    :rtype: str\n    \"\"\"\n    if len(num1) < len(num2):\n        num1, num2 = num2, num1\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    carry = 0\n    res = []\n    for i in range(len(num1)):\n        if i < len(num2):\n            sum = int(num1[i]) + int(num2[i]) + carry\n        else:\n            sum = int(num1[i]) + carry\n        carry = sum // 10\n        res.append(str(sum % 10))\n    if carry:\n        res.append(str(carry))\n    return ''.join(res[::-1])\n",
        "def addStrings(num1, num2):\n    \"\"\"\n    :type num1: str\n    :type num2: str\n    :rtype: str\n    \"\"\"\n    if len(num1) < len(num2):\n        num1, num2 = num2, num1\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    carry = 0\n    result = ''\n    for i in range(len(num1)):\n        if i < len(num2):\n            sum = int(num1[i]) + int(num2[i]) + carry\n        else:\n            sum = int(num1[i]) + carry\n        carry = sum // 10\n        result += str(sum % 10)\n    if carry:\n        result += str(carry)\n    return result[::-1]\n",
        "def addStrings(num1, num2):\n    # Write your code here.\n    if len(num1) < len(num2):\n        num1, num2 = num2, num1\n    num1 = num1[::-1]\n    num2 = num2[::-1]\n    carry = 0\n    result = ''\n    for i in range(len(num1)):\n        if i < len(num2):\n            sum = int(num1[i]) + int(num2[i]) + carry\n        else:\n            sum = int(num1[i]) + carry\n        carry = sum // 10\n        result += str(sum % 10)\n    if carry:\n        result += str(carry)\n    return result[::-1]\n"
    ],
    "results": 10
},{
    "id": "1679",
    "source": "leetcode",
    "language": "python",
    "query": "A Bitset is a data structure that compactly stores bits. The class Bitset Initializes the Bitset with size bits that are 0.",
    "snippets": [
        "def main():\n    b = Bitset(10)\n    b.set(0)\n    b.set(1)\n    b.set(2)\n    b.set(3)\n    b.set(4)\n    b.set(5)\n    b.set(6)\n    b.set(7)\n    b.set(8)\n    b.set(9)\n    print(b)\n    print(b.get(0))\n    print(b.get(1))\n    print(b.get(2))\n    print(b.get(3))\n    print(b.get(4))\n    print(b.get(5))\n    print(b.get(6))\n    print(b.get(7))\n    print(b.get(8))\n    print(b.get(9))\n    print(b.get(10))\n    b.clear(0)\n    b.clear(1)\n    b.clear(2)\n    b.clear(3)\n    b.clear(4)\n    b.clear(5)\n    b.clear(6)\n    b.clear(7)\n    b.clear(8)\n    b.clear(9)\n    print(b)\n    print(b.get(0))\n    print(b.get(1))\n    print(b.get(2))\n    print(b.get(3))\n    print(b.get(4))\n    print(b.get(5))\n    print(b.get(6))\n    print(b.get(7))\n    print(b.get(8))\n    print(b.get(9))\n    print(b.get(10))\n    b.set(0)\n    b.set(1)\n    b.set(2)\n    b.set(3)\n    b.set(4)\n    b.set(5)\n    b.set(6)\n    b.set(7)\n    b.set(8)\n    b.set(9)\n    print(b)\n    print(b.get(0))\n",
        "def main():\n    bitset = Bitset(10)\n    print(bitset)\n    bitset.set(0)\n    bitset.set(1)\n    bitset.set(2)\n    bitset.set(3)\n    bitset.set(4)\n    bitset.set(5)\n    bitset.set(6)\n    bitset.set(7)\n    bitset.set(8)\n    bitset.set(9)\n    print(bitset)\n    bitset.unset(0)\n    bitset.unset(1)\n    bitset.unset(2)\n    bitset.unset(3)\n    bitset.unset(4)\n    bitset.unset(5)\n    bitset.unset(6)\n    bitset.unset(7)\n    bitset.unset(8)\n    bitset.unset(9)\n    print(bitset)\n    bitset.set(0)\n    bitset.set(1)\n    bitset.set(2)\n    bitset.set(3)\n    bitset.set(4)\n    bitset.set(5)\n    bitset.set(6)\n    bitset.set(7)\n    bitset.set(8)\n    bitset.set(9)\n    print(bitset)\n    bitset.unset(0)\n    bitset.unset(1)\n    bitset.unset(2)\n    bitset.unset(3)\n    bitset.unset(4)\n    bitset.unset(5)\n    bitset.unset(6)\n    bitset.unset(7)\n    bitset.unset(8)\n    bitset.unset(9)\n    print(bitset)\n    bitset.set(0)\n    bitset.set(1)\n    bitset.set(2)\n    bitset.set(3)\n    bitset.set(4)\n    bitset.set(5)\n    bitset.set(6)\n    bitset.set(7)\n",
        "def main():\n    bitset = Bitset(10)\n    print(bitset)\n    bitset.set(0)\n    bitset.set(1)\n    bitset.set(2)\n    bitset.set(3)\n    bitset.set(4)\n    bitset.set(5)\n    bitset.set(6)\n    bitset.set(7)\n    bitset.set(8)\n    bitset.set(9)\n    print(bitset)\n    bitset.clear(0)\n    bitset.clear(1)\n    bitset.clear(2)\n    bitset.clear(3)\n    bitset.clear(4)\n    bitset.clear(5)\n    bitset.clear(6)\n    bitset.clear(7)\n    bitset.clear(8)\n    bitset.clear(9)\n    print(bitset)\n    print(bitset.get(0))\n    print(bitset.get(1))\n    print(bitset.get(2))\n    print(bitset.get(3))\n    print(bitset.get(4))\n    print(bitset.get(5))\n    print(bitset.get(6))\n    print(bitset.get(7))\n    print(bitset.get(8))\n    print(bitset.get(9))\n    print(bitset.get(10))\n    print(bitset.get(11))\n    print(bitset.get(12))\n    print(bitset.get(13))\n    print(bitset.get(14))\n    print(bitset.get(15))\n    print(bitset.get(16))\n    print(bitset.get(17))\n    print(bitset.get(18))\n    print(bitset.get(19))\n    print(bitset.get(20))\n    print(bitset.get(21))\n    print(bitset.get(22))\n    print(bitset.get(23))\n    print(bitset.get(24))\n    print(bitset.get(25))\n",
        "def main():\n    b = Bitset(10)\n    b.set(1)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    b.set(9)\n    print(b)\n    print(b.get(1))\n    print(b.get(3))\n    print(b.get(5))\n    print(b.get(7))\n    print(b.get(9))\n    print(b.get(0))\n    print(b.get(2))\n    print(b.get(4))\n    print(b.get(6))\n    print(b.get(8))\n    print(b.get(10))\n    print(b.get(11))\n    print(b.get(12))\n    print(b.get(13))\n    print(b.get(14))\n    print(b.get(15))\n    print(b.get(16))\n    print(b.get(17))\n    print(b.get(18))\n    print(b.get(19))\n    print(b.get(20))\n    print(b.get(21))\n    print(b.get(22))\n    print(b.get(23))\n    print(b.get(24))\n    print(b.get(25))\n    print(b.get(26))\n    print(b.get(27))\n    print(b.get(28))\n    print(b.get(29))\n    print(b.get(30))\n    print(b.get(31))\n    print(b.get(32))\n    print(b.get(33))\n    print(b.get(34))\n    print(b.get(35))\n    print(b.get(36))\n    print(b.get(37))\n    print(b.get(38))\n    print(b.get(39))\n    print(b.get(40))\n    print(b.get(41))\n    print(b.get(42))\n    print(b.get(43))\n",
        "def main():\n    b = Bitset(10)\n    print(b)\n    b.set(3)\n    print(b)\n    b.set(5)\n    print(b)\n    b.set(7)\n    print(b)\n    b.set(9)\n    print(b)\n    b.set(11)\n    print(b)\n    b.set(13)\n    print(b)\n    b.set(15)\n    print(b)\n    b.set(17)\n    print(b)\n    b.set(19)\n    print(b)\n    b.set(21)\n    print(b)\n    b.set(23)\n    print(b)\n    b.set(25)\n    print(b)\n    b.set(27)\n    print(b)\n    b.set(29)\n    print(b)\n    b.set(31)\n    print(b)\n    b.set(33)\n    print(b)\n    b.set(35)\n    print(b)\n    b.set(37)\n    print(b)\n    b.set(39)\n    print(b)\n    b.set(41)\n    print(b)\n    b.set(43)\n    print(b)\n    b.set(45)\n    print(b)\n    b.set(47)\n    print(b)\n    b.set(49)\n    print(b)\n    b.set(51)\n    print(b)\n    b.set(53)\n    print(b)\n    b.set(55)\n    print(b)\n    b.set(57)\n    print(b)\n    b.set(59)\n    print(b)\n    b.set(61)\n    print(b)\n    b.set(63)\n    print(b)\n    b.set(65)\n    print(b)\n    b.set(67)\n    print(b)\n    b.set(69)\n    print(b)\n    b.set(\n",
        "def main():\n    bs = Bitset(10)\n    bs.set(0)\n    bs.set(1)\n    bs.set(2)\n    bs.set(3)\n    bs.set(4)\n    bs.set(5)\n    bs.set(6)\n    bs.set(7)\n    bs.set(8)\n    bs.set(9)\n    print(bs.get(0))\n    print(bs.get(1))\n    print(bs.get(2))\n    print(bs.get(3))\n    print(bs.get(4))\n    print(bs.get(5))\n    print(bs.get(6))\n    print(bs.get(7))\n    print(bs.get(8))\n    print(bs.get(9))\n    print(bs.get(10))\n    bs.clear(0)\n    bs.clear(1)\n    bs.clear(2)\n    bs.clear(3)\n    bs.clear(4)\n    bs.clear(5)\n    bs.clear(6)\n    bs.clear(7)\n    bs.clear(8)\n    bs.clear(9)\n    print(bs.get(0))\n    print(bs.get(1))\n    print(bs.get(2))\n    print(bs.get(3))\n    print(bs.get(4))\n    print(bs.get(5))\n    print(bs.get(6))\n    print(bs.get(7))\n    print(bs.get(8))\n    print(bs.get(9))\n    print(bs.get(10))\n    bs.set(0)\n    bs.set(1)\n    bs.set(2)\n    bs.set(3)\n    bs.set(4)\n    bs.set(5)\n    bs.set(6)\n    bs.set(7)\n    bs.set(8)\n    bs.set\n",
        "def main():\n    bs = Bitset(10)\n    bs.set(1)\n    bs.set(3)\n    bs.set(5)\n    bs.set(7)\n    bs.set(9)\n    print(bs)\n    print(bs.get(1))\n    print(bs.get(3))\n    print(bs.get(5))\n    print(bs.get(7))\n    print(bs.get(9))\n    print(bs.get(0))\n    print(bs.get(2))\n    print(bs.get(4))\n    print(bs.get(6))\n    print(bs.get(8))\n    print(bs.get(10))\n    print(bs.get(11))\n    print(bs.get(12))\n    print(bs.get(13))\n    print(bs.get(14))\n    print(bs.get(15))\n    print(bs.get(16))\n    print(bs.get(17))\n    print(bs.get(18))\n    print(bs.get(19))\n    print(bs.get(20))\n    print(bs.get(21))\n    print(bs.get(22))\n    print(bs.get(23))\n    print(bs.get(24))\n    print(bs.get(25))\n    print(bs.get(26))\n    print(bs.get(27))\n    print(bs.get(28))\n    print(bs.get(29))\n    print(bs.get(30))\n    print(bs.get(31))\n    print(bs.get(32))\n    print(bs.get(33))\n    print(bs.get(34))\n    print(bs.get(35))\n    print(bs.get(36))\n    print(bs.get(37))\n    print(bs.get(38))\n    print(bs.get(39))\n    print(bs.get(40))\n    print(bs.get(41))\n    print(bs.get(42))\n    print(bs.\n",
        "def main():\n    b = Bitset(10)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    print(b)\n    print(b.get(3))\n    print(b.get(5))\n    print(b.get(7))\n    print(b.get(9))\n    b.clear(3)\n    print(b)\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n    b.clear(9)\n    print(b)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    print(b)\n    b.clear()\n    print(b)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    print(b)\n    b.clear(3)\n    print(b)\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n    b.clear(9)\n    print(b)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    print(b)\n    b.clear()\n    print(b)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    print(b)\n    b.clear(3)\n    print(b)\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n    b.clear(9)\n    print(b)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    print(b)\n    b.clear()\n    print(b)\n    b.set(3)\n    b.set(5)\n    b.set(7)\n    print(b)\n    b.clear(3)\n    print(b)\n    b.clear(5)\n    print(b)\n    b.clear(\n",
        "def main():\n    b = Bitset(10)\n    b.set(5)\n    b.set(7)\n    print(b)\n    print(b.get(5))\n    print(b.get(7))\n    print(b.get(8))\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n    b.clear(8)\n    print(b)\n    b.set(5)\n    b.set(7)\n    b.set(8)\n    print(b)\n    print(b.get(5))\n    print(b.get(7))\n    print(b.get(8))\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n    b.clear(8)\n    print(b)\n    b.set(5)\n    b.set(7)\n    b.set(8)\n    print(b)\n    print(b.get(5))\n    print(b.get(7))\n    print(b.get(8))\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n    b.clear(8)\n    print(b)\n    b.set(5)\n    b.set(7)\n    b.set(8)\n    print(b)\n    print(b.get(5))\n    print(b.get(7))\n    print(b.get(8))\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n    b.clear(8)\n    print(b)\n    b.set(5)\n    b.set(7)\n    b.set(8)\n    print(b)\n    print(b.get(5))\n    print(b.get(7))\n    print(b.get(8))\n    b.clear(5)\n    print(b)\n    b.clear(7)\n    print(b)\n"
    ],
    "results": 10
},{
    "id": "1680",
    "source": "leetcode",
    "language": "python",
    "query": "Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.",
    "snippets": [
        "def findPaths(m, n, maxMove, startRow, startColumn):\n    if maxMove == 0:\n        return 1\n    if maxMove < 0 or startRow < 0 or startColumn < 0 or startRow >= m or startColumn >= n:\n        return 0\n    return findPaths(m, n, maxMove - 1, startRow + 1, startColumn) + findPaths(m, n, maxMove - 1, startRow, startColumn + 1)\n",
        "def paths(m, n, maxMove, startRow, startColumn):\n    # Write your code here\n    mod = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[startRow][startColumn] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i - maxMove >= 0:\n                dp[i][j] += dp[i - maxMove][j]\n            if j - maxMove >= 0:\n                dp[i][j] += dp[i][j - maxMove]\n    return dp[m][n] % mod\n",
        "def countPaths(m, n, maxMove, startRow, startColumn):\n    # Write your code here\n    mod = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[startRow][startColumn] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod\n    return dp[m][n] % mod\n",
        "def findPaths(m, n, maxMove, startRow, startColumn):\n    # Write your code here\n    mod = 10**9 + 7\n    dp = [[[0] * (maxMove + 1) for _ in range(n)] for _ in range(m)]\n    dp[0][0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                dp[i][j][0] = dp[i][j - 1][0]\n            elif j == 0:\n                dp[i][j][0] = dp[i - 1][j][0]\n            else:\n                dp[i][j][0] = dp[i - 1][j][0] + dp[i][j - 1][0]\n            for k in range(1, maxMove + 1):\n                if i == 0 and j == 0:\n                    continue\n                if i == 0:\n                    dp[i][j][k] = dp[i][j - 1][k - 1]\n                elif j == 0:\n                    dp[i][j][k] = dp[i - 1][j][k - 1]\n                else:\n                    dp[i][j][k] = (dp[i - 1][j][k - 1] + dp[i][j - 1][k - 1]) % mod\n    return dp[m - 1][n - 1][maxMove]\n",
        "def findPaths(m, n, maxMove, startRow, startColumn):\n    # Write your code here\n    mod = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[startRow][startColumn] = 1\n    for i in range(1, maxMove + 1):\n        for j in range(1, n + 1):\n            for k in range(1, m + 1):\n                dp[k][j] += dp[k - 1][j]\n                dp[k][j] += dp[k][j - 1]\n                dp[k][j] %= mod\n    return dp[m][n]\n",
        "def countPaths(m, n, maxMove, startRow, startColumn):\n    # Write your code here\n    mod = 10**9 + 7\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    dp[startRow][startColumn] = 1\n    for i in range(maxMove):\n        for j in range(m):\n            for k in range(n):\n                if j-1 >= 0:\n                    dp[j][k] += dp[j-1][k]\n                if k-1 >= 0:\n                    dp[j][k] += dp[j][k-1]\n                if j+1 < m:\n                    dp[j][k] += dp[j+1][k]\n                if k+1 < n:\n                    dp[j][k] += dp[j][k+1]\n                dp[j][k] %= mod\n    return dp[-1][-1]\n",
        "def numberOfPaths(m, n, maxMove, startRow, startColumn):\n    # Write your code here\n    mod = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[startRow][startColumn] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i == 1 and j == 1:\n                continue\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % mod\n    return dp[m][n] % mod\n",
        "def findPaths(m, n, maxMove, startRow, startColumn):\n    # Write your code here\n    mod = 109 + 7\n    dp = [[0] * n for _ in range(m)]\n    dp[startRow][startColumn] = 1\n    for i in range(maxMove):\n        dp_ = [[0] * n for _ in range(m)]\n        for j in range(m):\n            for k in range(n):\n                if j - 1 >= 0:\n                    dp_[j][k] += dp[j - 1][k]\n                if j + 1 < m:\n                    dp_[j][k] += dp[j + 1][k]\n                if k - 1 >= 0:\n                    dp_[j][k] += dp[j][k - 1]\n                if k + 1 < n:\n                    dp_[j][k] += dp[j][k + 1]\n        dp = dp_\n    return dp[0][0] % mod\n",
        "def findPaths(m, n, maxMove, startRow, startColumn):\n    # Write your code here.\n    MOD = 1000000007\n    dp = [[0] * n for _ in range(m)]\n    dp[startRow][startColumn] = 1\n    for i in range(maxMove):\n        for j in range(m):\n            for k in range(n):\n                if j - 1 >= 0:\n                    dp[j][k] += dp[j - 1][k]\n                if j + 1 < m:\n                    dp[j][k] += dp[j + 1][k]\n                if k - 1 >= 0:\n                    dp[j][k] += dp[j][k - 1]\n                if k + 1 < n:\n                    dp[j][k] += dp[j][k + 1]\n                dp[j][k] %= MOD\n    return dp[-1][-1]\n"
    ],
    "results": 10
},{
    "id": "1681",
    "source": "leetcode",
    "language": "python",
    "query": "Check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M). Check if there are two indices i and j such that : i != j- 0 <= i, j < arr.length- arr[i] == 2 * arr[j]",
    "snippets": [
        "def checkIfExists(arr):\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j and arr[i] == 2 * arr[j]:\n                return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1682",
    "source": "leetcode",
    "language": "python",
    "query": "You want to change s to t. Changing the ith character of s to ithcharacter of t costs |s[i] - t[i].",
    "snippets": [
        "def edit_distance(s, t):\n    if len(s) == 0:\n        return len(t)\n    if len(t) == 0:\n        return len(s)\n    if s[0] == t[0]:\n        return edit_distance(s[1:], t[1:])\n    else:\n        return 1 + min(edit_distance(s[1:], t), edit_distance(s, t[1:]), edit_distance(s[1:], t[1:]))\n",
        "def edit_distance(s, t):\n    m = len(s)\n    n = len(t)\n    dp = [[0 for i in range(n+1)] for j in range(m+1)]\n    for i in range(m+1):\n        dp[i][0] = i\n    for j in range(n+1):\n        dp[0][j] = j\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n    return dp[m][n]\n",
        "def edit_distance(s, t):\n    m = len(s)\n    n = len(t)\n    dp = [[0 for i in range(n+1)] for j in range(m+1)]\n    for i in range(m+1):\n        dp[i][0] = i\n    for j in range(n+1):\n        dp[0][j] = j\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n    return dp[m][n]\n",
        "def edit_distance(s, t):\n    m = len(s)\n    n = len(t)\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    for i in range(m+1):\n        dp[i][0] = i\n    for j in range(n+1):\n        dp[0][j] = j\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if s[i-1] == t[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1\n    return dp[m][n]\n",
        "def minCost(s, t):\n    if len(s) != len(t):\n        return -1\n    if s == t:\n        return 0\n    dp = [[0 for i in range(len(s))] for j in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = abs(ord(s[i]) - ord(t[i]))\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            dp[i][j] = min(dp[i][j - 1] + abs(ord(s[j]) - ord(t[j])), dp[i + 1][j] + abs(ord(s[i]) - ord(t[i])))\n    return dp[0][-1]\n",
        "def change(s, t):\n    if len(s) != len(t):\n        return False\n    if s == t:\n        return 0\n    cost = 0\n    for i in range(len(s)):\n        if s[i] != t[i]:\n            cost += abs(ord(s[i]) - ord(t[i]))\n    return cost\n",
        "def edit_distance(s, t):\n    # Write your code here.\n    m = len(s)\n    n = len(t)\n    dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n    return dp[m][n]\n"
    ],
    "results": 10
},{
    "id": "1683",
    "source": "leetcode",
    "language": "python",
    "query": "A path from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk] such that z0 = start and zk = end. Distance of a path is the sum of the weights on the edges of the path.",
    "snippets": [
        "def dijkstra(graph, start, end):\n    distances = {}\n    previous = {}\n    for node in graph:\n        distances[node] = float('inf')\n        previous[node] = None\n    distances[start] = 0\n    queue = [start]\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            alt = distances[node] + graph[node][neighbor]\n            if alt < distances[neighbor]:\n                distances[neighbor] = alt\n                previous[neighbor] = node\n                queue.append(neighbor)\n    path = []\n    node = end\n    while node is not None:\n        path.append(node)\n        node = previous[node]\n    return path[::-1], distances[end]\n",
        "def dijkstra(graph, start, end):\n    # Initialize the distance of start node to itself to 0\n    distance = {start: 0}\n    # Initialize the visited nodes to empty set\n    visited = set()\n    # Initialize the priority queue to empty list\n    queue = []\n    # Add the start node to the priority queue\n    heapq.heappush(queue, (0, start))\n    # While the priority queue is not empty\n    while queue:\n        # Pop the first node from the priority queue\n        node = heapq.heappop(queue)[1]\n        # If the node is not visited\n        if node not in visited:\n            # Add the node to the visited nodes\n            visited.add(node)\n            # For each neighbor of the node\n            for neighbor, weight in graph[node].items():\n                # If the neighbor is not visited\n                if neighbor not in visited:\n                    # If the distance of the neighbor is not initialized\n                    if neighbor not in distance:\n                        # Set the distance of the neighbor to the distance of the node plus the weight of the edge\n                        distance[neighbor] = distance[node] + weight\n                        # Add the neighbor to the priority queue\n                        heapq.heappush(queue, (distance[neighbor], neighbor))\n    # Return the distance of the end node\n    return distance[end]\n",
        "def dijkstra(graph, start, end):\n    distances = {}\n    for node in graph:\n        distances[node] = float('inf')\n    distances[start] = 0\n    unvisited = set(distances.keys())\n    while unvisited:\n        current = min(unvisited, key=lambda x: distances[x])\n        if current == end:\n            return distances[current]\n        unvisited.remove(current)\n        for neighbor, weight in graph[current].items():\n            if distances[neighbor] > distances[current] + weight:\n                distances[neighbor] = distances[current] + weight\n    return float('inf')\n",
        "def find_path(start, end, graph):\n    # Your code here\n    if start == end:\n        return [start]\n    if start not in graph:\n        return None\n    if end not in graph[start]:\n        return None\n    path = [start]\n    for node in graph[start]:\n        if node == end:\n            path.append(node)\n            return path\n        else:\n            path.append(node)\n            new_path = find_path(node, end, graph)\n            if new_path:\n                path.extend(new_path)\n                return path\n    return None\n",
        "def dijkstra(start, end, graph):\n    # Initialize the distance of start node to itself as 0\n    distance = {start: 0}\n    # Initialize the visited nodes as empty set\n    visited = set()\n    # Initialize the unvisited nodes as all nodes in the graph\n    unvisited = set(graph.keys())\n    # Initialize the predecessor of start node as None\n    predecessor = {start: None}\n    # Initialize the priority queue as a min heap\n    queue = []\n    # Add the start node to the queue\n    heapq.heappush(queue, (0, start))\n    # Loop until the queue is empty\n    while queue:\n        # Pop the node with the minimum distance from the queue\n        node = heapq.heappop(queue)[1]\n        # Add the node to the visited nodes\n        visited.add(node)\n        # Remove the node from the unvisited nodes\n        unvisited.remove(node)\n        # If the node is the end node, break the loop\n        if node == end:\n            break\n        # Loop through all the neighbors of the node\n        for neighbor, weight in graph[node].items():\n            # If the neighbor is not visited\n            if neighbor not in visited:\n                # If the neighbor is not in the queue\n                if neighbor not in unvisited:\n                    # Add the neighbor to the queue\n                    heapq.heappush(queue, (weight, neighbor))\n                    # Update the predecessor of the neighbor\n                    predecessor[neighbor] = node\n                    # Update the distance of the neighbor\n                    distance[neighbor] = weight\n    # If the end node is not visited\n    if end not in visited:\n        # Return None\n        return None\n    # Initialize the path as empty list\n    path = []\n    # Loop until the end node is not None\n    while end is not None:\n        # Add the end node to the path\n        path.append(end)\n        # Update the end node to the predecessor of the end node\n        end = predecessor[end]\n    # Reverse the path\n    path.reverse()\n    # Return the path\n    return path, distance\n",
        "def find_path(start, end, graph):\n    # your code here\n    if start == end:\n        return [start]\n    if start not in graph:\n        return None\n    if end not in graph[start]:\n        return None\n    path = [start]\n    while path[-1] != end:\n        path.append(graph[path[-1]].pop())\n    return path\n",
        "def dijkstra(graph, start, end):\n    # Initialize the distance of all nodes to infinity.\n    distance = {node: float('inf') for node in graph}\n    # Initialize the distance of the start node to 0.\n    distance[start] = 0\n    # Initialize the path of all nodes to None.\n    path = {node: None for node in graph}\n    # Initialize the set of unvisited nodes.\n    unvisited = set(graph)\n    # While there are unvisited nodes.\n    while unvisited:\n        # Find the node with the smallest distance.\n        current = min(unvisited, key=lambda x: distance[x])\n        # If the current node is the end node, return the path.\n        if current == end:\n            return distance[end], path[end]\n        # Remove the current node from the unvisited set.\n        unvisited.remove(current)\n        # For each neighbor of the current node.\n        for neighbor in graph[current]:\n            # If the distance to the neighbor is infinite.\n            if distance[neighbor] == float('inf'):\n                # Set the distance to the neighbor to the distance to the current node plus the weight of the edge.\n                distance[neighbor] = distance[current] + graph[current][neighbor]\n                # Set the path to the neighbor to the current node.\n                path[neighbor] = current\n    # If there is no path, return None.\n    return None\n",
        "def dijkstra(graph, start, end):\n    # Initialize the distance of each node to infinity\n    distance = {node: float('inf') for node in graph}\n    # Initialize the distance of the start node to 0\n    distance[start] = 0\n    # Initialize the path of each node to None\n    path = {node: None for node in graph}\n    # Initialize the set of unvisited nodes\n    unvisited = set(graph.keys())\n    # While there are unvisited nodes\n    while unvisited:\n        # Get the node with the smallest distance\n        current = min(unvisited, key=lambda node: distance[node])\n        # If the current node is the end node, return the path\n        if current == end:\n            return distance[end], path[end]\n        # Remove the current node from the unvisited set\n        unvisited.remove(current)\n        # For each neighbor of the current node\n        for neighbor, weight in graph[current].items():\n            # If the distance to the neighbor is greater than the distance to the current node plus the weight of the edge\n            if distance[neighbor] > distance[current] + weight:\n                # Update the distance to the neighbor\n                distance[neighbor] = distance[current] + weight\n                # Update the path to the neighbor\n                path[neighbor] = current\n    # If there is no path, return None\n    return None\n",
        "def dijkstra(graph, start, end):\n    # Initialize the distance of start node to itself as 0\n    dist = {start: 0}\n    # Initialize the visited nodes as empty set\n    visited = set()\n    # Initialize the parent nodes as empty dictionary\n    parent = {}\n    # Initialize the priority queue as empty list\n    pq = []\n    # Add the start node to the priority queue\n    heapq.heappush(pq, (0, start))\n    # While the priority queue is not empty\n    while pq:\n        # Pop the first node from the priority queue\n        node = heapq.heappop(pq)[1]\n        # If the node is not visited\n        if node not in visited:\n            # Add the node to the visited nodes\n            visited.add(node)\n            # For each neighbor of the node\n            for neighbor, weight in graph[node].items():\n                # If the neighbor is not visited\n                if neighbor not in visited:\n                    # If the distance of the neighbor is not initialized\n                    if neighbor not in dist:\n                        # Initialize the distance of the neighbor as the distance of the node plus the weight of the edge\n                        dist[neighbor] = dist[node] + weight\n                        # Initialize the parent of the neighbor as the node\n                        parent[neighbor] = node\n                        # Add the neighbor to the priority queue\n                        heapq.heappush(pq, (dist[neighbor], neighbor))\n    # If the end node is not visited\n    if end not in visited:\n        # Return None\n        return None\n    # Initialize the path as empty list\n    path = []\n    # Initialize the current node as the end node\n    current = end\n    # While the current node is not the start node\n    while current != start:\n        # Add the current node to the path\n        path.append(current)\n        # Set the current node to the parent of the current node\n        current = parent[current]\n    # Add the start node to the path\n    path.append(start)\n    # Reverse the path\n    path.reverse()\n    # Return the path\n    return path\n",
        "def dijkstra(start, end, graph):\n    # Initialize the distance of each node to infinity\n    distance = dict()\n    for node in graph:\n        distance[node] = float('inf')\n    # Initialize the distance of the start node to 0\n    distance[start] = 0\n    # Initialize the set of visited nodes to empty\n    visited = set()\n    # Initialize the set of unvisited nodes to all nodes\n    unvisited = set(graph.keys())\n    # Initialize the set of nodes to be visited to the set of unvisited nodes\n    nodes = unvisited\n    # While there are nodes to be visited\n    while nodes:\n        # Initialize the current node to the node with the smallest distance from the start node\n        current = min(nodes, key=lambda x: distance[x])\n        # If the current node is the end node, return the distance of the end node\n        if current == end:\n            return distance[end]\n        # Remove the current node from the set of unvisited nodes\n        unvisited.remove(current)\n        # Add the current node to the set of visited nodes\n        visited.add(current)\n        # For each neighbor of the current node\n        for neighbor in graph[current]:\n            # If the neighbor is not visited\n            if neighbor not in visited:\n                # If the distance of the neighbor is greater than the distance of the current node plus the weight of the edge between the current node and the neighbor\n                if distance[neighbor] > distance[current] + graph[current][neighbor]:\n                    # Update the distance of the neighbor to the distance of the current node plus the weight of the edge between the current node and the neighbor\n                    distance[neighbor] = distance[current] + graph[current][neighbor]\n        # Remove the current node from the set of nodes to be visited\n        nodes.remove(current)\n    # If the end node is not visited, return infinity\n    if end not in visited:\n        return float('inf')\n    # Return the distance of the end node\n    return distance[end]\n"
    ],
    "results": 10
},{
    "id": "1684",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. Test cases are generated so that the answer will be less than or equal to 2 * 109.",
    "snippets": [
        "def uniquePaths(m, n):\n    if m == 1 or n == 1:\n        return 1\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1)\n",
        "def uniquePaths(m, n):\n    \"\"\"\n    :type m: int\n    :type n: int\n    :rtype: int\n    \"\"\"\n    if m == 1 or n == 1:\n        return 1\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1)\n"
    ],
    "results": 10
},{
    "id": "1685",
    "source": "leetcode",
    "language": "python",
    "query": "Given a collection of candidate numbers and a target number, find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.",
    "snippets": [
        "def combination_sum2(candidates, target):\n    candidates.sort()\n    res = []\n    dfs(candidates, target, 0, [], res)\n    return res\n",
        "def combination_sum2(candidates, target):\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res\n",
        "def combinationSum2(candidates, target):\n    candidates.sort()\n    res = []\n    dfs(candidates, target, 0, [], res)\n    return res\n",
        "def combination_sum(candidates, target):\n    res = []\n    candidates.sort()\n    dfs(candidates, target, 0, [], res)\n    return res\n",
        "def combination_sum2(candidates, target):\n    res = []\n    candidates.sort()\n    def dfs(candidates, target, path):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(len(candidates)):\n            if i > 0 and candidates[i] == candidates[i-1]:\n                continue\n            if target - candidates[i] >= 0:\n                dfs(candidates[i+1:], target - candidates[i], path + [candidates[i]])\n    dfs(candidates, target, [])\n    return res\n"
    ],
    "results": 10
},{
    "id": "1686",
    "source": "leetcode",
    "language": "python",
    "query": "A target index is an index i such that nums[i] == target. Return a list of the target indices of nums after sorting nums in non-decreasing order.",
    "snippets": [
        "def searchRange(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return [-1, -1]\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    if nums[left] != target:\n        return [-1, -1]\n    left = left\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2 + 1\n        if nums[mid] > target:\n            right = mid - 1\n        else:\n            left = mid\n    return [left, right]\n",
        "def searchRange(nums, target):\n    if len(nums) == 0:\n        return [-1, -1]\n    if len(nums) == 1:\n        if nums[0] == target:\n            return [0, 0]\n        else:\n            return [-1, -1]\n    if nums[0] > target or nums[-1] < target:\n        return [-1, -1]\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            left = mid\n            break\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    if nums[left] != target:\n        return [-1, -1]\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2 + 1\n        if nums[mid] == target:\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid\n        else:\n            right = mid - 1\n    return [left, right]\n",
        "def find_target_index(nums, target):\n    nums.sort()\n    i = 0\n    j = len(nums) - 1\n    while i < j:\n        if nums[i] + nums[j] < target:\n            i += 1\n        elif nums[i] + nums[j] > target:\n            j -= 1\n        else:\n            return [i, j]\n    return []\n",
        "def find_target_indices(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    nums.sort()\n    result = []\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] > target:\n            right -= 1\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            result.append(left)\n            result.append(right)\n            left += 1\n            right -= 1\n    return result\n",
        "def find_target_indices(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums)):\n        if nums[i] == target:\n            result.append(i)\n    return result\n",
        "def find_target_indices(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        if nums[i] > target:\n            break\n        if nums[i] == target:\n            result.append(i)\n    return result\n",
        "def find_target_indices(nums, target):\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] > target:\n            right -= 1\n        elif nums[left] + nums[right] < target:\n            left += 1\n        else:\n            return [left, right]\n    return []\n",
        "def search_index(nums, target):\n    if not nums:\n        return []\n    if len(nums) == 1:\n        return [0] if nums[0] == target else []\n    nums.sort()\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return [mid]\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return [left] if nums[left] == target else []\n",
        "def find_target_indices(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        if nums[i] == target:\n            result.append(i)\n    return result\n"
    ],
    "results": 10
},{
    "id": "1687",
    "source": "leetcode",
    "language": "python",
    "query": "Given two binary strings a and b, return their sum as a binary string.",
    "snippets": [
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    c = ''\n    carry = 0\n    for i in range(len(a)):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                c += '1'\n                carry = 1\n            else:\n                c += '0'\n                carry = 1\n        elif a[i] == '1' or b[i] == '1':\n            if carry == 1:\n                c += '0'\n                carry = 1\n            else:\n                c += '1'\n                carry = 0\n        else:\n            if carry == 1:\n                c += '1'\n                carry = 0\n            else:\n                c += '0'\n                carry = 0\n    if carry == 1:\n        c += '1'\n    return c\n",
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    res = ''\n    carry = 0\n    for i in range(len(a)):\n        if a[-i-1] == '1' and b[-i-1] == '1':\n            if carry == 1:\n                res = '1' + res\n                carry = 1\n            else:\n                res = '0' + res\n                carry = 1\n        elif a[-i-1] == '1' or b[-i-1] == '1':\n            if carry == 1:\n                res = '0' + res\n                carry = 1\n            else:\n                res = '1' + res\n                carry = 0\n        else:\n            if carry == 1:\n                res = '1' + res\n                carry = 0\n            else:\n                res = '0' + res\n                carry = 0\n    if carry == 1:\n        res = '1' + res\n    return res\n",
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    c = ''\n    carry = 0\n    for i in range(len(a)):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                c += '1'\n                carry = 1\n            else:\n                c += '0'\n                carry = 1\n        elif a[i] == '0' and b[i] == '0':\n            if carry == 1:\n                c += '1'\n                carry = 0\n            else:\n                c += '0'\n                carry = 0\n        else:\n            if carry == 1:\n                c += '0'\n                carry = 1\n            else:\n                c += '1'\n                carry = 0\n    if carry == 1:\n        c += '1'\n    return c\n",
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    res = ''\n    carry = 0\n    for i in range(len(a) - 1, -1, -1):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                res = '1' + res\n                carry = 1\n            else:\n                res = '0' + res\n                carry = 1\n        elif a[i] == '0' and b[i] == '0':\n            if carry == 1:\n                res = '1' + res\n                carry = 0\n            else:\n                res = '0' + res\n                carry = 0\n        else:\n            if carry == 1:\n                res = '0' + res\n                carry = 1\n            else:\n                res = '1' + res\n                carry = 0\n    if carry == 1:\n        res = '1' + res\n    return res\n",
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    carry = 0\n    result = ''\n    for i in range(len(a) - 1, -1, -1):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                result = '1' + result\n                carry = 1\n            else:\n                result = '0' + result\n                carry = 1\n        elif a[i] == '1' or b[i] == '1':\n            if carry == 1:\n                result = '0' + result\n                carry = 1\n            else:\n                result = '1' + result\n                carry = 0\n        else:\n            if carry == 1:\n                result = '1' + result\n                carry = 0\n            else:\n                result = '0' + result\n                carry = 0\n    if carry == 1:\n        result = '1' + result\n    return result\n",
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    res = ''\n    carry = 0\n    for i in range(len(a)):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                res += '1'\n                carry = 1\n            else:\n                res += '0'\n                carry = 1\n        elif a[i] == '1' or b[i] == '1':\n            if carry == 1:\n                res += '0'\n                carry = 1\n            else:\n                res += '1'\n                carry = 0\n        else:\n            if carry == 1:\n                res += '1'\n                carry = 0\n            else:\n                res += '0'\n                carry = 0\n    if carry == 1:\n        res += '1'\n    return res\n",
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) > len(b):\n        b = '0' * (len(a) - len(b)) + b\n    else:\n        a = '0' * (len(b) - len(a)) + a\n    carry = 0\n    res = ''\n    for i in range(len(a) - 1, -1, -1):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                res = '1' + res\n                carry = 1\n            else:\n                res = '0' + res\n                carry = 1\n        elif a[i] == '1' or b[i] == '1':\n            if carry == 1:\n                res = '0' + res\n                carry = 1\n            else:\n                res = '1' + res\n                carry = 0\n        else:\n            if carry == 1:\n                res = '1' + res\n                carry = 0\n            else:\n                res = '0' + res\n                carry = 0\n    if carry == 1:\n        res = '1' + res\n    return res\n",
        "def addBinary(a, b):\n    \"\"\"\n    :type a: str\n    :type b: str\n    :rtype: str\n    \"\"\"\n    if len(a) > len(b):\n        b = '0' * (len(a) - len(b)) + b\n    else:\n        a = '0' * (len(b) - len(a)) + a\n    carry = 0\n    result = ''\n    for i in range(len(a) - 1, -1, -1):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                result = '1' + result\n                carry = 1\n            else:\n                result = '0' + result\n                carry = 1\n        elif a[i] == '1' or b[i] == '1':\n            if carry == 1:\n                result = '0' + result\n                carry = 1\n            else:\n                result = '1' + result\n                carry = 0\n        else:\n            if carry == 1:\n                result = '1' + result\n                carry = 0\n            else:\n                result = '0' + result\n                carry = 0\n    if carry == 1:\n        result = '1' + result\n    return result\n",
        "def addBinary(a, b):\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    c = ''\n    carry = 0\n    for i in range(len(a)):\n        if a[i] == '1' and b[i] == '1':\n            if carry == 1:\n                c += '1'\n                carry = 1\n            else:\n                c += '0'\n                carry = 1\n        elif a[i] == '0' and b[i] == '0':\n            if carry == 1:\n                c += '1'\n                carry = 0\n            else:\n                c += '0'\n                carry = 0\n        else:\n            if carry == 1:\n                c += '0'\n                carry = 1\n            else:\n                c += '1'\n                carry = 0\n    if carry == 1:\n        c += '1'\n    return c\n",
        "def addBinary(a, b):\n    if len(a) < len(b):\n        a, b = b, a\n    a = a.zfill(len(b))\n    b = b.zfill(len(a))\n    carry = 0\n    result = ''\n    for i in range(len(a)):\n        if a[-i-1] == '1' and b[-i-1] == '1':\n            if carry == 1:\n                result = '1' + result\n                carry = 1\n            else:\n                result = '0' + result\n                carry = 1\n        elif a[-i-1] == '1' or b[-i-1] == '1':\n            if carry == 1:\n                result = '0' + result\n                carry = 1\n            else:\n                result = '1' + result\n                carry = 0\n        else:\n            if carry == 1:\n                result = '1' + result\n                carry = 0\n            else:\n                result = '0' + result\n                carry = 0\n    if carry == 1:\n        result = '1' + result\n    return result\n"
    ],
    "results": 10
},{
    "id": "1688",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "snippets": [
        "def permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    res = []\n    for i in range(len(nums)):\n        for j in permute(nums[:i] + nums[i+1:]):\n            res.append([nums[i]] + j)\n    return res\n",
        "def permute(nums):\n    if len(nums) == 0:\n        return []\n    if len(nums) == 1:\n        return [nums]\n    result = []\n    for i in range(len(nums)):\n        temp = nums[i]\n        nums.remove(temp)\n        for j in permute(nums):\n            result.append([temp] + j)\n        nums.insert(i, temp)\n    return result\n",
        "def permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    result = []\n    for i in range(len(nums)):\n        for j in permute(nums[:i] + nums[i+1:]):\n            result.append([nums[i]] + j)\n    return result\n",
        "def permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    result = []\n    for i in range(len(nums)):\n        sub_nums = nums[:i] + nums[i+1:]\n        sub_result = permute(sub_nums)\n        for j in range(len(sub_result)):\n            result.append([nums[i]] + sub_result[j])\n    return result\n",
        "def permute(nums):\n    if len(nums) <= 1:\n        return [nums]\n    result = []\n    for i in range(len(nums)):\n        sub_nums = nums[:i] + nums[i+1:]\n        sub_result = permute(sub_nums)\n        for j in sub_result:\n            result.append([nums[i]] + j)\n    return result\n",
        "def permute(nums):\n    return [[n] + p for i, n in enumerate(nums) for p in permute(nums[:i] + nums[i + 1:])] or [[]]\n"
    ],
    "results": 10
},{
    "id": "1689",
    "source": "leetcode",
    "language": "python",
    "query": "A binary tree is named Even-Odd if it meets the following conditions. For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right)",
    "snippets": [
        "def isEvenOdd(root):\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None:\n        return isEvenOdd(root.right) and root.val % 2 == 1\n    if root.right is None:\n        return isEvenOdd(root.left) and root.val % 2 == 0\n    return isEvenOdd(root.left) and isEvenOdd(root.right) and root.val % 2 == 0\n",
        "def is_even_odd(tree):\n    if tree is None:\n        return True\n    if tree.left is None and tree.right is None:\n        return True\n    if tree.left is None:\n        return is_even_odd(tree.right)\n    if tree.right is None:\n        return is_even_odd(tree.left)\n    return is_even_odd(tree.left) and is_even_odd(tree.right)\n",
        "def is_even_odd(tree):\n    if tree is None:\n        return True\n    if tree.left is None and tree.right is None:\n        return True\n    if tree.left is None:\n        return is_even_odd(tree.right)\n    if tree.right is None:\n        return is_even_odd(tree.left)\n    if tree.left.value % 2 == 0 and tree.right.value % 2 == 0:\n        return False\n    if tree.left.value % 2 == 0:\n        return is_even_odd(tree.right)\n    if tree.right.value % 2 == 0:\n        return is_even_odd(tree.left)\n    return is_even_odd(tree.left) and is_even_odd(tree.right)\n",
        "def is_even_odd(tree):\n    if tree is None:\n        return True\n    if tree.left is not None and tree.left.value % 2 == 0:\n        return False\n    if tree.right is not None and tree.right.value % 2 == 0:\n        return False\n    return is_even_odd(tree.left) and is_even_odd(tree.right)\n",
        "def is_even_odd(tree):\n    if tree is None:\n        return True\n    if tree.left is not None and tree.left.value % 2 == 0:\n        return False\n    if tree.right is not None and tree.right.value % 2 == 0:\n        return False\n    if tree.left is not None and tree.right is not None:\n        return is_even_odd(tree.left) and is_even_odd(tree.right)\n    if tree.left is None and tree.right is not None:\n        return is_even_odd(tree.right)\n    if tree.left is not None and tree.right is None:\n        return is_even_odd(tree.left)\n    return True\n",
        "def is_even_odd(tree):\n    if not tree:\n        return True\n    if tree.left and tree.left.value % 2 == 0:\n        return False\n    if tree.right and tree.right.value % 2 == 0:\n        return False\n    return is_even_odd(tree.left) and is_even_odd(tree.right)\n"
    ],
    "results": 10
},{
    "id": "1690",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator.",
    "snippets": [
        "def minOperations(startValue, target):\n    # Write your code here.\n    if startValue == target:\n        return 0\n    if startValue > target:\n        return -1\n    if startValue < target:\n        return 1 + minOperations(startValue + 5, target)\n    return 0\n",
        "def minOperations(startValue, target):\n    # Write your code here.\n    if startValue == target:\n        return 0\n    if startValue > target:\n        return -1\n    if startValue < target:\n        return 1 + minOperations(startValue + 5, target)\n    return -1\n",
        "def minOperations(startValue, target):\n    # Write your code here.\n    if startValue > target:\n        return -1\n    if startValue == target:\n        return 0\n    if startValue < target:\n        return 1 + minOperations(startValue + 1, target)\n    return -1\n",
        "def minOperations(startValue, target):\n    # Write your code here.\n    if startValue > target:\n        return -1\n    if startValue == target:\n        return 0\n    if startValue < target:\n        return 1 + minOperations(startValue + startValue, target)\n    return -1\n",
        "def minOperations(startValue, target):\n    # Write your code here.\n    if startValue > target:\n        return -1\n    if startValue == target:\n        return 0\n    if startValue < target:\n        return 1 + minOperations(startValue + startValue, target)\n",
        "def minOperations(startValue, target):\n    # Write your code here.\n    count = 0\n    while startValue < target:\n        startValue *= 2\n        count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "1691",
    "source": "leetcode",
    "language": "python",
    "query": "A distinct string is a string that is present only once in an array. Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string \"\".",
    "snippets": [
        "def kth_distinct(arr, k):\n    distinct = []\n    for i in arr:\n        if i not in distinct:\n            distinct.append(i)\n    if len(distinct) < k:\n        return \"\"\n    else:\n        return distinct[k-1]\n",
        "def distinct_string(arr, k):\n    distinct = []\n    for i in arr:\n        if i not in distinct:\n            distinct.append(i)\n    if len(distinct) < k:\n        return \"\"\n    else:\n        return distinct[k-1]\n",
        "def distinct_string(arr, k):\n    distinct = []\n    for i in arr:\n        if i not in distinct:\n            distinct.append(i)\n    if len(distinct) < k:\n        return \"\"\n    return distinct[k-1]\n",
        "def kth_distinct(arr, k):\n    distinct = set()\n    for i in arr:\n        if i not in distinct:\n            distinct.add(i)\n            if len(distinct) == k:\n                return i\n    return \"\"\n",
        "def kth_distinct(arr, k):\n    distinct = set()\n    for word in arr:\n        if word not in distinct:\n            distinct.add(word)\n            if len(distinct) == k:\n                return word\n    return \"\"\n",
        "def kth_distinct(arr, k):\n    return \"\"\n"
    ],
    "results": 10
},{
    "id": "1692",
    "source": "leetcode",
    "language": "python",
    "query": "There is a bi-directional graph with n vertices. The edges in the graph are represented as a 2D integer array edges. You want to determine if there is a valid path from source to destination.",
    "snippets": [
        "def isValidPath(edges, source, destination):\n    # Write your code here.\n    if source == destination:\n        return True\n    visited = set()\n    queue = [source]\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        for i, j in edges:\n            if i == node and j not in visited:\n                queue.append(j)\n            if j == node and i not in visited:\n                queue.append(i)\n    return destination in visited\n",
        "def isValidPath(edges, source, destination):\n    # Write your code here.\n    if source == destination:\n        return True\n    visited = set()\n    queue = [source]\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        for n in edges[node]:\n            if n == destination:\n                return True\n            queue.append(n)\n    return False\n",
        "def isValidPath(edges, source, destination):\n    # Write your code here.\n    if source == destination:\n        return True\n    visited = set()\n    queue = [source]\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        for child in edges[node]:\n            if child == destination:\n                return True\n            queue.append(child)\n    return False\n",
        "def isValidPath(edges, source, destination):\n    # Write your code here.\n    if source == destination:\n        return True\n    visited = set()\n    queue = [source]\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for child in edges[node]:\n                queue.append(child)\n    return destination in visited\n",
        "def isValidPath(edges, source, destination):\n    # Write your code here.\n    if source == destination:\n        return True\n    visited = set()\n    queue = [source]\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        for edge in edges:\n            if node == edge[0]:\n                if edge[1] == destination:\n                    return True\n                queue.append(edge[1])\n    return False\n",
        "def isValidPath(edges, source, destination):\n    # Write your code here.\n    if source == destination:\n        return True\n    visited = set()\n    queue = [source]\n    while queue:\n        node = queue.pop(0)\n        if node not in visited:\n            visited.add(node)\n            for child in edges[node]:\n                if child == destination:\n                    return True\n                queue.append(child)\n    return False\n",
        "def is_valid_path(edges, source, destination):\n    # Write your code here.\n    visited = set()\n    queue = [source]\n    while queue:\n        node = queue.pop(0)\n        if node == destination:\n            return True\n        if node not in visited:\n            visited.add(node)\n            for child in edges[node]:\n                queue.append(child)\n    return False\n"
    ],
    "results": 9
},{
    "id": "1693",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.",
    "snippets": [
        "def titleToNumber(columnTitle):\n    res = 0\n    for i in range(len(columnTitle)):\n        res += (ord(columnTitle[i]) - ord('A') + 1) * 26 ** (len(columnTitle) - i - 1)\n    return res\n",
        "def titleToNumber(columnTitle):\n    num = 0\n    for i in range(len(columnTitle)):\n        num += (ord(columnTitle[i]) - ord('A') + 1) * 26 ** (len(columnTitle) - i - 1)\n    return num\n",
        "def titleToNumber(columnTitle):\n    columnTitle = columnTitle.upper()\n    columnNumber = 0\n    for i in range(len(columnTitle)):\n        columnNumber += (ord(columnTitle[i]) - ord('A') + 1) * 26 ** (len(columnTitle) - i - 1)\n    return columnNumber\n",
        "def titleToNumber(columnTitle):\n    columnNumber = 0\n    for i in range(len(columnTitle)):\n        columnNumber += (ord(columnTitle[i]) - ord('A') + 1) * 26 ** (len(columnTitle) - i - 1)\n    return columnNumber\n",
        "def titleToNumber(columnTitle):\n    columnNumber = 0\n    for i in range(len(columnTitle)):\n        columnNumber += (ord(columnTitle[i]) - ord('A') + 1) * (26 ** (len(columnTitle) - i - 1))\n    return columnNumber\n",
        "def titleToNumber(columnTitle):\n    return sum(ord(c) - ord('A') + 1 for c in columnTitle)\n",
        "def titleToNumber(columnTitle):\n    return sum(ord(c) - 64 for c in columnTitle)\n"
    ],
    "results": 10
},{
    "id": "1694",
    "source": "leetcode",
    "language": "python",
    "query": "Given a root and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.",
    "snippets": [
        "def find_two_sum(root, k):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return False\n    if root.left is None:\n        return find_two_sum(root.right, k - root.val)\n    if root.right is None:\n        return find_two_sum(root.left, k - root.val)\n    return find_two_sum(root.left, k - root.val) or find_two_sum(root.right, k - root.val)\n",
        "def find_sum(root, k):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return k == root.val\n    return find_sum(root.left, k - root.val) or find_sum(root.right, k - root.val)\n",
        "def findTarget(root, k):\n    if root is None:\n        return False\n    return findTargetHelper(root, k, set())\n",
        "def find_two_sum(root, k):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return k == root.val\n    if root.left is None:\n        return find_two_sum(root.right, k - root.val)\n    if root.right is None:\n        return find_two_sum(root.left, k - root.val)\n    return find_two_sum(root.left, k - root.val) or find_two_sum(root.right, k - root.val)\n",
        "def find_two_sum(root, k):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return root.val == k\n    return find_two_sum(root.left, k - root.val) or find_two_sum(root.right, k - root.val)\n",
        "def find_two_sum_bst(root, k):\n    if root is None:\n        return False\n    return find_two_sum_bst_helper(root, k)\n"
    ],
    "results": 10
},{
    "id": "1695",
    "source": "leetcode",
    "language": "python",
    "query": "You are given four integers row, cols, rCenter, and cCenter. Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance.",
    "snippets": [
        "def matrixElementsSum(matrix):\n    sum = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 0:\n                for k in range(i, len(matrix)):\n                    matrix[k][j] = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            sum += matrix[i][j]\n    return sum\n",
        "def matrixElementsSum(matrix):\n    sum = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 0:\n                break\n            else:\n                sum += matrix[i][j]\n    return sum\n",
        "def matrixElementsSum(matrix):\n    sum = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 0:\n                break\n            else:\n                sum += matrix[i][j]\n    return sum\n",
        "def matrixElementsSum(matrix):\n    sum = 0\n    for i in range(len(matrix)):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 0:\n                break\n            sum += matrix[i][j]\n    return sum\n",
        "def matrix(row, cols, rCenter, cCenter):\n    return [[i, j] for i in range(row) for j in range(cols) if abs(i - rCenter) + abs(j - cCenter)]\n"
    ],
    "results": 10
},{
    "id": "1696",
    "source": "leetcode",
    "language": "python",
    "query": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only. For each query you need to find the number of plates between candles that are in the substring.",
    "snippets": [
        "def count_plates(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '*':\n            count += 1\n        elif s[i] == '|':\n            count -= 1\n    return count\n",
        "def candles(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '*':\n            count += 1\n        else:\n            break\n    for i in range(len(s)):\n        if s[i] == '|':\n            count += 1\n        else:\n            break\n    return count\n",
        "def candles(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '*':\n            count += 1\n        else:\n            break\n    return count\n",
        "def plates_between_candles(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '*':\n            count += 1\n        elif s[i] == '|':\n            count -= 1\n    return count\n",
        "def candles(s):\n    # your code goes here\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '*':\n            count += 1\n        else:\n            break\n    for i in range(len(s)):\n        if s[i] == '|':\n            count += 1\n        else:\n            break\n    return count\n",
        "def candles(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1 if s[0] == '*' else 0\n    if s[0] == '*':\n        return 1 + candles(s[1:])\n    if s[0] == '|':\n        return candles(s[1:])\n    if s[1] == '*':\n        return 1 + candles(s[2:])\n    if s[1] == '|':\n        return candles(s[2:])\n    return candles(s[2:])\n"
    ],
    "results": 10
},{
    "id": "1697",
    "source": "leetcode",
    "language": "python",
    "query": "You are given the head of a singly linked-list. You may not modify the values in the list's nodes. Only nodes themselves may be changed. The list can be represented as: L0, L1, L2, Ln - 1, ….",
    "snippets": [
        "def reverse(head):\n    if head is None or head.next is None:\n        return head\n    prev = None\n    curr = head\n    while curr is not None:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n    return prev\n",
        "def reverse(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    prev = None\n    curr = head\n    while curr is not None:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n    return prev\n",
        "def reverse_list(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    prev = None\n    curr = head\n    while curr is not None:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n    return prev\n"
    ],
    "results": 10
},{
    "id": "1698",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s.",
    "snippets": [
        "def ip_address(s):\n    if len(s) < 4 or len(s) > 12:\n        return []\n    if s[0] == '0':\n        return []\n    if int(s) > 255:\n        return []\n    if len(s) == 4:\n        return [s]\n    if len(s) == 3:\n        return [s + '.']\n    if len(s) == 2:\n        return [s + '.']\n    if len(s) == 1:\n        return [s + '.']\n    if len(s) == 12:\n        return [s[:4] + '.' + s[4:8] + '.' + s[8:12]]\n    if len(s) == 11:\n        return [s[:4] + '.' + s[4:8] + '.' + s[8:11]]\n    if len(s) == 10:\n        return [s[:4] + '.' + s[4:8] + '.' + s[8:10]]\n    if len(s) == 9:\n        return [s[:4] + '.' + s[4:7] + '.' + s[7:9]]\n    if len(s) == 8:\n        return [s[:4] + '.' + s[4:6] + '.' + s[6:8]]\n    if len(s) == 7:\n        return [s[:4] + '.' + s[4:7] + '.' + s[7:7]]\n    if len(s) == 6:\n        return [s[:4] + '.' + s[4:6] + '.' + s[6:6]]\n    if len(s) == 5:\n        return [s[:4] + '.' + s[4:5] + '.' + s[5:5]]\n    if len(s) == 4:\n        return [s[:4] + '.' + s[4:4] + '.' + s[4:4]]\n    if len(s) == 3:\n        return [s[:4]\n",
        "def ip_address(s):\n    if len(s) < 4 or len(s) > 12:\n        return []\n    if s[0] == '0':\n        return []\n    if int(s) > 255:\n        return []\n    if len(s) == 4:\n        return [s]\n    if len(s) == 3:\n        return [s + '.']\n    if len(s) == 2:\n        return [s + '.']\n    if len(s) == 1:\n        return [s + '.']\n    if len(s) == 12:\n        return [s]\n    if len(s) == 11:\n        return [s + '.']\n    if len(s) == 10:\n        return [s + '.']\n    if len(s) == 9:\n        return [s + '.']\n    if len(s) == 8:\n        return [s + '.']\n    if len(s) == 7:\n        return [s + '.']\n    if len(s) == 6:\n        return [s + '.']\n    if len(s) == 5:\n        return [s + '.']\n    if len(s) == 4:\n        return [s + '.']\n    if len(s) == 3:\n        return [s + '.']\n    if len(s) == 2:\n        return [s + '.']\n    if len(s) == 1:\n        return [s + '.']\n    if len(s) == 12:\n        return [s]\n    if len(s) == 11:\n        return [s + '.']\n    if len(s) == 10:\n        return [s + '.']\n    if len(s) == 9:\n        return [s + '.']\n    if len(s) == 8:\n        return [s + '.']\n    if len(s) == 7:\n        return [s + '.']\n    if len(s) == 6:\n        return [s + '.']\n    if len(s) == 5:\n        return [s\n",
        "def ip_address(s):\n    if len(s) < 4 or len(s) > 12:\n        return []\n    if len(s) == 4:\n        return [s]\n    res = []\n    for i in range(1, 4):\n        if int(s[:i]) > 255 or (s[0] == '0' and i != 1):\n            continue\n        for j in ip_address(s[i:]):\n            res.append(s[:i] + '.' + j)\n    return res\n",
        "def ip_address(s):\n    if len(s) == 0:\n        return []\n    if len(s) == 1:\n        return [s]\n    if len(s) == 2:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 3:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 4:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 5:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 6:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 7:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 8:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 9:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 10:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 11:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 12:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 13:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 14:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 15:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 16:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 17:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 18:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 19:\n        return [s] if int(s) <= 255 else []\n    if len(s) == 20:\n        return\n",
        "def ip_address(s):\n    if len(s) < 4 or len(s) > 12:\n        return []\n    if len(s) == 4:\n        return [s]\n    if len(s) == 12:\n        return [s]\n    if len(s) == 8:\n        return [s]\n    if len(s) == 6:\n        return [s]\n    if len(s) == 3:\n        return [s]\n    if len(s) == 2:\n        return [s]\n    if len(s) == 1:\n        return [s]\n    if len(s) == 7:\n        return [s]\n    if len(s) == 5:\n        return [s]\n    if len(s) == 9:\n        return [s]\n    if len(s) == 11:\n        return [s]\n    if len(s) == 10:\n        return [s]\n    if len(s) == 13:\n        return [s]\n    if len(s) == 14:\n        return [s]\n    if len(s) == 15:\n        return [s]\n    if len(s) == 16:\n        return [s]\n    if len(s) == 17:\n        return [s]\n    if len(s) == 18:\n        return [s]\n    if len(s) == 19:\n        return [s]\n    if len(s) == 20:\n        return [s]\n    if len(s) == 21:\n        return [s]\n    if len(s) == 22:\n        return [s]\n    if len(s) == 23:\n        return [s]\n    if len(s) == 24:\n        return [s]\n    if len(s) == 25:\n        return [s]\n    if len(s) == 26:\n        return [s]\n    if len(s) == 27:\n        return [s]\n    if len(s) == 28:\n        return [s]\n    if len(s) == 29:\n        return [s]\n    if len(s) ==\n",
        "def ip_address(s):\n    if len(s) < 4 or len(s) > 12:\n        return []\n    if len(s) == 4:\n        return [s]\n    if s[0] == '0':\n        return []\n    if int(s[0]) > 2:\n        return []\n    if int(s[0]) == 2 and int(s[1]) > 5:\n        return []\n    if int(s[0]) == 2 and int(s[1]) == 5 and int(s[2]) > 5:\n        return []\n    if int(s[0]) == 2 and int(s[1]) == 5 and int(s[2]) == 5 and int(s[3]) > 5:\n        return []\n    if int(s[0]) == 2 and int(s[1]) == 5 and int(s[2]) == 5 and int(s[3]) == 5 and int(s[4]) > 5:\n        return []\n    if int(s[0]) == 2 and int(s[1]) == 5 and int(s[2]) == 5 and int(s[3]) == 5 and int(s[4]) == 5 and int(s[5]) > 5:\n        return []\n    if int(s[0]) == 2 and int(s[1]) == 5 and int(s[2]) == 5 and int(s[3]) == 5 and int(s[4]) == 5 and int(s[5]) == 5 and int(s[6]) > 5:\n        return []\n    if int(s[0]) == 2 and int(s[1]) == 5 and int(s[2]) == 5 and int(s[3]) == 5 and int(s[4]) == 5 and int(s[5]) == 5 and int(s[6]) == 5 and int(s[7]) > 5:\n        return []\n    if int(s[0]) == 2 and int(s[1]) == 5 and int(s[2]) == 5 and int(s[3]) == 5 and int(s[4]) == 5 and int(s[5]) == 5 and int(s[\n",
        "def validIPAddress(s):\n    if s.startswith('0'):\n        return False\n    if s.startswith('.'):\n        return False\n    if s.startswith('+'):\n        return False\n    if s.startswith('-'):\n        return False\n    if s.startswith('e'):\n        return False\n    if s.startswith('E'):\n        return False\n    if s.startswith(' '):\n        return False\n    if s.startswith('\\t'):\n        return False\n    if s.startswith('\\n'):\n        return False\n    if s.startswith('\\r'):\n        return False\n    if s.startswith('\\f'):\n        return False\n    if s.startswith('\\v'):\n        return False\n    if s.startswith('\\b'):\n        return False\n    if s.startswith('\\a'):\n        return False\n    if s.startswith('\\0'):\n        return False\n    if s.startswith('\\x0'):\n        return False\n    if s.startswith('\\x1'):\n        return False\n    if s.startswith('\\x2'):\n        return False\n    if s.startswith('\\x3'):\n        return False\n    if s.startswith('\\x4'):\n        return False\n    if s.startswith('\\x5'):\n        return False\n    if s.startswith('\\x6'):\n        return False\n    if s.startswith('\\x7'):\n        return False\n    if s.startswith('\\x8'):\n        return False\n    if s.startswith('\\x9'):\n        return False\n    if s.startswith('\\xa'):\n        return False\n    if s.startswith('\\xb'):\n        return False\n    if s.startswith('\\xc'):\n        return False\n    if s.startswith('\\xd'):\n        return False\n"
    ],
    "results": 10
},{
    "id": "1699",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return the number of prime numbers that are strictly less than n.",
    "snippets": [
        "def count_primes(n):\n    if n < 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])\n    return sum(primes)\n",
        "def count_primes(n):\n    if n < 2:\n        return 0\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n % 2 == 0:\n        n -= 1\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if primes[i]:\n            primes[i*i::2*i] = [False] * ((n - i*i - 1)//(2*i) + 1)\n    return sum(primes)\n",
        "def count_primes(n):\n    # Write your code here.\n    if n < 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])\n    return sum(primes)\n",
        "def countPrimes(n):\n    if n < 3:\n        return 0\n    primes = [True] * (n)\n    primes[0] = primes[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i * i: n: i] = [False] * len(primes[i * i: n: i])\n    return sum(primes)\n"
    ],
    "results": 10
},{
    "id": "1700",
    "source": "leetcode",
    "language": "python",
    "query": "The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree. A subtree of a tree T is the tree consisting of a node in T and all its descendant nodes.",
    "snippets": [
        "def dfs(node, edges, visited, subtree_size):\n    visited[node] = True\n    subtree_size[node] = 1\n    for child in edges[node]:\n        if not visited[child]:\n            subtree_size[node] += dfs(child, edges, visited, subtree_size)\n    return subtree_size[node]\n",
        "def subtree(edges, node):\n    if len(edges) == 0:\n        return [node]\n    else:\n        subtrees = []\n        for edge in edges:\n            if edge[0] == node:\n                subtrees.append(subtree(edges, edge[1]))\n        return [node] + sum(subtrees, [])\n",
        "def findSubtree(n, edges, a, b):\n    # Write your code here.\n    def dfs(node):\n        if node == a or node == b:\n            return True\n        for child in edges[node]:\n            if dfs(child):\n                return True\n        return False\n    for i in range(n):\n        if dfs(i):\n            return i\n    return -1\n",
        "def findSubtree(n, edges):\n    # Write your code here\n    def dfs(node):\n        nonlocal subtree\n        if node in visited:\n            return\n        visited.add(node)\n        subtree.append(node)\n        for child in edges[node]:\n            dfs(child)\n        subtree.pop()\n    visited = set()\n    subtree = []\n    for i in range(n):\n        dfs(i)\n        if len(subtree) > len(visited):\n            return subtree\n    return []\n",
        "def subtree(edges, node):\n    if node not in edges:\n        return [node]\n    else:\n        return [node] + sum([subtree(edges, child) for child in edges[node]], [])\n",
        "def dfs(node, edges, visited, subtree):\n    if visited[node] == 1:\n        return\n    visited[node] = 1\n    subtree.append(node)\n    for i in range(len(edges)):\n        if edges[i][0] == node:\n            dfs(edges[i][1], edges, visited, subtree)\n    return\n",
        "def subtree(edges, node):\n    # Write your code here.\n    if len(edges) == 0:\n        return [node]\n    else:\n        subtrees = []\n        for edge in edges:\n            if edge[0] == node:\n                subtrees.append(subtree(edges, edge[1]))\n        return [node] + sum(subtrees, [])\n",
        "def subtree(edges, node):\n    if node not in edges:\n        return [node]\n    else:\n        children = []\n        for child in edges[node]:\n            children.extend(subtree(edges, child))\n        return [node] + children\n",
        "def subtree(edges, node):\n    if node not in edges:\n        return []\n    else:\n        return [node] + sum([subtree(edges, child) for child in edges[node]], [])\n"
    ],
    "results": 10
},{
    "id": "1701",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums [j]-1).",
    "snippets": [
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return (nums[0]-1)*(nums[1]-1)\n    max_product = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_product = max(max_product, (nums[i]-1)*(nums[j]-1))\n    return max_product\n",
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    max_product = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_product = max(max_product, (nums[i]-1)*(nums[j]-1))\n    return max_product\n",
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    max_product = -1\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            max_product = max(max_product, (nums[i]-1)*(nums[j]-1))\n    return max_product\n"
    ],
    "results": 10
},{
    "id": "1702",
    "source": "leetcode",
    "language": "python",
    "query": "Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.",
    "snippets": [
        "def findFrequentTreeSum(root):\n    if not root:\n        return []\n    d = {}\n    def dfs(root):\n        if not root:\n            return 0\n        s = root.val + dfs(root.left) + dfs(root.right)\n        d[s] = d.get(s, 0) + 1\n        return s\n    dfs(root)\n    max_count = max(d.values())\n    return [k for k, v in d.items() if v == max_count]\n",
        "def findFrequentTreeSum(root):\n    if not root:\n        return []\n    d = {}\n    def dfs(root):\n        if not root:\n            return 0\n        s = root.val + dfs(root.left) + dfs(root.right)\n        d[s] = d.get(s, 0) + 1\n        return s\n    dfs(root)\n    max_cnt = max(d.values())\n    return [k for k, v in d.items() if v == max_cnt]\n",
        "def findFrequentTreeSum(root):\n    if root is None:\n        return []\n    d = {}\n    def dfs(root):\n        if root is None:\n            return 0\n        s = root.val + dfs(root.left) + dfs(root.right)\n        d[s] = d.get(s, 0) + 1\n        return s\n    dfs(root)\n    max_count = max(d.values())\n    return [k for k, v in d.items() if v == max_count]\n",
        "def findFrequentTreeSum(root):\n    if not root:\n        return []\n    d = {}\n    def dfs(node):\n        if not node:\n            return 0\n        s = node.val + dfs(node.left) + dfs(node.right)\n        d[s] = d.get(s, 0) + 1\n        return s\n    dfs(root)\n    max_count = max(d.values())\n    return [k for k, v in d.items() if v == max_count]\n",
        "def findFrequentTreeSum(root):\n    if root is None:\n        return []\n    d = {}\n    def dfs(root):\n        if root is None:\n            return 0\n        s = root.val + dfs(root.left) + dfs(root.right)\n        d[s] = d.get(s, 0) + 1\n        return s\n    dfs(root)\n    max_cnt = max(d.values())\n    return [k for k, v in d.items() if v == max_cnt]\n"
    ],
    "results": 10
},{
    "id": "1703",
    "source": "leetcode",
    "language": "python",
    "query": "You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "snippets": [
        "def maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] < min_price:\n            min_price = prices[i]\n        elif prices[i] - min_price > max_profit:\n            max_profit = prices[i] - min_price\n    return max_profit\n",
        "def maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - min_price)\n        min_price = min(min_price, prices[i])\n    return max_profit\n",
        "def max_profit(prices):\n    if len(prices) < 2:\n        return 0\n    min_price = prices[0]\n    max_profit = prices[1] - prices[0]\n    for i in range(1, len(prices)):\n        profit = prices[i] - min_price\n        if profit > max_profit:\n            max_profit = profit\n        if prices[i] < min_price:\n            min_price = prices[i]\n    return max_profit\n",
        "def max_profit(prices):\n    if len(prices) < 2:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n    return max_profit\n",
        "def maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    min_price = prices[0]\n    max_profit = prices[1] - prices[0]\n    for i in range(1, len(prices)):\n        max_profit = max(max_profit, prices[i] - min_price)\n        min_price = min(min_price, prices[i])\n    return max_profit\n",
        "def maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n    return max_profit\n"
    ],
    "results": 10
},{
    "id": "1704",
    "source": "leetcode",
    "language": "python",
    "query": "Nim Game involves removing stones from a heap. The one who removes the last stone is the winner.",
    "snippets": [
        "def nim_game(heap):\n    if heap == 0:\n        return True\n    if heap == 1:\n        return False\n    if heap == 2:\n        return True\n    if heap == 3:\n        return False\n    if heap == 4:\n        return True\n    if heap == 5:\n        return False\n    if heap == 6:\n        return True\n    if heap == 7:\n        return False\n    if heap == 8:\n        return True\n    if heap == 9:\n        return False\n    if heap == 10:\n        return True\n    if heap == 11:\n        return False\n    if heap == 12:\n        return True\n    if heap == 13:\n        return False\n    if heap == 14:\n        return True\n    if heap == 15:\n        return False\n    if heap == 16:\n        return True\n    if heap == 17:\n        return False\n    if heap == 18:\n        return True\n    if heap == 19:\n        return False\n    if heap == 20:\n        return True\n    if heap == 21:\n        return False\n    if heap == 22:\n        return True\n    if heap == 23:\n        return False\n    if heap == 24:\n        return True\n    if heap == 25:\n        return False\n    if heap == 26:\n        return True\n    if heap == 27:\n        return False\n    if heap == 28:\n        return True\n    if heap == 29:\n        return False\n    if heap == 30:\n        return True\n    if heap == 31:\n        return False\n    if heap == 32:\n        return True\n    if heap == 33:\n        return False\n    if heap == 34:\n        return True\n    if heap == 35:\n        return False\n    if heap == 36:\n        return True\n    if heap == 37:\n        return False\n    if heap == 38:\n        return True\n    if heap == 39:\n        return False\n    if heap == 40:\n        return True\n    if heap == 41:\n        return False\n    if heap == 42:\n        return True\n    if heap == 43:\n        return False\n    if heap == 44:\n",
        "def nim(heap):\n    if heap == 0:\n        return True\n    elif heap % 4 == 0:\n        return False\n    else:\n        return nim(heap - 1)\n",
        "def nim_game(heap):\n    if heap == 0:\n        return True\n    elif heap == 1:\n        return False\n    else:\n        return nim_game(heap - 1)\n",
        "def nim(heap):\n    if heap == 0:\n        return True\n    if heap & (heap - 1) == 0:\n        return False\n    for i in range(1, heap):\n        if nim(heap ^ i):\n            return True\n    return False\n",
        "def nim_game(heap):\n    if heap == 0:\n        return True\n    elif heap == 1:\n        return False\n    elif heap == 2:\n        return False\n    elif heap == 3:\n        return False\n    elif heap == 4:\n        return False\n    elif heap == 5:\n        return False\n    elif heap == 6:\n        return False\n    elif heap == 7:\n        return False\n    elif heap == 8:\n        return False\n    elif heap == 9:\n        return False\n    elif heap == 10:\n        return False\n    elif heap == 11:\n        return False\n    elif heap == 12:\n        return False\n    elif heap == 13:\n        return False\n    elif heap == 14:\n        return False\n    elif heap == 15:\n        return False\n    elif heap == 16:\n        return False\n    elif heap == 17:\n        return False\n    elif heap == 18:\n        return False\n    elif heap == 19:\n        return False\n    elif heap == 20:\n        return False\n    elif heap == 21:\n        return False\n    elif heap == 22:\n        return False\n    elif heap == 23:\n        return False\n    elif heap == 24:\n        return False\n    elif heap == 25:\n        return False\n    elif heap == 26:\n        return False\n    elif heap == 27:\n        return False\n    elif heap == 28:\n        return False\n    elif heap == 29:\n        return False\n    elif heap == 30:\n        return False\n    elif heap == 31:\n        return False\n    elif heap == 32:\n        return False\n    elif heap == 33:\n        return False\n    elif heap == 34:\n        return False\n    elif heap == 35:\n        return False\n    elif heap == 36:\n        return False\n    elif heap == 37:\n        return False\n    elif heap == 38:\n        return False\n    elif heap == 39:\n        return False\n    elif heap == 40:\n        return False\n",
        "def nim_game(heap):\n    if heap == 0:\n        return True\n    if heap == 1:\n        return False\n    if heap == 2:\n        return False\n    if heap == 3:\n        return True\n    if heap == 4:\n        return True\n    if heap == 5:\n        return False\n    if heap == 6:\n        return True\n    if heap == 7:\n        return True\n    if heap == 8:\n        return True\n    if heap == 9:\n        return True\n    if heap == 10:\n        return True\n    if heap == 11:\n        return True\n    if heap == 12:\n        return True\n    if heap == 13:\n        return True\n    if heap == 14:\n        return True\n    if heap == 15:\n        return True\n    if heap == 16:\n        return True\n    if heap == 17:\n        return True\n    if heap == 18:\n        return True\n    if heap == 19:\n        return True\n    if heap == 20:\n        return True\n    if heap == 21:\n        return True\n    if heap == 22:\n        return True\n    if heap == 23:\n        return True\n    if heap == 24:\n        return True\n    if heap == 25:\n        return True\n    if heap == 26:\n        return True\n    if heap == 27:\n        return True\n    if heap == 28:\n        return True\n    if heap == 29:\n        return True\n    if heap == 30:\n        return True\n    if heap == 31:\n        return True\n    if heap == 32:\n        return True\n    if heap == 33:\n        return True\n    if heap == 34:\n        return True\n    if heap == 35:\n        return True\n    if heap == 36:\n        return True\n    if heap == 37:\n        return True\n    if heap == 38:\n        return True\n    if heap == 39:\n        return True\n    if heap == 40:\n        return True\n    if heap == 41:\n        return True\n    if heap == 42:\n        return True\n    if heap == 43:\n        return True\n    if heap == 44:\n",
        "def nim(heap):\n    if heap == 0:\n        return True\n    if heap % 4 == 0:\n        return False\n    return nim(heap - 1)\n",
        "def nim(heap):\n    if heap == 0:\n        return True\n    elif heap &lt;= 3:\n        return False\n    else:\n        return nim(heap &amp; 3) or nim(heap &amp; 5) or nim(heap &amp; 7)\n",
        "def nim_game(heap):\n    if heap == 0:\n        return False\n    if heap == 1:\n        return True\n    if heap % 4 == 0:\n        return nim_game(heap / 4)\n    else:\n        return not nim_game(heap - 1)\n",
        "def nim_game(n):\n    if n % 4 == 0:\n        return False\n    else:\n        return True\n"
    ],
    "results": 10
},{
    "id": "1705",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.",
    "snippets": [
        "def knows(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    return (knows(n-1) + knows(n-2)) % 1000000007\n",
        "def knows(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return (knows(n - 1) + knows(n - 2)) % 1000000007\n",
        "def knows(n):\n    if n == 1:\n        return 1\n    return (knows(n - 1) + knows(n - 2)) % 1000000007\n",
        "def numOfPeople(n):\n    if n == 1:\n        return 1\n    else:\n        return (numOfPeople(n-1) + numOfPeople(n-2)) % 1000000007\n",
        "def numPeople(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 4\n    if n == 3:\n        return 7\n    if n == 4:\n        return 13\n    if n == 5:\n        return 24\n    if n == 6:\n        return 44\n    if n == 7:\n        return 81\n    if n == 8:\n        return 149\n    if n == 9:\n        return 274\n    if n == 10:\n        return 504\n    if n == 11:\n        return 901\n    if n == 12:\n        return 1681\n    if n == 13:\n        return 3369\n    if n == 14:\n        return 6444\n    if n == 15:\n        return 12689\n    if n == 16:\n        return 25404\n    if n == 17:\n        return 50849\n    if n == 18:\n        return 101449\n    if n == 19:\n        return 202811\n    if n == 20:\n        return 405622\n    if n == 21:\n        return 811304\n    if n == 22:\n        return 1622609\n    if n == 23:\n        return 3245218\n    if n == 24:\n        return 6488436\n    if n == 25:\n        return 12976869\n    if n == 26:\n        return 25953739\n    if n == 27:\n        return 51907478\n    if n == 28:\n        return 103814897\n    if n == 29:\n        return 207629794\n    if n == 30:\n        return 415259788\n    if n == 31:\n        return 830511954\n    if n == 32:\n        return 1660843872\n    if n == 33:\n        return 3321747744\n    if n == 34:\n        return 6643495589\n    if n == 35:\n        return 13286981109\n    if n == 36:\n        return 26573962208\n    if n == 37:\n        return 53119784377\n    if n == 38:\n",
        "def knows(n):\n    if n == 1:\n        return 1\n    return (2 * knows(n - 1) + 1) % 1000000007\n",
        "def num_people_knowing_secret(n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return 2\n    if n == 2:\n        return 4\n    if n == 3:\n        return 7\n    if n == 4:\n        return 13\n    if n == 5:\n        return 24\n    if n == 6:\n        return 44\n    if n == 7:\n        return 81\n    if n == 8:\n        return 149\n    if n == 9:\n        return 274\n    if n == 10:\n        return 504\n    if n == 11:\n        return 901\n    if n == 12:\n        return 1597\n    if n == 13:\n        return 2793\n    if n == 14:\n        return 4913\n    if n == 15:\n        return 8377\n    if n == 16:\n        return 14589\n    if n == 17:\n        return 25377\n    if n == 18:\n        return 43929\n    if n == 19:\n        return 75597\n    if n == 20:\n        return 125979\n    if n == 21:\n        return 209937\n    if n == 22:\n        return 352797\n    if n == 23:\n        return 588579\n    if n == 24:\n        return 923369\n    if n == 25:\n        return 1492537\n    if n == 26:\n        return 2488759\n    if n == 27:\n        return 3973729\n    if n == 28:\n        return 6241409\n    if n == 29:\n        return 10234721\n    if n == 30:\n        return 16558337\n    if n == 31:\n        return 26843545\n    if n == 32:\n        return 43980465\n    if n == 33:\n        return 70740881\n    if n == 34:\n        return 114514069\n    if n == 35:\n        return 183631127\n    if n == 36:\n        return 290929089\n    if n == 37:\n        return 471435209\n    if n == 38:\n        return 7\n",
        "def knows(n):\n    if n == 0:\n        return 1\n    return (knows(n-1) + knows(n-2)) % 1000000007\n",
        "def numOfPeople(n):\n    if n == 1:\n        return 1\n    return (numOfPeople(n-1) + numOfPeople(n-2)) % 1000000007\n",
        "def knows(n):\n    if n == 1:\n        return 1\n    return (n * (n - 1) // 2) % 1000000007\n"
    ],
    "results": 10
},{
    "id": "1706",
    "source": "leetcode",
    "language": "python",
    "query": "We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup of champagne. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.",
    "snippets": [
        "def champagne_tower(n, queries):\n    glasses = [0] * (n + 1)\n    for i in range(n, -1, -1):\n        glasses[i] = max(0, (glasses[i] - 1) / 2)\n        for j in range(i + 1, n + 1):\n            glasses[j] = max(0, glasses[j] - 1)\n            glasses[j] += glasses[j - 1]\n    return [glasses[i] for i in queries]\n",
        "def champagneTower(poured, query_row, query_glass):\n    tower = [[0] * (query_row + 1) for _ in range(query_row + 1)]\n    tower[0][0] = poured\n    for i in range(query_row):\n        for j in range(i + 1):\n            if tower[i][j] > 1:\n                tower[i + 1][j] += (tower[i][j] - 1) / 2\n                tower[i + 1][j + 1] += (tower[i][j] - 1) / 2\n            tower[i][j] = 0\n    return tower[query_row][query_glass]\n",
        "def champagne_tower(n, queries):\n    # Write your code here\n    glasses = [0] * (n + 1)\n    for i in range(n, -1, -1):\n        glasses[i] = max(0, (glasses[i] - 1) / 2)\n        for j in range(i + 1, n + 1):\n            glasses[j] += glasses[i]\n            glasses[j] = max(0, glasses[j] - 1)\n    return [glasses[i] for i in queries]\n",
        "def champagne_tower(n, k):\n    \"\"\"\n    :param n: int\n    :param k: int\n    :return: float\n    \"\"\"\n    if n == 1:\n        return 1.0\n    if n == 2:\n        return 1.0\n    if n == 3:\n        return 1.0\n    if n == 4:\n        return 1.0\n    if n == 5:\n        return 1.0\n    if n == 6:\n        return 1.0\n    if n == 7:\n        return 1.0\n    if n == 8:\n        return 1.0\n    if n == 9:\n        return 1.0\n    if n == 10:\n        return 1.0\n    if n == 11:\n        return 1.0\n    if n == 12:\n        return 1.0\n    if n == 13:\n        return 1.0\n    if n == 14:\n        return 1.0\n    if n == 15:\n        return 1.0\n    if n == 16:\n        return 1.0\n    if n == 17:\n        return 1.0\n    if n == 18:\n        return 1.0\n    if n == 19:\n        return 1.0\n    if n == 20:\n        return 1.0\n    if n == 21:\n        return 1.0\n    if n == 22:\n        return 1.0\n    if n == 23:\n        return 1.0\n    if n == 24:\n        return 1.0\n    if n == 25:\n        return 1.0\n    if n == 26:\n        return 1.0\n    if n == 27:\n        return 1.0\n    if n == 28:\n        return 1.0\n    if n == 29:\n        return 1.0\n    if n == 30:\n        return 1.0\n    if n == 31:\n        return 1.0\n    if n == 32:\n        return 1.0\n    if n == 33:\n        return 1.0\n    if n == 34:\n        return 1.0\n    if n == 35:\n        return 1.0\n    if n == 36:\n        return\n",
        "def champagneTower(pints):\n    glasses = [0] * 100\n    for i in range(pints):\n        for j in range(i, -1, -1):\n            if glasses[j] > 0:\n                glasses[j] -= 1\n                glasses[j + 1] += 1\n                glasses[j + 1] += 1\n    return sum(glasses)\n",
        "def champagne_tower(n, k):\n    if n == 1:\n        return 1\n    else:\n        return (champagne_tower(n-1, k) + k) / 2\n",
        "def champagneTower(pints):\n    glasses = [0] * 101\n    for i in range(pints):\n        for j in range(101):\n            if glasses[j] > 0:\n                glasses[j] = (glasses[j] - 1) / 2\n                if j < 100:\n                    glasses[j + 1] += 1\n                if j > 0:\n                    glasses[j - 1] += 1\n    return sum(glasses)\n",
        "def champagne_tower(n, k):\n    glasses = [0] * n\n    for i in range(n - 1, -1, -1):\n        excess = max(0, (glasses[i] - 1) / 2)\n        for j in range(i + 1, min(i + k + 1, n)):\n            glasses[j] += excess\n            excess = max(0, excess - 1)\n    return sum(glasses)\n",
        "def champagne_tower(p):\n    \"\"\"\n    >>> champagne_tower(1)\n    1.0\n    >>> champagne_tower(2)\n    1.5\n    >>> champagne_tower(3)\n    2.0\n    >>> champagne_tower(6)\n    2.75\n    >>> champagne_tower(11)\n    3.5\n    >>> champagne_tower(52)\n    4.0\n    >>> champagne_tower(100)\n    5.0\n    \"\"\"\n    if p == 1:\n        return 1.0\n    else:\n        return (p-1) * champagne_tower(p-1) / 2 + 1.0\n",
        "def champagne_tower(p, q):\n    if p == 0:\n        return 0\n    if q == 0:\n        return 1\n    if p > q:\n        return 1 + champagne_tower(p - q, q)\n    else:\n        return 1 + champagne_tower(p, q - p)\n"
    ],
    "results": 10
},{
    "id": "1707",
    "source": "leetcode",
    "language": "python",
    "query": "A string is called palindrome if is one that reads the same backward as well as forward. You are given a string s consisting only of letters 'a' and 'b' In a single step you can remove one palindromic sequence from s.",
    "snippets": [
        "def palindrome(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return True\n    if s[0] == s[-1]:\n        return palindrome(s[1:-1])\n    else:\n        return False\n",
        "def palindrome(s):\n    if s == s[::-1]:\n        return True\n    else:\n        return False\n",
        "def is_palindrome(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return True\n    if s[0] == s[-1]:\n        return is_palindrome(s[1:-1])\n    else:\n        return False\n",
        "def palindrome(s):\n    if s == '':\n        return True\n    if s[0] != s[-1]:\n        return False\n    return palindrome(s[1:-1])\n",
        "def palindrome(s):\n    if len(s) == 0:\n        return 0\n    if s == s[::-1]:\n        return 1\n    return palindrome(s[:-1]) + palindrome(s[:-1])\n",
        "def remove_palindromic_sequence(s):\n    if len(s) == 0:\n        return 0\n    if len(s) == 1:\n        return 1\n    if s[0] == s[-1]:\n        return 1 + remove_palindromic_sequence(s[1:-1])\n    else:\n        return remove_palindromic_sequence(s[1:])\n"
    ],
    "results": 10
},{
    "id": "1708",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters for each string. Return the minimum possible value of answer.length.",
    "snippets": [
        "def minDeletionSize(strs):\n    ans = 0\n    for i in range(len(strs[0])):\n        for j in range(1, len(strs)):\n            if strs[j][i] < strs[j - 1][i]:\n                ans += 1\n                break\n    return ans\n",
        "def minDeletionSize(strs):\n    \"\"\"\n    :type strs: List[str]\n    :rtype: int\n    \"\"\"\n    if not strs:\n        return 0\n    n = len(strs[0])\n    for i in range(n):\n        for j in range(1, len(strs)):\n            if strs[j][i] < strs[j-1][i]:\n                return i\n    return n\n",
        "def minDeletionSize(strs):\n    ans = 0\n    for i in range(len(strs[0])):\n        for j in range(len(strs)):\n            if strs[j][i] > strs[j+1][i]:\n                ans += 1\n                break\n    return ans\n",
        "def minDeletionSize(strs):\n    if not strs:\n        return 0\n    n = len(strs[0])\n    for i in range(n):\n        for j in range(1, len(strs)):\n            if strs[j][i] < strs[j-1][i]:\n                return i\n    return n\n",
        "def min_deletion_size(strs):\n    if not strs:\n        return 0\n    if len(strs) == 1:\n        return 0\n    strs = sorted(strs)\n    for i in range(len(strs[0])):\n        for j in range(1, len(strs)):\n            if strs[j][i] < strs[j-1][i]:\n                return i\n    return 0\n",
        "def min_deletion_size(strs):\n    if not strs:\n        return 0\n    if len(strs) == 1:\n        return 0\n    strs.sort()\n    count = 0\n    for i in range(len(strs[0])):\n        for j in range(1, len(strs)):\n            if strs[j][i] < strs[j-1][i]:\n                count += 1\n                break\n    return count\n",
        "def min_deletions(strs):\n    return min(len(s) - len(set(s)) for s in strs)\n"
    ],
    "results": 10
},{
    "id": "1709",
    "source": "leetcode",
    "language": "python",
    "query": "Given a positive integer n, you can apply one of the following operations. If n is even, replace n with n / 2 or n + 1 or n - 1. Return the minimum number of operations needed for n to become 1.",
    "snippets": [
        "def minOperations(n):\n    if n == 1:\n        return 0\n    if n % 2 == 0:\n        return minOperations(n // 2) + 1\n    else:\n        return minOperations(n + 1) + 1\n",
        "def minOperations(n):\n    if n == 1:\n        return 0\n    if n % 2 == 0:\n        return minOperations(n // 2) + 1\n    else:\n        return minOperations(n - 1) + 1\n",
        "def minOperations(n):\n    if n == 1:\n        return 0\n    elif n % 2 == 0:\n        return minOperations(n // 2) + 1\n    else:\n        return minOperations(n + 1) + 1\n"
    ],
    "results": 10
},{
    "id": "1710",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.",
    "snippets": [
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    left = 0\n    right = 0\n    max_len = 0\n    while right < len(nums):\n        if nums[right] - nums[left] <= limit:\n            max_len = max(max_len, right - left + 1)\n            right += 1\n        else:\n            left += 1\n    return max_len\n",
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    left, right = 0, 0\n    max_len = 0\n    while right < len(nums):\n        while right < len(nums) and abs(nums[right] - nums[right - 1]) <= limit:\n            right += 1\n        max_len = max(max_len, right - left)\n        while right < len(nums) and abs(nums[right] - nums[right - 1]) > limit:\n            left += 1\n    return max_len\n",
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    l = 0\n    r = 0\n    max_len = 0\n    while r < len(nums):\n        if abs(nums[r] - nums[l]) <= limit:\n            r += 1\n            max_len = max(max_len, r - l)\n        else:\n            l += 1\n    return max_len\n",
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return 1\n    max_len = 1\n    for i in range(1, len(nums)):\n        if abs(nums[i] - nums[i-1]) <= limit:\n            max_len += 1\n        else:\n            max_len = max(max_len, i)\n    return max_len\n",
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    ans = 0\n    left = 0\n    right = 0\n    while right < len(nums):\n        while right < len(nums) and abs(nums[right] - nums[left]) <= limit:\n            right += 1\n        ans = max(ans, right - left)\n        left += 1\n    return ans\n",
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    left = 0\n    right = 0\n    max_len = 0\n    min_val = nums[0]\n    max_val = nums[0]\n    while right < len(nums):\n        if nums[right] - min_val > limit:\n            min_val = nums[left]\n            left += 1\n        else:\n            max_val = max(max_val, nums[right])\n            right += 1\n        max_len = max(max_len, right - left)\n    return max_len\n",
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    left, right = 0, 0\n    max_len = 0\n    while right < len(nums):\n        if nums[right] - nums[left] <= limit:\n            max_len = max(max_len, right - left + 1)\n            right += 1\n        else:\n            left += 1\n    return max_len\n",
        "def longestSubarray(nums, limit):\n    \"\"\"\n    :type nums: List[int]\n    :type limit: int\n    :rtype: int\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    max_len = 1\n    for i in range(1, len(nums)):\n        if abs(nums[i] - nums[i - 1]) <= limit:\n            max_len += 1\n        else:\n            max_len = max(max_len, i)\n    return max_len\n",
        "def longestSubarray(nums, limit):\n    if len(nums) == 0:\n        return 0\n    start = 0\n    end = 0\n    max_len = 0\n    while end < len(nums):\n        if nums[end] - nums[start] <= limit:\n            end += 1\n        else:\n            start += 1\n        max_len = max(max_len, end - start)\n    return max_len\n"
    ],
    "results": 10
},{
    "id": "1711",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd. Return any answer array that satisfies this condition.",
    "snippets": [
        "def sortArray(nums):\n    return [x for x in nums if x % 2 == 0] + [x for x in nums if x % 2 == 1]\n",
        "def sortArray(nums):\n    return sorted(nums, key=lambda x: x % 2)\n",
        "def sortArray(nums):\n    # Write your code here\n    i = 0\n    j = len(nums) - 1\n    while i < j:\n        if nums[i] % 2 == 0:\n            i += 1\n        else:\n            nums[i], nums[j] = nums[j], nums[i]\n            j -= 1\n    return nums\n",
        "def sortArray(nums):\n    return [n for n in nums if n % 2 == 0] + [n for n in nums if n % 2 != 0]\n",
        "def sortArray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # nums = sorted(nums)\n    # for i in range(len(nums)):\n    #     if nums[i] % 2 == 0:\n    #         return nums[i:] + nums[:i]\n    # return nums\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        while left < right and nums[left] % 2 == 0:\n            left += 1\n        while left < right and nums[right] % 2 == 1:\n            right -= 1\n        if left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n    return nums\n",
        "def sortArray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # nums = sorted(nums)\n    # return nums[::2] + nums[1::2]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0] + [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0] + [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0] + [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0] + [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0] + [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0] + [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0] + [nums[i] for i in range(len(nums)) if i % 2 == 1]\n    # return [nums[i] for i in range(len(nums)) if i % 2 == 0\n"
    ],
    "results": 10
},{
    "id": "1712",
    "source": "leetcode",
    "language": "python",
    "query": "A subarray is a contiguous subsequence of the array. Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.",
    "snippets": [
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    max_product = nums[0]\n    min_product = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            temp = max_product\n            max_product = min_product\n            min_product = temp\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n    return max_product\n",
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    max_product = nums[0]\n    min_product = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max_product * nums[i], min_product * nums[i], nums[i])\n        min_product = min(temp * nums[i], min_product * nums[i], nums[i])\n    return max_product\n",
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    max_product = nums[0]\n    min_product = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max_product * nums[i], min_product * nums[i], nums[i])\n        min_product = min(min_product * nums[i], temp * nums[i], nums[i])\n    return max_product\n",
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    max_product = nums[0]\n    min_product = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max(max_product * nums[i], min_product * nums[i]), nums[i])\n        min_product = min(min(temp * nums[i], min_product * nums[i]), nums[i])\n    return max_product\n",
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(nums[i], max_product * nums[i], min_product * nums[i])\n        min_product = min(nums[i], temp * nums[i], min_product * nums[i])\n    return max_product\n",
        "def maxProduct(nums):\n    if len(nums) == 0:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max_product * nums[i], min_product * nums[i], nums[i])\n        min_product = min(temp * nums[i], min_product * nums[i], nums[i])\n    return max_product\n",
        "def maxProduct(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    for i in range(1, len(nums)):\n        temp = max_product\n        max_product = max(max_product * nums[i], min_product * nums[i], nums[i])\n        min_product = min(temp * nums[i], min_product * nums[i], nums[i])\n    return max_product\n",
        "def maxProduct(nums):\n    if not nums:\n        return 0\n    max_product = nums[0]\n    min_product = nums[0]\n    res = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        res = max(res, max_product)\n    return res\n"
    ],
    "results": 10
},{
    "id": "1713",
    "source": "leetcode",
    "language": "python",
    "query": "An array nums of length n is beautiful if: nums is a permutation of the integers in the range [1, n]. For every 0 <= i < j < n, there is no index k with i < k < j. There will be at least one valid answer for the given n.",
    "snippets": [
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3, 2]\n    if n == 4:\n        return [1, 4, 3, 2]\n    if n == 5:\n        return [1, 5, 4, 3, 2]\n    if n == 6:\n        return [1, 6, 5, 4, 3, 2]\n    if n == 7:\n        return [1, 7, 6, 5, 4, 3, 2]\n    if n == 8:\n        return [1, 8, 7, 6, 5, 4, 3, 2]\n    if n == 9:\n        return [1, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 10:\n        return [1, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 11:\n        return [1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 12:\n        return [1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 13:\n        return [1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 14:\n        return [1, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 15:\n        return [1, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 16:\n        return [1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 17:\n        return [1, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 2, 3]\n    if n == 4:\n        return [1, 2, 3, 4]\n    if n == 5:\n        return [1, 2, 3, 4, 5]\n    if n == 6:\n        return [1, 2, 3, 4, 5, 6]\n    if n == 7:\n        return [1, 2, 3, 4, 5, 6, 7]\n    if n == 8:\n        return [1, 2, 3, 4, 5, 6, 7, 8]\n    if n == 9:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    if n == 10:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    if n == 11:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    if n == 12:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    if n == 13:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    if n == 14:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    if n == 15:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    if n == 16:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n    if n == 17:\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    else:\n        return [i for i in range(1, n+1) if i not in beautifulArray(n-1)]\n",
        "def beautifulArray(n):\n    if n == 1:\n        return [1]\n    else:\n        for i in range(n):\n            if i == 0:\n                if nums[i] == 1:\n                    return nums\n                else:\n                    nums[i] = 1\n                    return nums\n            else:\n                if nums[i] == 1:\n                    nums[i] = 2\n                    return nums\n                else:\n                    nums[i] = 1\n                    return nums\n",
        "def beautifulArray(n):\n    return [i for i in range(1, n+1) if i not in [j for j in range(1, n+1) if j in [k for k in range(1, n+1) if k in [l for l in range(1, n+1) if l in [m for m in range(1, n+1) if m in [n for n in range(1, n+1) if n in [o for o in range(1, n+1) if o in [p for p in range(1, n+1) if p in [q for q in range(1, n+1) if q in [r for r in range(1, n+1) if r in [s for s in range(1, n+1) if s in [t for t in range(1, n+1) if t in [u for u in range(1, n+1) if u in [v for v in range(1, n+1) if v in [w for w in range(1, n+1) if w in [x for x in range(1, n+1) if x in [y for y in range(1, n+1) if y in [z for z in range(1, n+1) if z in [aa for aa in range(1, n+1) if aa in [bb for bb in range(1, n+1) if bb in [cc for cc in range(1, n+1) if cc in [dd for dd in range(1, n+1) if dd in [ee for ee in range(1, n+1) if ee in [ff for ff in range(1, n+1) if ff in [gg for gg in range(1, n+1) if gg in [hh for hh in range(1, n+1) if hh in [ii for ii in range(1, n+1) if ii in [jj for jj in range(1, n+1) if jj in [kk for kk in range(1, n+1) if kk in [ll for ll in range(1, n+\n",
        "def beautifulArray(n):\n    return [i for i in range(1, n + 1) if i == 1 or i == n or nums[i - 1] < nums[i]]\n",
        "def beautifulArray(n):\n    return [i for i in range(1, n+1) if i % 2 == 1] + [i for i in range(n, 0, -1) if i % 2 == 0]\n"
    ],
    "results": 10
},{
    "id": "1714",
    "source": "leetcode",
    "language": "python",
    "query": "Vertical area is an area of fixed-width extending infinitely along the y-axis. The widest vertical area is the one with the maximum width. Points on the edge of a vertical area are not considered included in the area.",
    "snippets": [
        "def max_area(height):\n    max_area = 0\n    for i in range(len(height)):\n        for j in range(i+1, len(height)):\n            area = (j-i) * min(height[i], height[j])\n            if area > max_area:\n                max_area = area\n    return max_area\n",
        "def max_area(height):\n    max_area = 0\n    left = 0\n    right = len(height) - 1\n    while left < right:\n        area = (right - left) * min(height[left], height[right])\n        max_area = max(max_area, area)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n",
        "def maxArea(height):\n    max_area = 0\n    left = 0\n    right = len(height) - 1\n    while left < right:\n        area = (right - left) * min(height[left], height[right])\n        max_area = max(max_area, area)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n"
    ],
    "results": 10
},{
    "id": "1715",
    "source": "leetcode",
    "language": "python",
    "query": "There is a programming language with only four operations and one variable X. The value of X is 0.",
    "snippets": [
        "def main():\n    X = 0\n    X = X + 1\n    X = X + 1\n    X = X + 1\n    X = X + 1\n    print(X)\n",
        "def program(x):\n    x = x + 1\n    x = x * 2\n    x = x - 1\n    return x\n"
    ],
    "results": 7
},{
    "id": "1716",
    "source": "leetcode",
    "language": "python",
    "query": "A critical point in a linked list is defined as either a local maxima or a local minima. A node can only be a localmaxima if there exists both a previous node and a next node.",
    "snippets": [
        "def is_critical_point(node):\n    if node is None:\n        return False\n    if node.prev is None or node.next is None:\n        return False\n    if node.prev.data < node.data and node.next.data < node.data:\n        return True\n    if node.prev.data > node.data and node.next.data > node.data:\n        return True\n    return False\n",
        "def is_critical_point(node):\n    if node.prev and node.next:\n        return node.val > node.prev.val and node.val > node.next.val\n    elif node.prev:\n        return node.val > node.prev.val\n    elif node.next:\n        return node.val > node.next.val\n    else:\n        return False\n",
        "def is_critical_point(node):\n    if node.prev is None or node.next is None:\n        return False\n    if node.prev.data < node.data and node.next.data < node.data:\n        return True\n    if node.prev.data > node.data and node.next.data > node.data:\n        return True\n    return False\n",
        "def is_critical_point(node):\n    if node.previous is None or node.next is None:\n        return False\n    if node.previous.data < node.data and node.next.data < node.data:\n        return True\n    if node.previous.data > node.data and node.next.data > node.data:\n        return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1717",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed array nums consisting of n positive integers. You can choose an index i and change nums[i] into any positive integer.",
    "snippets": [
        "def change(nums):\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n",
        "def change(nums):\n    n = len(nums)\n    if n == 1:\n        return 1\n    if n == 2:\n        return max(nums[0], nums[1])\n    dp = [0] * n\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    return dp[n-1]\n",
        "def change(nums):\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n    else:\n        return nums[0] + change(nums[1:])\n",
        "def change(nums, i):\n    nums[i] = max(nums[i], 1)\n    return nums\n",
        "def change(nums, i):\n    nums[i] = 1\n    return nums\n",
        "def arrayNums(nums):\n    for i in range(len(nums)):\n        nums[i] = i\n    return nums\n"
    ],
    "results": 10
},{
    "id": "1718",
    "source": "leetcode",
    "language": "python",
    "query": "There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at  (n - 1, n - 1) You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell.",
    "snippets": [
        "def robot(n, startPos):\n    # Write your code here.\n    if n == 1:\n        return [[0]]\n    if n == 2:\n        return [[0, 0], [0, 1]]\n    if n == 3:\n        return [[0, 0], [0, 1], [0, 2]]\n    if n == 4:\n        return [[0, 0], [0, 1], [0, 2], [0, 3]]\n    if n == 5:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4]]\n    if n == 6:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5]]\n    if n == 7:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6]]\n    if n == 8:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7]]\n    if n == 9:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8]]\n    if n == 10:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9]]\n    if n == 11:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [0, 10]]\n    if n == 12:\n        return [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [\n",
        "def robot(n, startPos):\n    # Write your code here.\n    if n == 1:\n        return [[0]]\n    if n == 2:\n        return [[0, 1], [1, 0]]\n    if n == 3:\n        return [[0, 1, 2], [1, 2, 0], [2, 0, 1]]\n    if n == 4:\n        return [[0, 1, 2, 3], [1, 2, 3, 0], [2, 3, 0, 1], [3, 0, 1, 2]]\n    if n == 5:\n        return [[0, 1, 2, 3, 4], [1, 2, 3, 4, 0], [2, 3, 4, 0, 1], [3, 4, 0, 1, 2], [4, 0, 1, 2, 3]]\n    if n == 6:\n        return [[0, 1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 0], [2, 3, 4, 5, 0, 1], [3, 4, 5, 0, 1, 2], [4, 5, 0, 1, 2, 3], [5, 0, 1, 2, 3, 4]]\n    if n == 7:\n        return [[0, 1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6, 0], [2, 3, 4, 5, 6, 0, 1], [3, 4, 5, 6, 0, 1, 2], [4, 5, 6, 0, 1, 2, 3], [5, 6, 0, 1, 2, 3, 4], [6, 0, 1, 2, 3, 4, 5]]\n    if n == 8:\n        return [[0, 1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7, 0], [2, 3, 4, 5, 6, 7, 0, 1], [3, 4, 5, 6, 7, 0, 1, 2], [4, 5, 6, 7, 0, 1, 2, 3], [5, 6, 7, 0, 1,\n",
        "def robot_in_grid(n, startPos):\n    # Write your code here.\n    if n == 1:\n        return True\n    if startPos[0] < 0 or startPos[0] >= n or startPos[1] < 0 or startPos[1] >= n:\n        return False\n    return True\n",
        "def robot_in_grid(n, startPos):\n    if n == 1:\n        return True\n    if startPos[0] < 0 or startPos[0] >= n or startPos[1] < 0 or startPos[1] >= n:\n        return False\n    return True\n",
        "def robot(n, startPos):\n    # Write your code here.\n    if n == 1:\n        return [startPos]\n    else:\n        return robot(n - 1, startPos) + [[startPos[0] + 1, startPos[1]]] + robot(n - 1, [startPos[0] + 1, startPos[1] + 1]) + [[startPos[0] + 1, startPos[1] + 1]] + robot(n - 1, [startPos[0], startPos[1] + 1]) + [[startPos[0], startPos[1] + 1]]\n"
    ],
    "results": 10
},{
    "id": "1719",
    "source": "leetcode",
    "language": "python",
    "query": "Test cases are generated such that digit occurs at least once in number. Return the resulting string after removing exactly one occurrence of digit.",
    "snippets": [
        "def remove_digit(number, digit):\n    number = str(number)\n    digit = str(digit)\n    if digit in number:\n        number = number.replace(digit, '')\n    return number\n",
        "def remove_digit(number, digit):\n    number = str(number)\n    digit = str(digit)\n    if digit in number:\n        number = number.replace(digit, \"\")\n    return number\n",
        "def remove_digit(number, digit):\n    number = str(number)\n    digit = str(digit)\n    for i in range(len(number)):\n        if number[i] == digit:\n            number = number[:i] + number[i+1:]\n            break\n    return number\n",
        "def remove_digit(number, digit):\n    return str(int(number) - int(digit))\n",
        "def remove_digit(num, digit):\n    num = str(num)\n    for i in range(len(num)):\n        if num[i] == digit:\n            num = num[:i] + num[i+1:]\n            break\n    return int(num)\n"
    ],
    "results": 10
},{
    "id": "1720",
    "source": "leetcode",
    "language": "python",
    "query": "The test cases are generated such that there are no cycles anywhere in the entire linked structure. Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.",
    "snippets": [
        "def getIntersectionNode(self, headA, headB):\n    \"\"\"\n    :type head1, head1: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if headA is None or headB is None:\n        return None\n    p1 = headA\n    p2 = headB\n    while p1 != p2:\n        p1 = p1.next if p1 else headB\n        p2 = p2.next if p2 else headA\n    return p1\n",
        "def getIntersectionNode(self, headA, headB):\n    \"\"\"\n    :type head1, head1: ListNode\n    :rtype: ListNode\n    \"\"\"\n    if not headA or not headB:\n        return None\n    a = headA\n    b = headB\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n    return a\n",
        "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    if not headA or not headB:\n        return None\n    a, b = headA, headB\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n    return a\n",
        "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    if not headA or not headB:\n        return None\n    a = headA\n    b = headB\n    while a != b:\n        a = a.next if a else headB\n        b = b.next if b else headA\n    return a\n",
        "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    if headA is None or headB is None:\n        return None\n    a = headA\n    b = headB\n    while a != b:\n        if a is None:\n            a = headB\n        else:\n            a = a.next\n        if b is None:\n            b = headA\n        else:\n            b = b.next\n    return a\n",
        "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    if not headA or not headB:\n        return None\n    a = headA\n    b = headB\n    while a != b:\n        a = a.next\n        b = b.next\n        if not a and not b:\n            return None\n        if not a:\n            a = headB\n        if not b:\n            b = headA\n    return a\n",
        "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    if headA is None or headB is None:\n        return None\n    p1 = headA\n    p2 = headB\n    while p1 != p2:\n        p1 = p1.next\n        p2 = p2.next\n        if p1 is None and p2 is None:\n            return None\n        if p1 is None:\n            p1 = headB\n        if p2 is None:\n            p2 = headA\n    return p1\n",
        "def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n    if not headA or not headB:\n        return None\n    p1, p2 = headA, headB\n    while p1 != p2:\n        p1 = p1.next if p1 else headB\n        p2 = p2.next if p2 else headA\n    return p1\n",
        "def getIntersectionNode(headA, headB):\n    if headA is None or headB is None:\n        return None\n    if headA == headB:\n        return headA\n    a = headA\n    b = headB\n    while a != b:\n        if a is None:\n            a = headB\n        else:\n            a = a.next\n        if b is None:\n            b = headA\n        else:\n            b = b.next\n    return a\n"
    ],
    "results": 10
},{
    "id": "1721",
    "source": "leetcode",
    "language": "python",
    "query": "Return the kth positive integer that is missing from this array. Given an array of positive integers sorted in a strictly increasing order, and an integer k.",
    "snippets": [
        "def find_kth_positive_integer(arr, k):\n    if len(arr) == 0:\n        return k\n    if k == 1:\n        return arr[0] + 1\n    if k == len(arr) + 1:\n        return arr[-1] + 1\n    if k > len(arr) + 1:\n        return arr[-1] + k - len(arr) - 1\n    if k < 1:\n        return arr[0] - 1\n    if k == len(arr):\n        return arr[-1] + 1\n    if k == len(arr) - 1:\n        return arr[-1] + 2\n    if k == len(arr) // 2:\n        return arr[len(arr) // 2] + 1\n    if k == len(arr) // 2 + 1:\n        return arr[len(arr) // 2] + 2\n    if k == len(arr) // 2 + 2:\n        return arr[len(arr) // 2] + 3\n    if k == len(arr) // 2 + 3:\n        return arr[len(arr) // 2] + 4\n    if k == len(arr) // 2 + 4:\n        return arr[len(arr) // 2] + 5\n    if k == len(arr) // 2 + 5:\n        return arr[len(arr) // 2] + 6\n    if k == len(arr) // 2 + 6:\n        return arr[len(arr) // 2] + 7\n    if k == len(arr) // 2 + 7:\n        return arr[len(arr) // 2] + 8\n    if k == len(arr) // 2 + 8:\n        return arr[len(arr) // 2] + 9\n    if k == len(arr) // 2 + 9:\n        return arr[len(arr) // 2] + 10\n    if k == len(arr) // 2 + 10:\n        return arr[len(arr) // 2] + 11\n    if k == len(arr) // 2 + 11:\n        return arr[len(arr) // 2] + 12\n    if k == len(arr) // 2 + 12\n",
        "def find_kth_positive_integer(arr, k):\n    if len(arr) == 0:\n        return k\n    if k == 1:\n        return arr[0] + 1\n    if k == len(arr) + 1:\n        return arr[-1] + 1\n    if k > len(arr) + 1:\n        return arr[-1] + k - len(arr) - 1\n    if k < 1:\n        return arr[0] - 1\n    if k == len(arr):\n        return arr[-1] + 1\n    if k == len(arr) - 1:\n        return arr[-1] + 2\n    if k == len(arr) + 2:\n        return arr[-1] + 3\n    if k == len(arr) + 3:\n        return arr[-1] + 4\n    if k == len(arr) + 4:\n        return arr[-1] + 5\n    if k == len(arr) + 5:\n        return arr[-1] + 6\n    if k == len(arr) + 6:\n        return arr[-1] + 7\n    if k == len(arr) + 7:\n        return arr[-1] + 8\n    if k == len(arr) + 8:\n        return arr[-1] + 9\n    if k == len(arr) + 9:\n        return arr[-1] + 10\n    if k == len(arr) + 10:\n        return arr[-1] + 11\n    if k == len(arr) + 11:\n        return arr[-1] + 12\n    if k == len(arr) + 12:\n        return arr[-1] + 13\n    if k == len(arr) + 13:\n        return arr[-1] + 14\n    if k == len(arr) + 14:\n        return arr[-1] + 15\n    if k == len(arr) + 15:\n        return arr[-1] + 16\n    if k == len(arr) + 16:\n        return arr[-1] + 17\n    if k == len(arr) + 17:\n        return arr[\n",
        "def find_kth_positive_integer(arr, k):\n    if len(arr) == 0:\n        return k\n    if len(arr) == 1:\n        return arr[0] + k\n    if len(arr) == 2:\n        return arr[1] + k\n    if len(arr) == 3:\n        return arr[2] + k\n    if len(arr) == 4:\n        return arr[3] + k\n    if len(arr) == 5:\n        return arr[4] + k\n    if len(arr) == 6:\n        return arr[5] + k\n    if len(arr) == 7:\n        return arr[6] + k\n    if len(arr) == 8:\n        return arr[7] + k\n    if len(arr) == 9:\n        return arr[8] + k\n    if len(arr) == 10:\n        return arr[9] + k\n    if len(arr) == 11:\n        return arr[10] + k\n    if len(arr) == 12:\n        return arr[11] + k\n    if len(arr) == 13:\n        return arr[12] + k\n    if len(arr) == 14:\n        return arr[13] + k\n    if len(arr) == 15:\n        return arr[14] + k\n    if len(arr) == 16:\n        return arr[15] + k\n    if len(arr) == 17:\n        return arr[16] + k\n    if len(arr) == 18:\n        return arr[17] + k\n    if len(arr) == 19:\n        return arr[18] + k\n    if len(arr) == 20:\n        return arr[19] + k\n    if len(arr) == 21:\n        return arr[20] + k\n    if len(arr) == 22:\n        return arr[21] + k\n    if len(arr) == 23:\n        return arr[22] + k\n    if len(arr) == 24:\n        return arr[23] + k\n    if len(arr) == 25:\n        return arr[24\n",
        "def find_kth_positive_integer(arr, k):\n    if len(arr) == 0:\n        return k\n    if k == 1:\n        return arr[0] + 1\n    if k > len(arr):\n        return arr[-1] + k - len(arr)\n    if k == len(arr) + 1:\n        return arr[-1] + 2\n    if k == len(arr) + 2:\n        return arr[-1] + 3\n    if k == len(arr) + 3:\n        return arr[-1] + 4\n    if k == len(arr) + 4:\n        return arr[-1] + 5\n    if k == len(arr) + 5:\n        return arr[-1] + 6\n    if k == len(arr) + 6:\n        return arr[-1] + 7\n    if k == len(arr) + 7:\n        return arr[-1] + 8\n    if k == len(arr) + 8:\n        return arr[-1] + 9\n    if k == len(arr) + 9:\n        return arr[-1] + 10\n    if k == len(arr) + 10:\n        return arr[-1] + 11\n    if k == len(arr) + 11:\n        return arr[-1] + 12\n    if k == len(arr) + 12:\n        return arr[-1] + 13\n    if k == len(arr) + 13:\n        return arr[-1] + 14\n    if k == len(arr) + 14:\n        return arr[-1] + 15\n    if k == len(arr) + 15:\n        return arr[-1] + 16\n    if k == len(arr) + 16:\n        return arr[-1] + 17\n    if k == len(arr) + 17:\n        return arr[-1] + 18\n    if k == len(arr) + 18:\n        return arr[-1] + 19\n    if k == len(arr) + 19:\n        return arr[-1] + 20\n    if k == len(arr) + 20:\n",
        "def missing_number(arr, k):\n    if len(arr) == k:\n        return k + 1\n    elif len(arr) == k - 1:\n        return arr[-1] + 1\n    else:\n        return arr[k - 1] + 1\n",
        "def findMissing(arr, k):\n    if len(arr) == 0:\n        return k\n    if arr[0] > k:\n        return k\n    if arr[-1] < k:\n        return k\n    for i in range(len(arr)):\n        if arr[i] == k:\n            return findMissing(arr[i+1:], k+1)\n    return k\n",
        "def find_kth_positive_integer(arr, k):\n    if k == 1:\n        return arr[0] + 1\n    elif k == len(arr) + 1:\n        return arr[-1] + 1\n    else:\n        return arr[k - 2] + 1\n",
        "def find_missing_number(arr, k):\n    if len(arr) == k:\n        return k + 1\n    elif len(arr) == k - 1:\n        return arr[-1] + 1\n    else:\n        return arr[k - 1] + 1\n",
        "def find_missing_number(arr, k):\n    if len(arr) == 0:\n        return k\n    if len(arr) == 1:\n        if arr[0] == k:\n            return k + 1\n        else:\n            return k\n    if arr[0] == k:\n        return find_missing_number(arr[1:], k + 1)\n    else:\n        return find_missing_number(arr[1:], k)\n"
    ],
    "results": 10
},{
    "id": "1722",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of aNon-Zero area, return 0.",
    "snippets": [
        "def largestPerimeter(nums):\n    nums.sort()\n    for i in range(len(nums)-1, 1, -1):\n        if nums[i-1] + nums[i-2] > nums[i]:\n            return nums[i-1] + nums[i-2] + nums[i]\n    return 0\n",
        "def largestPerimeter(nums):\n    nums.sort()\n    for i in range(len(nums)-1, 1, -1):\n        if nums[i-1]+nums[i-2]>nums[i]:\n            return nums[i]+nums[i-1]+nums[i-2]\n    return 0\n",
        "def largestPerimeter(nums):\n    nums.sort()\n    for i in range(len(nums)-2, -1, -1):\n        if nums[i] + nums[i+1] > nums[i+2]:\n            return nums[i] + nums[i+1] + nums[i+2]\n    return 0\n",
        "def largestPerimeter(A):\n    A.sort()\n    for i in range(len(A)-1, 1, -1):\n        if A[i-1] + A[i-2] > A[i]:\n            return A[i-1] + A[i-2] + A[i]\n    return 0\n"
    ],
    "results": 10
},{
    "id": "1723",
    "source": "leetcode",
    "language": "python",
    "query": "When a customer is paying, their bill is represented as two parallel integer arrays product and amount. The jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought.",
    "snippets": [
        "def buy(product, amount):\n    total = 0\n    for i in range(len(product)):\n        total += amount[i] * product[i]\n    return total\n",
        "def buy_products(product, amount):\n    total = 0\n    for i in range(len(product)):\n        total += amount[i] * product[i]\n    return total\n",
        "def get_change(amount):\n    coins = [1, 5, 10, 25]\n    change = []\n    for coin in coins:\n        while amount >= coin:\n            amount -= coin\n            change.append(coin)\n    return change\n",
        "def get_change(amount):\n    change = []\n    while amount > 0:\n        if amount >= 25:\n            change.append(25)\n            amount -= 25\n        elif amount >= 10:\n            change.append(10)\n            amount -= 10\n        elif amount >= 5:\n            change.append(5)\n            amount -= 5\n        elif amount >= 1:\n            change.append(1)\n            amount -= 1\n    return change\n",
        "def buy_product(product, amount):\n    total = 0\n    for i in range(len(product)):\n        total += amount[i] * product[i]\n    return total\n",
        "def get_change(amount):\n    coins = [1, 5, 10, 25]\n    change = []\n    for coin in coins:\n        while amount >= coin:\n            change.append(coin)\n            amount -= coin\n    return change\n",
        "def buy_products(product, amount):\n    \"\"\"\n    :param product: list of integers\n    :param amount: list of integers\n    :return: list of integers\n    \"\"\"\n    # Initialize a list to store the total amount of each product\n    total_amount = [0] * len(product)\n    # Iterate through the product list\n    for i in range(len(product)):\n        # Add the amount of each product to the total amount list\n        total_amount[product[i]] += amount[i]\n    # Return the total amount list\n    return total_amount\n"
    ],
    "results": 10
},{
    "id": "1724",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.",
    "snippets": [
        "def canPartitionKSubsets(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 1:\n        return True\n    if len(nums) < k:\n        return False\n    if sum(nums) % k != 0:\n        return False\n    target = sum(nums) // k\n    nums.sort(reverse=True)\n    if nums[0] > target:\n        return False\n    if nums[0] == target:\n        return True\n    return dfs(nums, k, target, 0, 0, [])\n",
        "def canPartitionKSubsets(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 1:\n        return True\n    if len(nums) < k:\n        return False\n    if sum(nums) % k != 0:\n        return False\n    target = sum(nums) // k\n    nums.sort(reverse=True)\n    return dfs(nums, k, target, 0, 0, 0)\n",
        "def canPartitionKSubsets(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 1:\n        return True\n    if len(nums) < k:\n        return False\n    if sum(nums) % k != 0:\n        return False\n    target = sum(nums) // k\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    if nums[-1] == target:\n        if k == 2:\n            return True\n        else:\n            return False\n    if nums[-1] < target:\n        return canPartitionKSubsets(nums[:-1], k-1)\n    return False\n",
        "def canPartitionKSubsets(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 1:\n        return True\n    if k == 0 or len(nums) == 0:\n        return False\n    if len(nums) < k:\n        return False\n    sum = sum(nums)\n    if sum % k != 0:\n        return False\n    target = sum // k\n    nums.sort()\n    if nums[-1] > target:\n        return False\n    if nums[-1] == target:\n        return True\n    if nums[-1] < target:\n        return canPartitionKSubsets(nums[:-1], k - 1)\n    return False\n",
        "def canPartitionKSubsets(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 1:\n        return True\n    if len(nums) < k:\n        return False\n    if sum(nums) % k != 0:\n        return False\n    target = sum(nums) // k\n    nums.sort(reverse=True)\n    if nums[0] > target:\n        return False\n    if nums[0] == target:\n        return True if k == 2 else False\n    if nums[0] < target:\n        return dfs(nums, k, target, 0, 0)\n",
        "def canPartitionKSubsets(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 1:\n        return True\n    if len(nums) < k:\n        return False\n    if sum(nums) % k != 0:\n        return False\n    target = sum(nums) // k\n    nums.sort(reverse=True)\n    if nums[0] > target:\n        return False\n    if nums[0] == target:\n        return True if k == 2 else False\n    if nums[0] < target:\n        return canPartitionKSubsets(nums[1:], k - 1) or canPartitionKSubsets(nums[1:], k)\n    return False\n"
    ],
    "results": 10
},{
    "id": "1725",
    "source": "leetcode",
    "language": "python",
    "query": "The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down. Every move incurs some cost. There is an m x n grid, where (0, 0) is the top-left cell.",
    "snippets": [
        "def minCost(m, n, cost):\n    if m == 0 or n == 0:\n        return 0\n    if m == 1 and n == 1:\n        return cost[0][0]\n    if m == 1:\n        return minCost(n, n, cost)\n    if n == 1:\n        return minCost(m, m, cost)\n    return min(minCost(m, n - 1, cost), minCost(m - 1, n, cost)) + cost[m - 1][n - 1]\n",
        "def minCost(m, n, cost):\n    if m == 0 or n == 0:\n        return 0\n    if m == 1 and n == 1:\n        return cost[0][0]\n    if m == 1:\n        return min(cost[0][0], cost[0][1]) + minCost(m, n-1, cost)\n    if n == 1:\n        return min(cost[0][0], cost[1][0]) + minCost(m-1, n, cost)\n    return min(cost[0][0], cost[0][1], cost[1][0], cost[1][1]) + minCost(m-1, n-1, cost)\n",
        "def minCost(m, n, cost):\n    if m == 0 or n == 0:\n        return 0\n    if m == 1 and n == 1:\n        return cost[0][0]\n    if m == 1:\n        return minCost(n, n, cost)\n    if n == 1:\n        return minCost(m, m, cost)\n    return min(minCost(m, n - 1, cost) + cost[0][n - 1], minCost(m - 1, n, cost) + cost[m - 1][0], minCost(m - 1, n - 1, cost) + cost[m - 1][n - 1], minCost(m - 1, n, cost) + cost[m - 1][0])\n",
        "def find_path(m, n, cost):\n    # Write your code here.\n    if m == 0 and n == 0:\n        return 0\n    if m == 0:\n        return find_path(m, n-1, cost) + cost[n-1][0]\n    if n == 0:\n        return find_path(m-1, n, cost) + cost[0][m-1]\n    return min(find_path(m-1, n, cost) + cost[0][m-1], find_path(m, n-1, cost) + cost[n-1][0], find_path(m-1, n-1, cost) + cost[0][m-1], find_path(m-1, n-1, cost) + cost[n-1][0])\n",
        "def find_path(m, n, cost):\n    # Write your code here.\n    if m == 0 and n == 0:\n        return 0\n    if m == 0:\n        return find_path(m, n-1, cost)\n    if n == 0:\n        return find_path(m-1, n, cost)\n    return min(find_path(m, n-1, cost), find_path(m-1, n, cost)) + cost[m][n]\n",
        "def find_path(m, n, grid):\n    # Write your code here.\n    if m == 0 and n == 0:\n        return 0\n    if grid[m][n] == -1:\n        return float('inf')\n    if m == 0:\n        return find_path(m, n-1, grid) + grid[m][n]\n    if n == 0:\n        return find_path(m-1, n, grid) + grid[m][n]\n    return min(find_path(m, n-1, grid) + grid[m][n], find_path(m-1, n, grid) + grid[m][n], find_path(m-1, n-1, grid) + grid[m][n], find_path(m, n-1, grid) + grid[m][n])\n",
        "def get_path(m, n, cost):\n    # Write your code here.\n    if m == 0 and n == 0:\n        return 0\n    if m == 0:\n        return n * cost[0]\n    if n == 0:\n        return m * cost[1]\n    return min(get_path(m - 1, n, cost) + cost[0], get_path(m, n - 1, cost) + cost[1])\n",
        "def find_path(m, n, grid):\n    if m == 0 and n == 0:\n        return 0\n    if grid[m][n] == -1:\n        return -1\n    if m == 0:\n        return find_path(m, n-1, grid) + grid[m][n]\n    if n == 0:\n        return find_path(m-1, n, grid) + grid[m][n]\n    left = find_path(m, n-1, grid)\n    up = find_path(m-1, n, grid)\n    if left == -1 and up == -1:\n        return -1\n    if left == -1:\n        return up + grid[m][n]\n    if up == -1:\n        return left + grid[m][n]\n    return min(left, up) + grid[m][n]\n",
        "def find_path(m, n, grid):\n    if m == 0 and n == 0:\n        return 0\n    if grid[m][n] == -1:\n        return -1\n    if m == 0:\n        return find_path(m, n - 1, grid) + grid[m][n]\n    if n == 0:\n        return find_path(m - 1, n, grid) + grid[m][n]\n    return min(find_path(m - 1, n, grid), find_path(m, n - 1, grid)) + grid[m][n]\n"
    ],
    "results": 10
},{
    "id": "1726",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed integer array nums of length n. Each num contains a valid split at index i if the following are true: 1 + 1 is greater than or equal to the sum of the last n - i - 1 elements.",
    "snippets": [
        "def valid(nums, n):\n    for i in range(n):\n        if nums[i] + 1 < sum(nums[i+1:]):\n            return False\n    return True\n",
        "def splitArray(nums):\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n    if len(nums) == 3:\n        return max(nums[0], nums[1], nums[2])\n    if len(nums) == 4:\n        return max(nums[0], nums[1], nums[2], nums[3])\n    if len(nums) == 5:\n        return max(nums[0], nums[1], nums[2], nums[3], nums[4])\n    if len(nums) == 6:\n        return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5])\n    if len(nums) == 7:\n        return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6])\n    if len(nums) == 8:\n        return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7])\n    if len(nums) == 9:\n        return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8])\n    if len(nums) == 10:\n        return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9])\n    if len(nums) == 11:\n        return max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8\n",
        "def valid(nums, n):\n    for i in range(n):\n        if 1 + 1 < sum(nums[i + 1:n]):\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1727",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for. If original is found in nums, multiply it by two (i.e., set original = 2 * original). Otherwise, stop the process.",
    "snippets": [
        "def double_numbers(nums, original):\n    for i in range(len(nums)):\n        if nums[i] == original:\n            nums[i] = 2 * original\n            return nums\n    return nums\n",
        "def search(nums, original):\n    for i in range(len(nums)):\n        if nums[i] == original:\n            nums[i] = 2 * original\n            return\n    return\n",
        "def double_me(nums, original):\n    for i in range(len(nums)):\n        if nums[i] == original:\n            nums[i] = 2 * original\n            return nums\n    return nums\n"
    ],
    "results": 10
},{
    "id": "1728",
    "source": "leetcode",
    "language": "python",
    "query": "Your country has an infinite number of lakes. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.",
    "snippets": [
        "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    ans = 0\n    for i in range(n):\n        if a[i] == 0:\n            ans += 1\n        else:\n            break\n    print(ans)\n",
        "def main():\n    # Your code goes here\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    e = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n    g = list(map(int, input().split()))\n    h = list(map(int, input().split()))\n    i = list(map(int, input().split()))\n    j = list(map(int, input().split()))\n    k = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    m = list(map(int, input().split()))\n    n = list(map(int, input().split()))\n    o = list(map(int, input().split()))\n    p = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n    r = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n    u = list(map(int, input().split()))\n    v = list(map(int, input().split()))\n    w = list(map(int, input().split()))\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    z = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    d = list(map(int, input().split()))\n    e = list(map(int, input().split()))\n    f = list(map(int, input().split()))\n",
        "def avoid_flood(arr):\n    # Write your code here.\n    lakes = []\n    for i in range(len(arr)):\n        if arr[i] == 1:\n            lakes.append(i)\n    lakes.sort()\n    for i in range(len(lakes)):\n        if i == 0:\n            continue\n        if lakes[i] - lakes[i-1] < 3:\n            return False\n    return True\n",
        "def main():\n    # Your code goes here\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    for i in range(n):\n        if a[i] == 0:\n            print(i+1)\n            return\n    print(-1)\n",
        "def avoid_floods(lakes):\n    lakes.sort()\n    for i in range(len(lakes)):\n        if lakes[i] > 0:\n            return i\n    return -1\n",
        "def avoid_flood(arr):\n    # Write your code here.\n    # print(arr)\n    # print(len(arr))\n    # print(arr[0])\n    # print(arr[1])\n    # print(arr[2])\n    # print(arr[3])\n    # print(arr[4])\n    # print(arr[5])\n    # print(arr[6])\n    # print(arr[7])\n    # print(arr[8])\n    # print(arr[9])\n    # print(arr[10])\n    # print(arr[11])\n    # print(arr[12])\n    # print(arr[13])\n    # print(arr[14])\n    # print(arr[15])\n    # print(arr[16])\n    # print(arr[17])\n    # print(arr[18])\n    # print(arr[19])\n    # print(arr[20])\n    # print(arr[21])\n    # print(arr[22])\n    # print(arr[23])\n    # print(arr[24])\n    # print(arr[25])\n    # print(arr[26])\n    # print(arr[27])\n    # print(arr[28])\n    # print(arr[29])\n    # print(arr[30])\n    # print(arr[31])\n    # print(arr[32])\n    # print(arr[33])\n    # print(arr[34])\n    # print(arr[35])\n    # print(arr[36])\n    # print(arr[37])\n    # print(arr[38])\n    # print(arr[39])\n    # print(arr[40])\n    # print(arr[41])\n    # print(arr[42])\n    # print(arr[43])\n    # print(arr[44])\n    # print(arr[45])\n    # print(arr[46])\n    # print(arr[47])\n    # print(arr[48])\n    # print(arr[49])\n    # print(arr[50])\n    # print(arr[51])\n"
    ],
    "results": 8
},{
    "id": "1729",
    "source": "leetcode",
    "language": "python",
    "query": "Solve a given equation and return the value of 'x' in the form of a string. The equation contains only '+', '-' operation, the variable 'x', and its coefficient. You should return \"No solution\" if there is no solution for the equation.",
    "snippets": [
        "def solveEquation(equation):\n    # Write your code here\n    equation = equation.split('=')\n    left = equation[0]\n    right = equation[1]\n    left = left.split('+')\n    right = right.split('+')\n    left_sum = 0\n    right_sum = 0\n    for i in left:\n        if 'x' in i:\n            i = i.split('x')\n            left_sum += int(i[0]) * int(i[1])\n        else:\n            left_sum += int(i)\n    for i in right:\n        if 'x' in i:\n            i = i.split('x')\n            right_sum += int(i[0]) * int(i[1])\n        else:\n            right_sum += int(i)\n    if left_sum == right_sum:\n        return 'x=0'\n    elif left_sum == 0:\n        return 'x=' + str(right_sum)\n    elif right_sum == 0:\n        return 'x=' + str(left_sum)\n    else:\n        return 'No solution'\n",
        "def solveEquation(equation):\n    # Write your code here\n    equation = equation.split('=')\n    left = equation[0]\n    right = equation[1]\n    left = left.split('+')\n    right = right.split('+')\n    left_sum = 0\n    right_sum = 0\n    for i in left:\n        if 'x' in i:\n            i = i.split('x')\n            if len(i) == 1:\n                left_sum += int(i[0])\n            else:\n                left_sum += int(i[0]) * int(i[1])\n        else:\n            left_sum += int(i)\n    for i in right:\n        if 'x' in i:\n            i = i.split('x')\n            if len(i) == 1:\n                right_sum += int(i[0])\n            else:\n                right_sum += int(i[0]) * int(i[1])\n        else:\n            right_sum += int(i)\n    if left_sum == right_sum:\n        return 'x=0'\n    elif left_sum == 0:\n        return 'x=' + str(right_sum)\n    elif right_sum == 0:\n        return 'x=' + str(left_sum)\n    else:\n        return 'No solution'\n",
        "def solveEquation(equation):\n    # Write your code here\n    equation = equation.split('=')\n    left = equation[0]\n    right = equation[1]\n    left = left.split('+')\n    right = right.split('+')\n    left = [x.split('x') for x in left]\n    right = [x.split('x') for x in right]\n    left = [int(x[0]) if len(x) == 1 else int(x[0]) * int(x[1]) for x in left]\n    right = [int(x[0]) if len(x) == 1 else int(x[0]) * int(x[1]) for x in right]\n    left = sum(left)\n    right = sum(right)\n    if left == right:\n        return 'x=0'\n    if left == 0:\n        return 'x=' + str(-right)\n    if right == 0:\n        return 'x=' + str(-left)\n    return 'No solution'\n",
        "def solveEquation(equation):\n    x = 0\n    y = 0\n    for i in equation:\n        if i == '=':\n            x = y\n            y = 0\n        elif i == '+':\n            x = x + y\n            y = 0\n        elif i == '-':\n            x = x - y\n            y = 0\n        else:\n            y = y * 10 + int(i)\n    return str(x - y) if x != y else \"No solution\"\n",
        "def solveEquation(equation):\n    x = 0\n    y = 0\n    for i in equation:\n        if i == 'x':\n            x += 1\n        elif i == '=':\n            y += 1\n        elif i == '+':\n            x += 1\n            y += 1\n        elif i == '-':\n            x += 1\n            y -= 1\n    if x == y:\n        return 'x=0'\n    elif x > y:\n        return 'No solution'\n    else:\n        return 'x=' + str(y // x)\n",
        "def solveEquation(equation):\n    # Write your code here\n    equation = equation.split('=')\n    if equation[0] == equation[1]:\n        return 'x=0'\n    if equation[0] == '0':\n        return 'x=' + str(eval(equation[1]))\n    if equation[1] == '0':\n        return 'x=' + str(eval(equation[0]))\n    if 'x' in equation[0]:\n        if 'x' in equation[1]:\n            return 'x=' + str(eval(equation[1]) - eval(equation[0]))\n        else:\n            return 'x=' + str(eval(equation[1]) - eval(equation[0]))\n    else:\n        if 'x' in equation[1]:\n            return 'x=' + str(eval(equation[1]) - eval(equation[0]))\n        else:\n            return 'x=' + str(eval(equation[1]) - eval(equation[0]))\n    return 'No solution'\n",
        "def solveEquation(equation):\n    # Write your code here\n    equation = equation.split('=')\n    if equation[0] == equation[1]:\n        return 'x=0'\n    if equation[0] == '0':\n        return 'x=' + equation[1]\n    if equation[1] == '0':\n        return 'x=' + equation[0]\n    if equation[0] == 'x':\n        return 'x=' + equation[1]\n    if equation[1] == 'x':\n        return 'x=' + equation[0]\n    if equation[0] == '1x':\n        return 'x=' + equation[1]\n    if equation[1] == '1x':\n        return 'x=' + equation[0]\n    if equation[0] == 'x+1':\n        return 'x=' + equation[1]\n    if equation[1] == 'x+1':\n        return 'x=' + equation[0]\n    if equation[0] == '1x+1':\n        return 'x=' + equation[1]\n    if equation[1] == '1x+1':\n        return 'x=' + equation[0]\n    if equation[0] == 'x-1':\n        return 'x=' + equation[1]\n    if equation[1] == 'x-1':\n        return 'x=' + equation[0]\n    if equation[0] == '1x-1':\n        return 'x=' + equation[1]\n    if equation[1] == '1x-1':\n        return 'x=' + equation[0]\n    if equation[0] == 'x-1':\n        return 'x=' + equation[1]\n    if equation[1] == 'x-1':\n        return 'x=' + equation[0]\n    if equation[0] == '1x-1':\n        return 'x=' + equation[1]\n    if equation[1] == '1x-1':\n        return 'x=' + equation[0]\n    if equation[0] == 'x+1':\n        return 'x=' + equation[1]\n    if\n",
        "def solveEquation(equation):\n    x = 0\n    a = 0\n    b = 0\n    for i in equation:\n        if i == '+':\n            x += a\n            a = 0\n        elif i == '-':\n            x += a\n            a = 0\n        elif i == 'x':\n            a = x\n            x = 0\n        else:\n            a = a * 10 + int(i)\n    x += a\n    b = x - a\n    if b == 0:\n        return \"Infinite solutions\"\n    elif b == 0:\n        return \"No solution\"\n    else:\n        return \"x=\" + str(b // x)\n",
        "def solveEquation(equation):\n    # Write your code here\n    equation = equation.split('=')\n    a, b = equation[0].split('+')\n    c, d = equation[1].split('+')\n    a, b, c, d = int(a), int(b), int(c), int(d)\n    if a == c:\n        if b == d:\n            return 'x=0'\n        else:\n            return 'No solution'\n    else:\n        x = (d - b) / (a - c)\n        return 'x=' + str(x)\n"
    ],
    "results": 9
},{
    "id": "1730",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array nums and two integers limit and goal. Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i], limit.",
    "snippets": [
        "def min_add(nums, limit, goal):\n    if goal == 0:\n        return 0\n    if goal > 0:\n        return min_add_positive(nums, limit, goal)\n    else:\n        return min_add_negative(nums, limit, goal)\n",
        "def min_add_to_make_sum_equal_to_goal(nums, limit, goal):\n    if goal > limit * len(nums):\n        return -1\n    if goal == 0:\n        return 0\n    if goal < 0:\n        return -1\n    if goal == 1:\n        return 1\n    if goal == 2:\n        return 2\n    if goal == 3:\n        return 3\n    if goal == 4:\n        return 4\n    if goal == 5:\n        return 5\n    if goal == 6:\n        return 6\n    if goal == 7:\n        return 7\n    if goal == 8:\n        return 8\n    if goal == 9:\n        return 9\n    if goal == 10:\n        return 10\n    if goal == 11:\n        return 11\n    if goal == 12:\n        return 12\n    if goal == 13:\n        return 13\n    if goal == 14:\n        return 14\n    if goal == 15:\n        return 15\n    if goal == 16:\n        return 16\n    if goal == 17:\n        return 17\n    if goal == 18:\n        return 18\n    if goal == 19:\n        return 19\n    if goal == 20:\n        return 20\n    if goal == 21:\n        return 21\n    if goal == 22:\n        return 22\n    if goal == 23:\n        return 23\n    if goal == 24:\n        return 24\n    if goal == 25:\n        return 25\n    if goal == 26:\n        return 26\n    if goal == 27:\n        return 27\n    if goal == 28:\n        return 28\n    if goal == 29:\n        return 29\n    if goal == 30:\n        return 30\n    if goal == 31:\n        return 31\n    if goal == 32:\n        return 32\n    if goal == 33:\n        return 33\n    if goal == 34:\n        return 34\n    if goal == 35:\n        return 35\n    if goal == 36:\n        return 36\n    if goal == 37:\n        return 37\n    if goal == 38:\n        return 38\n    if goal == 39:\n        return 39\n    if goal == 40:\n",
        "def min_add_to_make_sum_equal_to_goal(nums, limit, goal):\n    if goal > limit * len(nums):\n        return -1\n    if goal == 0:\n        return 0\n    if goal < 0:\n        return -1\n    if goal == 1:\n        return len(nums)\n    if goal == 2:\n        return len(nums) + 1\n    if goal == 3:\n        return len(nums) + 2\n    if goal == 4:\n        return len(nums) + 3\n    if goal == 5:\n        return len(nums) + 4\n    if goal == 6:\n        return len(nums) + 5\n    if goal == 7:\n        return len(nums) + 6\n    if goal == 8:\n        return len(nums) + 7\n    if goal == 9:\n        return len(nums) + 8\n    if goal == 10:\n        return len(nums) + 9\n    if goal == 11:\n        return len(nums) + 10\n    if goal == 12:\n        return len(nums) + 11\n    if goal == 13:\n        return len(nums) + 12\n    if goal == 14:\n        return len(nums) + 13\n    if goal == 15:\n        return len(nums) + 14\n    if goal == 16:\n        return len(nums) + 15\n    if goal == 17:\n        return len(nums) + 16\n    if goal == 18:\n        return len(nums) + 17\n    if goal == 19:\n        return len(nums) + 18\n    if goal == 20:\n        return len(nums) + 19\n    if goal == 21:\n        return len(nums) + 20\n    if goal == 22:\n        return len(nums) + 21\n    if goal == 23:\n        return len(nums) + 22\n    if goal == 24:\n        return len(nums) + 23\n    if goal == 25:\n        return len(nums) + 24\n    if goal == 26:\n        return len(n\n",
        "def min_add(nums, limit, goal):\n    if goal > limit * len(nums):\n        return -1\n    if goal == 0:\n        return 0\n    if goal < 0:\n        return -1\n    if goal == 1:\n        return 1\n    if goal == 2:\n        return 2\n    if goal == 3:\n        return 3\n    if goal == 4:\n        return 4\n    if goal == 5:\n        return 5\n    if goal == 6:\n        return 6\n    if goal == 7:\n        return 7\n    if goal == 8:\n        return 8\n    if goal == 9:\n        return 9\n    if goal == 10:\n        return 10\n    if goal == 11:\n        return 11\n    if goal == 12:\n        return 12\n    if goal == 13:\n        return 13\n    if goal == 14:\n        return 14\n    if goal == 15:\n        return 15\n    if goal == 16:\n        return 16\n    if goal == 17:\n        return 17\n    if goal == 18:\n        return 18\n    if goal == 19:\n        return 19\n    if goal == 20:\n        return 20\n    if goal == 21:\n        return 21\n    if goal == 22:\n        return 22\n    if goal == 23:\n        return 23\n    if goal == 24:\n        return 24\n    if goal == 25:\n        return 25\n    if goal == 26:\n        return 26\n    if goal == 27:\n        return 27\n    if goal == 28:\n        return 28\n    if goal == 29:\n        return 29\n    if goal == 30:\n        return 30\n    if goal == 31:\n        return 31\n    if goal == 32:\n        return 32\n    if goal == 33:\n        return 33\n    if goal == 34:\n        return 34\n    if goal == 35:\n        return 35\n    if goal == 36:\n        return 36\n    if goal == 37:\n        return 37\n    if goal == 38:\n        return 38\n    if goal == 39:\n        return 39\n    if goal == 40:\n        return 40\n    if goal == 41:\n",
        "def min_add_to_make_sum_equal_to_goal(nums, limit, goal):\n    if goal == 0:\n        return 0\n    if goal < 0:\n        return -1\n    if limit == 0:\n        return -1\n    if goal > limit:\n        return -1\n    if goal == limit:\n        return len(nums)\n    if len(nums) == 0:\n        return -1\n    if len(nums) == 1:\n        if nums[0] == goal:\n            return 0\n        else:\n            return -1\n    if nums[0] == goal:\n        return 1\n    if nums[0] > goal:\n        return -1\n    if nums[0] < goal:\n        return 1\n    if nums[0] == goal:\n        return 1\n    if nums[0] < goal:\n        return 1\n    if nums[0] > goal:\n        return -1\n    if nums[0] == goal:\n        return 1\n    if nums[0] < goal:\n        return 1\n    if nums[0] > goal:\n        return -1\n    if nums[0] == goal:\n        return 1\n    if nums[0] < goal:\n        return 1\n    if nums[0] > goal:\n        return -1\n    if nums[0] == goal:\n        return 1\n    if nums[0] < goal:\n        return 1\n    if nums[0] > goal:\n        return -1\n    if nums[0] == goal:\n        return 1\n    if nums[0] < goal:\n        return 1\n    if nums[0] > goal:\n        return -1\n    if nums[0] == goal:\n        return 1\n    if nums[0] < goal:\n        return 1\n    if nums[0] > goal:\n        return -1\n    if nums[0] == goal:\n        return 1\n    if nums[0] < goal:\n        return 1\n    if nums[0] > goal:\n",
        "def min_add_to_make_sum_equal_to_goal(nums, limit, goal):\n    if goal == 0:\n        return 0\n    if goal > 0:\n        return min_add_to_make_sum_greater_than_goal(nums, limit, goal)\n    else:\n        return min_add_to_make_sum_less_than_goal(nums, limit, goal)\n",
        "def min_add_to_make_sum_equal_to_goal(nums, limit, goal):\n    # Write your code here.\n    if goal == 0:\n        return 0\n    if limit == 0:\n        return len(nums)\n    if goal < 0:\n        return len(nums)\n    if limit < 0:\n        return len(nums)\n    if goal > limit:\n        return len(nums)\n    if limit > goal:\n        return len(nums)\n    if goal == limit:\n        return 0\n    if goal == 1:\n        return len(nums)\n    if limit == 1:\n        return len(nums)\n    if goal == 2:\n        return len(nums)\n    if limit == 2:\n        return len(nums)\n    if goal == 3:\n        return len(nums)\n    if limit == 3:\n        return len(nums)\n    if goal == 4:\n        return len(nums)\n    if limit == 4:\n        return len(nums)\n    if goal == 5:\n        return len(nums)\n    if limit == 5:\n        return len(nums)\n    if goal == 6:\n        return len(nums)\n    if limit == 6:\n        return len(nums)\n    if goal == 7:\n        return len(nums)\n    if limit == 7:\n        return len(nums)\n    if goal == 8:\n        return len(nums)\n    if limit == 8:\n        return len(nums)\n    if goal == 9:\n        return len(nums)\n    if limit == 9:\n        return len(nums)\n    if goal == 10:\n        return len(nums)\n    if limit == 10:\n        return len(nums)\n    if goal == 11:\n        return len(nums)\n    if limit == 11:\n        return len(nums)\n    if goal == 12:\n        return len(nums)\n    if limit == 12:\n        return len(nums)\n    if goal == 13:\n        return len\n",
        "def min_add_to_make_sum_equal_to_goal(nums, limit, goal):\n    if goal == 0:\n        return 0\n    if goal < 0:\n        return None\n    if limit == 0:\n        return None\n    if goal > limit:\n        return None\n    if goal == limit:\n        return len(nums)\n    if goal < limit:\n        return None\n    if len(nums) == 0:\n        return None\n    if len(nums) == 1:\n        if nums[0] == goal:\n            return 0\n        else:\n            return None\n    if nums[0] == goal:\n        return 0\n    if nums[0] > goal:\n        return None\n    if nums[0] < goal:\n        return 1 + min_add_to_make_sum_equal_to_goal(nums[1:], limit, goal - nums[0])\n    if nums[0] == goal:\n        return 0\n    if nums[0] < goal:\n        return 1 + min_add_to_make_sum_equal_to_goal(nums[1:], limit, goal - nums[0])\n    if nums[0] == goal:\n        return 0\n    if nums[0] < goal:\n        return 1 + min_add_to_make_sum_equal_to_goal(nums[1:], limit, goal - nums[0])\n    if nums[0] == goal:\n        return 0\n    if nums[0] < goal:\n        return 1 + min_add_to_make_sum_equal_to_goal(nums[1:], limit, goal - nums[0])\n    if nums[0] == goal:\n        return 0\n    if nums[0] < goal:\n        return 1 + min_add_to_make_sum_equal_to_goal(nums[1:], limit, goal - nums[0])\n    if nums[0] == goal:\n        return 0\n    if nums[0] < goal:\n        return 1 + min\n"
    ],
    "results": 8
},{
    "id": "1731",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers. For example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6.",
    "snippets": [
        "def hidden_sequence(differences, lower, upper):\n    # Write your code here.\n    if len(differences) == 0:\n        return []\n    if len(differences) == 1:\n        return [lower, lower + differences[0], upper - differences[0], upper]\n    if len(differences) == 2:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper]\n    if len(differences) == 3:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper]\n    if len(differences) == 4:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[3], upper]\n    if len(differences) == 5:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[3], upper, lower + differences[4], upper - differences[4], upper]\n    if len(differences) == 6:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[3], upper, lower + differences[4], upper - differences[4], upper, lower + differences[5], upper - differences[5], upper]\n    if len(differences) == 7:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[\n",
        "def hidden_sequence(differences, lower, upper):\n    if len(differences) == 0:\n        return []\n    if len(differences) == 1:\n        return [lower, lower + differences[0], upper - differences[0], upper]\n    if len(differences) == 2:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper]\n    if len(differences) == 3:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper]\n    if len(differences) == 4:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[3], upper]\n    if len(differences) == 5:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[3], upper, lower + differences[4], upper - differences[4], upper]\n    if len(differences) == 6:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[3], upper, lower + differences[4], upper - differences[4], upper, lower + differences[5], upper - differences[5], upper]\n    if len(differences) == 7:\n        return [lower, lower + differences[0], upper - differences[0], upper, lower + differences[1], upper - differences[1], upper, lower + differences[2], upper - differences[2], upper, lower + differences[3], upper - differences[3], upper, lower + differences[\n",
        "def hidden_sequence(differences, lower, upper):\n    if not differences:\n        return []\n    if len(differences) == 1:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] == 0:\n        return [lower, lower + differences[1], upper, upper + differences[1]]\n    if differences[0] > 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] < 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] == 0:\n        return [lower, lower + differences[1], upper, upper + differences[1]]\n    if differences[0] > 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] < 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] == 0:\n        return [lower, lower + differences[1], upper, upper + differences[1]]\n    if differences[0] > 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] < 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] == 0:\n        return [lower, lower + differences[1], upper, upper + differences[1]]\n    if differences[0] > 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] < 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] == 0:\n        return [lower, lower + differences[1], upper, upper + differences[1]]\n    if differences[0] > 0:\n        return [lower, lower + differences[0], upper, upper + differences[0]]\n    if differences[0] < 0:\n        return [lower, lower + differences[0], upper, upper + differences\n",
        "def hidden_sequence(differences, lower, upper):\n    # Write your code here.\n    return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(i - j for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1\n",
        "def hidden_sequence(differences, lower, upper):\n    # Write your code here.\n    return [i for i in range(lower, upper+1) if sum(i-j for j in differences) == 0]\n",
        "def hidden_sequence(differences, lower, upper):\n    # Write your code here.\n    return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [i for i in range(lower, upper + 1) if sum(abs(i - j) for j in differences) == 0]\n    # return [\n",
        "def hidden_sequence(differences, lower, upper):\n    # Write your code here.\n    return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1) if sum(x-y for y in differences) == 0]\n    # return [x for x in range(lower, upper+1\n"
    ],
    "results": 10
},{
    "id": "1732",
    "source": "leetcode",
    "language": "python",
    "query": "A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. If there is no way to replace a character to make it not a palindrome, return an empty string.",
    "snippets": [
        "def make_palindrome(a):\n    if a == a[::-1]:\n        return a\n    for i in range(len(a)):\n        if a[i] != a[len(a)-i-1]:\n            if a[i] < a[len(a)-i-1]:\n                return a[:i] + a[i+1:] + a[i] + a[i+1:len(a)-i-1] + a[len(a)-i-1]\n            else:\n                return a[:i] + a[i+1:] + a[len(a)-i-1] + a[i+1:len(a)-i-1] + a[i]\n    return \"\"\n",
        "def palindrome(a):\n    if a == a[::-1]:\n        return a\n    else:\n        for i in range(len(a)):\n            if a[i] != a[len(a)-i-1]:\n                return a[:i] + a[i+1:]\n",
        "def palindrome(a):\n    if a == a[::-1]:\n        return a\n    else:\n        for i in range(len(a)):\n            if a[i] != a[len(a)-i-1]:\n                return a[:i] + a[i+1:]\n    return \"\"\n",
        "def make_palindrome(a):\n    if a == a[::-1]:\n        return a\n    for i in range(len(a)):\n        if a[i] != a[-i-1]:\n            if a[i] < a[-i-1]:\n                return a[:i] + a[i] + a[i+1:]\n            else:\n                return a[:i] + a[-i-1] + a[-i:]\n    return ''\n",
        "def is_palindrome(s):\n    return s == s[::-1]\n",
        "def is_palindrome(a):\n    return a == a[::-1]\n",
        "def palindrome(a):\n    if a == a[::-1]:\n        return a\n    else:\n        return \"\"\n"
    ],
    "results": 10
},{
    "id": "1733",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, return all the different possible increasing subsequences of the given array with at least two elements. You may return the answer in any order.",
    "snippets": [
        "def findSubsequences(nums):\n    res = []\n    dfs(nums, 0, [], res)\n    return res\n",
        "def findSubsequences(nums):\n    res = []\n    if len(nums) < 2:\n        return res\n    nums.sort()\n    dfs(nums, 0, [], res)\n    return res\n",
        "def findSubsequences(nums):\n    res = []\n    if not nums:\n        return res\n    nums.sort()\n    dfs(nums, 0, [], res)\n    return res\n",
        "def findSubsequences(nums):\n    res = []\n    if len(nums) < 2:\n        return res\n    def dfs(nums, index, path):\n        if len(path) >= 2:\n            res.append(path)\n        for i in range(index, len(nums)):\n            if i > index and nums[i] == nums[i-1]:\n                continue\n            dfs(nums, i+1, path+[nums[i]])\n    dfs(nums, 0, [])\n    return res\n",
        "def findSubsequences(nums):\n    res = []\n    if len(nums) < 2:\n        return res\n    dfs(nums, 0, [], res)\n    return res\n",
        "def findSubsequences(nums):\n    res = []\n    backtrack(nums, [], res)\n    return res\n"
    ],
    "results": 10
},{
    "id": "1734",
    "source": "leetcode",
    "language": "python",
    "query": "The functions get and put must each run in O(1) average time complexity. The data structure follows the constraints of a Least Recently Used (LRU) cache.",
    "snippets": [
        "def get(key):\n    if key in cache:\n        cache.remove(key)\n        cache.append(key)\n        return cache[cache.index(key)]\n    else:\n        return -1\n",
        "def get(key):\n    if key in cache:\n        cache.remove(key)\n        cache.append(key)\n        return cache[0]\n    else:\n        return -1\n",
        "def get(key):\n    if key in cache:\n        cache.remove(key)\n        cache.append(key)\n        return cache[-1]\n    return -1\n"
    ],
    "results": 10
},{
    "id": "1735",
    "source": "leetcode",
    "language": "python",
    "query": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. You must find a solution with a memory complexity better than O(n2)",
    "snippets": [
        "def kthSmallest(matrix, k):\n    # Write your code here.\n    n = len(matrix)\n    if n == 0:\n        return None\n    if n == 1:\n        return matrix[0][0]\n    if n == 2:\n        return matrix[0][1]\n    if n == 3:\n        return matrix[1][1]\n    if n == 4:\n        return matrix[2][1]\n    if n == 5:\n        return matrix[3][1]\n    if n == 6:\n        return matrix[4][1]\n    if n == 7:\n        return matrix[5][1]\n    if n == 8:\n        return matrix[6][1]\n    if n == 9:\n        return matrix[7][1]\n    if n == 10:\n        return matrix[8][1]\n    if n == 11:\n        return matrix[9][1]\n    if n == 12:\n        return matrix[10][1]\n    if n == 13:\n        return matrix[11][1]\n    if n == 14:\n        return matrix[12][1]\n    if n == 15:\n        return matrix[13][1]\n    if n == 16:\n        return matrix[14][1]\n    if n == 17:\n        return matrix[15][1]\n    if n == 18:\n        return matrix[16][1]\n    if n == 19:\n        return matrix[17][1]\n    if n == 20:\n        return matrix[18][1]\n    if n == 21:\n        return matrix[19][1]\n    if n == 22:\n        return matrix[20][1]\n    if n == 23:\n        return matrix[21][1]\n    if n == 24:\n        return matrix[22][1]\n    if n == 25:\n        return matrix[23][1]\n    if n == 26:\n        return matrix[24][1]\n    if n == 27:\n        return matrix[25][1]\n    if n == 28:\n        return matrix[26][1]\n    if n == 29:\n        return matrix[27\n",
        "def kthSmallest(matrix, k):\n    # Write your code here.\n    n = len(matrix)\n    if n == 0:\n        return None\n    if k > n * n:\n        return None\n    if k == 1:\n        return matrix[0][0]\n    if k == n * n:\n        return matrix[n - 1][n - 1]\n    if k % n == 0:\n        return matrix[k // n - 1][n - 1]\n    if k % n == 1:\n        return matrix[k // n - 1][0]\n    if k // n == 1:\n        return matrix[0][k % n - 1]\n    return matrix[k // n - 1][k % n - 1]\n",
        "def kthSmallest(matrix, k):\n    # Write your code here.\n    n = len(matrix)\n    if n == 1:\n        return matrix[0][0]\n    mid = n // 2\n    if k <= mid:\n        return kthSmallest(matrix[:mid], k)\n    else:\n        return kthSmallest(matrix[mid:], k - mid)\n",
        "def kthSmallest(matrix, k):\n    # Write your code here.\n    n = len(matrix)\n    if n == 0:\n        return None\n    if k > n * n:\n        return None\n    if k == 1:\n        return matrix[0][0]\n    if k == n * n:\n        return matrix[n - 1][n - 1]\n    if k % n == 0:\n        return matrix[k // n - 1][n - 1]\n    if k % n == 1:\n        return matrix[k // n - 1][0]\n    if k // n == 1:\n        return matrix[0][k % n - 1]\n    if k // n == n:\n        return matrix[n - 1][k % n - 1]\n    return matrix[k // n - 1][k % n - 1]\n",
        "def kthSmallest(matrix, k):\n    # Write your code here.\n    n = len(matrix)\n    if n == 0:\n        return None\n    if k > n * n:\n        return None\n    if k == 1:\n        return matrix[0][0]\n    if k == n * n:\n        return matrix[n - 1][n - 1]\n    if k == n * (n + 1) / 2:\n        return matrix[n - 1][n - 1] + matrix[n - 1][n - 2]\n    if k == n * (n + 1) / 2 + 1:\n        return matrix[n - 1][n - 1] + matrix[n - 1][n - 2] + matrix[n - 2][n - 1]\n    if k == n * (n + 1) / 2 + 2:\n        return matrix[n - 1][n - 1] + matrix[n - 1][n - 2] + matrix[n - 2][n - 1] + matrix[n - 2][n - 2]\n    if k == n * (n + 1) / 2 + 3:\n        return matrix[n - 1][n - 1] + matrix[n - 1][n - 2] + matrix[n - 2][n - 1] + matrix[n - 2][n - 2] + matrix[n - 3][n - 1]\n    if k == n * (n + 1) / 2 + 4:\n        return matrix[n - 1][n - 1] + matrix[n - 1][n - 2] + matrix[n - 2][n - 1] + matrix[n - 2][n - 2] + matrix[n - 3][n - 1] + matrix[n - 3][n - 2]\n    if k == n * (n + 1) / 2 + 5:\n        return matrix[n - 1][n - 1] + matrix[n - 1][n - 2] + matrix[n - 2][n - 1] + matrix[n - 2][n - 2] + matrix[n - 3][n - 1] + matrix[n - 3][n - 2] + matrix[n - 4][n - 1]\n",
        "def kthSmallest(matrix, k):\n    # Write your code here.\n    n = len(matrix)\n    if n == 0:\n        return None\n    if k > n * n:\n        return None\n    if k == 1:\n        return matrix[0][0]\n    if k == n * n:\n        return matrix[n-1][n-1]\n    row = 0\n    col = n-1\n    while row < n and col >= 0:\n        if matrix[row][col] > k:\n            col -= 1\n        elif matrix[row][col] < k:\n            row += 1\n        else:\n            return matrix[row][col]\n    return matrix[row][col]\n",
        "def kthSmallest(matrix, k):\n    if not matrix or not matrix[0]:\n        return None\n    n = len(matrix)\n    if k > n * n:\n        return None\n    if k == 1:\n        return matrix[0][0]\n    if k == n * n:\n        return matrix[n - 1][n - 1]\n    row = k // n\n    col = k % n\n    return matrix[row][col]\n",
        "def kthSmallest(matrix, k):\n    return sorted(sum(matrix, []))[k-1]\n"
    ],
    "results": 10
},{
    "id": "1736",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string date representing a Gregorian calendar date, return the day number of the year.",
    "snippets": [
        "def day_of_year(date):\n    year, month, day = date.split('-')\n    year = int(year)\n    month = int(month)\n    day = int(day)\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if year % 4 == 0:\n        days[1] = 29\n    return sum(days[:month - 1]) + day\n",
        "def day_of_year(date):\n    year, month, day = date.split('-')\n    year = int(year)\n    month = int(month)\n    day = int(day)\n    if month == 1:\n        return day\n    elif month == 2:\n        return day + 31\n    elif month == 3:\n        return day + 31 + 28\n    elif month == 4:\n        return day + 31 + 28 + 31\n    elif month == 5:\n        return day + 31 + 28 + 31 + 30\n    elif month == 6:\n        return day + 31 + 28 + 31 + 30 + 31\n    elif month == 7:\n        return day + 31 + 28 + 31 + 30 + 31 + 30\n    elif month == 8:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31\n    elif month == 9:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31\n    elif month == 10:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30\n    elif month == 11:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31\n    elif month == 12:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30\n    else:\n        return 'Invalid month'\n",
        "def day_of_year(date):\n    year, month, day = date.split('-')\n    year = int(year)\n    month = int(month)\n    day = int(day)\n    if month == 1:\n        return day\n    elif month == 2:\n        return day + 31\n    elif month == 3:\n        return day + 31 + 28\n    elif month == 4:\n        return day + 31 + 28 + 31\n    elif month == 5:\n        return day + 31 + 28 + 31 + 30\n    elif month == 6:\n        return day + 31 + 28 + 31 + 30 + 31\n    elif month == 7:\n        return day + 31 + 28 + 31 + 30 + 31 + 30\n    elif month == 8:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31\n    elif month == 9:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31\n    elif month == 10:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30\n    elif month == 11:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31\n    elif month == 12:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30\n    else:\n        return None\n",
        "def day_of_year(date):\n    # your code here\n    year, month, day = date.split('-')\n    year = int(year)\n    month = int(month)\n    day = int(day)\n    days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if year % 4 == 0:\n        days[1] = 29\n    days_sum = sum(days[:month-1]) + day\n    return days_sum\n",
        "def day_of_year(date):\n    year, month, day = map(int, date.split('-'))\n    return sum(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) + day\n",
        "def day_of_year(date):\n    # your code here\n    return datetime.datetime.strptime(date, '%Y-%m-%d').timetuple().tm_yday\n",
        "def day_of_year(date):\n    # your code here\n    import datetime\n    date = datetime.datetime.strptime(date, '%Y-%m-%d')\n    return date.timetuple().tm_yday\n",
        "def day_of_year(date):\n    # your code here\n    year, month, day = map(int, date.split('-'))\n    return sum(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    # return day_of_year(date)\n",
        "def day_of_year(date):\n    # your code here\n    year, month, day = map(int, date.split('-'))\n    return sum(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    if month == 1:\n        return day\n    elif month == 2:\n        return day + 31\n    elif month == 3:\n        return day + 31 + 28\n    elif month == 4:\n        return day + 31 + 28 + 31\n    elif month == 5:\n        return day + 31 + 28 + 31 + 30\n    elif month == 6:\n        return day + 31 + 28 + 31 + 30 + 31\n    elif month == 7:\n        return day + 31 + 28 + 31 + 30 + 31 + 30\n    elif month == 8:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31\n    elif month == 9:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31\n    elif month == 10:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30\n    elif month == 11:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31\n    elif month == 12:\n        return day + 31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30\n    else:\n        return \"Invalid month\"\n",
        "def day_of_year(date):\n    year, month, day = date.split('-')\n    return sum(days_in_month(int(month), int(year))) + int(day)\n"
    ],
    "results": 10
},{
    "id": "1737",
    "source": "leetcode",
    "language": "python",
    "query": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you can move to either index i or index i + 1.",
    "snippets": [
        "def minimum_path_sum(triangle):\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n",
        "def minimum_path_sum(triangle):\n    for i in range(len(triangle) - 1, 0, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n",
        "def min_path_sum(triangle):\n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += min(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n"
    ],
    "results": 10
},{
    "id": "1738",
    "source": "leetcode",
    "language": "python",
    "query": "The game involves two robots playing on a 2D grid. The first robot moves from (0, 0) to (1, n-1), collecting the points on its path. The second robot wants to minimize the number of points collected by the first.",
    "snippets": [
        "def main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    a.sort()\n    b.sort()\n    print(sum(a) - sum(b))\n",
        "def main():\n    n = int(input())\n    a = [int(x) for x in input().split()]\n    b = [int(x) for x in input().split()]\n    a.sort()\n    b.sort()\n    a.reverse()\n    b.reverse()\n    print(sum(a) - sum(b))\n",
        "def main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    a.sort()\n    b.sort()\n    a.reverse()\n    b.reverse()\n    print(sum(a) - sum(b))\n",
        "def min_points(n):\n    return n * (n - 1) // 2\n",
        "def main():\n    n = int(input())\n    points = [0] * n\n    for i in range(n):\n        points[i] = int(input())\n    points.sort()\n    print(points[-2])\n"
    ],
    "results": 10
},{
    "id": "1739",
    "source": "leetcode",
    "language": "python",
    "query": "You must write an algorithm that runs in O(n) time. Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
    "snippets": [
        "def longest_consecutive(nums):\n    nums = set(nums)\n    longest = 0\n    while nums:\n        n = nums.pop()\n        l = 1\n        while n - 1 in nums:\n            nums.remove(n - 1)\n            n -= 1\n            l += 1\n        while n + 1 in nums:\n            nums.remove(n + 1)\n            n += 1\n            l += 1\n        longest = max(longest, l)\n    return longest\n",
        "def longest_consecutive(nums):\n    nums_set = set(nums)\n    longest_streak = 0\n    for num in nums:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n            longest_streak = max(longest_streak, current_streak)\n    return longest_streak\n",
        "def longest_consecutive(nums):\n    nums = set(nums)\n    longest = 0\n    while nums:\n        n = nums.pop()\n        current = 1\n        while n - 1 in nums:\n            nums.remove(n - 1)\n            n -= 1\n            current += 1\n        while n + 1 in nums:\n            nums.remove(n + 1)\n            n += 1\n            current += 1\n        longest = max(longest, current)\n    return longest\n",
        "def longest_consecutive(nums):\n    nums = set(nums)\n    longest = 0\n    while nums:\n        n = nums.pop()\n        current = 1\n        while n - 1 in nums:\n            nums.remove(n - 1)\n            current += 1\n        while n + 1 in nums:\n            nums.remove(n + 1)\n            current += 1\n        longest = max(longest, current)\n    return longest\n",
        "def longest_consecutive_sequence(nums):\n    nums = set(nums)\n    longest_sequence = 0\n    while nums:\n        current_num = nums.pop()\n        current_sequence = 1\n        while current_num + 1 in nums:\n            current_num += 1\n            current_sequence += 1\n        longest_sequence = max(longest_sequence, current_sequence)\n    return longest_sequence\n",
        "def longest_consecutive(nums):\n    longest_streak = 0\n    nums_set = set(nums)\n    for num in nums:\n        if num - 1 not in nums_set:\n            current_num = num\n            current_streak = 1\n            while current_num + 1 in nums_set:\n                current_num += 1\n                current_streak += 1\n            longest_streak = max(longest_streak, current_streak)\n    return longest_streak\n"
    ],
    "results": 10
},{
    "id": "1740",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.",
    "snippets": [
        "def convertToTitle(n):\n    result = \"\"\n    while n > 0:\n        n -= 1\n        result = chr(65 + n % 26) + result\n        n //= 26\n    return result\n",
        "def convertToTitle(n):\n    result = ''\n    while n > 0:\n        n -= 1\n        result = chr(65 + n % 26) + result\n        n //= 26\n    return result\n",
        "def convertToTitle(n):\n    res = \"\"\n    while n > 0:\n        n -= 1\n        res = chr(65 + n % 26) + res\n        n //= 26\n    return res\n",
        "def convertToTitle(columnNumber):\n    result = \"\"\n    while columnNumber > 0:\n        columnNumber -= 1\n        result = chr(65 + (columnNumber % 26)) + result\n        columnNumber //= 26\n    return result\n",
        "def convertToTitle(n):\n    result = \"\"\n    while n > 0:\n        result = chr((n - 1) % 26 + ord('A')) + result\n        n = (n - 1) // 26\n    return result\n",
        "def convertToTitle(n):\n    \"\"\"\n    :type n: int\n    :rtype: str\n    \"\"\"\n    result = \"\"\n    while n > 0:\n        n -= 1\n        result = chr(n % 26 + ord('A')) + result\n        n //= 26\n    return result\n"
    ],
    "results": 10
},{
    "id": "1741",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.",
    "snippets": [
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    d = {0: -1}\n    max_len = 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == 0:\n            count -= 1\n        else:\n            count += 1\n        if count in d:\n            max_len = max(max_len, i - d[count])\n        else:\n            d[count] = i\n    return max_len\n",
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    d = {0: -1}\n    max_len = 0\n    count = 0\n    for i, num in enumerate(nums):\n        if num == 0:\n            count -= 1\n        else:\n            count += 1\n        if count in d:\n            max_len = max(max_len, i - d[count])\n        else:\n            d[count] = i\n    return max_len\n",
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    d = {0: -1}\n    ans = 0\n    for i, num in enumerate(nums):\n        if num == 0:\n            num = -1\n        if num in d:\n            ans = max(ans, i - d[num])\n        else:\n            d[num] = i\n    return ans\n",
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    dic = {0: -1}\n    max_len = 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == 0:\n            count -= 1\n        else:\n            count += 1\n        if count in dic:\n            max_len = max(max_len, i - dic[count])\n        else:\n            dic[count] = i\n    return max_len\n",
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    dic = {}\n    dic[0] = -1\n    max_len = 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == 0:\n            count -= 1\n        else:\n            count += 1\n        if count in dic:\n            max_len = max(max_len, i - dic[count])\n        else:\n            dic[count] = i\n    return max_len\n",
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # use a dictionary to store the count of 0 and 1\n    # key is the count, value is the index\n    # if the count is 0, then the index is the start of a contiguous subarray with 0s\n    # if the count is 1, then the index is the start of a contiguous subarray with 1s\n    # if the count is 2, then the index is the start of a contiguous subarray with 2s\n    # if the count is 3, then the index is the start of a contiguous subarray with 3s\n    # if the count is 4, then the index is the start of a contiguous subarray with 4s\n    # if the count is 5, then the index is the start of a contiguous subarray with 5s\n    # if the count is 6, then the index is the start of a contiguous subarray with 6s\n    # if the count is 7, then the index is the start of a contiguous subarray with 7s\n    # if the count is 8, then the index is the start of a contiguous subarray with 8s\n    # if the count is 9, then the index is the start of a contiguous subarray with 9s\n    # if the count is 10, then the index is the start of a contiguous subarray with 10s\n    # if the count is 11, then the index is the start of a contiguous subarray with 11s\n    # if the count is 12, then the index is the start of a contiguous subarray with 12s\n    # if the count is 13, then the index is the start of a contiguous subarray with 13s\n    # if the count is 14, then the index is the start of a contiguous subarray with 14s\n    # if the count is 15, then the index is the start of a contiguous subarray with 15s\n    # if the count is 16, then the index is the start of a contiguous subarray with 16s\n    # if the count is 17, then the index is the start of a contiguous subarray with 17s\n    # if the count is 18, then the index is the start of a contiguous subarray with 18s\n    # if the\n",
        "def findMaxLength(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    d = {0: -1}\n    res = 0\n    for i, num in enumerate(nums):\n        if num == 0:\n            num = -1\n        d[num] = i\n        res = max(res, i - d[-num - 1])\n    return res\n"
    ],
    "results": 10
},{
    "id": "1742",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers piles where piles[i] is the number of coins in the ith pile. There are 3n piles of coins of varying size, you and your friends will take piles of Coins.",
    "snippets": [
        "def min_coins(piles):\n    piles.sort()\n    n = len(piles)\n    if n % 2 == 0:\n        return (n // 2) * piles[n // 2]\n    else:\n        return (n // 2) * piles[n // 2] + piles[n // 2 + 1]\n",
        "def min_coins(piles):\n    piles.sort()\n    n = len(piles)\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        dp[i] = piles[i - 1] + dp[i - 1]\n    return dp[n]\n",
        "def min_coins(piles):\n    piles.sort()\n    n = len(piles)\n    dp = [0] * (piles[-1] + 1)\n    for i in range(n):\n        for j in range(piles[i], len(dp)):\n            dp[j] = min(dp[j], dp[j - piles[i]] + 1)\n    return dp[-1]\n",
        "def min_coins(piles):\n    piles.sort()\n    piles.reverse()\n    n = len(piles)\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        dp[i] = min(dp[i - 1] + 1, piles[i - 1] + dp[i - 2])\n    return dp[n]\n",
        "def min_coins(piles):\n    piles.sort()\n    n = len(piles)\n    if n % 3 != 0:\n        return -1\n    else:\n        n = n // 3\n        return sum(piles[n:2 * n])\n",
        "def min_coins(piles):\n    piles.sort()\n    piles.reverse()\n    n = len(piles)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = piles[i]\n    for i in range(n-1):\n        dp[i][i+1] = piles[i] + piles[i+1]\n    for i in range(2, n):\n        for j in range(i+1, n):\n            dp[i][j] = min(dp[i][j-1] + piles[j], dp[i-1][j] + piles[i])\n    return dp[n-1][n-1]\n",
        "def min_coins(piles):\n    piles.sort()\n    piles.reverse()\n    return sum(piles[:3])\n"
    ],
    "results": 10
},{
    "id": "1743",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. LCA is defined between two nodes p and q.",
    "snippets": [
        "def lowestCommonAncestor(root, p, q):\n    if root is None:\n        return None\n    if root.val > p.val and root.val > q.val:\n        return lowestCommonAncestor(root.left, p, q)\n    if root.val < p.val and root.val < q.val:\n        return lowestCommonAncestor(root.right, p, q)\n    return root\n",
        "def lowestCommonAncestor(root, p, q):\n    if not root:\n        return None\n    if root.val > p.val and root.val > q.val:\n        return lowestCommonAncestor(root.left, p, q)\n    if root.val < p.val and root.val < q.val:\n        return lowestCommonAncestor(root.right, p, q)\n    return root\n",
        "def lowestCommonAncestor(root, p, q):\n    if root is None:\n        return None\n    if root.val > p and root.val > q:\n        return lowestCommonAncestor(root.left, p, q)\n    if root.val < p and root.val < q:\n        return lowestCommonAncestor(root.right, p, q)\n    return root\n"
    ],
    "results": 10
},{
    "id": "1744",
    "source": "leetcode",
    "language": "python",
    "query": "A prefix of a string is a substring that occurs at the beginning of the string. You are given a string array words and a string s.",
    "snippets": [
        "def prefix(s):\n    for i in range(len(s)):\n        if s[:i+1] in words:\n            return s[:i+1]\n    return \"\"\n",
        "def prefix(s):\n    for i in range(len(s)):\n        if s[:i+1] in words:\n            return s[:i+1]\n    return ''\n",
        "def prefix(s):\n    for i in range(len(s)):\n        if s[:i+1] in s:\n            return s[:i+1]\n    return \"\"\n",
        "def prefix_of_string(s, words):\n    for word in words:\n        if s.startswith(word):\n            return word\n    return None\n"
    ],
    "results": 10
},{
    "id": "1745",
    "source": "leetcode",
    "language": "python",
    "query": "The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100,80,60,70,75,85], then the stock spans would be [1,1,.1,2,1,4,6].",
    "snippets": [
        "def stockSpan(prices):\n    if len(prices) == 0:\n        return []\n    result = [1]\n    for i in range(1, len(prices)):\n        count = 1\n        while i - count >= 0 and prices[i - count] <= prices[i]:\n            count += 1\n        result.append(count)\n    return result\n",
        "def stockSpan(price):\n    n = len(price)\n    span = [1] * n\n    for i in range(1, n):\n        j = i - 1\n        while j >= 0 and price[i] >= price[j]:\n            j -= span[j]\n        span[i] = i - j\n    return span\n",
        "def stockSpan(prices):\n    stack = []\n    for i in range(len(prices)):\n        while stack and prices[i] >= prices[stack[-1]]:\n            stack.pop()\n        stack.append(i)\n        print(stack)\n    return [len(prices) - i for i in stack]\n",
        "def stockSpan(prices):\n    # Write your code here.\n    if len(prices) == 0:\n        return []\n    result = [1]\n    for i in range(1, len(prices)):\n        count = 1\n        for j in range(i-1, -1, -1):\n            if prices[i] > prices[j]:\n                count += 1\n            else:\n                break\n        result.append(count)\n    return result\n",
        "def stockSpan(prices):\n    if len(prices) == 0:\n        return []\n    span = [1]\n    for i in range(1, len(prices)):\n        count = 1\n        while i - count >= 0 and prices[i] >= prices[i - count]:\n            count += 1\n        span.append(count)\n    return span\n",
        "def stockSpan(prices):\n    result = [1]\n    for i in range(1, len(prices)):\n        count = 1\n        while i - count >= 0 and prices[i - count] <= prices[i]:\n            count += 1\n        result.append(count)\n    return result\n",
        "def stock_span(prices):\n    span = [1]\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            span.append(span[i-1]+1)\n        else:\n            j = i-1\n            while j >= 0 and prices[j] > prices[i]:\n                j -= span[j]\n            span.append(i-j)\n    return span\n",
        "def stockSpan(prices):\n    if len(prices) == 0:\n        return []\n    stack = []\n    stack.append((prices[0], 1))\n    for i in range(1, len(prices)):\n        while len(stack) > 0 and stack[-1][0] <= prices[i]:\n            stack.pop()\n        if len(stack) == 0:\n            stack.append((prices[i], i + 1))\n        else:\n            stack.append((prices[i], i - stack[-1][1]))\n    return [x[1] for x in stack]\n",
        "def stockSpan(prices):\n    # Write your code here.\n    if len(prices) == 0:\n        return []\n    stack = []\n    stack.append((prices[0], 0))\n    for i in range(1, len(prices)):\n        while stack and stack[-1][0] <= prices[i]:\n            stack.pop()\n        if stack:\n            span = i - stack[-1][1]\n        else:\n            span = i + 1\n        stack.append((prices[i], i))\n        prices[i] = span\n    return prices\n"
    ],
    "results": 10
},{
    "id": "1746",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array. Return the minimum size of the set so that at least half of the integers of the array are removed.",
    "snippets": [
        "def minSetSize(arr):\n    d = {}\n    for i in arr:\n        d[i] = d.get(i, 0) + 1\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    count = 0\n    for i in d:\n        count += i[1]\n        if count >= len(arr) // 2:\n            return len(d) - i[1]\n    return 0\n",
        "def minSetSize(arr):\n    d = {}\n    for i in arr:\n        d[i] = d.get(i, 0) + 1\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    cnt = 0\n    for i in d:\n        cnt += i[1]\n        if cnt >= len(arr) // 2:\n            return len(arr) - cnt\n    return 0\n",
        "def minSetSize(arr):\n    d = {}\n    for i in arr:\n        d[i] = d.get(i, 0) + 1\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    cnt = 0\n    for i in d:\n        cnt += 1\n        if cnt * 2 > len(arr):\n            return cnt\n    return cnt\n",
        "def minSetSize(arr):\n    d = {}\n    for i in arr:\n        d[i] = d.get(i, 0) + 1\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    count = 0\n    for i in d:\n        count += i[1]\n        if count >= len(arr) // 2:\n            return len(d) - count + i[1]\n    return len(d) - count + i[1]\n",
        "def minSetSize(arr):\n    d = {}\n    for i in arr:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    count = 0\n    for i in d:\n        count += i[1]\n        if count >= len(arr) // 2:\n            return len(d) - i[1]\n    return 0\n",
        "def minSetSize(arr):\n    # Write your code here.\n    count = {}\n    for i in arr:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n    count = sorted(count.items(), key=lambda x: x[1], reverse=True)\n    count = [x[1] for x in count]\n    count = sum(count[:len(count)//2])\n    count = len(arr) - count\n    return count\n",
        "def minSetSize(arr):\n    # Write your code here.\n    d = {}\n    for i in arr:\n        d[i] = d.get(i, 0) + 1\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    count = 0\n    for i in d:\n        count += i[1]\n        if count >= len(arr) // 2:\n            return len(d) - i[1]\n    return 0\n",
        "def minSetSize(arr):\n    # Write your code here.\n    count = {}\n    for i in arr:\n        count[i] = count.get(i, 0) + 1\n    count = sorted(count.items(), key=lambda x: x[1], reverse=True)\n    count = list(map(lambda x: x[0], count))\n    n = len(count)\n    ans = 0\n    for i in range(n):\n        if n - i - 1 < n // 2:\n            break\n        ans += 1\n        n -= count[i]\n    return ans\n"
    ],
    "results": 10
},{
    "id": "1747",
    "source": "leetcode",
    "language": "python",
    "query": "You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed) Your goal is to maximize your total score by potentially playing each token in one of two ways.",
    "snippets": [
        "def bag_of_tokens(tokens, power):\n    tokens.sort()\n    i = 0\n    j = len(tokens) - 1\n    while i <= j:\n        if power >= tokens[i]:\n            power -= tokens[i]\n            i += 1\n        elif power < tokens[j]:\n            power += tokens[j]\n            j -= 1\n        else:\n            return -1\n    return i\n",
        "def bag_of_tokens(tokens, power):\n    tokens.sort()\n    i = 0\n    j = len(tokens) - 1\n    while i <= j:\n        if power >= tokens[i]:\n            power -= tokens[i]\n            i += 1\n        elif power < tokens[i]:\n            if power + tokens[j] >= tokens[i]:\n                power += tokens[j]\n                j -= 1\n            else:\n                return -1\n    return power\n",
        "def bag(power, tokens, score):\n    if power == 0:\n        return score\n    if len(tokens) == 0:\n        return score\n    if tokens[0] > power:\n        return bag(power, tokens[1:], score)\n    else:\n        return max(bag(power - tokens[0], tokens[1:], score + tokens[0]), bag(power, tokens[1:], score))\n",
        "def bag(power, tokens, score):\n    if power == 0:\n        return score\n    if len(tokens) == 0:\n        return score\n    if power >= tokens[0]:\n        return max(bag(power - tokens[0], tokens[1:], score + tokens[0]), bag(power, tokens[1:], score))\n    else:\n        return bag(power, tokens[1:], score)\n",
        "def bag_game(power, tokens):\n    # Write your code here.\n    if power == 0:\n        return 0\n    if len(tokens) == 0:\n        return 0\n    if power < tokens[0]:\n        return bag_game(power, tokens[1:])\n    return max(bag_game(power - tokens[0], tokens[1:]), bag_game(power, tokens[1:]))\n",
        "def bagOfTokens(tokens, power):\n    tokens.sort()\n    l = len(tokens)\n    i = 0\n    j = l - 1\n    score = 0\n    while i <= j and power >= tokens[i]:\n        power -= tokens[i]\n        score += 1\n        i += 1\n    if i > j:\n        return score\n    while j >= 0 and power >= tokens[j]:\n        power -= tokens[j]\n        score += 1\n        j -= 1\n    return score if power >= 0 else -1\n",
        "def bagOfTokens(tokens, power):\n    tokens.sort()\n    l = len(tokens)\n    i = 0\n    j = l - 1\n    score = 0\n    while i <= j and power >= tokens[i]:\n        power -= tokens[i]\n        score += 1\n        i += 1\n    while j >= 0 and power >= tokens[j]:\n        power -= tokens[j]\n        score += 1\n        j -= 1\n    return score if score <= l else -1\n",
        "def bagOfTokens(tokens, power):\n    tokens.sort()\n    tokens_count = len(tokens)\n    score = 0\n    tokens_used = 0\n    while power >= tokens[tokens_used] and tokens_used < tokens_count:\n        power -= tokens[tokens_used]\n        tokens_used += 1\n        score += 1\n    if tokens_used == tokens_count:\n        return score\n    while power >= tokens[tokens_used] and tokens_used < tokens_count:\n        power -= tokens[tokens_used]\n        tokens_used += 1\n        score += 1\n        if tokens_used == tokens_count:\n            return score\n    return 0\n"
    ],
    "results": 10
},{
    "id": "1748",
    "source": "leetcode",
    "language": "python",
    "query": "A prefix of a string s is any leading contiguous substring of s. Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.",
    "snippets": [
        "def is_prefix(sentence, searchWord):\n    for word in sentence.split():\n        if word.startswith(searchWord):\n            return True\n    return False\n",
        "def prefix(sentence, searchWord):\n    words = sentence.split()\n    for word in words:\n        if word.startswith(searchWord):\n            return True\n    return False\n",
        "def prefix(sentence, searchWord):\n    for word in sentence.split():\n        if word.startswith(searchWord):\n            return True\n    return False\n",
        "def isPrefix(sentence, searchWord):\n    words = sentence.split()\n    for word in words:\n        if word.startswith(searchWord):\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1749",
    "source": "leetcode",
    "language": "python",
    "query": "A lattice point is a point with integer coordinates. Given a 2D integer array circles where circles[i] = [xi, yi, ri], return the number of lattice points inside at least one circle.",
    "snippets": [
        "def lattice_points(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    ans = 0\n    for i in range(n):\n        x, y, r = circles[i]\n        ans += (x - r) * (x + r) * (y - r) * (y + r)\n        ans += (x - r) * (x + r) * (y - r) * (y + r)\n        ans += (x - r) * (x + r) * (y - r) * (y + r)\n        ans += (x - r) * (x + r) * (y - r) * (y + r)\n    return ans\n",
        "def lattice_points(circles):\n    # Write your code here.\n    x, y, r = circles[0]\n    count = 0\n    for i in range(x - r, x + r + 1):\n        for j in range(y - r, y + r + 1):\n            if (i - x) ** 2 + (j - y) ** 2 <= r ** 2:\n                count += 1\n    return count\n",
        "def lattice_points(circles):\n    # Write your code here.\n    x = [circle[0] for circle in circles]\n    y = [circle[1] for circle in circles]\n    r = [circle[2] for circle in circles]\n    n = len(x)\n    ans = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if (x[i] - x[j])**2 + (y[i] - y[j])**2 <= r[i]**2:\n                    ans += 1\n    return ans\n",
        "def lattice_points(circles):\n    # Write your code here\n    x, y, r = circles[0]\n    count = 0\n    for i in range(x-r, x+r+1):\n        for j in range(y-r, y+r+1):\n            if (i-x)**2 + (j-y)**2 <= r**2:\n                count += 1\n    return count\n",
        "def lattice_points(circles):\n    # Write your code here.\n    count = 0\n    for i in range(len(circles)):\n        x = circles[i][0]\n        y = circles[i][1]\n        r = circles[i][2]\n        for j in range(x-r, x+r+1):\n            for k in range(y-r, y+r+1):\n                if (j-x)**2 + (k-y)**2 <= r**2:\n                    count += 1\n    return count\n",
        "def lattice_points(circles):\n    n = len(circles)\n    if n == 0:\n        return 0\n    points = set()\n    for i in range(n):\n        x, y, r = circles[i]\n        for j in range(x - r, x + r + 1):\n            for k in range(y - r, y + r + 1):\n                if (j - x) ** 2 + (k - y) ** 2 <= r ** 2:\n                    points.add((j, k))\n    return len(points)\n",
        "def lattice_points(circles):\n    # Write your code here.\n    x_min = min(circle[0] for circle in circles)\n    x_max = max(circle[0] for circle in circles)\n    y_min = min(circle[1] for circle in circles)\n    y_max = max(circle[1] for circle in circles)\n    points = set()\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            for circle in circles:\n                if (x - circle[0]) ** 2 + (y - circle[1]) ** 2 <= circle[2] ** 2:\n                    points.add((x, y))\n    return len(points)\n",
        "def lattice_points(circles):\n    # Write your code here.\n    pass\n    return 0\n",
        "def lattice_points(circles):\n    # Write your code here.\n    pass\n"
    ],
    "results": 10
},{
    "id": "1750",
    "source": "leetcode",
    "language": "python",
    "query": "The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps. For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1.",
    "snippets": [
        "def power(x):\n    if x == 1:\n        return 0\n    elif x % 2 == 0:\n        return 1 + power(x // 2)\n    else:\n        return 1 + power(x * 3 + 1)\n",
        "def power(x):\n    if x == 1:\n        return 0\n    if x % 2 == 0:\n        return 1 + power(x // 2)\n    else:\n        return 1 + power(x * 3 + 1)\n",
        "def power(x):\n    if x == 1:\n        return 0\n    if x % 2 == 0:\n        return 1 + power(x / 2)\n    else:\n        return 1 + power(3 * x + 1)\n"
    ],
    "results": 10
},{
    "id": "1751",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.",
    "snippets": [
        "def moveZeroes(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i] = nums[j]\n            i += 1\n    for j in range(i, len(nums)):\n        nums[j] = 0\n    return nums\n",
        "def moveZeroes(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i] = nums[j]\n            i += 1\n    for k in range(i, len(nums)):\n        nums[k] = 0\n    return nums\n",
        "def moveZeroes(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i] = nums[j]\n            i += 1\n    for j in range(i, len(nums)):\n        nums[j] = 0\n    return nums\n",
        "def moveZeros(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i] = nums[j]\n            i += 1\n    for j in range(i, len(nums)):\n        nums[j] = 0\n    return nums\n",
        "def moveZeroes(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # nums.sort(key=lambda x: x == 0)\n    # nums.reverse()\n    # return nums\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i] = nums[j]\n            i += 1\n    for j in range(i, len(nums)):\n        nums[j] = 0\n    return nums\n",
        "def moveZeroes(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # nums.sort(key=lambda x: x == 0)\n    # nums.sort(key=lambda x: x)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n    # nums.sort(key=lambda x: x, reverse=False)\n    # nums.sort(key=lambda x: x, reverse=True)\n",
        "def moveZeroes(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # for i in range(len(nums)):\n    #     if nums[i] == 0:\n    #         nums.remove(nums[i])\n    #         nums.append(0)\n    # return nums\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i] = nums[j]\n            i += 1\n    for k in range(i, len(nums)):\n        nums[k] = 0\n    return nums\n",
        "def moveZeroes(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # i = 0\n    # for j in range(len(nums)):\n    #     if nums[j] != 0:\n    #         nums[i] = nums[j]\n    #         i += 1\n    # for k in range(i, len(nums)):\n    #     nums[k] = 0\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != 0:\n            nums[i] = nums[j]\n            i += 1\n    for k in range(i, len(nums)):\n        nums[k] = 0\n    return nums\n"
    ],
    "results": 9
},{
    "id": "1752",
    "source": "leetcode",
    "language": "python",
    "query": "Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year.",
    "snippets": [
        "def day_of_the_week(day, month, year):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    date = datetime.date(year, month, day)\n    return days[date.weekday()]\n",
        "def day_of_week(day, month, year):\n    days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n    months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']\n    year = year - (14 - month) // 12\n    x = year + year // 4 - year // 100 + year // 400\n    m = month + 12 * ((14 - month) // 12) - 2\n    d = (day + x + (31 * m) // 12) % 7\n    return days[d]\n",
        "def dayOfWeek(day, month, year):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]\n    year = year - (14 - month) // 12\n    x = year + year // 4 - year // 100 + year // 400\n    month = month + 12 * ((14 - month) // 12) - 2\n    day = (day + x + (31 * month) // 12) % 7\n    return days[day]\n",
        "def day_of_the_week(day, month, year):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    return days[date(year, month, day).weekday()]\n",
        "def day_of_the_week(day, month, year):\n    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    # Write your code here\n    return days[(year + (month + 1) * 13 + day) % 7]\n",
        "def dayOfWeek(day, month, year):\n    # your code here\n    import datetime\n    d = datetime.date(year, month, day)\n    return d.strftime(\"%A\")\n"
    ],
    "results": 10
},{
    "id": "1753",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, handle multiple queries of the following type: Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.",
    "snippets": [
        "def sum_between_indices(nums, left, right):\n    return sum(nums[left:right+1])\n",
        "def sum_range(nums, left, right):\n    return sum(nums[left:right+1])\n",
        "def sum_array(nums, left, right):\n    return sum(nums[left:right+1])\n",
        "def sum_of_nums(nums, left, right):\n    return sum(nums[left:right+1])\n",
        "def sum_between(nums, left, right):\n    return sum(nums[left:right+1])\n"
    ],
    "results": 10
},{
    "id": "1754",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.",
    "snippets": [
        "def findMaxConsecutiveOnes(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    count = 0\n    max_count = 0\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            count += 1\n        else:\n            count = 0\n        if count > max_count:\n            max_count = count\n        if count > k:\n            count = 0\n    return max_count\n",
        "def findMaxConsecutiveOnes(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    max_consecutive_ones = 0\n    consecutive_ones = 0\n    for num in nums:\n        if num == 1:\n            consecutive_ones += 1\n        else:\n            consecutive_ones = 0\n        max_consecutive_ones = max(max_consecutive_ones, consecutive_ones)\n    return max_consecutive_ones\n",
        "def findMaxConsecutiveOnes(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    max_count = 0\n    count = 0\n    for num in nums:\n        if num == 1:\n            count += 1\n        else:\n            count = 0\n        max_count = max(max_count, count)\n    return max_count\n",
        "def findMaxConsecutiveOnes(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    max_count = 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            count += 1\n        else:\n            count = 0\n        max_count = max(max_count, count)\n    return max_count\n"
    ],
    "results": 10
},{
    "id": "1755",
    "source": "leetcode",
    "language": "python",
    "query": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2. The integers in the lists may be returned in any order.",
    "snippets": [
        "def arrayPairSum(nums):\n    nums.sort()\n    return [nums[i] + nums[i+1] for i in range(0, len(nums), 2)]\n",
        "def twoSum(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n    i = 0\n    j = 0\n    answer = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] + nums2[j] == 0:\n            answer.append(nums1[i])\n            answer.append(nums2[j])\n            return answer\n        elif nums1[i] + nums2[j] > 0:\n            j += 1\n        else:\n            i += 1\n    return answer\n",
        "def array_pair_sum(nums):\n    nums.sort()\n    return [nums[i] for i in range(0, len(nums), 2)]\n",
        "def arrayPairSum(nums):\n    nums.sort()\n    return [nums[i] for i in range(0, len(nums), 2)]\n"
    ],
    "results": 10
},{
    "id": "1756",
    "source": "leetcode",
    "language": "python",
    "query": "A valid \"croak\" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. The frogs have to print all five letters to finish a croak. Return the minimum number of different frogs to finish all the croaks in the given string.",
    "snippets": [
        "def min_frogs(croakOfFrogs):\n    # Write your code here.\n    count = 0\n    for i in range(len(croakOfFrogs)):\n        if croakOfFrogs[i] == 'c':\n            count += 1\n        elif croakOfFrogs[i] == 'r':\n            count += 1\n        elif croakOfFrogs[i] == 'o':\n            count += 1\n        elif croakOfFrogs[i] == 'a':\n            count += 1\n        elif croakOfFrogs[i] == 'k':\n            count += 1\n    return count\n",
        "def minNumberOfFrogs(croakOfFrogs):\n    # Write your code here.\n    croakOfFrogs = list(croakOfFrogs)\n    croakOfFrogs.sort()\n    print(croakOfFrogs)\n    frogs = 0\n    for i in range(len(croakOfFrogs)):\n        if croakOfFrogs[i] == 'c':\n            frogs += 1\n        elif croakOfFrogs[i] == 'r':\n            frogs -= 1\n        elif croakOfFrogs[i] == 'o':\n            frogs += 1\n        elif croakOfFrogs[i] == 'a':\n            frogs -= 1\n        elif croakOfFrogs[i] == 'k':\n            frogs += 1\n        else:\n            return -1\n    if frogs == 0:\n        return frogs\n    else:\n        return -1\n    return frogs\n",
        "def min_frogs(croakOfFrogs):\n    # Write your code here.\n    cnt = 0\n    for i in range(len(croakOfFrogs)):\n        if croakOfFrogs[i] == 'c':\n            cnt += 1\n        elif croakOfFrogs[i] == 'r':\n            cnt += 1\n        elif croakOfFrogs[i] == 'o':\n            cnt += 1\n        elif croakOfFrogs[i] == 'a':\n            cnt += 1\n        elif croakOfFrogs[i] == 'k':\n            cnt += 1\n    return cnt\n",
        "def min_frogs(s):\n    # Write your code here.\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 'c':\n            count += 1\n        elif s[i] == 'r':\n            count += 1\n        elif s[i] == 'o':\n            count += 1\n        elif s[i] == 'a':\n            count += 1\n        elif s[i] == 'k':\n            count += 1\n    return count\n",
        "def min_frogs(croak):\n    # Write your code here.\n    count = 0\n    for i in range(len(croak)):\n        if croak[i] == 'c':\n            if i+4 < len(croak) and croak[i+1] == 'r' and croak[i+2] == 'o' and croak[i+3] == 'a' and croak[i+4] == 'k':\n                count += 1\n                i += 4\n            else:\n                return -1\n        else:\n            i += 1\n    return count\n",
        "def min_frogs(s):\n    return len(set(s[i:i+5] for i in range(len(s)-4)))\n",
        "def min_frogs(croakOfFrogs):\n    # Write your code here.\n    croakOfFrogs = croakOfFrogs.replace('croak', 'c')\n    croakOfFrogs = croakOfFrogs.replace('croak', 'r')\n    croakOfFrogs = croakOfFrogs.replace('croak', 'o')\n    croakOfFrogs = croakOfFrogs.replace('croak', 'a')\n    croakOfFrogs = croakOfFrogs.replace('croak', 'k')\n    return croakOfFrogs.count('c') + croakOfFrogs.count('r') + croakOfFrogs.count('o') + croakOfFrogs.count('a') + croakOfFrogs.count('k')\n",
        "def min_frogs(croaks):\n    # Write your code here.\n    croaks = croaks.replace('croak', 'croak ')\n    croaks = croaks.split()\n    croaks = [x for x in croaks if x != '']\n    print(croaks)\n    return len(croaks)\n",
        "def min_frogs(s):\n    return len(set(s)) - 1\n",
        "def min_frogs(croaks):\n    return len(set(croaks))\n"
    ],
    "results": 10
},{
    "id": "1757",
    "source": "leetcode",
    "language": "python",
    "query": "An integer x is a multiple of k if there exists an integer n such that x = n * k. Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to aMultiple of k.",
    "snippets": [
        "def checkSubarraySum(nums, k):\n    if len(nums) < 2:\n        return False\n    if k == 0:\n        for i in range(len(nums) - 1):\n            if nums[i] == 0 and nums[i + 1] == 0:\n                return True\n        return False\n    if k == 1:\n        for i in range(len(nums) - 1):\n            if nums[i] == 1 and nums[i + 1] == 1:\n                return True\n        return False\n    if k == -1:\n        for i in range(len(nums) - 1):\n            if nums[i] == -1 and nums[i + 1] == -1:\n                return True\n        return False\n    if k == -2:\n        for i in range(len(nums) - 1):\n            if nums[i] == -2 and nums[i + 1] == -2:\n                return True\n        return False\n    if k == -3:\n        for i in range(len(nums) - 1):\n            if nums[i] == -3 and nums[i + 1] == -3:\n                return True\n        return False\n    if k == -4:\n        for i in range(len(nums) - 1):\n            if nums[i] == -4 and nums[i + 1] == -4:\n                return True\n        return False\n    if k == -5:\n        for i in range(len(nums) - 1):\n            if nums[i] == -5 and nums[i + 1] == -5:\n                return True\n        return False\n    if k == -6:\n        for i in range(len(nums) - 1):\n            if nums[i] == -6 and nums[i + 1] == -6:\n                return True\n        return False\n    if k == -7:\n        for i in range(len(nums) - 1):\n            if nums[i] == -7 and nums[i + 1] == -7:\n",
        "def checkSubarraySum(nums, k):\n    if len(nums) < 2:\n        return False\n    if k == 0:\n        for i in range(len(nums) - 1):\n            if nums[i] == 0 and nums[i + 1] == 0:\n                return True\n        return False\n    if k == 1:\n        for i in range(len(nums) - 1):\n            if nums[i] == 1 and nums[i + 1] == 1:\n                return True\n        return False\n    if k == -1:\n        for i in range(len(nums) - 1):\n            if nums[i] == -1 and nums[i + 1] == -1:\n                return True\n        return False\n    if k == 2:\n        for i in range(len(nums) - 1):\n            if nums[i] == 2 and nums[i + 1] == 2:\n                return True\n        return False\n    if k == -2:\n        for i in range(len(nums) - 1):\n            if nums[i] == -2 and nums[i + 1] == -2:\n                return True\n        return False\n    if k == 3:\n        for i in range(len(nums) - 1):\n            if nums[i] == 3 and nums[i + 1] == 3:\n                return True\n        return False\n    if k == -3:\n        for i in range(len(nums) - 1):\n            if nums[i] == -3 and nums[i + 1] == -3:\n                return True\n        return False\n    if k == 4:\n        for i in range(len(nums) - 1):\n            if nums[i] == 4 and nums[i + 1] == 4:\n                return True\n        return False\n    if k == -4:\n        for i in range(len(nums) - 1):\n            if nums[i] == -4 and nums[i + 1] == -4:\n                return True\n        return False\n    if\n",
        "def checkSubarraySum(nums, k):\n    if len(nums) < 2:\n        return False\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i] == 0 and nums[i-1] == 0:\n                return True\n        return False\n    if k < 0:\n        k = -k\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        sum = nums[i]\n        for j in range(i+1, len(nums)):\n            sum += nums[j]\n            if sum % k == 0:\n                return True\n    return False\n",
        "def checkSubarraySum(nums, k):\n    if len(nums) < 2:\n        return False\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i] == 0 and nums[i - 1] == 0:\n                return True\n        return False\n    if k == 1:\n        for i in range(1, len(nums)):\n            if nums[i] == 1 and nums[i - 1] == 1:\n                return True\n        return False\n    if k == -1:\n        for i in range(1, len(nums)):\n            if nums[i] == -1 and nums[i - 1] == -1:\n                return True\n        return False\n    if k == -2:\n        for i in range(1, len(nums)):\n            if nums[i] == -2 and nums[i - 1] == -2:\n                return True\n        return False\n    if k == -3:\n        for i in range(1, len(nums)):\n            if nums[i] == -3 and nums[i - 1] == -3:\n                return True\n        return False\n    if k == -4:\n        for i in range(1, len(nums)):\n            if nums[i] == -4 and nums[i - 1] == -4:\n                return True\n        return False\n    if k == -5:\n        for i in range(1, len(nums)):\n            if nums[i] == -5 and nums[i - 1] == -5:\n                return True\n        return False\n    if k == -6:\n        for i in range(1, len(nums)):\n            if nums[i] == -6 and nums[i - 1] == -6:\n                return True\n        return False\n    if k == -7:\n        for i in range(1, len(nums)):\n            if nums[i] == -7 and nums[i - 1] == -7:\n",
        "def checkSubarraySum(nums, k):\n    if len(nums) < 2:\n        return False\n    if k == 0:\n        for i in range(1, len(nums)):\n            if nums[i] == 0 and nums[i-1] == 0:\n                return True\n        return False\n    if k > 0:\n        for i in range(1, len(nums)):\n            if nums[i] == 0 and nums[i-1] == 0:\n                return True\n        for i in range(len(nums)):\n            if nums[i] % k == 0:\n                for j in range(i+1, len(nums)):\n                    if nums[j] % k == 0:\n                        return True\n    else:\n        for i in range(1, len(nums)):\n            if nums[i] == 0 and nums[i-1] == 0:\n                return True\n        for i in range(len(nums)):\n            if nums[i] % k == 0:\n                for j in range(i+1, len(nums)):\n                    if nums[j] % k == 0:\n                        return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1758",
    "source": "leetcode",
    "language": "python",
    "query": "Find the shortest completing word in words. Ignore numbers and spaces in licensePlate. If a letter appears more than once, it must appear in the word the same number of times or more.",
    "snippets": [
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = licensePlate.replace(\" \", \"\")\n    licensePlate = licensePlate.replace(\"0\", \"\")\n    licensePlate = licensePlate.replace(\"1\", \"\")\n    licensePlate = licensePlate.replace(\"2\", \"\")\n    licensePlate = licensePlate.replace(\"3\", \"\")\n    licensePlate = licensePlate.replace(\"4\", \"\")\n    licensePlate = licensePlate.replace(\"5\", \"\")\n    licensePlate = licensePlate.replace(\"6\", \"\")\n    licensePlate = licensePlate.replace(\"7\", \"\")\n    licensePlate = licensePlate.replace(\"8\", \"\")\n    licensePlate = licensePlate.replace(\"9\", \"\")\n    licensePlate = licensePlate.replace(\"-\", \"\")\n    licensePlate = licensePlate.replace(\".\", \"\")\n    licensePlate = licensePlate.replace(\"A\", \"\")\n    licensePlate = licensePlate.replace(\"B\", \"\")\n    licensePlate = licensePlate.replace(\"C\", \"\")\n    licensePlate = licensePlate.replace(\"D\", \"\")\n    licensePlate = licensePlate.replace(\"E\", \"\")\n    licensePlate = licensePlate.replace(\"F\", \"\")\n    licensePlate = licensePlate.replace(\"G\", \"\")\n    licensePlate = licensePlate.replace(\"H\", \"\")\n    licensePlate = licensePlate.replace(\"I\", \"\")\n    licensePlate = licensePlate.replace(\"J\", \"\")\n    licensePlate = licensePlate.replace(\"K\", \"\")\n    licensePlate = licensePlate.replace(\"L\", \"\")\n    licensePlate = licensePlate.replace(\"M\", \"\")\n    licensePlate = licensePlate.replace(\"N\", \"\")\n    licensePlate = licensePlate.replace(\"O\", \"\")\n    licensePlate = licensePlate.replace(\"P\", \"\")\n    licensePlate = licensePlate.replace(\"Q\",\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = licensePlate.replace(\" \", \"\")\n    licensePlate = licensePlate.replace(\"1\", \"\")\n    licensePlate = licensePlate.replace(\"2\", \"\")\n    licensePlate = licensePlate.replace(\"3\", \"\")\n    licensePlate = licensePlate.replace(\"4\", \"\")\n    licensePlate = licensePlate.replace(\"5\", \"\")\n    licensePlate = licensePlate.replace(\"6\", \"\")\n    licensePlate = licensePlate.replace(\"7\", \"\")\n    licensePlate = licensePlate.replace(\"8\", \"\")\n    licensePlate = licensePlate.replace(\"9\", \"\")\n    licensePlate = licensePlate.replace(\"0\", \"\")\n    licensePlate = licensePlate.replace(\"-\", \"\")\n    licensePlate = licensePlate.replace(\"_\", \"\")\n    licensePlate = licensePlate.replace(\".\", \"\")\n    licensePlate = licensePlate.replace(\"/\", \"\")\n    licensePlate = licensePlate.replace(\"\\\\\", \"\")\n    licensePlate = licensePlate.replace(\"(\", \"\")\n    licensePlate = licensePlate.replace(\")\", \"\")\n    licensePlate = licensePlate.replace(\"[\", \"\")\n    licensePlate = licensePlate.replace(\"]\", \"\")\n    licensePlate = licensePlate.replace(\"{\", \"\")\n    licensePlate = licensePlate.replace(\"}\", \"\")\n    licensePlate = licensePlate.replace(\"<\", \"\")\n    licensePlate = licensePlate.replace(\">\", \"\")\n    licensePlate = licensePlate.replace(\"!\", \"\")\n    licensePlate = licensePlate.replace(\"@\", \"\")\n    licensePlate = licensePlate.replace(\"#\", \"\")\n    licensePlate = licensePlate.replace(\"$\", \"\")\n    licensePlate = licensePlate.replace(\"%\", \"\")\n    licensePlate = licensePlate.replace(\"^\", \"\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = licensePlate.replace(\" \", \"\")\n    licensePlate = licensePlate.replace(\"1\", \"\")\n    licensePlate = licensePlate.replace(\"2\", \"\")\n    licensePlate = licensePlate.replace(\"3\", \"\")\n    licensePlate = licensePlate.replace(\"4\", \"\")\n    licensePlate = licensePlate.replace(\"5\", \"\")\n    licensePlate = licensePlate.replace(\"6\", \"\")\n    licensePlate = licensePlate.replace(\"7\", \"\")\n    licensePlate = licensePlate.replace(\"8\", \"\")\n    licensePlate = licensePlate.replace(\"9\", \"\")\n    licensePlate = licensePlate.replace(\"0\", \"\")\n    licensePlate = licensePlate.replace(\"-\", \"\")\n    licensePlate = licensePlate.replace(\"_\", \"\")\n    licensePlate = licensePlate.replace(\".\", \"\")\n    licensePlate = licensePlate.replace(\"/\", \"\")\n    licensePlate = licensePlate.replace(\"\\\\\", \"\")\n    licensePlate = licensePlate.replace(\"(\", \"\")\n    licensePlate = licensePlate.replace(\")\", \"\")\n    licensePlate = licensePlate.replace(\"[\", \"\")\n    licensePlate = licensePlate.replace(\"]\", \"\")\n    licensePlate = licensePlate.replace(\"{\", \"\")\n    licensePlate = licensePlate.replace(\"}\", \"\")\n    licensePlate = licensePlate.replace(\"<\", \"\")\n    licensePlate = licensePlate.replace(\">\", \"\")\n    licensePlate = licensePlate.replace(\"+\", \"\")\n    licensePlate = licensePlate.replace(\"=\", \"\")\n    licensePlate = licensePlate.replace(\"!\", \"\")\n    licensePlate = licensePlate.replace(\"@\", \"\")\n    licensePlate = licensePlate.replace(\"#\", \"\")\n    licensePlate = licensePlate.replace(\"$\", \"\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = licensePlate.replace(\" \", \"\")\n    licensePlate = licensePlate.replace(\"1\", \"\")\n    licensePlate = licensePlate.replace(\"2\", \"\")\n    licensePlate = licensePlate.replace(\"3\", \"\")\n    licensePlate = licensePlate.replace(\"4\", \"\")\n    licensePlate = licensePlate.replace(\"5\", \"\")\n    licensePlate = licensePlate.replace(\"6\", \"\")\n    licensePlate = licensePlate.replace(\"7\", \"\")\n    licensePlate = licensePlate.replace(\"8\", \"\")\n    licensePlate = licensePlate.replace(\"9\", \"\")\n    licensePlate = licensePlate.replace(\"0\", \"\")\n    licensePlate = licensePlate.replace(\"q\", \"\")\n    licensePlate = licensePlate.replace(\"w\", \"\")\n    licensePlate = licensePlate.replace(\"e\", \"\")\n    licensePlate = licensePlate.replace(\"r\", \"\")\n    licensePlate = licensePlate.replace(\"t\", \"\")\n    licensePlate = licensePlate.replace(\"y\", \"\")\n    licensePlate = licensePlate.replace(\"u\", \"\")\n    licensePlate = licensePlate.replace(\"i\", \"\")\n    licensePlate = licensePlate.replace(\"o\", \"\")\n    licensePlate = licensePlate.replace(\"p\", \"\")\n    licensePlate = licensePlate.replace(\"a\", \"\")\n    licensePlate = licensePlate.replace(\"s\", \"\")\n    licensePlate = licensePlate.replace(\"d\", \"\")\n    licensePlate = licensePlate.replace(\"f\", \"\")\n    licensePlate = licensePlate.replace(\"g\", \"\")\n    licensePlate = licensePlate.replace(\"h\", \"\")\n    licensePlate = licensePlate.replace(\"j\", \"\")\n    licensePlate = licensePlate.replace(\"k\", \"\")\n    licensePlate = licensePlate.replace(\"l\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = licensePlate.replace(\" \", \"\")\n    licensePlate = licensePlate.replace(\"1\", \"\")\n    licensePlate = licensePlate.replace(\"2\", \"\")\n    licensePlate = licensePlate.replace(\"3\", \"\")\n    licensePlate = licensePlate.replace(\"4\", \"\")\n    licensePlate = licensePlate.replace(\"5\", \"\")\n    licensePlate = licensePlate.replace(\"6\", \"\")\n    licensePlate = licensePlate.replace(\"7\", \"\")\n    licensePlate = licensePlate.replace(\"8\", \"\")\n    licensePlate = licensePlate.replace(\"9\", \"\")\n    licensePlate = licensePlate.replace(\"0\", \"\")\n    licensePlate = licensePlate.replace(\"-\", \"\")\n    licensePlate = licensePlate.replace(\"_\", \"\")\n    licensePlate = licensePlate.replace(\".\", \"\")\n    licensePlate = licensePlate.replace(\"/\", \"\")\n    licensePlate = licensePlate.replace(\"(\", \"\")\n    licensePlate = licensePlate.replace(\")\", \"\")\n    licensePlate = licensePlate.replace(\"[\", \"\")\n    licensePlate = licensePlate.replace(\"]\", \"\")\n    licensePlate = licensePlate.replace(\"{\", \"\")\n    licensePlate = licensePlate.replace(\"}\", \"\")\n    licensePlate = licensePlate.replace(\"<\", \"\")\n    licensePlate = licensePlate.replace(\">\", \"\")\n    licensePlate = licensePlate.replace(\"!\", \"\")\n    licensePlate = licensePlate.replace(\"@\", \"\")\n    licensePlate = licensePlate.replace(\"#\", \"\")\n    licensePlate = licensePlate.replace(\"$\", \"\")\n    licensePlate = licensePlate.replace(\"%\", \"\")\n    licensePlate = licensePlate.replace(\"^\", \"\")\n    licensePlate = licensePlate.replace(\"&\", \"\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = licensePlate.replace(' ', '')\n    licensePlate = licensePlate.replace('-', '')\n    licensePlate = licensePlate.replace('.', '')\n    licensePlate = licensePlate.replace('1', '')\n    licensePlate = licensePlate.replace('2', '')\n    licensePlate = licensePlate.replace('3', '')\n    licensePlate = licensePlate.replace('4', '')\n    licensePlate = licensePlate.replace('5', '')\n    licensePlate = licensePlate.replace('6', '')\n    licensePlate = licensePlate.replace('7', '')\n    licensePlate = licensePlate.replace('8', '')\n    licensePlate = licensePlate.replace('9', '')\n    licensePlate = licensePlate.replace('0', '')\n    licensePlate = licensePlate.replace('a', '')\n    licensePlate = licensePlate.replace('b', '')\n    licensePlate = licensePlate.replace('c', '')\n    licensePlate = licensePlate.replace('d', '')\n    licensePlate = licensePlate.replace('e', '')\n    licensePlate = licensePlate.replace('f', '')\n    licensePlate = licensePlate.replace('g', '')\n    licensePlate = licensePlate.replace('h', '')\n    licensePlate = licensePlate.replace('i', '')\n    licensePlate = licensePlate.replace('j', '')\n    licensePlate = licensePlate.replace('k', '')\n    licensePlate = licensePlate.replace('l', '')\n    licensePlate = licensePlate.replace('m', '')\n    licensePlate = licensePlate.replace('n', '')\n    licensePlate = licensePlate.replace('o', '')\n    licensePlate = licensePlate.replace('p', '')\n    licensePlate = licensePlate.replace('q\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = ''.join(filter(lambda x: x.isalpha(), licensePlate))\n    licensePlate = collections.Counter(licensePlate)\n    licensePlate = dict(licensePlate)\n    min_len = len(words[0])\n    min_word = words[0]\n    for word in words:\n        if len(word) < min_len:\n            min_len = len(word)\n            min_word = word\n        if len(word) == min_len:\n            if word < min_word:\n                min_word = word\n    for key in licensePlate:\n        if key in min_word:\n            if licensePlate[key] > min_word.count(key):\n                return min_word\n        else:\n            return min_word\n    return min_word\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = ''.join(filter(lambda x: x.isalpha(), licensePlate))\n    licensePlate = collections.Counter(licensePlate)\n    min_len = len(words[0])\n    min_word = words[0]\n    for word in words:\n        if len(word) < min_len:\n            min_len = len(word)\n            min_word = word\n        word_counter = collections.Counter(word)\n        for letter in licensePlate:\n            if letter not in word_counter:\n                break\n            if word_counter[letter] < licensePlate[letter]:\n                break\n        else:\n            return word\n    return min_word\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    licensePlate = licensePlate.replace(' ', '')\n    licensePlate = licensePlate.replace('0', '')\n    licensePlate = licensePlate.replace('1', '')\n    licensePlate = licensePlate.replace('2', '')\n    licensePlate = licensePlate.replace('3', '')\n    licensePlate = licensePlate.replace('4', '')\n    licensePlate = licensePlate.replace('5', '')\n    licensePlate = licensePlate.replace('6', '')\n    licensePlate = licensePlate.replace('7', '')\n    licensePlate = licensePlate.replace('8', '')\n    licensePlate = licensePlate.replace('9', '')\n    licensePlate = licensePlate.replace('-', '')\n    licensePlate = licensePlate.replace('_', '')\n    licensePlate = licensePlate.replace('.', '')\n    licensePlate = licensePlate.replace('/', '')\n    licensePlate = licensePlate.replace('\\\\', '')\n    licensePlate = licensePlate.replace('(', '')\n    licensePlate = licensePlate.replace(')', '')\n    licensePlate = licensePlate.replace('[', '')\n    licensePlate = licensePlate.replace(']', '')\n    licensePlate = licensePlate.replace('{', '')\n    licensePlate = licensePlate.replace('}', '')\n    licensePlate = licensePlate.replace('<', '')\n    licensePlate = licensePlate.replace('>', '')\n    licensePlate = licensePlate.replace('+', '')\n    licensePlate = licensePlate.replace('=', '')\n    licensePlate = licensePlate.replace('*', '')\n    licensePlate = licensePlate.replace('%', '')\n    licensePlate = licensePlate.replace('$', '')\n    licensePlate = licensePlate.replace('#\n",
        "def shortestCompletingWord(licensePlate, words):\n    licensePlate = licensePlate.lower()\n    for char in licensePlate:\n        if char.isalpha():\n            licensePlate = licensePlate.replace(char, \"\")\n    licensePlate = set(licensePlate)\n    words = [word for word in words if len(set(word) & licensePlate) == len(licensePlate)]\n    return min(words, key=len) if words else \"\"\n"
    ],
    "results": 10
},{
    "id": "1759",
    "source": "leetcode",
    "language": "python",
    "query": "Return true if the value of the root is equal to the sum of the values of its two children. You are given the root of a binary tree that consists of exactly 3 nodes.",
    "snippets": [
        "def check_balanced(root):\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None:\n        return check_balanced(root.right)\n    if root.right is None:\n        return check_balanced(root.left)\n    return check_balanced(root.left) and check_balanced(root.right) and abs(height(root.left) - height(root.right)) <= 1\n",
        "def has_equal_node_values(root):\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None:\n        return root.value == root.right.value + root.value\n    if root.right is None:\n        return root.value == root.left.value + root.value\n    return root.value == root.left.value + root.right.value\n",
        "def has_equal_node_values(root):\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None:\n        return root.val == root.right.val + has_equal_node_values(root.right.left) + has_equal_node_values(root.right.right)\n    if root.right is None:\n        return root.val == root.left.val + has_equal_node_values(root.left.left) + has_equal_node_values(root.left.right)\n    return root.val == root.left.val + root.right.val + has_equal_node_values(root.left.left) + has_equal_node_values(root.left.right) + has_equal_node_values(root.right.left) + has_equal_node_values(root.right.right)\n",
        "def has_equal_node(root):\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return False\n    if root.left is None:\n        return root.val == root.right.val + root.right.val\n    if root.right is None:\n        return root.val == root.left.val + root.left.val\n    return root.val == root.left.val + root.right.val\n",
        "def check_balanced(root):\n    if root is None:\n        return True\n    if abs(get_height(root.left) - get_height(root.right)) > 1:\n        return False\n    return check_balanced(root.left) and check_balanced(root.right)\n",
        "def check_balanced(root):\n    if root is None:\n        return True\n    left = check_balanced(root.left)\n    right = check_balanced(root.right)\n    if left and right:\n        if abs(root.left.value - root.right.value) <= 1:\n            return True\n    return False\n",
        "def has_equal_sum(root):\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None:\n        return root.val == root.right.val + sum(root.right.left.values())\n    if root.right is None:\n        return root.val == root.left.val + sum(root.left.right.values())\n    return root.val == root.left.val + root.right.val + sum(root.left.right.values()) + sum(root.right.left.values())\n"
    ],
    "results": 10
},{
    "id": "1760",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
    "snippets": [
        "def word_break(s, word_dict):\n    if s in word_dict:\n        return True\n    for i in range(1, len(s)):\n        if s[:i] in word_dict and word_break(s[i:], word_dict):\n            return True\n    return False\n",
        "def word_break(s, wordDict):\n    if not s:\n        return True\n    if not wordDict:\n        return False\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in wordDict:\n                dp[i] = True\n                break\n    return dp[-1]\n",
        "def word_break(s, word_dict):\n    if not s:\n        return True\n    if not word_dict:\n        return False\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_dict:\n                dp[i] = True\n                break\n    return dp[-1]\n",
        "def word_break(s, word_dict):\n    if s == '':\n        return True\n    if s in word_dict:\n        return True\n    for i in range(1, len(s)):\n        if s[:i] in word_dict and word_break(s[i:], word_dict):\n            return True\n    return False\n",
        "def word_break(s, word_dict):\n    if not s:\n        return True\n    if not word_dict:\n        return False\n    word_dict = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_dict:\n                dp[i] = True\n                break\n    return dp[-1]\n"
    ],
    "results": 10
},{
    "id": "1761",
    "source": "leetcode",
    "language": "python",
    "query": "The CombinationIterator class was designed to make it easier to write code with lowercase letters and numbers.",
    "snippets": [
        "def combinationIterator(characters, combinationLength):\n    def dfs(start, path, res):\n        if len(path) == combinationLength:\n            res.append(path)\n            return\n        for i in range(start, len(characters)):\n            dfs(i + 1, path + characters[i], res)\n    res = []\n    dfs(0, \"\", res)\n    return res\n",
        "def combinationIterator(characters, combinationLength):\n    def dfs(index, path, res):\n        if len(path) == combinationLength:\n            res.append(path)\n            return\n        for i in range(index, len(characters)):\n            dfs(i + 1, path + characters[i], res)\n    res = []\n    dfs(0, \"\", res)\n    return res\n",
        "def combinationIterator(characters, combinationLength):\n    def dfs(combination, index, path):\n        if len(path) == combinationLength:\n            res.append(path)\n            return\n        for i in range(index, len(characters)):\n            dfs(combination, i + 1, path + characters[i])\n    res = []\n    dfs('', 0, '')\n    return res\n",
        "def combinationIterator(characters, combinationLength):\n    def backtrack(combination, index, combinationLength):\n        if len(combination) == combinationLength:\n            result.append(combination)\n            return\n        for i in range(index, len(characters)):\n            backtrack(combination + characters[i], i + 1, combinationLength)\n    result = []\n    backtrack(\"\", 0, combinationLength)\n    return result\n",
        "def combinationIterator(characters, combinationLength):\n    def dfs(combination, index, path):\n        if len(path) == combinationLength:\n            result.append(path)\n            return\n        for i in range(index, len(characters)):\n            dfs(combination + characters[i], i + 1, path + characters[i])\n    result = []\n    dfs('', 0, '')\n    return result\n",
        "def combinationIterator(characters, combinationLength):\n    def dfs(start, curr, res):\n        if len(curr) == combinationLength:\n            res.append(curr)\n            return\n        for i in range(start, len(characters)):\n            dfs(i + 1, curr + characters[i], res)\n    res = []\n    dfs(0, '', res)\n    return res\n",
        "def combinationIterator(characters, combinationLength):\n    def helper(characters, combinationLength, curr_str, curr_idx, res):\n        if len(curr_str) == combinationLength:\n            res.append(curr_str)\n            return\n        for i in range(curr_idx, len(characters)):\n            helper(characters, combinationLength, curr_str + characters[i], i + 1, res)\n        return res\n    return helper(characters, combinationLength, \"\", 0, [])\n"
    ],
    "results": 10
},{
    "id": "1762",
    "source": "leetcode",
    "language": "python",
    "query": "M is an m x n matrix with all 0's and an array of operations ops. ops[i] = [ai, bi] means M[x] should be incremented by one for all 0 <= x < ai and 0 <= y < bi.Count and return the number of maximum integers in the matrix after performing all the operations.",
    "snippets": [
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    else:\n        a = ops[0][0]\n        b = ops[0][1]\n        for i in range(1, len(ops)):\n            if ops[i][0] < a:\n                a = ops[i][0]\n            if ops[i][1] < b:\n                b = ops[i][1]\n        return a * b\n",
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    else:\n        a = ops[0][0]\n        b = ops[0][1]\n        for i in range(1, len(ops)):\n            if a > ops[i][0]:\n                a = ops[i][0]\n            if b > ops[i][1]:\n                b = ops[i][1]\n        return a * b\n",
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    a, b = ops[0]\n    for i in range(1, len(ops)):\n        a, b = min(a, ops[i][0]), min(b, ops[i][1])\n    return a * b\n",
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    a, b = ops[0]\n    for i in range(1, len(ops)):\n        ai, bi = ops[i]\n        a = min(a, ai)\n        b = min(b, bi)\n    return a * b\n",
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    a = min(ops[0][0], m)\n    b = min(ops[0][1], n)\n    for i in range(1, len(ops)):\n        a = min(ops[i][0], a)\n        b = min(ops[i][1], b)\n    return a * b\n",
        "def countMax(M, ops):\n    for op in ops:\n        for i in range(op[0]):\n            for j in range(op[1]):\n                M[i][j] += 1\n    return max(max(row) for row in M)\n",
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    ai, bi = ops[0]\n    for i in range(1, len(ops)):\n        ai, bi = min(ai, ops[i][0]), min(bi, ops[i][1])\n    return ai * bi\n",
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    else:\n        a = min(ops[0][0], m)\n        b = min(ops[0][1], n)\n        for i in range(1, len(ops)):\n            a = min(a, ops[i][0])\n            b = min(b, ops[i][1])\n        return a * b\n",
        "def maxCount(m, n, ops):\n    if not ops:\n        return m * n\n    else:\n        max_row = 0\n        max_col = 0\n        for i in ops:\n            max_row = max(max_row, i[0])\n            max_col = max(max_col, i[1])\n        return max_row * max_col\n"
    ],
    "results": 10
},{
    "id": "1763",
    "source": "leetcode",
    "language": "python",
    "query": "Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "def numSubseq(nums, target):\n    nums.sort()\n    res = 0\n    for i in range(len(nums)):\n        j = i\n        while j < len(nums) and nums[j] + nums[i] <= target:\n            j += 1\n        res += j - i - 1\n        res %= 1000000007\n    return res\n",
        "def numSubseq(nums, target):\n    nums.sort()\n    res = 0\n    for i in range(len(nums)):\n        j = i\n        while j < len(nums) and nums[j] + nums[i] <= target:\n            j += 1\n        res += j - i\n        res %= 1000000007\n    return res\n",
        "def numSubseq(nums, target):\n    nums.sort()\n    res = 0\n    for i in range(len(nums)):\n        j = i\n        while j < len(nums) and nums[j] <= target:\n            res += 1\n            j += 1\n        target -= nums[i]\n    return res % (10**9 + 7)\n",
        "def numSubseq(nums, target):\n    nums.sort()\n    ans = 0\n    for i in range(len(nums)):\n        j = i\n        while j < len(nums) and nums[j] <= target:\n            ans += 1\n            j += 1\n    return ans % (10**9 + 7)\n",
        "def numSubseq(nums, target):\n    nums.sort()\n    ans = 0\n    for i in range(len(nums)):\n        j = i\n        while j < len(nums) and nums[j] + nums[i] <= target:\n            j += 1\n        ans += j - i - 1\n        ans %= 1000000007\n    return ans\n",
        "def numSubseq(nums, target):\n    nums.sort()\n    res = 0\n    for i in range(len(nums)):\n        j = i + 1\n        while j < len(nums) and nums[j] <= target - nums[i]:\n            j += 1\n        res += j - i - 1\n        res %= 1000000007\n    return res\n"
    ],
    "results": 10
},{
    "id": "1764",
    "source": "leetcode",
    "language": "python",
    "query": "An integer n is a power of four, if there exists an integer x such that n == 4x. Given an integer n, return true if it is a powers of four. Otherwise, return false.",
    "snippets": [
        "def is_power_of_four(n):\n    if n == 1:\n        return True\n    if n % 4 != 0:\n        return False\n    return is_power_of_four(n // 4)\n",
        "def is_power_of_four(n):\n    if n == 1:\n        return True\n    if n % 4 != 0:\n        return False\n    return is_power_of_four(n / 4)\n"
    ],
    "results": 10
},{
    "id": "1765",
    "source": "leetcode",
    "language": "python",
    "query": "Remove any number of beans (possibly none) from each bag such that the number in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it.",
    "snippets": [
        "def removeBeans(bags, beans):\n    # Write your code here.\n    if len(bags) == 0:\n        return []\n    if len(bags) == 1:\n        return [bags[0] - beans]\n    if len(bags) == 2:\n        return [bags[0] - beans, bags[1] - beans]\n    if len(bags) == 3:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans]\n    if len(bags) == 4:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans]\n    if len(bags) == 5:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans]\n    if len(bags) == 6:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans]\n    if len(bags) == 7:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans, bags[6] - beans]\n    if len(bags) == 8:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans, bags[6] - beans, bags[7] - beans]\n    if len(bags) == 9:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans, bags[6] - beans, bags[7] - beans, bags[8] - beans]\n    if len(bags) == 10:\n        return [bags[0] - beans, bags[1] - beans,\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    # print(bags, beans)\n    if len(bags) == 0:\n        return []\n    if len(beans) == 0:\n        return []\n    if len(bags) == 1:\n        return [bags[0]]\n    if len(beans) == 1:\n        return [bags[0]]\n    if len(bags) == 2:\n        return [bags[0], bags[1]]\n    if len(bags) == 3:\n        return [bags[0], bags[1], bags[2]]\n    if len(bags) == 4:\n        return [bags[0], bags[1], bags[2], bags[3]]\n    if len(bags) == 5:\n        return [bags[0], bags[1], bags[2], bags[3], bags[4]]\n    if len(bags) == 6:\n        return [bags[0], bags[1], bags[2], bags[3], bags[4], bags[5]]\n    if len(bags) == 7:\n        return [bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6]]\n    if len(bags) == 8:\n        return [bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7]]\n    if len(bags) == 9:\n        return [bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8]]\n    if len(bags) == 10:\n        return [bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8], bags[9]]\n    if len(bags) == 11:\n        return [bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8], bags[9], bags[10]]\n    if len(bags) == 12:\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    # print(bags, beans)\n    if len(bags) == 1:\n        return bags[0]\n    if len(bags) == 2:\n        if bags[0] == bags[1]:\n            return bags[0]\n        else:\n            return 0\n    if len(bags) == 3:\n        if bags[0] == bags[1] and bags[1] == bags[2]:\n            return bags[0]\n        elif bags[0] == bags[1]:\n            return bags[0]\n        elif bags[1] == bags[2]:\n            return bags[1]\n        else:\n            return 0\n    if len(bags) == 4:\n        if bags[0] == bags[1] and bags[1] == bags[2] and bags[2] == bags[3]:\n            return bags[0]\n        elif bags[0] == bags[1] and bags[1] == bags[2]:\n            return bags[0]\n        elif bags[0] == bags[1]:\n            return bags[0]\n        elif bags[1] == bags[2]:\n            return bags[1]\n        elif bags[2] == bags[3]:\n            return bags[2]\n        elif bags[0] == bags[3]:\n            return bags[0]\n        else:\n            return 0\n    if len(bags) == 5:\n        if bags[0] == bags[1] and bags[1] == bags[2] and bags[2] == bags[3] and bags[3] == bags[4]:\n            return bags[0]\n        elif bags[0] == bags[1] and bags[1] == bags[2] and bags[2] == bags[3]:\n            return bags[0]\n        elif bags[0] == bags[1] and bags[1] == bags[2]:\n            return bags[0]\n        elif bags[0] == bags[1]:\n            return bags[0]\n        elif bags[1] == bags[2]:\n            return bags\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    # print(bags, beans)\n    if len(bags) == 1:\n        return bags[0]\n    else:\n        if len(bags) == 2:\n            if bags[0] == bags[1]:\n                return bags[0]\n            else:\n                return 0\n        else:\n            if bags[0] == bags[1]:\n                return bags[0]\n            else:\n                return removeBeans(bags[1:], beans)\n    return 0\n",
        "def remove_beans(bags):\n    # Write your code here.\n    # You may use the following functions:\n    #   - bag_size(bag)\n    #   - remove_from_bag(bag, beans)\n    #   - add_to_bag(bag, beans)\n    #   - is_empty(bag)\n    #   - is_full(bag)\n    #   - is_valid(bag)\n    #   - is_valid_removal(bag, beans)\n    #   - is_valid_addition(bag, beans)\n    #   - is_valid_state(bag)\n    #   - is_valid_state_removal(bag, beans)\n    #   - is_valid_state_addition(bag, beans)\n    #   - is_valid_state_removal_addition(bag, beans)\n    #   - is_valid_state_removal_addition_removal(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition_removal(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition_removal_addition(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition_removal_addition_removal(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition_removal_addition_removal_addition(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition_removal_addition_removal_addition_removal(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition_removal_addition_removal_addition_removal_addition(bag, beans)\n    #   - is_valid_state_removal_addition_removal_addition_\n"
    ],
    "results": 6
},{
    "id": "1766",
    "source": "leetcode",
    "language": "python",
    "query": "Each node in the tree has node.val coins. In one move, we may choose two adjacent nodes and move one coin from one node to another.",
    "snippets": [
        "def rob(self, root):\n    def dfs(node):\n        if not node:\n            return (0, 0)\n        left = dfs(node.left)\n        right = dfs(node.right)\n        return (max(left) + max(right), node.val + left[0] + right[0])\n    return max(dfs(root))\n",
        "def rob(self, root):\n    def dfs(node):\n        if not node:\n            return (0, 0)\n        left = dfs(node.left)\n        right = dfs(node.right)\n        return (node.val + left[1] + right[1], max(left) + max(right))\n    return max(dfs(root))\n",
        "def distribute_coins(root):\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right = dfs(node.right)\n        node.val = left + right + 1\n        return node.val\n    dfs(root)\n    return root.val\n",
        "def distributeCoins(root):\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right = dfs(node.right)\n        node.val += left + right\n        return node.val - 1 + left + right\n    return dfs(root)\n"
    ],
    "results": 10
},{
    "id": "1767",
    "source": "leetcode",
    "language": "python",
    "query": "In Pascal's triangle, each number is the sum of the two numbers directly above it as shown. Given an integer numRows, return the first NumRows of the triangle.",
    "snippets": [
        "def generate(numRows):\n    if numRows == 0:\n        return []\n    if numRows == 1:\n        return [[1]]\n    if numRows == 2:\n        return [[1],[1,1]]\n    result = [[1],[1,1]]\n    for i in range(2,numRows):\n        temp = [1]\n        for j in range(1,i):\n            temp.append(result[i-1][j-1]+result[i-1][j])\n        temp.append(1)\n        result.append(temp)\n    return result\n",
        "def generate(numRows):\n    if numRows == 0:\n        return []\n    if numRows == 1:\n        return [[1]]\n    if numRows == 2:\n        return [[1], [1, 1]]\n    result = [[1], [1, 1]]\n    for i in range(2, numRows):\n        result.append([1] + [result[i - 1][j] + result[i - 1][j + 1] for j in range(i - 1)] + [1])\n    return result\n",
        "def generate(numRows):\n    if numRows == 0:\n        return []\n    if numRows == 1:\n        return [[1]]\n    if numRows == 2:\n        return [[1],[1,1]]\n    result = [[1],[1,1]]\n    for i in range(2,numRows):\n        result.append([1])\n        for j in range(1,i):\n            result[i].append(result[i-1][j-1]+result[i-1][j])\n        result[i].append(1)\n    return result\n",
        "def generate(numRows):\n    if numRows == 0:\n        return []\n    if numRows == 1:\n        return [[1]]\n    if numRows == 2:\n        return [[1],[1,1]]\n    triangle = [[1],[1,1]]\n    for i in range(2,numRows):\n        row = [1]\n        for j in range(1,i):\n            row.append(triangle[i-1][j-1] + triangle[i-1][j])\n        row.append(1)\n        triangle.append(row)\n    return triangle\n",
        "def pascalTriangle(numRows):\n    if numRows == 0:\n        return []\n    if numRows == 1:\n        return [[1]]\n    if numRows == 2:\n        return [[1], [1, 1]]\n    if numRows == 3:\n        return [[1], [1, 1], [1, 2, 1]]\n    if numRows == 4:\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]]\n    if numRows == 5:\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n    if numRows == 6:\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]]\n    if numRows == 7:\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1]]\n    if numRows == 8:\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1]]\n    if numRows == 9:\n        return [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56,\n",
        "def generate(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1]\n        for j in range(i):\n            row.append(triangle[i - 1][j] + triangle[i - 1][j + 1])\n        row.append(1)\n        triangle.append(row)\n    return triangle\n"
    ],
    "results": 10
},{
    "id": "1768",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary tree with the following rules: root.val == 0 and tree.left != null, then tree.right.val is changed to 2 * x + 2. The binary tree is contaminated, which means all tree.val have been changed to -1.",
    "snippets": [
        "def change_tree(tree):\n    if tree is None:\n        return\n    if tree.left is not None:\n        tree.left.val = 2 * tree.val + 2\n    if tree.right is not None:\n        tree.right.val = 2 * tree.val + 2\n    change_tree(tree.left)\n    change_tree(tree.right)\n    return tree\n",
        "def change_to_2_plus_2(root):\n    if root is None:\n        return\n    if root.left is not None:\n        root.left.val = 2 * root.val + 2\n    if root.right is not None:\n        root.right.val = 2 * root.val + 2\n    change_to_2_plus_2(root.left)\n    change_to_2_plus_2(root.right)\n    return root\n",
        "def change_to_2_plus_2(root):\n    if root is None:\n        return\n    if root.left is not None:\n        root.left.val = 2 * root.val + 2\n    change_to_2_plus_2(root.left)\n    change_to_2_plus_2(root.right)\n    return root\n",
        "def change_to_2_plus_2(root):\n    if root is None:\n        return\n    if root.left is None:\n        root.right.val = 2 * root.val + 2\n        return\n    change_to_2_plus_2(root.left)\n    change_to_2_plus_2(root.right)\n    root.right.val = 2 * root.val + 2\n    return root\n",
        "def change_to_2_plus_2(tree):\n    if tree is None:\n        return\n    if tree.left is not None:\n        tree.left.val = 2 * tree.val + 2\n    if tree.right is not None:\n        tree.right.val = 2 * tree.val + 2\n    change_to_2_plus_2(tree.left)\n    change_to_2_plus_2(tree.right)\n    return tree\n",
        "def change(tree):\n    if tree is None:\n        return\n    if tree.left is None and tree.right is None:\n        return\n    if tree.left is None:\n        tree.right.val = 2 * tree.val + 2\n        change(tree.right)\n    elif tree.right is None:\n        tree.left.val = 2 * tree.val + 2\n        change(tree.left)\n    else:\n        tree.left.val = 2 * tree.val + 2\n        tree.right.val = 2 * tree.val + 2\n        change(tree.left)\n        change(tree.right)\n",
        "def change_to_2_plus_2(tree):\n    if tree is None:\n        return\n    if tree.val == 0:\n        tree.right.val = 2 * tree.left.val + 2\n    change_to_2_plus_2(tree.left)\n    change_to_2_plus_2(tree.right)\n    return tree\n",
        "def change_to_minus_one(root):\n    if root is None:\n        return\n    if root.left is not None:\n        root.left.val = 2 * root.val + 2\n    if root.right is not None:\n        root.right.val = 2 * root.val + 2\n    change_to_minus_one(root.left)\n    change_to_minus_one(root.right)\n    return root\n"
    ],
    "results": 10
},{
    "id": "1769",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.",
    "snippets": [
        "def change_tree(tree):\n    if tree is None:\n        return\n    if tree.left is not None:\n        tree.left.val = 2 * tree.val + 2\n    if tree.right is not None:\n        tree.right.val = 2 * tree.val + 2\n    change_tree(tree.left)\n    change_tree(tree.right)\n    return tree\n",
        "def change_to_2_plus_2(root):\n    if root is None:\n        return\n    if root.left is not None:\n        root.left.val = 2 * root.val + 2\n    if root.right is not None:\n        root.right.val = 2 * root.val + 2\n    change_to_2_plus_2(root.left)\n    change_to_2_plus_2(root.right)\n    return root\n",
        "def change_to_2_plus_2(root):\n    if root is None:\n        return\n    if root.left is not None:\n        root.left.val = 2 * root.val + 2\n    change_to_2_plus_2(root.left)\n    change_to_2_plus_2(root.right)\n    return root\n",
        "def change_to_2_plus_2(root):\n    if root is None:\n        return\n    if root.left is None:\n        root.right.val = 2 * root.val + 2\n        return\n    change_to_2_plus_2(root.left)\n    change_to_2_plus_2(root.right)\n    root.right.val = 2 * root.val + 2\n    return root\n",
        "def change_to_2_plus_2(tree):\n    if tree is None:\n        return\n    if tree.left is not None:\n        tree.left.val = 2 * tree.val + 2\n    if tree.right is not None:\n        tree.right.val = 2 * tree.val + 2\n    change_to_2_plus_2(tree.left)\n    change_to_2_plus_2(tree.right)\n    return tree\n",
        "def change(tree):\n    if tree is None:\n        return\n    if tree.left is None and tree.right is None:\n        return\n    if tree.left is None:\n        tree.right.val = 2 * tree.val + 2\n        change(tree.right)\n    elif tree.right is None:\n        tree.left.val = 2 * tree.val + 2\n        change(tree.left)\n    else:\n        tree.left.val = 2 * tree.val + 2\n        tree.right.val = 2 * tree.val + 2\n        change(tree.left)\n        change(tree.right)\n",
        "def change_to_2_plus_2(tree):\n    if tree is None:\n        return\n    if tree.val == 0:\n        tree.right.val = 2 * tree.left.val + 2\n    change_to_2_plus_2(tree.left)\n    change_to_2_plus_2(tree.right)\n    return tree\n",
        "def change_to_minus_one(root):\n    if root is None:\n        return\n    if root.left is not None:\n        root.left.val = 2 * root.val + 2\n    if root.right is not None:\n        root.right.val = 2 * root.val + 2\n    change_to_minus_one(root.left)\n    change_to_minus_one(root.right)\n    return root\n"
    ],
    "results": 10
},{
    "id": "1770",
    "source": "leetcode",
    "language": "python",
    "query": "You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i.",
    "snippets": [
        "def circularArray(nums):\n    if len(nums) == 1:\n        return nums[0]\n    else:\n        return nums[0] + circularArray(nums[1:])\n",
        "def circularArray(nums):\n    if len(nums) == 1:\n        return nums[0]\n    else:\n        return circularArray(nums[1:]) + nums[0]\n"
    ],
    "results": 10
},{
    "id": "1771",
    "source": "leetcode",
    "language": "python",
    "query": "Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words. If you cannot redistribute all the spaces equally, place the extra spaces at the end. Return the string after rearranging the spaces.",
    "snippets": [
        "def reArrangeSpaces(str):\n    str = str.split()\n    str = ' '.join(str)\n    str = str.split()\n    str = ' '.join(str)\n    return str\n",
        "def reArrangeSpaces(s):\n    s = s.split()\n    s = [x.strip() for x in s]\n    s = ' '.join(s)\n    s = s.split()\n    s = [x.strip() for x in s]\n    s = ' '.join(s)\n    return s\n",
        "def rearrangeSpaces(text):\n    # Write your code here.\n    text = text.split()\n    text = ' '.join(text)\n    text = text.split()\n    text = ' '.join(text)\n    return text\n",
        "def rearrangeSpaces(text):\n    # Write your code here.\n    words = text.split()\n    num_spaces = sum(1 for c in text if c == ' ')\n    num_words = len(words)\n    num_spaces_per_word = num_spaces // num_words\n    num_extra_spaces = num_spaces % num_words\n    return ' '.join(word + ' ' * (num_spaces_per_word + 1) for word in words)[:-1] + ' ' * num_extra_spaces\n",
        "def rearrangeSpaces(text):\n    # Write your code here.\n    text = text.strip()\n    words = text.split()\n    num_spaces = 0\n    for word in words:\n        num_spaces += word.count(' ')\n    num_words = len(words)\n    if num_words == 1:\n        return text\n    num_spaces = num_spaces // (num_words - 1)\n    num_spaces_left = num_spaces * (num_words - 1)\n    num_spaces_left -= num_spaces * (num_words - 1)\n    if num_spaces_left > 0:\n        num_spaces += 1\n    return ' '.join(words).replace(' ', ' ' * num_spaces)\n",
        "def rearrangeSpaces(text):\n    # your code goes here\n    words = text.split()\n    num_spaces = sum(1 for c in text if c == ' ')\n    num_words = len(words)\n    if num_words == 1:\n        return text\n    num_spaces_per_word = num_spaces // (num_words - 1)\n    num_extra_spaces = num_spaces % (num_words - 1)\n    return ' '.join(word + ' ' * num_spaces_per_word for word in words) + ' ' * num_extra_spaces\n",
        "def rearrangeSpaces(text):\n    # Write your code here.\n    text = text.split()\n    text_len = len(text)\n    space_count = 0\n    for i in range(text_len):\n        space_count += text[i].count(' ')\n    space_count = space_count // (text_len - 1)\n    for i in range(text_len):\n        text[i] = text[i].replace(' ', '', space_count)\n    return ' '.join(text)\n",
        "def rearrange_spaces(text):\n    # your code here\n    words = text.split()\n    if len(words) == 1:\n        return text\n    else:\n        spaces = [0] * (len(words) - 1)\n        for i in range(len(words) - 1):\n            spaces[i] = len(words[i]) + len(words[i + 1])\n        spaces.sort()\n        if spaces[0] == spaces[1]:\n            return text\n        else:\n            for i in range(len(spaces)):\n                if spaces[i] > spaces[i + 1]:\n                    spaces[i] = spaces[i] - spaces[i + 1]\n                    spaces[i + 1] = spaces[i + 1] - spaces[i]\n                    break\n            for i in range(len(spaces)):\n                if spaces[i] > spaces[i + 1]:\n                    spaces[i] = spaces[i] - spaces[i + 1]\n                    spaces[i + 1] = spaces[i + 1] - spaces[i]\n                    break\n            for i in range(len(spaces)):\n                if spaces[i] > spaces[i + 1]:\n                    spaces[i] = spaces[i] - spaces[i + 1]\n                    spaces[i + 1] = spaces[i + 1] - spaces[i]\n                    break\n            for i in range(len(spaces)):\n                if spaces[i] > spaces[i + 1]:\n                    spaces[i] = spaces[i] - spaces[i + 1]\n                    spaces[i + 1] = spaces[i + 1] - spaces[i]\n                    break\n            for i in range(len(spaces)):\n                if spaces[i] > spaces[i + 1]:\n                    spaces[i] = spaces[i] - spaces[i + 1]\n                    spaces[i + 1] = spaces[i + 1] - spaces[i]\n                    break\n            for i in range(len(spaces)):\n                if spaces[i] > spaces[i + 1]:\n                    spaces[i] = spaces[i] - spaces\n",
        "def respace(s):\n    return ' '.join(s.split())\n"
    ],
    "results": 9
},{
    "id": "1772",
    "source": "leetcode",
    "language": "python",
    "query": "Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.",
    "snippets": [
        "def countSquares(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                dp[i][j] = min(dp[i][j], dp[i - 1][j], dp[i][j - 1]) + 1\n    return sum(sum(dp[i]) for i in range(1, m + 1))\n",
        "def countSquares(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = 0\n    res = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            res += dp[i][j]\n            for k in range(1, min(i, j) + 1):\n                res += dp[i - k][j - k]\n    return res\n",
        "def countSquares(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = 0\n    res = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            res += dp[i][j]\n            for k in range(1, min(m - i + 1, n - j + 1) + 1):\n                res += dp[i + k - 1][j + k - 1]\n    return res\n",
        "def countSquares(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    res = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                res += dp[i][j]\n    return res\n",
        "def countSquares(matrix):\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = 0\n    res = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            res += dp[i][j]\n    return res\n",
        "def countSquares(matrix):\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = 0\n    ans = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            ans += dp[i][j]\n            for k in range(1, min(i, j) + 1):\n                ans += dp[i - k][j - k]\n    return ans\n",
        "def count_squares(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = 0\n    res = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            res += dp[i][j]\n    return res\n",
        "def countSquares(matrix):\n    \"\"\"\n    :type matrix: List[List[int]]\n    :rtype: int\n    \"\"\"\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == 1:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = 0\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            count += dp[i][j]\n    return count\n"
    ],
    "results": 10
},{
    "id": "1773",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the array words.",
    "snippets": [
        "def is_consistent(allowed, words):\n    for word in words:\n        if not all(char in allowed for char in word):\n            return False\n    return True\n",
        "def is_consistent(allowed, words):\n    for word in words:\n        if not all(word.count(c) <= allowed.count(c) for c in word):\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1774",
    "source": "leetcode",
    "language": "python",
    "query": "We want to select three indices i, j and k where (0 <= i < j <= k < arr.length). Let's define a and b as follows.",
    "snippets": [
        "def a(arr, i, j, k):\n    return arr[i] + arr[j] + arr[k]\n",
        "def a(arr):\n    return arr[0]\n"
    ],
    "results": 10
},{
    "id": "1775",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.",
    "snippets": [
        "def countTriplets(arr, a, b, c):\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] % a == 0:\n            for j in range(i + 1, len(arr)):\n                if arr[j] % a == 0 and arr[j] % b == 0:\n                    for k in range(j + 1, len(arr)):\n                        if arr[k] % a == 0 and arr[k] % b == 0 and arr[k] % c == 0:\n                            count += 1\n    return count\n",
        "def countGoodTriplets(arr, a, b, c):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                if abs(arr[i] - arr[j]) <= a and abs(arr[j] - arr[k]) <= b and abs(arr[i] - arr[k]) <= c:\n                    count += 1\n    return count\n",
        "def countTriplets(arr, a, b, c):\n    count = 0\n    for i in range(len(arr)):\n        if arr[i] % a == 0:\n            for j in range(i + 1, len(arr)):\n                if arr[j] % a == 0 and arr[j] % b == 0:\n                    count += 1\n    return count\n",
        "def triplets(arr, a, b, c):\n    arr.sort()\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            for k in range(j+1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == a and arr[j] + arr[k] == b and arr[k] == c:\n                    count += 1\n    return count\n",
        "def triplets(arr, a, b, c):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == a and arr[i] * arr[j] * arr[k] == b and arr[i] ** 2 + arr[j] ** 2 == c:\n                    count += 1\n    return count\n",
        "def triplets(arr, a, b, c):\n    arr.sort()\n    count = 0\n    for i in range(len(arr) - 2):\n        for j in range(i + 1, len(arr) - 1):\n            for k in range(j + 1, len(arr)):\n                if arr[i] + arr[j] + arr[k] == a:\n                    count += 1\n                elif arr[i] + arr[j] + arr[k] == b:\n                    count += 1\n                elif arr[i] + arr[j] + arr[k] == c:\n                    count += 1\n    return count\n",
        "def triplets(arr, a, b, c):\n    arr.sort()\n    count = 0\n    for i in range(len(arr) - 2):\n        if arr[i] + arr[i + 1] > a:\n            for j in range(i + 1, len(arr) - 1):\n                if arr[i] + arr[j] > b and arr[j] + arr[j + 1] > c:\n                    count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "1776",
    "source": "leetcode",
    "language": "python",
    "query": "Each number from 1 to n is grouped according to the sum of its digits. You are given an integer n.",
    "snippets": [
        "def sum_of_digits(n):\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n = n // 10\n    return sum\n",
        "def sum_of_digits(n):\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum\n",
        "def sum_digits(n):\n    s = 0\n    while n > 0:\n        s += n % 10\n        n //= 10\n    return s\n",
        "def group(n):\n    groups = {}\n    for i in range(1, n+1):\n        sum = 0\n        for j in str(i):\n            sum += int(j)\n        if sum in groups:\n            groups[sum].append(i)\n        else:\n            groups[sum] = [i]\n    return groups\n",
        "def sum_digits(n):\n    s = 0\n    while n > 0:\n        s += n % 10\n        n = n // 10\n    return s\n",
        "def group(n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3]\n    if n == 4:\n        return [1, 2, 4]\n    if n == 5:\n        return [1, 5]\n    if n == 6:\n        return [1, 2, 3, 6]\n    if n == 7:\n        return [1, 7]\n    if n == 8:\n        return [1, 2, 8]\n    if n == 9:\n        return [1, 3, 9]\n    if n == 10:\n        return [1, 2, 5, 10]\n    if n == 11:\n        return [1, 11]\n    if n == 12:\n        return [1, 2, 3, 4, 12]\n    if n == 13:\n        return [1, 13]\n    if n == 14:\n        return [1, 2, 7, 14]\n    if n == 15:\n        return [1, 3, 5, 15]\n    if n == 16:\n        return [1, 2, 4, 16]\n    if n == 17:\n        return [1, 17]\n    if n == 18:\n        return [1, 2, 9, 18]\n    if n == 19:\n        return [1, 3, 7, 19]\n    if n == 20:\n        return [1, 2, 5, 10, 20]\n    if n == 21:\n        return [1, 3, 8, 21]\n    if n == 22:\n        return [1, 2, 11, 22]\n    if n == 23:\n        return [1, 3, 4, 23]\n    if n == 24:\n        return [1, 2, 6, 24]\n    if n == 25:\n        return [1, 5, 25]\n    if n == 26:\n        return [1, 2, 3, 6, 26]\n    if n == 27:\n        return [1, 3, 7, 14, 27]\n    if n ==\n"
    ],
    "results": 10
},{
    "id": "1777",
    "source": "leetcode",
    "language": "python",
    "query": "A laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. The test cases are guaranteed so that the ray will meet a receptor eventually.",
    "snippets": [
        "def main():\n    q = int(input())\n    print(q * 2)\n",
        "def main():\n    for _ in range(int(input())):\n        q, n = map(int, input().split())\n        print(q + n * (n + 1) // 2)\n",
        "def main():\n    n = int(input())\n    for i in range(n):\n        q = int(input())\n        print(q*2)\n",
        "def main():\n    q = int(input())\n    print(q * q)\n",
        "def main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        q = int(input())\n        print(n - q)\n"
    ],
    "results": 10
},{
    "id": "1778",
    "source": "leetcode",
    "language": "python",
    "query": "In English, we have a concept called root, which can be followed by some other word to form another longer word. For example, when the root \"an\" is followed by the successor word \"other\", we can form a new word \"another\"",
    "snippets": [
        "def find_root(word):\n    if word == \"\":\n        return \"\"\n    if word[0] == \"a\":\n        return \"a\"\n    if word[0] == \"b\":\n        return \"b\"\n    if word[0] == \"c\":\n        return \"c\"\n    if word[0] == \"d\":\n        return \"d\"\n    if word[0] == \"e\":\n        return \"e\"\n    if word[0] == \"f\":\n        return \"f\"\n    if word[0] == \"g\":\n        return \"g\"\n    if word[0] == \"h\":\n        return \"h\"\n    if word[0] == \"i\":\n        return \"i\"\n    if word[0] == \"j\":\n        return \"j\"\n    if word[0] == \"k\":\n        return \"k\"\n    if word[0] == \"l\":\n        return \"l\"\n    if word[0] == \"m\":\n        return \"m\"\n    if word[0] == \"n\":\n        return \"n\"\n    if word[0] == \"o\":\n        return \"o\"\n    if word[0] == \"p\":\n        return \"p\"\n    if word[0] == \"q\":\n        return \"q\"\n    if word[0] == \"r\":\n        return \"r\"\n    if word[0] == \"s\":\n        return \"s\"\n    if word[0] == \"t\":\n        return \"t\"\n    if word[0] == \"u\":\n        return \"u\"\n    if word[0] == \"v\":\n        return \"v\"\n    if word[0] == \"w\":\n        return \"w\"\n    if word[0] == \"x\":\n        return \"x\"\n    if word[0] == \"y\":\n        return \"y\"\n    if word[0] == \"z\":\n        return \"z\"\n    return \"\"\n",
        "def build_successor_table(words):\n    table = {}\n    for word in words:\n        for i in range(len(word)):\n            root = word[:i]\n            if root not in table:\n                table[root] = []\n            table[root].append(word)\n    return table\n",
        "def is_root(word):\n    return word[-1] == 's'\n",
        "def is_root(word):\n    return word[-1] == 'r'\n",
        "def is_word_in_dict(word, word_dict):\n    return word in word_dict\n"
    ],
    "results": 10
},{
    "id": "1779",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
    "snippets": [
        "def rotate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n",
        "def rotate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if k == 0:\n        return\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n",
        "def rotate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: void Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if not nums:\n        return\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n",
        "def rotate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: None Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if k == 0:\n        return nums\n    k = k % len(nums)\n    nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]\n    return nums\n",
        "def rotate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: None Do not return anything, modify nums in-place instead.\n    \"\"\"\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n",
        "def rotate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: None Do not return anything, modify nums in-place instead.\n    \"\"\"\n    if k == 0:\n        return nums\n    k = k % len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n"
    ],
    "results": 10
},{
    "id": "1780",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-' Reformat the phone number in a certain manner.",
    "snippets": [
        "def format_phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('+', '')\n    number = number.replace('.', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n    number = number.replace('$', '')\n    number = number.replace('@', '')\n    number = number.replace('!', '')\n    number = number.replace('~', '')\n    number = number.replace('`', '')\n    number = number.replace('|', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('\"', '')\n    number = number.replace('\\'', '')\n    number = number.replace('{', '')\n    number = number.replace('}', '')\n    number = number.replace('[', '')\n    number = number.replace(']', '')\n    number = number.replace('|', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('/', '')\n    number = number.replace('.', '')\n    number = number.replace(',', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('\"', '')\n",
        "def format_phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('.', '')\n    number = number.replace('+', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('#', '')\n    number = number.replace('*', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n    number = number.replace('$', '')\n    number = number.replace('!', '')\n    number = number.replace('~', '')\n    number = number.replace('`', '')\n    number = number.replace('|', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('\"', '')\n    number = number.replace('\\'', '')\n    number = number.replace('{', '')\n    number = number.replace('}', '')\n    number = number.replace('[', '')\n    number = number.replace(']', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('.', '')\n    number = number.replace('+', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('#', '')\n    number = number.replace('*', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n    number = number.replace('$', '')\n",
        "def format_phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('+', '')\n    number = number.replace('.', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('~', '')\n    number = number.replace('!', '')\n    number = number.replace('@', '')\n    number = number.replace('$', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('_', '')\n    number = number.replace('+', '')\n    number = number.replace('.', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('~', '')\n    number = number.replace('!', '')\n    number = number.replace('@', '')\n    number = number.replace('$', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('_', '')\n    number = number.replace('+', '')\n    number = number.replace('.', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('*', '')\n",
        "def format_phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('.', '')\n    number = number.replace('+', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('_', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n    number = number.replace('!', '')\n    number = number.replace('~', '')\n    number = number.replace('`', '')\n    number = number.replace('|', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('\"', '')\n    number = number.replace('\\'', '')\n    number = number.replace('{', '')\n    number = number.replace('}', '')\n    number = number.replace('[', '')\n    number = number.replace(']', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('.', '')\n    number = number.replace('+', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('_', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n",
        "def format_phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    return '({}) {}-{}'.format(number[0:3], number[3:6], number[6:])\n",
        "def format_phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('+', '')\n    number = number.replace('.', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('+', '')\n    number = number.replace('_', '')\n    number = number.replace('=', '')\n    number = number.replace('~', '')\n    number = number.replace('`', '')\n    number = number.replace('!', '')\n    number = number.replace('@', '')\n    number = number.replace('$', '')\n    number = number.replace('%', '')\n    number = number.replace('^', '')\n    number = number.replace('&', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('{', '')\n    number = number.replace('}', '')\n    number = number.replace('[', '')\n    number = number.replace(']', '')\n    number = number.replace('|', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('.', '')\n    number = number.replace('-', '')\n    number = number.replace('_', '')\n    number = number.replace('=', '')\n    number = number.replace('~', '')\n    number = number.replace('`', '')\n",
        "def format_phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('.', '')\n    number = number.replace('+', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('&', '')\n    number = number.replace('%', '')\n    number = number.replace('$', '')\n    number = number.replace('!', '')\n    number = number.replace('@', '')\n    number = number.replace('^', '')\n    number = number.replace('~', '')\n    number = number.replace('`', '')\n    number = number.replace('|', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('\"', '')\n    number = number.replace('\\'', '')\n    number = number.replace('{', '')\n    number = number.replace('}', '')\n    number = number.replace('[', '')\n    number = number.replace(']', '')\n    number = number.replace('|', '')\n    number = number.replace('.', '')\n    number = number.replace(',', '')\n    number = number.replace(';', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('?', '')\n    number = number.replace('!', '')\n    number = number.replace('@', '')\n    number = number.replace('#', '')\n    number = number.replace('$', '')\n",
        "def phone_number(number):\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    return number\n",
        "def format_phone_number(number):\n    return '({}) {}-{}'.format(number[0:3], number[3:6], number[6:])\n",
        "def format_phone_number(number):\n    # your code here\n    number = number.replace('-', '')\n    number = number.replace(' ', '')\n    number = number.replace('(', '')\n    number = number.replace(')', '')\n    number = number.replace('.', '')\n    number = number.replace('+', '')\n    number = number.replace('/', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('*', '')\n    number = number.replace('#', '')\n    number = number.replace('^', '')\n    number = number.replace('%', '')\n    number = number.replace('$', '')\n    number = number.replace('&', '')\n    number = number.replace('!', '')\n    number = number.replace('~', '')\n    number = number.replace('`', '')\n    number = number.replace('|', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('\"', '')\n    number = number.replace('\\'', '')\n    number = number.replace('{', '')\n    number = number.replace('}', '')\n    number = number.replace('[', '')\n    number = number.replace(']', '')\n    number = number.replace('|', '')\n    number = number.replace('\\\\', '')\n    number = number.replace('/', '')\n    number = number.replace('.', '')\n    number = number.replace(',', '')\n    number = number.replace(';', '')\n    number = number.replace(':', '')\n    number = number.replace('<', '')\n    number = number.replace('>', '')\n    number = number.replace('?', '')\n    number = number.replace('\"', '')\n    number = number.\n"
    ],
    "results": 10
},{
    "id": "1781",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array coins representing coins of different denominations. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "snippets": [
        "def fewest_coins(coins, amount):\n    if amount == 0:\n        return 0\n    if amount < 0:\n        return -1\n    if len(coins) == 0:\n        return -1\n    if coins[0] > amount:\n        return fewest_coins(coins[1:], amount)\n    return min(fewest_coins(coins, amount - coins[0]), 1 + fewest_coins(coins[1:], amount))\n",
        "def fewest_coins(coins, amount):\n    if amount == 0:\n        return 0\n    if amount < 0:\n        return -1\n    if len(coins) == 0:\n        return -1\n    if amount == 1:\n        return 1\n    if amount == 2:\n        return 2\n    if amount == 3:\n        return 3\n    if amount == 4:\n        return 4\n    if amount == 5:\n        return 5\n    if amount == 6:\n        return 6\n    if amount == 7:\n        return 7\n    if amount == 8:\n        return 8\n    if amount == 9:\n        return 9\n    if amount == 10:\n        return 10\n    if amount == 11:\n        return 11\n    if amount == 12:\n        return 12\n    if amount == 13:\n        return 13\n    if amount == 14:\n        return 14\n    if amount == 15:\n        return 15\n    if amount == 16:\n        return 16\n    if amount == 17:\n        return 17\n    if amount == 18:\n        return 18\n    if amount == 19:\n        return 19\n    if amount == 20:\n        return 20\n    if amount == 21:\n        return 21\n    if amount == 22:\n        return 22\n    if amount == 23:\n        return 23\n    if amount == 24:\n        return 24\n    if amount == 25:\n        return 25\n    if amount == 26:\n        return 26\n    if amount == 27:\n        return 27\n    if amount == 28:\n        return 28\n    if amount == 29:\n        return 29\n    if amount == 30:\n        return 30\n    if amount == 31:\n        return 31\n    if amount == 32:\n        return 32\n    if amount == 33:\n        return 33\n    if amount == 34:\n        return 34\n    if amount == 35:\n        return 35\n    if amount == 36:\n        return 36\n    if amount == 37:\n        return 37\n    if amount == 38:\n        return 38\n    if amount == 39:\n        return 39\n    if amount == 40:\n        return 40\n    if amount == 41:\n        return 41\n",
        "def fewest_coins(coins, amount):\n    if amount == 0:\n        return 0\n    if amount < 0:\n        return -1\n    if len(coins) == 0:\n        return -1\n    if amount in coins:\n        return 1\n    min_coins = amount + 1\n    for i in range(len(coins)):\n        if coins[i] <= amount:\n            num_coins = 1 + fewest_coins(coins, amount - coins[i])\n            if num_coins < min_coins:\n                min_coins = num_coins\n    return min_coins\n",
        "def fewest_coins(coins, amount):\n    # Write your code here.\n    if amount == 0:\n        return 0\n    if amount < 0:\n        return -1\n    if len(coins) == 0:\n        return -1\n    if amount in coins:\n        return 1\n    if amount < min(coins):\n        return -1\n    for i in range(len(coins)):\n        if coins[i] <= amount:\n            if coins[i] == amount:\n                return 1\n            else:\n                result = fewest_coins(coins[i+1:], amount - coins[i])\n                if result != -1:\n                    return result + 1\n    return -1\n"
    ],
    "results": 10
},{
    "id": "1782",
    "source": "leetcode",
    "language": "python",
    "query": "Two binary trees are considered leaf-similar if their leaf value sequence is the same. Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leafvalue sequence.",
    "snippets": [
        "def leafSimilar(root1, root2):\n    def dfs(root):\n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [root.val]\n        return dfs(root.left) + dfs(root.right)\n    return dfs(root1) == dfs(root2)\n",
        "def leafSimilar(root1, root2):\n    \"\"\"\n    :type root1: TreeNode\n    :type root2: TreeNode\n    :rtype: bool\n    \"\"\"\n    def dfs(root):\n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [root.val]\n        return dfs(root.left) + dfs(root.right)\n    return dfs(root1) == dfs(root2)\n",
        "def leafSimilar(root1, root2):\n    \"\"\"\n    :type root1: TreeNode\n    :type root2: TreeNode\n    :rtype: bool\n    \"\"\"\n    def get_leaf(root):\n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [root.val]\n        return get_leaf(root.left) + get_leaf(root.right)\n    return get_leaf(root1) == get_leaf(root2)\n",
        "def leafSimilar(root1, root2):\n    def leaf(root):\n        if not root:\n            return []\n        if not root.left and not root.right:\n            return [root.val]\n        return leaf(root.left) + leaf(root.right)\n    return leaf(root1) == leaf(root2)\n"
    ],
    "results": 10
},{
    "id": "1783",
    "source": "leetcode",
    "language": "python",
    "query": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. You are given an array of strings sentences. Each sentences[i] represents a single sentence.",
    "snippets": [
        "def split_sentence(sentence):\n    return sentence.split(' ')\n",
        "def is_valid_sentence(sentence):\n    return sentence.split() == sorted(sentence.split())\n"
    ],
    "results": 10
},{
    "id": "1784",
    "source": "leetcode",
    "language": "python",
    "query": "Return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. Return the empty string if there is no possible result.",
    "snippets": [
        "def longest_substring(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        return s[0] if s[0] > s[1] else s[1]\n    if len(s) == 3:\n        return s[0] if s[0] > s[1] else s[1] if s[1] > s[2] else s[2]\n    if len(s) == 4:\n        return s[0] if s[0] > s[1] else s[1] if s[1] > s[2] else s[2] if s[2] > s[3] else s[3]\n    if len(s) == 5:\n        return s[0] if s[0] > s[1] else s[1] if s[1] > s[2] else s[2] if s[2] > s[3] else s[3] if s[3] > s[4] else s[4]\n    if len(s) == 6:\n        return s[0] if s[0] > s[1] else s[1] if s[1] > s[2] else s[2] if s[2] > s[3] else s[3] if s[3] > s[4] else s[4] if s[4] > s[5] else s[5]\n    if len(s) == 7:\n        return s[0] if s[0] > s[1] else s[1] if s[1] > s[2] else s[2] if s[2] > s[3] else s[3] if s[3] > s[4] else s[4] if s[4] > s[5] else s[5] if s[5] > s[6] else s[6]\n    if len(s) == 8:\n        return s[0] if s[0] > s[1] else s[1] if s[1] > s[2] else s[2]\n",
        "def longest_substring(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        return s[0]\n    if len(s) == 3:\n        return s[0] + s[2]\n    if len(s) == 4:\n        return s[0] + s[3]\n    if len(s) == 5:\n        return s[0] + s[4]\n    if len(s) == 6:\n        return s[0] + s[5]\n    if len(s) == 7:\n        return s[0] + s[6]\n    if len(s) == 8:\n        return s[0] + s[7]\n    if len(s) == 9:\n        return s[0] + s[8]\n    if len(s) == 10:\n        return s[0] + s[9]\n    if len(s) == 11:\n        return s[0] + s[10]\n    if len(s) == 12:\n        return s[0] + s[11]\n    if len(s) == 13:\n        return s[0] + s[12]\n    if len(s) == 14:\n        return s[0] + s[13]\n    if len(s) == 15:\n        return s[0] + s[14]\n    if len(s) == 16:\n        return s[0] + s[15]\n    if len(s) == 17:\n        return s[0] + s[16]\n    if len(s) == 18:\n        return s[0] + s[17]\n    if len(s) == 19:\n        return s[0] + s[18]\n    if len(s) == 20:\n        return s[0] + s[19]\n    if len(s) == 21:\n        return s[0] + s[20]\n    if len(s) == 22:\n        return s[0] + s[21]\n    if len(s)\n",
        "def longest_substring(string):\n    if len(string) == 0:\n        return ''\n    if len(string) == 1:\n        return string\n    if len(string) == 2:\n        return string[0] if string[0] != string[1] else ''\n    if len(string) == 3:\n        return string[0] if string[0] != string[1] and string[0] != string[2] else ''\n    if len(string) == 4:\n        return string[0] if string[0] != string[1] and string[0] != string[2] and string[0] != string[3] else ''\n    if len(string) == 5:\n        return string[0] if string[0] != string[1] and string[0] != string[2] and string[0] != string[3] and string[0] != string[4] else ''\n    if len(string) == 6:\n        return string[0] if string[0] != string[1] and string[0] != string[2] and string[0] != string[3] and string[0] != string[4] and string[0] != string[5] else ''\n    if len(string) == 7:\n        return string[0] if string[0] != string[1] and string[0] != string[2] and string[0] != string[3] and string[0] != string[4] and string[0] != string[5] and string[0] != string[6] else ''\n    if len(string) == 8:\n        return string[0] if string[0] != string[1] and string[0] != string[2] and string[0] != string[3] and string[0] != string[4] and string[0] != string[5] and string[0] != string[6] and string[0] != string[7] else ''\n    if len(string) == 9:\n        return string[0] if string[0] != string[1] and string[0] != string[2] and string[0] != string[3] and string[0\n",
        "def longest_substring(string):\n    if len(string) == 0:\n        return ''\n    if len(string) == 1:\n        return string\n    if len(string) == 2:\n        return string[0] if string[0] != string[1] else ''\n    longest = ''\n    for i in range(len(string)):\n        for j in range(i+1, len(string)):\n            if string[i] == string[j]:\n                continue\n            substring = string[i:j+1]\n            if len(substring) > len(longest):\n                longest = substring\n    return longest\n",
        "def longest_substring(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 3:\n        if s[0] == s[1] and s[1] == s[2]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 4:\n        if s[0] == s[1] and s[1] == s[2] and s[2] == s[3]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 5:\n        if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 6:\n        if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 7:\n        if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5] and s[5] == s[6]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 8:\n        if s[0] == s[1] and s[1] == s[2] and s[2] == s[3] and s[3] == s[4] and s[4] == s[5] and s[5] == s[6] and s[6] == s[7]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 9:\n        if s[0\n",
        "def longest_substring(string):\n    if len(string) == 0:\n        return \"\"\n    if len(string) == 1:\n        return string\n    if len(string) == 2:\n        if string[0] == string[1]:\n            return \"\"\n        else:\n            return string\n    if len(string) == 3:\n        if string[0] == string[1] and string[1] == string[2]:\n            return \"\"\n        else:\n            return string\n    if len(string) == 4:\n        if string[0] == string[1] and string[1] == string[2] and string[2] == string[3]:\n            return \"\"\n        else:\n            return string\n    if len(string) == 5:\n        if string[0] == string[1] and string[1] == string[2] and string[2] == string[3] and string[3] == string[4]:\n            return \"\"\n        else:\n            return string\n    if len(string) == 6:\n        if string[0] == string[1] and string[1] == string[2] and string[2] == string[3] and string[3] == string[4] and string[4] == string[5]:\n            return \"\"\n        else:\n            return string\n    if len(string) == 7:\n        if string[0] == string[1] and string[1] == string[2] and string[2] == string[3] and string[3] == string[4] and string[4] == string[5] and string[5] == string[6]:\n            return \"\"\n        else:\n            return string\n    if len(string) == 8:\n        if string[0] == string[1] and string[1] == string[2] and string[2] == string[3] and string[3] == string[4] and string[4] == string[5] and string[5] == string[6] and string[6] == string[7]:\n            return \"\"\n        else:\n            return string\n    if len(string) == 9:\n        if string[0\n",
        "def longest_substring(s):\n    if len(s) == 0:\n        return ''\n    if len(s) == 1:\n        return s\n    max_len = 0\n    max_str = ''\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if len(set(s[i:j])) == len(s[i:j]):\n                if len(s[i:j]) > max_len:\n                    max_len = len(s[i:j])\n                    max_str = s[i:j]\n    return max_str\n",
        "def longest_substring(str):\n    if len(str) == 0:\n        return \"\"\n    if len(str) == 1:\n        return str\n    if len(str) == 2:\n        return str[0] if str[0] > str[1] else str[1]\n    if len(str) == 3:\n        return str[0] if str[0] > str[1] else str[1] if str[1] > str[2] else str[2]\n    if len(str) == 4:\n        return str[0] if str[0] > str[1] else str[1] if str[1] > str[2] else str[2] if str[2] > str[3] else str[3]\n    if len(str) == 5:\n        return str[0] if str[0] > str[1] else str[1] if str[1] > str[2] else str[2] if str[2] > str[3] else str[3] if str[3] > str[4] else str[4]\n    if len(str) == 6:\n        return str[0] if str[0] > str[1] else str[1] if str[1] > str[2] else str[2] if str[2] > str[3] else str[3] if str[3] > str[4] else str[4] if str[4] > str[5] else str[5]\n    if len(str) == 7:\n        return str[0] if str[0] > str[1] else str[1] if str[1] > str[2] else str[2] if str[2] > str[3] else str[3] if str[3] > str[4] else str[4] if str[4] > str[5] else str[5] if str[5] > str[6] else str[6]\n    if len(str) == 8:\n        return str[0] if str[0] > str[1] else str[1] if str[1] > str[2] else str[2]\n",
        "def find_longest_word(string, words):\n    words = sorted(words, key=lambda x: (-len(x), x))\n    for word in words:\n        if all(word[i] in string for i in range(len(word))):\n            return word\n    return ''\n"
    ],
    "results": 10
},{
    "id": "1785",
    "source": "leetcode",
    "language": "python",
    "query": "You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty sub-array of arr and reverse it.",
    "snippets": [
        "def reverse(arr, start, end):\n    while start < end:\n        arr[start], arr[end] = arr[end], arr[start]\n        start += 1\n        end -= 1\n    return arr\n",
        "def reverse(arr, target):\n    if len(arr) != len(target):\n        return False\n    for i in range(len(arr)):\n        if arr[i] != target[i]:\n            return False\n    return True\n",
        "def reverse(arr):\n    return arr[::-1]\n"
    ],
    "results": 10
},{
    "id": "1786",
    "source": "leetcode",
    "language": "python",
    "query": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. A node is a safe node if every possible path starting from that node leads to a terminal node.",
    "snippets": [
        "def dfs(graph, start, visited):\n    visited[start] = True\n    for i in graph[start]:\n        if not visited[i]:\n            dfs(graph, i, visited)\n"
    ],
    "results": 10
},{
    "id": "1787",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. Athletes are placed based on their scores, where the 1st place athlete has the highest score.",
    "snippets": [
        "def sort(score):\n    for i in range(len(score)):\n        for j in range(len(score) - 1):\n            if score[j] < score[j + 1]:\n                score[j], score[j + 1] = score[j + 1], score[j]\n    return score\n",
        "def solution(score):\n    answer = []\n    for i in range(len(score)):\n        if score[i] == max(score):\n            answer.append(i+1)\n    return answer\n",
        "def rank(score):\n    score.sort(reverse=True)\n    rank = [0] * len(score)\n    for i in range(len(score)):\n        rank[i] = score.index(score[i]) + 1\n    return rank\n",
        "def rank(score):\n    rank = [1]\n    for i in range(1, len(score)):\n        if score[i] > score[i-1]:\n            rank.append(rank[i-1]+1)\n        else:\n            rank.append(rank[i-1])\n    return rank\n",
        "def rank(score):\n    rank = [1] * len(score)\n    for i in range(1, len(score)):\n        if score[i] > score[i-1]:\n            rank[i] = rank[i-1] + 1\n    return rank\n",
        "def solution(score):\n    answer = 0\n    for i in range(len(score)):\n        if score[i] == max(score):\n            answer += 1\n    return answer\n",
        "def get_score(score):\n    score.sort(reverse=True)\n    return score\n"
    ],
    "results": 10
},{
    "id": "1788",
    "source": "leetcode",
    "language": "python",
    "query": "Given three integers n, k, and target, return the number of possible ways to roll the dice so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "def numRollsToTarget(n, k, target):\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for t in range(target + 1):\n                if t >= j:\n                    dp[i][t] += dp[i - 1][t - j]\n                dp[i][t] %= 1000000007\n    return dp[n][target]\n",
        "def numRollsToTarget(n, k, target):\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            for x in range(1, k + 1):\n                if j - x >= 0:\n                    dp[i][j] += dp[i - 1][j - x]\n            dp[i][j] %= 1000000007\n    return dp[n][target]\n",
        "def numRollsToTarget(n, k, target):\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for x in range(j, target + 1):\n                dp[i][x] += dp[i - 1][x - j]\n    return dp[n][target] % (10 ** 9 + 7)\n",
        "def numRollsToTarget(n, k, target):\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for x in range(target + 1):\n                if x >= j:\n                    dp[i][x] += dp[i - 1][x - j]\n                dp[i][x] %= 1000000007\n    return dp[n][target]\n",
        "def numRollsToTarget(n, k, target):\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            for t in range(target + 1):\n                if t >= j:\n                    dp[i][t] += dp[i - 1][t - j]\n                dp[i][t] %= 1000000007\n    return dp[n][target]\n",
        "def numRollsToTarget(n, k, target):\n    dp = [[0 for i in range(target+1)] for j in range(n+1)]\n    for i in range(1, n+1):\n        for j in range(1, k+1):\n            for x in range(1, target+1):\n                if x >= j:\n                    dp[i][x] += dp[i-1][x-j]\n                else:\n                    dp[i][x] += dp[i-1][x]\n    return dp[n][target] % (10**9 + 7)\n"
    ],
    "results": 10
},{
    "id": "1789",
    "source": "leetcode",
    "language": "python",
    "query": "24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23. The earliest 24-hour time is 00:00, and the latest is 23:59.",
    "snippets": [
        "def time_to_minutes(time):\n    hours, minutes = time.split(':')\n    return int(hours) * 60 + int(minutes)\n",
        "def valid_time(time):\n    return (0 <= int(time[:2]) <= 23) and (0 <= int(time[3:]) <= 59)\n",
        "def is_valid_time(time):\n    if time[0] == '0' and len(time) == 2:\n        return True\n    elif time[0] == '0' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '1' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '2' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '3' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '4' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '5' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '6' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '7' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '8' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    elif time[0] == '9' and len(time) == 3:\n        if time[1] == ':':\n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def is_valid_time(time):\n    if time[0] == '0':\n        if time[1] == ':':\n            if time[2] == '0':\n                if time[3] == '0':\n                    return True\n    return False\n",
        "def is_valid_time(time):\n    return time.split(':')[0] in range(24) and time.split(':')[1] in range(60)\n",
        "def is_valid_time(time):\n    if time[:2] in range(24) and time[3:] in range(60):\n        return True\n    else:\n        return False\n",
        "def valid_time(time):\n    if time[0] == '0':\n        time = time[1:]\n    if time[0] == '2':\n        if time[1] == '4':\n            if time[2] == ':':\n                if time[3] == '0':\n                    if time[4] == '0':\n                        return True\n                    else:\n                        return False\n                else:\n                    return False\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n",
        "def is_valid_time(time):\n    if time[0] == '0':\n        time = time[1:]\n    if time[0] == '2':\n        if time[1] == '0':\n            if time[2] == '0':\n                if time[3] == '0':\n                    return True\n                else:\n                    return False\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n"
    ],
    "results": 8
},{
    "id": "1790",
    "source": "leetcode",
    "language": "python",
    "query": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color.",
    "snippets": [
        "def paint(image, sr, sc, color):\n    if sr < 0 or sr >= len(image) or sc < 0 or sc >= len(image[0]):\n        return image\n    if image[sr][sc] == color:\n        return image\n    image[sr][sc] = color\n    paint(image, sr + 1, sc, color)\n    paint(image, sr - 1, sc, color)\n    paint(image, sr, sc + 1, color)\n    paint(image, sr, sc - 1, color)\n    return image\n",
        "def update_image(image, sr, sc, new_color):\n    m, n = len(image), len(image[0])\n    old_color = image[sr][sc]\n    for i in range(m):\n        for j in range(n):\n            if image[i][j] == old_color:\n                image[i][j] = new_color\n    return image\n",
        "def newImage(image, sr, sc, newColor):\n    m = len(image)\n    n = len(image[0])\n    oldColor = image[sr][sc]\n    if oldColor == newColor:\n        return image\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or image[i][j] != oldColor:\n            return\n        image[i][j] = newColor\n        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n        dfs(i, j + 1)\n    dfs(sr, sc)\n    return image\n",
        "def image_change(image, sr, sc, new_color):\n    old_color = image[sr][sc]\n    if old_color == new_color:\n        return image\n    image[sr][sc] = new_color\n    if sr > 0:\n        image = image_change(image, sr - 1, sc, new_color)\n    if sr < len(image) - 1:\n        image = image_change(image, sr + 1, sc, new_color)\n    if sc > 0:\n        image = image_change(image, sr, sc - 1, new_color)\n    if sc < len(image[0]) - 1:\n        image = image_change(image, sr, sc + 1, new_color)\n    return image\n",
        "def newGrid(m, n, sr, sc, color):\n    grid = [[0 for x in range(n)] for y in range(m)]\n    grid[sr][sc] = color\n    return grid\n",
        "def update_image(image, sr, sc, color):\n    image[sr][sc] = color\n    return image\n",
        "def set_color(image, sr, sc, color):\n    image[sr][sc] = color\n    return image\n",
        "def flip_color(image, sr, sc, new_color):\n    # Fill this in.\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == sr and image[i][j] == sc:\n                image[i][j] = new_color\n    return image\n"
    ],
    "results": 10
},{
    "id": "1791",
    "source": "leetcode",
    "language": "python",
    "query": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by somenumber of 1's (also possibly none) You can flip s[i] changing it from 0 to 1 or from 1 to 0.",
    "snippets": [
        "def isMonotone(s):\n    if s == '':\n        return True\n    if s[0] == '0':\n        return isMonotone(s[1:])\n    if s[0] == '1':\n        return isMonotone(s[1:]) and s[1] == '0'\n    return False\n",
        "def isMonotone(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return s[0] == '0'\n    if s[0] == '0':\n        return isMonotone(s[1:])\n    else:\n        return isMonotone(s[1:]) and s[0] == s[1]\n",
        "def isMonotone(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return s[0] == '0'\n    if s[0] == '0':\n        return isMonotone(s[1:])\n    if s[0] == '1':\n        return isMonotone(s[1:]) and s[1] == '0'\n    return False\n",
        "def isMonotone(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return s[0] == 1\n    if s[0] == 1:\n        return isMonotone(s[1:])\n    else:\n        return False\n",
        "def isMonotone(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return s[0] == '0'\n    if s[0] == '0':\n        return isMonotone(s[1:])\n    else:\n        return isMonotone(s[1:]) and s[0] == '1'\n",
        "def is_monotone(s):\n    if s == '':\n        return True\n    if s[0] == '0':\n        return is_monotone(s[1:])\n    if s[0] == '1':\n        return is_monotone(s[1:]) and s[1] != '0'\n    return False\n",
        "def isMonotone(s):\n    if s == '':\n        return True\n    if s[0] == '0':\n        return isMonotone(s[1:])\n    else:\n        return isMonotone(s[1:]) and s[0] == '1'\n",
        "def isMonotone(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return s[0] == 1\n    if s[0] == 0:\n        return isMonotone(s[1:])\n    else:\n        return isMonotone(s[1:]) and s[0] == 1\n",
        "def isMonotoneIncreasing(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return True\n    if s[0] == '1':\n        return False\n    if s[0] == '0':\n        return isMonotoneIncreasing(s[1:])\n    if s[0] == '1' and s[1] == '0':\n        return isMonotoneIncreasing(s[2:])\n    return False\n"
    ],
    "results": 10
},{
    "id": "1792",
    "source": "leetcode",
    "language": "python",
    "query": "Given two positive integers n and k, the binary string Sn is formed as follows. It is guaranteed that k is valid for the given n.",
    "snippets": [
        "def Sn(n, k):\n    if n == 0:\n        return '0'\n    if n == 1:\n        return '1'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '11'\n    if n == 4:\n        return '100'\n    if n == 5:\n        return '101'\n    if n == 6:\n        return '110'\n    if n == 7:\n        return '111'\n    if n == 8:\n        return '1000'\n    if n == 9:\n        return '1001'\n    if n == 10:\n        return '1010'\n    if n == 11:\n        return '1011'\n    if n == 12:\n        return '1100'\n    if n == 13:\n        return '1101'\n    if n == 14:\n        return '1110'\n    if n == 15:\n        return '1111'\n    if n == 16:\n        return '10000'\n    if n == 17:\n        return '10001'\n    if n == 18:\n        return '10010'\n    if n == 19:\n        return '10011'\n    if n == 20:\n        return '10100'\n    if n == 21:\n        return '10101'\n    if n == 22:\n        return '10110'\n    if n == 23:\n        return '10111'\n    if n == 24:\n        return '11000'\n    if n == 25:\n        return '11001'\n    if n == 26:\n        return '11010'\n    if n == 27:\n        return '11011'\n    if n == 28:\n        return '11100'\n    if n == 29:\n        return '11101'\n    if n == 30:\n        return '11110'\n    if n == 31:\n        return '11111'\n    if n == 32:\n        return '100000'\n    if n == 33:\n        return '100001'\n    if n == 34:\n        return '100010'\n    if n == 35:\n        return '100011'\n",
        "def Sn(n, k):\n    if n == 1:\n        return '1'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '11'\n    if n == 4:\n        return '100'\n    if n == 5:\n        return '101'\n    if n == 6:\n        return '110'\n    if n == 7:\n        return '111'\n    if n == 8:\n        return '1000'\n    if n == 9:\n        return '1001'\n    if n == 10:\n        return '1010'\n    if n == 11:\n        return '1011'\n    if n == 12:\n        return '1100'\n    if n == 13:\n        return '1101'\n    if n == 14:\n        return '1110'\n    if n == 15:\n        return '1111'\n    if n == 16:\n        return '10000'\n    if n == 17:\n        return '10001'\n    if n == 18:\n        return '10010'\n    if n == 19:\n        return '10011'\n    if n == 20:\n        return '10100'\n    if n == 21:\n        return '10101'\n    if n == 22:\n        return '10110'\n    if n == 23:\n        return '10111'\n    if n == 24:\n        return '11000'\n    if n == 25:\n        return '11001'\n    if n == 26:\n        return '11010'\n    if n == 27:\n        return '11011'\n    if n == 28:\n        return '11100'\n    if n == 29:\n        return '11101'\n    if n == 30:\n        return '11110'\n    if n == 31:\n        return '11111'\n    if n == 32:\n        return '100000'\n    if n == 33:\n        return '100001'\n    if n == 34:\n        return '100010'\n    if n == 35:\n        return '100011'\n    if n == 36:\n        return '100100'\n",
        "def Sn(n, k):\n    if n == 0:\n        return '0'\n    if n == 1:\n        return '1'\n    if k == 0:\n        return '0'\n    if k == 1:\n        return '1'\n    if k == 2:\n        return '10'\n    if k == 3:\n        return '11'\n    if k == 4:\n        return '100'\n    if k == 5:\n        return '101'\n    if k == 6:\n        return '110'\n    if k == 7:\n        return '111'\n    if k == 8:\n        return '1000'\n    if k == 9:\n        return '1001'\n    if k == 10:\n        return '1010'\n    if k == 11:\n        return '1011'\n    if k == 12:\n        return '1100'\n    if k == 13:\n        return '1101'\n    if k == 14:\n        return '1110'\n    if k == 15:\n        return '1111'\n    if k == 16:\n        return '10000'\n    if k == 17:\n        return '10001'\n    if k == 18:\n        return '10010'\n    if k == 19:\n        return '10011'\n    if k == 20:\n        return '10100'\n    if k == 21:\n        return '10101'\n    if k == 22:\n        return '10110'\n    if k == 23:\n        return '10111'\n    if k == 24:\n        return '11000'\n    if k == 25:\n        return '11001'\n    if k == 26:\n        return '11010'\n    if k == 27:\n        return '11011'\n    if k == 28:\n        return '11100'\n    if k == 29:\n        return '11101'\n    if k == 30:\n        return '11110'\n    if k == 31:\n        return '11111'\n    if k == 32:\n        return '100000'\n    if k == 33:\n        return '100001'\n    if k\n",
        "def Sn(n, k):\n    if n == 1:\n        return '0'\n    if k == 1:\n        return '1'\n    if k == 2:\n        return '10'\n    if k == 3:\n        return '11'\n    if k == 4:\n        return '100'\n    if k == 5:\n        return '101'\n    if k == 6:\n        return '110'\n    if k == 7:\n        return '111'\n    if k == 8:\n        return '1000'\n    if k == 9:\n        return '1001'\n    if k == 10:\n        return '1010'\n    if k == 11:\n        return '1011'\n    if k == 12:\n        return '1100'\n    if k == 13:\n        return '1101'\n    if k == 14:\n        return '1110'\n    if k == 15:\n        return '1111'\n    if k == 16:\n        return '10000'\n    if k == 17:\n        return '10001'\n    if k == 18:\n        return '10010'\n    if k == 19:\n        return '10011'\n    if k == 20:\n        return '10100'\n    if k == 21:\n        return '10101'\n    if k == 22:\n        return '10110'\n    if k == 23:\n        return '10111'\n    if k == 24:\n        return '11000'\n    if k == 25:\n        return '11001'\n    if k == 26:\n        return '11010'\n    if k == 27:\n        return '11011'\n    if k == 28:\n        return '11100'\n    if k == 29:\n        return '11101'\n    if k == 30:\n        return '11110'\n    if k == 31:\n        return '11111'\n    if k == 32:\n        return '100000'\n    if k == 33:\n        return '100001'\n    if k == 34:\n        return '100010'\n    if k == 35:\n        return '100011'\n",
        "def Sn(n, k):\n    if n == 1:\n        return '0'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '110'\n    if n == 4:\n        return '1110'\n    if n == 5:\n        return '11110'\n    if n == 6:\n        return '111110'\n    if n == 7:\n        return '1111110'\n    if n == 8:\n        return '11111110'\n    if n == 9:\n        return '111111110'\n    if n == 10:\n        return '1111111110'\n    if n == 11:\n        return '11111111110'\n    if n == 12:\n        return '111111111110'\n    if n == 13:\n        return '1111111111110'\n    if n == 14:\n        return '11111111111110'\n    if n == 15:\n        return '111111111111110'\n    if n == 16:\n        return '1111111111111110'\n    if n == 17:\n        return '11111111111111110'\n    if n == 18:\n        return '111111111111111110'\n    if n == 19:\n        return '1111111111111111110'\n    if n == 20:\n        return '11111111111111111110'\n    if n == 21:\n        return '111111111111111111110'\n    if n == 22:\n        return '1111111111111111111110'\n    if n == 23:\n        return '11111111111111111111110'\n    if n == 24:\n        return '111111111111111111111110'\n    if n == 25:\n        return '1111111111111111111111110'\n    if n == 26:\n        return '11111111111111111111111110'\n    if n == 27:\n        return '111111111111111111111111110'\n    if n == 28:\n        return '1111111111111111111111111110'\n    if n == 29:\n        return '11111111111111111111111111110'\n    if n == 30:\n        return '111111111111111111111111\n",
        "def Sn(n, k):\n    if n == 1:\n        return '0'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '11'\n    if n == 4:\n        return '100'\n    if n == 5:\n        return '101'\n    if n == 6:\n        return '110'\n    if n == 7:\n        return '111'\n    if n == 8:\n        return '1000'\n    if n == 9:\n        return '1001'\n    if n == 10:\n        return '1010'\n    if n == 11:\n        return '1011'\n    if n == 12:\n        return '1100'\n    if n == 13:\n        return '1101'\n    if n == 14:\n        return '1110'\n    if n == 15:\n        return '1111'\n    if n == 16:\n        return '10000'\n    if n == 17:\n        return '10001'\n    if n == 18:\n        return '10010'\n    if n == 19:\n        return '10011'\n    if n == 20:\n        return '10100'\n    if n == 21:\n        return '10101'\n    if n == 22:\n        return '10110'\n    if n == 23:\n        return '10111'\n    if n == 24:\n        return '11000'\n    if n == 25:\n        return '11001'\n    if n == 26:\n        return '11010'\n    if n == 27:\n        return '11011'\n    if n == 28:\n        return '11100'\n    if n == 29:\n        return '11101'\n    if n == 30:\n        return '11110'\n    if n == 31:\n        return '11111'\n    if n == 32:\n        return '100000'\n    if n == 33:\n        return '100001'\n    if n == 34:\n        return '100010'\n    if n == 35:\n        return '100011'\n    if n == 36:\n        return '100100'\n",
        "def binary_string(n, k):\n    if n == 0:\n        return '0'\n    if n == 1:\n        return '1'\n    if n == 2:\n        return '10'\n    if n == 3:\n        return '11'\n    if n == 4:\n        return '100'\n    if n == 5:\n        return '101'\n    if n == 6:\n        return '110'\n    if n == 7:\n        return '111'\n    if n == 8:\n        return '1000'\n    if n == 9:\n        return '1001'\n    if n == 10:\n        return '1010'\n    if n == 11:\n        return '1011'\n    if n == 12:\n        return '1100'\n    if n == 13:\n        return '1101'\n    if n == 14:\n        return '1110'\n    if n == 15:\n        return '1111'\n    if n == 16:\n        return '10000'\n    if n == 17:\n        return '10001'\n    if n == 18:\n        return '10010'\n    if n == 19:\n        return '10011'\n    if n == 20:\n        return '10100'\n    if n == 21:\n        return '10101'\n    if n == 22:\n        return '10110'\n    if n == 23:\n        return '10111'\n    if n == 24:\n        return '11000'\n    if n == 25:\n        return '11001'\n    if n == 26:\n        return '11010'\n    if n == 27:\n        return '11011'\n    if n == 28:\n        return '11100'\n    if n == 29:\n        return '11101'\n    if n == 30:\n        return '11110'\n    if n == 31:\n        return '11111'\n    if n == 32:\n        return '100000'\n    if n == 33:\n        return '100001'\n    if n == 34:\n        return '100010'\n    if n == 35:\n        return '100011'\n",
        "def binary_string(n, k):\n    return ''.join(['1' if i < k else '0' for i in range(n)])\n"
    ],
    "results": 10
},{
    "id": "1793",
    "source": "leetcode",
    "language": "python",
    "query": "Given an m x n matrix, return all elements of the matrix in spiral order.",
    "snippets": [
        "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    res = []\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, 0\n    while i < m and j < n:\n        for j in range(j, n):\n            res.append(matrix[i][j])\n        for i in range(i + 1, m):\n            res.append(matrix[i][j])\n        for j in range(j - 1, j - n - 1, -1):\n            res.append(matrix[i][j])\n        for i in range(i - 1, i - m - 1, -1):\n            res.append(matrix[i][j])\n        j += 1\n        i += 1\n    return res\n",
        "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    res = []\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, 0\n    while i < m and j < n:\n        for j in range(j, n):\n            res.append(matrix[i][j])\n        for i in range(i + 1, m):\n            res.append(matrix[i][j])\n        for j in range(j - 1, j - n, -1):\n            res.append(matrix[i][j])\n        for i in range(i - 1, i - m, -1):\n            res.append(matrix[i][j])\n        i, j = i + 1, j + 1\n    return res\n",
        "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    res = []\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, 0\n    while i < m and j < n:\n        for j in range(j, n):\n            res.append(matrix[i][j])\n        for i in range(i + 1, m):\n            res.append(matrix[i][n - 1])\n        for j in range(n - 2, j - 1, -1):\n            res.append(matrix[m - 1][j])\n        for i in range(m - 2, i, -1):\n            res.append(matrix[i][j - 1])\n        i, j = i + 1, j + 1\n    return res\n",
        "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    res = []\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, 0\n    while i < m and j < n:\n        for j in range(j, n):\n            res.append(matrix[i][j])\n        for i in range(i + 1, m):\n            res.append(matrix[i][j])\n        for j in range(j - 1, j - n - 1, -1):\n            res.append(matrix[i][j])\n        for i in range(i - 1, i - m - 1, -1):\n            res.append(matrix[i][j])\n        i, j = i + 1, j + 1\n    return res\n",
        "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    res = []\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, 0\n    while i < m and j < n:\n        for k in range(j, n):\n            res.append(matrix[i][k])\n        for k in range(i + 1, m):\n            res.append(matrix[k][n - 1])\n        for k in range(n - 2, j - 1, -1):\n            if i < m - 1:\n                res.append(matrix[m - 1][k])\n        for k in range(m - 2, i, -1):\n            if j < n - 1:\n                res.append(matrix[k][j])\n        i, j = i + 1, j + 1\n    return res\n",
        "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    res = []\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, 0\n    while i < m and j < n:\n        for j in range(j, n):\n            res.append(matrix[i][j])\n        for i in range(i + 1, m):\n            res.append(matrix[i][j])\n        for j in range(j - 1, -1, -1):\n            res.append(matrix[i][j])\n        for i in range(i - 1, -1, -1):\n            res.append(matrix[i][j])\n        i, j = i + 1, j + 1\n    return res\n",
        "def spiralOrder(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    m, n = len(matrix), len(matrix[0])\n    res = []\n    i, j = 0, 0\n    while i < m and j < n:\n        for j in range(j, n):\n            res.append(matrix[i][j])\n        for i in range(i + 1, m):\n            res.append(matrix[i][j])\n        for j in range(j - 1, j - 1 + n - i - 1, -1):\n            res.append(matrix[i][j])\n        for i in range(i - 1, i - 1 - m + i + 1, -1):\n            res.append(matrix[i][j])\n        i, j = i + 1, j + 1\n    return res\n",
        "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    result = []\n    m, n = len(matrix), len(matrix[0])\n    i, j = 0, 0\n    while i < m and j < n:\n        for j in range(j, n):\n            result.append(matrix[i][j])\n        for i in range(i + 1, m):\n            result.append(matrix[i][n - 1])\n        for j in range(n - 2, j - 1, -1):\n            result.append(matrix[m - 1][j])\n        for i in range(m - 2, i, -1):\n            result.append(matrix[i][j])\n        i, j = i + 1, j + 1\n    return result\n",
        "def spiral_order(matrix):\n    if not matrix:\n        return []\n    result = []\n    row_start, row_end = 0, len(matrix) - 1\n    col_start, col_end = 0, len(matrix[0]) - 1\n    while row_start <= row_end and col_start <= col_end:\n        for i in range(col_start, col_end + 1):\n            result.append(matrix[row_start][i])\n        row_start += 1\n        for i in range(row_start, row_end + 1):\n            result.append(matrix[i][col_end])\n        col_end -= 1\n        if row_start <= row_end:\n            for i in range(col_end, col_start - 1, -1):\n                result.append(matrix[row_end][i])\n        row_end -= 1\n        if col_start <= col_end:\n            for i in range(row_end, row_start - 1, -1):\n                result.append(matrix[i][col_start])\n        col_start += 1\n    return result\n"
    ],
    "results": 10
},{
    "id": "1794",
    "source": "leetcode",
    "language": "python",
    "query": "Formally, a Fibonacci-like sequence is a list f of non-negative integers. Each integer fits in a 32-bit signed integer type. Each piece must not have extra leading zeroes.",
    "snippets": [
        "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n",
        "def fibonacci_like(f):\n    if len(f) == 0:\n        return True\n    if len(f) == 1:\n        return True\n    if len(f) == 2:\n        return f[0] == 0 or f[1] == 0 or f[0] + f[1] == f[1]\n    if f[0] == 0 or f[1] == 0 or f[0] + f[1] == f[1]:\n        return False\n    for i in range(2, len(f)):\n        if f[i] == 0 or f[i] + f[i-1] == f[i-1]:\n            return False\n    return True\n",
        "def fibonacci_like(f):\n    if len(f) == 0:\n        return True\n    if len(f) == 1:\n        return True\n    if len(f) == 2:\n        return True\n    if len(f) == 3:\n        return True\n    if len(f) == 4:\n        return True\n    if len(f) == 5:\n        return True\n    if len(f) == 6:\n        return True\n    if len(f) == 7:\n        return True\n    if len(f) == 8:\n        return True\n    if len(f) == 9:\n        return True\n    if len(f) == 10:\n        return True\n    if len(f) == 11:\n        return True\n    if len(f) == 12:\n        return True\n    if len(f) == 13:\n        return True\n    if len(f) == 14:\n        return True\n    if len(f) == 15:\n        return True\n    if len(f) == 16:\n        return True\n    if len(f) == 17:\n        return True\n    if len(f) == 18:\n        return True\n    if len(f) == 19:\n        return True\n    if len(f) == 20:\n        return True\n    if len(f) == 21:\n        return True\n    if len(f) == 22:\n        return True\n    if len(f) == 23:\n        return True\n    if len(f) == 24:\n        return True\n    if len(f) == 25:\n        return True\n    if len(f) == 26:\n        return True\n    if len(f) == 27:\n        return True\n    if len(f) == 28:\n        return True\n    if len(f) == 29:\n        return True\n    if len(f) == 30:\n        return True\n    if len(f) == 31:\n        return True\n    if len(f) == 32:\n        return True\n    if len(f) == 33:\n        return True\n    if len(f) == 34:\n        return True\n",
        "def fibonacci_like(f):\n    if len(f) == 0:\n        return True\n    if len(f) == 1:\n        return True\n    if len(f) == 2:\n        return True\n    if f[0] == 0:\n        return False\n    if f[1] == 0:\n        return False\n    if f[2] == 0:\n        return False\n    if f[0] > 2**31-1:\n        return False\n    if f[1] > 2**31-1:\n        return False\n    if f[2] > 2**31-1:\n        return False\n    if f[0] + f[1] > 2**31-1:\n        return False\n    if f[1] + f[2] > 2**31-1:\n        return False\n    if f[2] + f[3] > 2**31-1:\n        return False\n    return True\n",
        "def fibonacci_like_sequence(f):\n    if len(f) == 0:\n        return True\n    if len(f) == 1:\n        return True\n    if len(f) == 2:\n        return f[0] == 0 or f[1] == 0 or f[0] + f[1] == f[1]\n    if f[0] == 0 or f[1] == 0 or f[0] + f[1] == f[1]:\n        return False\n    for i in range(2, len(f)):\n        if f[i] == 0 or f[i] + f[i-1] == f[i-1]:\n            return False\n    return True\n",
        "def fibonacci_like_sequence(f):\n    return all(map(lambda x: x >= 0, f)) and all(map(lambda x: len(str(x)) == len(str(int(x))), f))\n",
        "def fibonacci_like(f):\n    return True if len(f) == 0 else (f[0] == 0 or (f[0] == 1 and len(f) == 1) or (f[0] == 2 and len(f) == 2) or (f[0] == 3 and len(f) == 3) or (f[0] == 4 and len(f) == 4) or (f[0] == 5 and len(f) == 5) or (f[0] == 6 and len(f) == 6) or (f[0] == 7 and len(f) == 7) or (f[0] == 8 and len(f) == 8) or (f[0] == 9 and len(f) == 9) or (f[0] == 10 and len(f) == 10) or (f[0] == 11 and len(f) == 11) or (f[0] == 12 and len(f) == 12) or (f[0] == 13 and len(f) == 13) or (f[0] == 14 and len(f) == 14) or (f[0] == 15 and len(f) == 15) or (f[0] == 16 and len(f) == 16) or (f[0] == 17 and len(f) == 17) or (f[0] == 18 and len(f) == 18) or (f[0] == 19 and len(f) == 19) or (f[0] == 20 and len(f) == 20) or (f[0] == 21 and len(f) == 21) or (f[0] == 22 and len(f) == 22) or (f[0] == 23 and len(f) == 23) or (f[0] == 24 and len(f) == 24) or (f[0] == 25 and len(f) == 25) or (f[0] == 26 and len(f) == 26) or (f[0] == 27 and len(f) == 27) or (f[0] == 28 and len(f) == 28) or (f[0] == 29 and len(f) == 29) or (f[0] == 30\n",
        "def fibonacci_like(f):\n    return all(map(lambda x: x == 0 or x == 1 or x == 2 or x == 3 or x == 5 or x == 8 or x == 13 or x == 21 or x == 34 or x == 55 or x == 89 or x == 144 or x == 233 or x == 377 or x == 610 or x == 987 or x == 1597 or x == 2584 or x == 4181 or x == 6765, f))\n",
        "def fibonacci_like_sequence(f):\n    return all(f[i] == f[i+1] for i in range(len(f)-1))\n"
    ],
    "results": 10
},{
    "id": "1795",
    "source": "leetcode",
    "language": "python",
    "query": "The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space.",
    "snippets": [
        "def solve(n):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3, 2]\n    if n == 4:\n        return [1, 4, 3, 2]\n    if n == 5:\n        return [1, 5, 4, 3, 2]\n    if n == 6:\n        return [1, 6, 5, 4, 3, 2]\n    if n == 7:\n        return [1, 7, 6, 5, 4, 3, 2]\n    if n == 8:\n        return [1, 8, 7, 6, 5, 4, 3, 2]\n    if n == 9:\n        return [1, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 10:\n        return [1, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 11:\n        return [1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 12:\n        return [1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 13:\n        return [1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 14:\n        return [1, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 15:\n        return [1, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 16:\n        return [1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 17:\n        return [1, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n",
        "def solve(n, k):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3, 2]\n    if n == 4:\n        return [1, 4, 3, 2]\n    if n == 5:\n        return [1, 5, 4, 3, 2]\n    if n == 6:\n        return [1, 6, 5, 4, 3, 2]\n    if n == 7:\n        return [1, 7, 6, 5, 4, 3, 2]\n    if n == 8:\n        return [1, 8, 7, 6, 5, 4, 3, 2]\n    if n == 9:\n        return [1, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 10:\n        return [1, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 11:\n        return [1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 12:\n        return [1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 13:\n        return [1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 14:\n        return [1, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 15:\n        return [1, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 16:\n        return [1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 17:\n        return [1, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n",
        "def solve(n, m, k):\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 3, 2]\n    if n == 4:\n        return [1, 4, 3, 2]\n    if n == 5:\n        return [1, 5, 4, 3, 2]\n    if n == 6:\n        return [1, 6, 5, 4, 3, 2]\n    if n == 7:\n        return [1, 7, 6, 5, 4, 3, 2]\n    if n == 8:\n        return [1, 8, 7, 6, 5, 4, 3, 2]\n    if n == 9:\n        return [1, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 10:\n        return [1, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 11:\n        return [1, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 12:\n        return [1, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 13:\n        return [1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 14:\n        return [1, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 15:\n        return [1, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 16:\n        return [1, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]\n    if n == 17:\n        return [1, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3,\n",
        "def solve(n, m, k, a, b):\n    if k == 0:\n        return []\n    if n == 1:\n        return [a[0]]\n    if m == 1:\n        return [b[0]]\n    if n == 2:\n        return [a[0], a[1]]\n    if m == 2:\n        return [b[0], b[1]]\n    if n == 3:\n        return [a[0], a[1], a[2]]\n    if m == 3:\n        return [b[0], b[1], b[2]]\n    if n == 4:\n        return [a[0], a[1], a[2], a[3]]\n    if m == 4:\n        return [b[0], b[1], b[2], b[3]]\n    if n == 5:\n        return [a[0], a[1], a[2], a[3], a[4]]\n    if m == 5:\n        return [b[0], b[1], b[2], b[3], b[4]]\n    if n == 6:\n        return [a[0], a[1], a[2], a[3], a[4], a[5]]\n    if m == 6:\n        return [b[0], b[1], b[2], b[3], b[4], b[5]]\n    if n == 7:\n        return [a[0], a[1], a[2], a[3], a[4], a[5], a[6]]\n    if m == 7:\n        return [b[0], b[1], b[2], b[3], b[4], b[5], b[6]]\n    if n == 8:\n        return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]]\n    if m == 8:\n        return [b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]]\n    if n == 9:\n        return [a\n",
        "def solve(n, a):\n    a.sort()\n    return a[n-1]\n"
    ],
    "results": 10
},{
    "id": "1796",
    "source": "leetcode",
    "language": "python",
    "query": "There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.",
    "snippets": [
        "def numWaterBottles(numBottles, numExchange):\n    if numBottles == 0:\n        return 0\n    elif numBottles == 1:\n        return 1\n    else:\n        return numWaterBottles(numBottles - 1, numExchange) + numExchange\n",
        "def numWaterBottles(numBottles, numExchange):\n    if numBottles == 0:\n        return 0\n    if numBottles % numExchange == 0:\n        return numBottles // numExchange\n    else:\n        return numBottles // numExchange + 1\n",
        "def exchange(numBottles, numExchange):\n    if numBottles == 0:\n        return 0\n    elif numBottles == 1:\n        return 1\n    else:\n        return exchange(numBottles - 1, numExchange) + numExchange\n",
        "def exchangeBottles(numBottles, numExchange):\n    if numBottles == 0:\n        return 0\n    elif numBottles == 1:\n        return 1\n    else:\n        return exchangeBottles(numBottles - 1, numExchange) + numExchange\n",
        "def numWaterBottles(numBottles, numExchange):\n    if numBottles == 0:\n        return 0\n    elif numBottles == 1:\n        return 1\n    else:\n        return 1 + numWaterBottles(numBottles - numExchange, numExchange)\n",
        "def numWaterBottles(numBottles, numExchange):\n    if numBottles == 0:\n        return 0\n    else:\n        return numBottles + numWaterBottles(numBottles - numExchange, numExchange)\n",
        "def exchangeWater(numBottles, numExchange):\n    if numBottles < numExchange:\n        return numBottles\n    else:\n        return numBottles - numExchange + exchangeWater(numBottles - numExchange, numExchange)\n"
    ],
    "results": 10
},{
    "id": "1797",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s, return true if every 'a' appears before every 'b' in the string. Otherwise, return false.",
    "snippets": [
        "def ab(s):\n    if s.count('a') == 0:\n        return True\n    if s.count('b') == 0:\n        return True\n    if s.count('a') == s.count('b'):\n        return True\n    if s.count('a') > s.count('b'):\n        return False\n    if s.count('a') < s.count('b'):\n        return False\n    if s.count('a') == s.count('b') and s.count('a') != 0 and s.count('b') != 0:\n        return False\n    return True\n",
        "def ab(s):\n    if s.count('a') == 0:\n        return True\n    if s.count('b') == 0:\n        return True\n    if s.count('a') == s.count('b'):\n        return True\n    return False\n",
        "def ab(s):\n    if s.count('a') == 0 or s.count('b') == 0:\n        return True\n    if s.count('a') != s.count('b'):\n        return False\n    if s.count('a') == s.count('b'):\n        return True\n    return False\n",
        "def ab(s):\n    if s == \"\":\n        return True\n    if s[0] == \"b\":\n        return False\n    if s[0] == \"a\":\n        return ab(s[1:])\n    return False\n",
        "def ab(s):\n    if s.count('a') == 0 or s.count('b') == 0:\n        return True\n    if s.count('a') > s.count('b'):\n        return False\n    if s.count('a') == s.count('b'):\n        return True\n    for i in range(len(s)):\n        if s[i] == 'a':\n            if s[i+1] == 'b':\n                return False\n    return True\n",
        "def ab(s):\n    if s.count('a') == s.count('b'):\n        return True\n    else:\n        return False\n",
        "def ab_check(s):\n    if s.count('a') == 0 or s.count('b') == 0:\n        return True\n    if s.count('a') > s.count('b'):\n        return False\n    else:\n        return True\n",
        "def ab_check(x):\n    if x.count('a') == x.count('b'):\n        return True\n    else:\n        return False\n",
        "def ab_check(s):\n    if s.count('a') == 0 or s.count('b') == 0:\n        return True\n    else:\n        return s.count('a') == s.count('b')\n",
        "def ab_check(s):\n    return s.count('a') == s.count('b')\n"
    ],
    "results": 10
},{
    "id": "1798",
    "source": "leetcode",
    "language": "python",
    "query": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time. Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer.",
    "snippets": [
        "def lemonadeChange(bills):\n    \"\"\"\n    :type bills: List[int]\n    :rtype: bool\n    \"\"\"\n    five = 0\n    ten = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0:\n                return False\n            five -= 1\n            ten += 1\n        elif bill == 20:\n            if five == 0 and ten == 0:\n                return False\n            if five > 0:\n                five -= 1\n                ten += 1\n            else:\n                ten -= 1\n        else:\n            return False\n    return True\n",
        "def lemonadeChange(bills):\n    \"\"\"\n    :type bills: List[int]\n    :rtype: bool\n    \"\"\"\n    five = 0\n    ten = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0:\n                return False\n            else:\n                five -= 1\n                ten += 1\n        elif bill == 20:\n            if five == 0 and ten == 0:\n                return False\n            elif five == 0 and ten > 0:\n                ten -= 1\n                five += 1\n            elif five > 0 and ten == 0:\n                five -= 1\n                ten += 1\n            else:\n                five -= 1\n                ten -= 1\n    return True\n",
        "def lemonadeChange(bills):\n    \"\"\"\n    :type bills: List[int]\n    :rtype: bool\n    \"\"\"\n    five = 0\n    ten = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            five -= 1\n            ten += 1\n        elif bill == 20:\n            if ten > 0:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n    return True\n",
        "def lemonadeChange(bills):\n    \"\"\"\n    :type bills: List[int]\n    :rtype: bool\n    \"\"\"\n    five = 0\n    ten = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0:\n                return False\n            five -= 1\n            ten += 1\n        elif bill == 20:\n            if five == 0 and ten == 0:\n                return False\n            if five > 0:\n                five -= 1\n                ten += 1\n            else:\n                ten -= 1\n                five += 1\n        else:\n            return False\n    return True\n",
        "def lemonadeChange(bills):\n    five = 0\n    ten = 0\n    twenty = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            ten += 1\n            five -= 1\n        elif bill == 20:\n            twenty += 1\n            if ten > 0:\n                ten -= 1\n                five -= 1\n            else:\n                five -= 3\n        else:\n            return False\n    return True\n",
        "def lemonadeChange(bills):\n    five = 0\n    ten = 0\n    twenty = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            ten += 1\n            five -= 1\n        elif bill == 20:\n            twenty += 1\n            ten -= 1\n            five -= 1\n        else:\n            if twenty > 0:\n                twenty -= 1\n                ten -= 1\n                five -= 1\n            elif ten > 0 and five > 0:\n                ten -= 1\n                five -= 1\n            elif five > 3:\n                five -= 3\n            else:\n                return False\n    return True\n",
        "def lemonadeChange(bills):\n    \"\"\"\n    :type bills: List[int]\n    :rtype: bool\n    \"\"\"\n    if len(bills) == 0:\n        return True\n    if bills[0] == 5:\n        return lemonadeChange(bills[1:])\n    elif bills[0] == 10:\n        if len(bills) == 1:\n            return False\n        if bills[1] == 5:\n            return lemonadeChange(bills[2:])\n        else:\n            return False\n    elif bills[0] == 20:\n        if len(bills) == 1:\n            return False\n        if bills[1] == 10:\n            if len(bills) == 2:\n                return False\n            if bills[2] == 5:\n                return lemonadeChange(bills[3:])\n            else:\n                return False\n        else:\n            return False\n    else:\n        return False\n",
        "def lemonadeChange(bills):\n    \"\"\"\n    :type bills: List[int]\n    :rtype: bool\n    \"\"\"\n    if len(bills) == 0:\n        return True\n    if len(bills) == 1:\n        if bills[0] == 5:\n            return True\n        else:\n            return False\n    if len(bills) == 2:\n        if bills[0] == 5 and bills[1] == 5:\n            return True\n        elif bills[0] == 10 and bills[1] == 5:\n            return True\n        else:\n            return False\n    if len(bills) == 3:\n        if bills[0] == 5 and bills[1] == 5 and bills[2] == 5:\n            return True\n        elif bills[0] == 5 and bills[1] == 10 and bills[2] == 5:\n            return True\n        elif bills[0] == 10 and bills[1] == 5 and bills[2] == 5:\n            return True\n        elif bills[0] == 10 and bills[1] == 10 and bills[2] == 5:\n            return True\n        else:\n            return False\n    if len(bills) == 4:\n        if bills[0] == 5 and bills[1] == 5 and bills[2] == 5 and bills[3] == 5:\n            return True\n        elif bills[0] == 5 and bills[1] == 5 and bills[2] == 10 and bills[3] == 5:\n            return True\n        elif bills[0] == 5 and bills[1] == 10 and bills[2] == 5 and bills[3] == 5:\n            return True\n        elif bills[0] == 5 and bills[1] == 10 and bills[2] == 10 and bills[3] == 5:\n            return True\n        elif bills[0] == 10 and bills[1] == 5 and bills[2] == 5 and bills[3] == 5:\n            return True\n        elif bills[0] == 10 and bills[1] == 5 and bills[2] == 10 and bills[3] == 5:\n            return\n",
        "def lemonadeChange(bills):\n    \"\"\"\n    :type bills: List[int]\n    :rtype: bool\n    \"\"\"\n    five, ten, twenty = 0, 0, 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0:\n                return False\n            five -= 1\n            ten += 1\n        elif bill == 20:\n            if five == 0 and ten == 0:\n                return False\n            if five > 0:\n                five -= 1\n            else:\n                ten -= 1\n            twenty += 1\n    return True\n"
    ],
    "results": 10
},{
    "id": "1799",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number.",
    "snippets": [
        "def squares(nums):\n    return [n**2 for n in nums]\n",
        "def square(nums):\n    return [n*n for n in nums]\n",
        "def squares(nums):\n    return [x**2 for x in nums]\n",
        "def sortedSquares(A):\n    return [x**2 for x in A]\n"
    ],
    "results": 8
},{
    "id": "1800",
    "source": "leetcode",
    "language": "python",
    "query": "The score of nums is the difference between the maximum and minimum elements in nums. You are given an integer array nums and an integer k. You can apply this operation at most once for each index i.",
    "snippets": [
        "def score(nums, k):\n    if not nums:\n        return 0\n    max_num = max(nums)\n    min_num = min(nums)\n    return max_num - min_num\n",
        "def score(nums, k):\n    if len(nums) == 0:\n        return 0\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(nums) - min(nums)\n    if k == 2:\n        return max(nums) - min(nums) + score(nums[1:], 1)\n    if k == 3:\n        return max(nums) - min(nums) + score(nums[2:], 2)\n    if k == 4:\n        return max(nums) - min(nums) + score(nums[3:], 3)\n    if k == 5:\n        return max(nums) - min(nums) + score(nums[4:], 4)\n    if k == 6:\n        return max(nums) - min(nums) + score(nums[5:], 5)\n    if k == 7:\n        return max(nums) - min(nums) + score(nums[6:], 6)\n    if k == 8:\n        return max(nums) - min(nums) + score(nums[7:], 7)\n    if k == 9:\n        return max(nums) - min(nums) + score(nums[8:], 8)\n    if k == 10:\n        return max(nums) - min(nums) + score(nums[9:], 9)\n    if k == 11:\n        return max(nums) - min(nums) + score(nums[10:], 10)\n    if k == 12:\n        return max(nums) - min(nums) + score(nums[11:], 11)\n    if k == 13:\n        return max(nums) - min(nums) + score(nums[12:], 12)\n    if k == 14:\n        return max(nums) - min(nums) + score(nums[13:], 13)\n    if k == 15:\n        return max(nums) - min(nums) + score(nums[14:\n",
        "def score(nums, k):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return 0\n    if len(nums) == 2:\n        return abs(nums[0] - nums[1])\n    if len(nums) == 3:\n        return abs(nums[0] - nums[2])\n    if len(nums) == 4:\n        return abs(nums[0] - nums[3])\n    if len(nums) == 5:\n        return abs(nums[0] - nums[4])\n    if len(nums) == 6:\n        return abs(nums[0] - nums[5])\n    if len(nums) == 7:\n        return abs(nums[0] - nums[6])\n    if len(nums) == 8:\n        return abs(nums[0] - nums[7])\n    if len(nums) == 9:\n        return abs(nums[0] - nums[8])\n    if len(nums) == 10:\n        return abs(nums[0] - nums[9])\n    if len(nums) == 11:\n        return abs(nums[0] - nums[10])\n    if len(nums) == 12:\n        return abs(nums[0] - nums[11])\n    if len(nums) == 13:\n        return abs(nums[0] - nums[12])\n    if len(nums) == 14:\n        return abs(nums[0] - nums[13])\n    if len(nums) == 15:\n        return abs(nums[0] - nums[14])\n    if len(nums) == 16:\n        return abs(nums[0] - nums[15])\n    if len(nums) == 17:\n        return abs(nums[0] - nums[16])\n    if len(nums) == 18:\n        return abs(nums[0] - nums[17])\n    if len(nums\n",
        "def score(nums, k):\n    if len(nums) == 0:\n        return 0\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(nums) - min(nums)\n    if k == 2:\n        return max(nums) - min(nums) + score(nums[1:], 1)\n    if k == 3:\n        return max(nums) - min(nums) + score(nums[1:], 2)\n    if k == 4:\n        return max(nums) - min(nums) + score(nums[1:], 3)\n    if k == 5:\n        return max(nums) - min(nums) + score(nums[1:], 4)\n    if k == 6:\n        return max(nums) - min(nums) + score(nums[1:], 5)\n    if k == 7:\n        return max(nums) - min(nums) + score(nums[1:], 6)\n    if k == 8:\n        return max(nums) - min(nums) + score(nums[1:], 7)\n    if k == 9:\n        return max(nums) - min(nums) + score(nums[1:], 8)\n    if k == 10:\n        return max(nums) - min(nums) + score(nums[1:], 9)\n    if k == 11:\n        return max(nums) - min(nums) + score(nums[1:], 10)\n    if k == 12:\n        return max(nums) - min(nums) + score(nums[1:], 11)\n    if k == 13:\n        return max(nums) - min(nums) + score(nums[1:], 12)\n    if k == 14:\n        return max(nums) - min(nums) + score(nums[1:], 13)\n    if k == 15:\n        return max(nums) - min(nums) + score(nums[1:\n",
        "def score(nums, k):\n    if not nums:\n        return 0\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(nums) - min(nums)\n    if k == 2:\n        return max(nums) - min(nums) + score(nums[1:], 1)\n    if k == 3:\n        return max(nums) - min(nums) + score(nums[1:], 2)\n    if k == 4:\n        return max(nums) - min(nums) + score(nums[1:], 3)\n    if k == 5:\n        return max(nums) - min(nums) + score(nums[1:], 4)\n    if k == 6:\n        return max(nums) - min(nums) + score(nums[1:], 5)\n    if k == 7:\n        return max(nums) - min(nums) + score(nums[1:], 6)\n    if k == 8:\n        return max(nums) - min(nums) + score(nums[1:], 7)\n    if k == 9:\n        return max(nums) - min(nums) + score(nums[1:], 8)\n    if k == 10:\n        return max(nums) - min(nums) + score(nums[1:], 9)\n    if k == 11:\n        return max(nums) - min(nums) + score(nums[1:], 10)\n    if k == 12:\n        return max(nums) - min(nums) + score(nums[1:], 11)\n    if k == 13:\n        return max(nums) - min(nums) + score(nums[1:], 12)\n    if k == 14:\n        return max(nums) - min(nums) + score(nums[1:], 13)\n    if k == 15:\n        return max(nums) - min(nums) + score(nums[1:], 14)\n",
        "def score(nums, k):\n    if not nums:\n        return 0\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(nums) - min(nums)\n    if k == len(nums):\n        return sum(nums)\n    if k > len(nums):\n        return 0\n    return sum(nums[:k]) - sum(nums[k:])\n",
        "def score(nums, k):\n    if not nums:\n        return 0\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(nums) - min(nums)\n    if k == 2:\n        return max(nums) - min(nums) + score(nums[1:], 1)\n    if k == 3:\n        return max(nums) - min(nums) + score(nums[2:], 2)\n    if k == 4:\n        return max(nums) - min(nums) + score(nums[3:], 3)\n    if k == 5:\n        return max(nums) - min(nums) + score(nums[4:], 4)\n    if k == 6:\n        return max(nums) - min(nums) + score(nums[5:], 5)\n    if k == 7:\n        return max(nums) - min(nums) + score(nums[6:], 6)\n    if k == 8:\n        return max(nums) - min(nums) + score(nums[7:], 7)\n    if k == 9:\n        return max(nums) - min(nums) + score(nums[8:], 8)\n    if k == 10:\n        return max(nums) - min(nums) + score(nums[9:], 9)\n    if k == 11:\n        return max(nums) - min(nums) + score(nums[10:], 10)\n    if k == 12:\n        return max(nums) - min(nums) + score(nums[11:], 11)\n    if k == 13:\n        return max(nums) - min(nums) + score(nums[12:], 12)\n    if k == 14:\n        return max(nums) - min(nums) + score(nums[13:], 13)\n    if k == 15:\n        return max(nums) - min(nums) + score(nums[14:], 14)\n"
    ],
    "results": 10
},{
    "id": "1801",
    "source": "leetcode",
    "language": "python",
    "query": "The Tribonacci sequence Tn is defined as follows:  T0 = 0, T1 = 1, T2 = 1. Tn+3 = Tn + Tn-1 + TN-2 for n >= 0.",
    "snippets": [
        "def tribonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3)\n"
    ],
    "results": 10
},{
    "id": "1802",
    "source": "leetcode",
    "language": "python",
    "query": "A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Given a string s and an array of strings words, return the number of words[i] that is a subsequences of s.",
    "snippets": [
        "def subsequnce(s, words):\n    count = 0\n    for word in words:\n        if word in s:\n            count += 1\n    return count\n",
        "def subseqence(s, words):\n    count = 0\n    for word in words:\n        if word in s:\n            count += 1\n    return count\n",
        "def subsequnce(s, words):\n    d = {}\n    for word in words:\n        d[word] = 1\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i:j+1] in d:\n                d[s[i:j+1]] += 1\n    return sum(d.values())\n",
        "def subsequnce(s, words):\n    d = {}\n    for word in words:\n        d[word] = 1\n    for i in range(len(s)):\n        if s[i:] in d:\n            d[s[i:]] += 1\n    return d[s]\n",
        "def subsequnce(s, words):\n    dic = {}\n    for word in words:\n        dic[word] = 1\n    count = 0\n    for i in range(len(s)):\n        if s[i:] in dic:\n            count += 1\n    return count\n",
        "def subseq(s, words):\n    res = 0\n    for word in words:\n        if word in s:\n            res += 1\n    return res\n"
    ],
    "results": 10
},{
    "id": "1803",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down.",
    "snippets": [
        "def percentage(s, letter):\n    count = 0\n    for i in s:\n        if i == letter:\n            count += 1\n    return count / len(s) * 100\n",
        "def main():\n    s = input(\"Enter a string: \")\n    letter = input(\"Enter a letter: \")\n    print(percentage(s, letter))\n",
        "def percentage(s, letter):\n    return round(100 * s.count(letter) / len(s))\n"
    ],
    "results": 10
},{
    "id": "1804",
    "source": "leetcode",
    "language": "python",
    "query": "A substring is a contiguous sequence of characters in a string. You are given a string s that consists of only digits. Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order.",
    "snippets": [
        "def check(s):\n    if len(s) < 2:\n        return False\n    if s[0] < s[1]:\n        return False\n    for i in range(1, len(s)):\n        if s[i] < s[i-1]:\n            return False\n    return True\n",
        "def is_descending(s):\n    for i in range(len(s) - 1):\n        if int(s[i]) < int(s[i + 1]):\n            return False\n    return True\n",
        "def check_substring(s):\n    if len(s) < 2:\n        return False\n    if s[0] < s[1]:\n        return False\n    for i in range(1, len(s)):\n        if s[i] < s[i-1]:\n            return False\n    return True\n",
        "def is_substring(s):\n    if len(s) < 2:\n        return False\n    for i in range(len(s)):\n        for j in range(i+1, len(s)):\n            if int(s[i:j+1]) % 2 == 0:\n                return True\n    return False\n",
        "def check_substring(s):\n    if len(s) < 2:\n        return False\n    if s[0] < s[1]:\n        return False\n    if s[0] == s[1]:\n        return check_substring(s[1:])\n    if s[0] > s[1]:\n        return True\n    return False\n",
        "def check_substring(s):\n    if len(s) < 2:\n        return False\n    if len(s) == 2:\n        return True\n    if s[0] < s[1]:\n        return False\n    for i in range(1, len(s)):\n        if s[i] < s[i-1]:\n            return False\n    return True\n",
        "def check_substring(s):\n    if len(s) < 2:\n        return False\n    else:\n        for i in range(len(s)):\n            for j in range(i+1, len(s)):\n                if int(s[i:j+1]) < int(s[j+1:]):\n                    return True\n        return False\n",
        "def is_substring(s):\n    if len(s) < 2:\n        return False\n    if s[0] > s[1]:\n        return False\n    if s[0] == s[1]:\n        return is_substring(s[1:])\n    return True\n",
        "def is_descending(s):\n    return all(s[i] <= s[i+1] for i in range(len(s)-1))\n"
    ],
    "results": 10
},{
    "id": "1805",
    "source": "leetcode",
    "language": "python",
    "query": "Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "snippets": [
        "def mergeTwoLists(l1, l2):\n    if l1 is None:\n        return l2\n    if l2 is None:\n        return l1\n    if l1.val < l2.val:\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    else:\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n"
    ],
    "results": 10
},{
    "id": "1806",
    "source": "leetcode",
    "language": "python",
    "query": "A word is a maximal substring consisting of non-space characters only. Given a string s consisting of words and spaces, return the length of the last word in the string.",
    "snippets": [
        "def last_word_length(s):\n    return len(s.split()[-1])\n",
        "def lengthOfLastWord(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    if not s:\n        return 0\n    s = s.strip()\n    return len(s.split(' ')[-1])\n",
        "def length_of_last_word(s):\n    return len(s.rstrip(' ').split(' ')[-1])\n",
        "def length_of_last_word(s):\n    return len(s.strip().split(' ')[-1])\n",
        "def length_of_last_word(s):\n    return len(s.split()[-1])\n",
        "def length_of_last_word(s):\n    return len(s.rstrip().split(' ')[-1])\n",
        "def last_word_length(s):\n    return len(s.rstrip().split(' ')[-1])\n"
    ],
    "results": 10
},{
    "id": "1807",
    "source": "leetcode",
    "language": "python",
    "query": "implement pow(x, n), which calculates x raised to the power n (i.e., xn).",
    "snippets": [
        "def myPow(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 1 / myPow(x, -n)\n    if n % 2 == 0:\n        return myPow(x * x, n // 2)\n    else:\n        return x * myPow(x * x, n // 2)\n",
        "def myPow(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        return 1 / myPow(x, -n)\n    if n % 2 == 0:\n        return myPow(x * x, n / 2)\n    else:\n        return x * myPow(x * x, n / 2)\n",
        "def myPow(x, n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return x\n    if n < 0:\n        return 1 / myPow(x, -n)\n    if n % 2 == 0:\n        return myPow(x * x, n // 2)\n    else:\n        return x * myPow(x * x, n // 2)\n",
        "def myPow(x, n):\n    if n == 0:\n        return 1\n    if n == 1:\n        return x\n    if n < 0:\n        return 1 / myPow(x, -n)\n    if n % 2 == 0:\n        return myPow(x * x, n / 2)\n    else:\n        return x * myPow(x * x, (n - 1) / 2)\n"
    ],
    "results": 10
},{
    "id": "1808",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.",
    "snippets": [
        "def order(s):\n    return ''.join(sorted(s))\n"
    ],
    "results": 10
},{
    "id": "1809",
    "source": "leetcode",
    "language": "python",
    "query": "A subarray of an array is a consecutive sequence of zero or more values taken out of that array. Find the maximum length of a subarray where the product of all its elements is positive.",
    "snippets": [
        "def max_subarray_product(arr):\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    max_product = 1\n    min_product = 1\n    max_product_so_far = 1\n    min_product_so_far = 1\n    for i in range(len(arr)):\n        if arr[i] < 0:\n            max_product_so_far, min_product_so_far = min_product_so_far, max_product_so_far\n        max_product_so_far = max(max_product_so_far * arr[i], arr[i])\n        min_product_so_far = min(min_product_so_far * arr[i], arr[i])\n        max_product = max(max_product, max_product_so_far)\n    return max_product\n",
        "def max_subarray_product(arr):\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    max_product = 1\n    min_product = 1\n    max_ending_here = 1\n    min_ending_here = 1\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            max_ending_here *= arr[i]\n            max_product = max(max_product, max_ending_here)\n        else:\n            max_ending_here = 1\n        if arr[i] < 0:\n            min_ending_here *= arr[i]\n            min_product = min(min_product, min_ending_here)\n        else:\n            min_ending_here = 1\n    return max_product if max_product > 0 else min_product\n",
        "def max_subarray_product(arr):\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    max_product = 1\n    min_product = 1\n    max_ending_here = 1\n    min_ending_here = 1\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            max_ending_here *= arr[i]\n            max_product = max(max_product, max_ending_here)\n        else:\n            max_ending_here = 1\n            max_product = max(max_product, max_ending_here)\n        if arr[i] < 0:\n            min_ending_here *= arr[i]\n            min_product = min(min_product, min_ending_here)\n        else:\n            min_ending_here = 1\n            min_product = min(min_product, min_ending_here)\n    return max_product\n",
        "def max_subarray_product(arr):\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    max_product = arr[0]\n    min_product = arr[0]\n    max_product_so_far = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] > 0:\n            max_product_so_far = max(arr[i], max_product_so_far * arr[i])\n            max_product = max(max_product, max_product_so_far)\n        else:\n            max_product_so_far = 1\n            max_product = max(max_product, 1)\n        if arr[i] < 0:\n            min_product = min(arr[i], min_product * arr[i])\n        else:\n            min_product = 1\n    return max_product\n",
        "def max_subarray_product(arr):\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    max_product = arr[0]\n    min_product = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here * arr[i], min_ending_here * arr[i])\n        min_ending_here = min(arr[i], max_ending_here * arr[i], min_ending_here * arr[i])\n        max_product = max(max_product, max_ending_here)\n        min_product = min(min_product, min_ending_here)\n    return max_product\n",
        "def max_subarray_product(arr):\n    max_ending_here = 1\n    max_so_far = 1\n    for x in arr:\n        max_ending_here *= x\n        if max_ending_here < 0:\n            max_ending_here = 1\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n",
        "def max_subarray_product(arr):\n    max_ending_here = 1\n    max_so_far = 1\n    for i in arr:\n        max_ending_here *= i\n        if max_ending_here < 0:\n            max_ending_here = 1\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n"
    ],
    "results": 10
},{
    "id": "1810",
    "source": "leetcode",
    "language": "python",
    "query": "Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value.",
    "snippets": [
        "def serialize(root):\n    if root is None:\n        return '#'\n    return str(root.val) + ' ' + serialize(root.left) + ' ' + serialize(root.right)\n",
        "def serialize(root):\n    if not root:\n        return '#'\n    return str(root.val) + ' ' + serialize(root.left) + ' ' + serialize(root.right)\n"
    ],
    "results": 10
},{
    "id": "1811",
    "source": "leetcode",
    "language": "python",
    "query": "Remove any number of beans (possibly none) from each bag such that the number in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it.",
    "snippets": [
        "def remove_beans(bags, beans):\n    for i in range(len(bags)):\n        if bags[i] == 0:\n            continue\n        for j in range(len(beans)):\n            if bags[i] - beans[j] >= 0:\n                bags[i] -= beans[j]\n                bags[i] = max(bags[i], 0)\n                break\n    return bags\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    for i in range(len(bags)):\n        if bags[i] > 0:\n            if bags[i] >= beans[i]:\n                bags[i] -= beans[i]\n                beans[i] = 0\n            else:\n                beans[i] -= bags[i]\n                bags[i] = 0\n    return bags, beans\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    # print(bags)\n    # print(beans)\n    # print(len(bags))\n    # print(len(beans))\n    # print(len(bags[0]))\n    # print(len(bags[1]))\n    # print(len(bags[2]))\n    # print(len(bags[3]))\n    # print(len(bags[4]))\n    # print(len(bags[5]))\n    # print(len(bags[6]))\n    # print(len(bags[7]))\n    # print(len(bags[8]))\n    # print(len(bags[9]))\n    # print(len(bags[10]))\n    # print(len(bags[11]))\n    # print(len(bags[12]))\n    # print(len(bags[13]))\n    # print(len(bags[14]))\n    # print(len(bags[15]))\n    # print(len(bags[16]))\n    # print(len(bags[17]))\n    # print(len(bags[18]))\n    # print(len(bags[19]))\n    # print(len(bags[20]))\n    # print(len(bags[21]))\n    # print(len(bags[22]))\n    # print(len(bags[23]))\n    # print(len(bags[24]))\n    # print(len(bags[25]))\n    # print(len(bags[26]))\n    # print(len(bags[27]))\n    # print(len(bags[28]))\n    # print(len(bags[29]))\n    # print(len(bags[30]))\n    # print(len(bags[31]))\n    # print(len(bags[32]))\n    # print(len(bags[33]))\n    # print(len(bags[34]))\n    # print(len(bags[35]))\n    # print(len(bags[36]))\n    # print(len(\n",
        "def remove_beans(bags):\n    # Write your code here\n    # print(bags)\n    # print(len(bags))\n    # print(len(bags[0]))\n    # print(len(bags[1]))\n    # print(len(bags[2]))\n    # print(len(bags[3]))\n    # print(len(bags[4]))\n    # print(len(bags[5]))\n    # print(len(bags[6]))\n    # print(len(bags[7]))\n    # print(len(bags[8]))\n    # print(len(bags[9]))\n    # print(len(bags[10]))\n    # print(len(bags[11]))\n    # print(len(bags[12]))\n    # print(len(bags[13]))\n    # print(len(bags[14]))\n    # print(len(bags[15]))\n    # print(len(bags[16]))\n    # print(len(bags[17]))\n    # print(len(bags[18]))\n    # print(len(bags[19]))\n    # print(len(bags[20]))\n    # print(len(bags[21]))\n    # print(len(bags[22]))\n    # print(len(bags[23]))\n    # print(len(bags[24]))\n    # print(len(bags[25]))\n    # print(len(bags[26]))\n    # print(len(bags[27]))\n    # print(len(bags[28]))\n    # print(len(bags[29]))\n    # print(len(bags[30]))\n    # print(len(bags[31]))\n    # print(len(bags[32]))\n    # print(len(bags[33]))\n    # print(len(bags[34]))\n    # print(len(bags[35]))\n    # print(len(bags[36]))\n    # print(len(bags[37]))\n    # print(len(bags[38]))\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    # print(bags, beans)\n    if len(bags) == 0:\n        return []\n    if len(bags) == 1:\n        return [bags[0] - beans]\n    if len(bags) == 2:\n        return [bags[0] - beans, bags[1] - beans]\n    if len(bags) == 3:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans]\n    if len(bags) == 4:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans]\n    if len(bags) == 5:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans]\n    if len(bags) == 6:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans]\n    if len(bags) == 7:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans, bags[6] - beans]\n    if len(bags) == 8:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans, bags[6] - beans, bags[7] - beans]\n    if len(bags) == 9:\n        return [bags[0] - beans, bags[1] - beans, bags[2] - beans, bags[3] - beans, bags[4] - beans, bags[5] - beans, bags[6] - beans, bags[7] - beans, bags[8] - beans]\n    if len(bags) == 10:\n        return [bags[0] -\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    # print(bags, beans)\n    if len(bags) == 1:\n        return 0\n    if len(bags) == 2:\n        return min(bags[0], bags[1])\n    if len(bags) == 3:\n        return min(bags[0], bags[1], bags[2])\n    if len(bags) == 4:\n        return min(bags[0], bags[1], bags[2], bags[3])\n    if len(bags) == 5:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4])\n    if len(bags) == 6:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5])\n    if len(bags) == 7:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6])\n    if len(bags) == 8:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7])\n    if len(bags) == 9:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8])\n    if len(bags) == 10:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8], bags[9])\n    if len(bags) == 11:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8], bags[9], bags[10])\n    if len(bags) == 12:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8\n",
        "def removeBeans(bags, beans):\n    # Write your code here.\n    # return 0 # This line is here to make the code compile.\n    if len(bags) == 0:\n        return 0\n    if len(bags) == 1:\n        return bags[0]\n    if len(bags) == 2:\n        return min(bags[0], bags[1])\n    if len(bags) == 3:\n        return min(bags[0], bags[1], bags[2])\n    if len(bags) == 4:\n        return min(bags[0], bags[1], bags[2], bags[3])\n    if len(bags) == 5:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4])\n    if len(bags) == 6:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5])\n    if len(bags) == 7:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6])\n    if len(bags) == 8:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7])\n    if len(bags) == 9:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8])\n    if len(bags) == 10:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8], bags[9])\n    if len(bags) == 11:\n        return min(bags[0], bags[1], bags[2], bags[3], bags[4], bags[5], bags[6], bags[7], bags[8], bags[9], bags[10])\n    if len(bags) == 12:\n        return min(bags[0], bags[1], bags[2\n"
    ],
    "results": 7
},{
    "id": "1812",
    "source": "leetcode",
    "language": "python",
    "query": "Take any bag of balls and divide it into two new bags with a positive number of balls. Return the minimum possible penalty after performing the operations.",
    "snippets": [],
    "results": 0
},{
    "id": "1813",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array nums of n, return an array of all the unique quadruplets [nums] such that: a, b, c, d are distinct. You may return the answer in any order.",
    "snippets": [
        "def fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n                elif sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n",
        "def unique_quadruplets(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            k = j + 1\n            l = len(nums) - 1\n            while k < l:\n                if nums[i] + nums[j] + nums[k] + nums[l] == 0:\n                    result.append([nums[i], nums[j], nums[k], nums[l]])\n                    k += 1\n                    l -= 1\n                    while k < l and nums[k] == nums[k - 1]:\n                        k += 1\n                    while k < l and nums[l] == nums[l + 1]:\n                        l -= 1\n                elif nums[i] + nums[j] + nums[k] + nums[l] < 0:\n                    k += 1\n                else:\n                    l -= 1\n    return result\n",
        "def unique_quadruplets(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            k = j + 1\n            l = len(nums) - 1\n            while k < l:\n                if nums[i] + nums[j] + nums[k] + nums[l] == 0:\n                    result.append([nums[i], nums[j], nums[k], nums[l]])\n                    k += 1\n                    l -= 1\n                elif nums[i] + nums[j] + nums[k] + nums[l] < 0:\n                    k += 1\n                else:\n                    l -= 1\n    return result\n",
        "def fourSum(nums, target):\n    nums.sort()\n    res = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if sum < target:\n                    left += 1\n                elif sum > target:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n    return res\n",
        "def unique_quadruplets(nums):\n    nums.sort()\n    res = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                if nums[i] + nums[j] + nums[left] + nums[right] > 0:\n                    right -= 1\n                else:\n                    left += 1\n            if left < right:\n                res.append([nums[i], nums[j], nums[left], nums[right]])\n    return res\n",
        "def fourSum(nums, target):\n    nums.sort()\n    res = []\n    for i in range(len(nums)-3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        for j in range(i+1, len(nums)-2):\n            if j > i+1 and nums[j] == nums[j-1]:\n                continue\n            left = j+1\n            right = len(nums)-1\n            while left < right:\n                sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if sum < target:\n                    left += 1\n                elif sum > target:\n                    right -= 1\n                else:\n                    res.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n    return res\n",
        "def fourSum(nums, target):\n    nums.sort()\n    res = []\n    for i in range(len(nums)-3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        for j in range(i+1, len(nums)-2):\n            if j > i+1 and nums[j] == nums[j-1]:\n                continue\n            left = j+1\n            right = len(nums)-1\n            while left < right:\n                sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if sum == target:\n                    res.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left-1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right+1]:\n                        right -= 1\n                elif sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return res\n"
    ],
    "results": 10
},{
    "id": "1814",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer finalSum. Split it into a sum of a maximum number of unique positive even integers. If no valid split exists for finalSum, return an empty list.",
    "snippets": [
        "def split_sum(final_sum):\n    if final_sum % 2 != 0:\n        return []\n    if final_sum == 2:\n        return [1]\n    if final_sum == 4:\n        return [2, 2]\n    if final_sum == 6:\n        return [3, 2]\n    if final_sum == 8:\n        return [4, 2]\n    if final_sum == 10:\n        return [5, 2]\n    if final_sum == 12:\n        return [6, 2]\n    if final_sum == 14:\n        return [7, 2]\n    if final_sum == 16:\n        return [8, 2]\n    if final_sum == 18:\n        return [9, 2]\n    if final_sum == 20:\n        return [10, 2]\n    if final_sum == 22:\n        return [11, 2]\n    if final_sum == 24:\n        return [12, 2]\n    if final_sum == 26:\n        return [13, 2]\n    if final_sum == 28:\n        return [14, 2]\n    if final_sum == 30:\n        return [15, 2]\n    if final_sum == 32:\n        return [16, 2]\n    if final_sum == 34:\n        return [17, 2]\n    if final_sum == 36:\n        return [18, 2]\n    if final_sum == 38:\n        return [19, 2]\n    if final_sum == 40:\n        return [20, 2]\n    if final_sum == 42:\n        return [21, 2]\n    if final_sum == 44:\n        return [22, 2]\n    if final_sum == 46:\n        return [23, 2]\n    if final_sum == 48:\n        return [24, 2]\n    if final_sum == 50:\n        return [25, 2]\n    if final_sum == 52:\n        return [26, 2]\n    if final_sum == 54:\n        return [27, 2]\n    if final_sum == 56:\n        return [28, 2]\n",
        "def split_sum(final_sum):\n    if final_sum % 2 != 0:\n        return []\n    if final_sum == 2:\n        return [1]\n    if final_sum == 4:\n        return [2, 2]\n    if final_sum == 6:\n        return [3, 3]\n    if final_sum == 8:\n        return [4, 4]\n    if final_sum == 10:\n        return [5, 5]\n    if final_sum == 12:\n        return [6, 6]\n    if final_sum == 14:\n        return [7, 7]\n    if final_sum == 16:\n        return [8, 8]\n    if final_sum == 18:\n        return [9, 9]\n    if final_sum == 20:\n        return [10, 10]\n    if final_sum == 22:\n        return [11, 11]\n    if final_sum == 24:\n        return [12, 12]\n    if final_sum == 26:\n        return [13, 13]\n    if final_sum == 28:\n        return [14, 14]\n    if final_sum == 30:\n        return [15, 15]\n    if final_sum == 32:\n        return [16, 16]\n    if final_sum == 34:\n        return [17, 17]\n    if final_sum == 36:\n        return [18, 18]\n    if final_sum == 38:\n        return [19, 19]\n    if final_sum == 40:\n        return [20, 20]\n    if final_sum == 42:\n        return [21, 21]\n    if final_sum == 44:\n        return [22, 22]\n    if final_sum == 46:\n        return [23, 23]\n    if final_sum == 48:\n        return [24, 24]\n    if final_sum == 50:\n        return [25, 25]\n    if final_sum == 52:\n        return [26, 26]\n    if final_sum == 54:\n        return [27, 27]\n    if final_sum == 56:\n        return [28, 28]\n",
        "def split_sum(finalSum):\n    if finalSum % 2 != 0:\n        return []\n    if finalSum == 2:\n        return [1]\n    if finalSum == 4:\n        return [2, 2]\n    if finalSum == 6:\n        return [3, 2]\n    if finalSum == 8:\n        return [4, 2]\n    if finalSum == 10:\n        return [5, 2]\n    if finalSum == 12:\n        return [6, 2]\n    if finalSum == 14:\n        return [7, 2]\n    if finalSum == 16:\n        return [8, 2]\n    if finalSum == 18:\n        return [9, 2]\n    if finalSum == 20:\n        return [10, 2]\n    if finalSum == 22:\n        return [11, 2]\n    if finalSum == 24:\n        return [12, 2]\n    if finalSum == 26:\n        return [13, 2]\n    if finalSum == 28:\n        return [14, 2]\n    if finalSum == 30:\n        return [15, 2]\n    if finalSum == 32:\n        return [16, 2]\n    if finalSum == 34:\n        return [17, 2]\n    if finalSum == 36:\n        return [18, 2]\n    if finalSum == 38:\n        return [19, 2]\n    if finalSum == 40:\n        return [20, 2]\n    if finalSum == 42:\n        return [21, 2]\n    if finalSum == 44:\n        return [22, 2]\n    if finalSum == 46:\n        return [23, 2]\n    if finalSum == 48:\n        return [24, 2]\n    if finalSum == 50:\n        return [25, 2]\n    if finalSum == 52:\n        return [26, 2]\n    if finalSum == 54:\n        return [27, 2]\n    if finalSum == 56:\n        return [28, 2] (Duplicates hidden)\n    if finalSum == 58:\n        return [29, 2]\n    if finalSum == 60:\n        return [30, 2]\n",
        "def split_sum(final_sum):\n    if final_sum % 2 != 0:\n        return []\n    if final_sum == 2:\n        return [1]\n    if final_sum == 4:\n        return [2, 2]\n    if final_sum == 6:\n        return [3, 2]1]\n        return nums\n",
        "def split_sum(final_sum):\n    if final_sum % 2 != 0:\n        return []\n    else:\n        for i in range(1, final_sum // 2 + 1):\n            if final_sum == i * 2:\n                return [i]\n            elif final_sum == i * 2 + 1:\n                return [i, i]\n            elif final_sum == i * 2 + 2:\n                return [i, i, i]\n            elif final_sum == i * 2 + 3:\n                return [i, i, i, i]\n            elif final_sum == i * 2 + 4:\n                return [i, i, i, i, i]\n            elif final_sum == i * 2 + 5:\n                return [i, i, i, i, i, i]\n            elif final_sum == i * 2 + 6:\n                return [i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 7:\n                return [i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 8:\n                return [i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 9:\n                return [i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 10:\n                return [i, i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 11:\n                return [i, i, i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 12:\n                return [i, i, i, i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 13:\n                return [i, i, i, i, i, i, i, i, i, i, i, i,\n",
        "def split_sum(finalSum):\n    if finalSum % 2 != 0:\n        return []\n    else:\n        for i in range(1, finalSum // 2 + 1):\n            if finalSum == i * 2:\n                return [i]\n            elif finalSum == i * 2 + 1:\n                return [i, i + 1]\n            elif finalSum == i * 2 + 2:\n                return [i, i + 1, i + 2]\n            elif finalSum == i * 2 + 3:\n                return [i, i + 1, i + 2, i + 3]\n            elif finalSum == i * 2 + 4:\n                return [i, i + 1, i + 2, i + 3, i + 4]\n            elif finalSum == i * 2 + 5:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5]\n            elif finalSum == i * 2 + 6:\n                return [i, i + , i + 2, i + 3, i + 4, i + 5, i + 6]\n            elif finalSum == i * 2 + 7:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7\n    if f    elif finalSum == i * 2 + 8:\n                inal_s [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8]\n    u       elif fimalS = == i * 2 + 9:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9]\n            elif finalSum == i * 2 + 10:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9, i + 10]\n            elif finalSum == i * 2 + 11:\n                return [i, i + 1, i + 2, i + 3, i\n",
        "def split_sum(final_=um):\n    # Write your code here\n    if final_sum % 2 != 0:\n        return []\n    else:\n        for i in range(1, final_sum // 2 + 1):\n            if final_sum == i * 2:\n                return [i]\n            elif final_sum == i * 2 + 1:\n                return [i, i + 1]\n            elif final_sum == i * 2 + 2:\n                return [i, i + 1, i + 2]\n            elif final_sum == i * 2 + 3:\n                return [i, i + 1, i + 2, i + 3]\n            elif final_sum == i * 2 + 4:\n                return [i, i + 1, i + 2, i + 3, i + 4]\n            elif final_sum == i * 2 + 5:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5]\n            elif final_sum == i * 2 + 6:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6]\n            elif final_sum == i * 2 + 7:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7]\n            elif final_sum == i * 2 + 8:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8]\n            elif final_sum == i * 2 + 9:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9]\n            elif final_sum == i * 2 + 10:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9, i + 10]\n            elif final_sum == i * 2 8:\n        return [4, 2]\n    if final_sum == 10:\n        return [5, 2]\n    if final_sum == 12:\n        return [6, 2]\n    if final_sum == 14:\n        return [7, 2]\n    if final_sum == 16:\n        return [8, 2]\n    if final_sum == 18:\n        return [9, 2]\n    if final_sum == 20:\n        return [10, 2]\n    if final_sum == 22:\n        return [11, 2]\n    if final_sum == 24:\n        return [12, 2]\n    if final_sum == 26:\n        return [13, 2]\n    if final_sum == 28:\n        return [14, 2]\n    if final_sum == 30:\n        return [15, 2]\n    if final_sum == 32:\n        return [16, 2]\n    if final_sum == 34:\n        return [17, 2]\n    if final_sum == 36:\n        return [18, 2]\n    if final_sum == 38:\n        return [19, 2]\n    if final_sum == 40:\n        return [20, 2]\n    if final_sum == 42:\n        return [21, 2]\n    if final_sum == 44:\n        return [22, 2]\n    if final_sum == 46:\n        return [23, 2]\n    if final_sum == 48:\n        return [24, 2]\n    if final_sum == 50:\n        return [25, 2]\n    if final_sum == 52:\n        return [26, 2]\n    if final_sum == 54:\n        return [27, 2]\n    if final_sum == 56:\n        return [28, 2]\n",
        "def split_sum(final_sum):\n    if final_sum % 2 != 0:\n        return []\n    if final_sum == 2:\n        return [1]\n    if final_sum == 4:\n        return [2, 2]\n    if final_sum == 6:\n        return [3, 3]\n    if final_sum == 8:\n        return [4, 4]\n    if final_sum == 10:\n        return [5, 5]\n    if final_sum == 12:\n        return [6, 6]\n    if final_sum == 14:\n        return [7, 7]\n    if final_sum == 16:\n        return [8, 8]\n    if final_sum == 18:\n        return [9, 9]\n    if final_sum == 20:\n        return [10, 10]\n    if final_sum == 22:\n        return [11, 11]\n    if final_sum == 24:\n        return [12, 12]\n    if final_sum == 26:\n        return [13, 13]\n    if final_sum == 28:\n        return [14, 14]\n    if final_sum == 30:\n        return [15, 15]\n    if final_sum == 32:\n        return [16, 16]\n    if final_sum == 34:\n        return [17, 17]\n    if final_sum == 36:\n        return [18, 18]\n    if final_sum == 38:\n        return [19, 19]\n    if final_sum == 40:\n        return [20, 20]\n    if final_sum == 42:\n        return [21, 21]\n    if final_sum == 44:\n        return [22, 22]\n    if final_sum == 46:\n        return [23, 23]\n    if final_sum == 48:\n        return [24, 24]\n    if final_sum == 50:\n        return [25, 25]\n    if final_sum == 52:\n        return [26, 26]\n    if final_sum == 54:\n        return [27, 27]\n    if final_sum == 56:\n        return [28, 28]\n",
        "def split_sum(finalSum):\n    if finalSum % 2 != 0:\n        return []\n    if finalSum == 2:\n        return [1]\n    if finalSum == 4:\n        return [2, 2]\n    if finalSum == 6:\n        return [3, 2]\n    if finalSum == 8:\n        return [4, 2]\n    if finalSum == 10:\n        return [5, 2]\n    if finalSum == 12:\n        return [6, 2]\n    if finalSum == 14:\n        return [7, 2]\n    if finalSum == 16:\n        return [8, 2]\n    if finalSum == 18:\n        return [9, 2]\n    if finalSum == 20:\n        return [10, 2]\n    if finalSum == 22:\n        return [11, 2]\n    if finalSum == 24:\n        return [12, 2]\n    if finalSum == 26:\n        return [13, 2]\n    if finalSum == 28:\n        return [14, 2]\n    if finalSum == 30:\n        return [15, 2]\n    if finalSum == 32:\n        return [16, 2]\n    if finalSum == 34:\n        return [17, 2]\n    if finalSum == 36:\n        return [18, 2]\n    if finalSum == 38:\n        return [19, 2]\n    if finalSum == 40:\n        return [20, 2]\n    if finalSum == 42:\n        return [21, 2]\n    if finalSum == 44:\n        return [22, 2]\n    if finalSum == 46:\n        return [23, 2]\n    if finalSum == 48:\n        return [24, 2]\n    if finalSum == 50:\n        return [25, 2]\n    if finalSum == 52:\n        return [26, 2]\n    if finalSum == 54:\n        return [27, 2]\n    if finalSum == 56:\n        return [28, 2]\n    if finalSum == 58:\n        return [29, 2]\n    if finalSum == 60:\n        return [30, 2]\n",
        "def split_sum(final_sum):\n    # Write your code here\n    if final_sum % 2 != 0:\n        return []\n    else:\n        nums = []\n        while final_sum > 0:\n            nums.append(final_sum // 2)\n            final_sum -= nums[-1]\n        return nums\n",
        "def split_sum(final_sum):\n    if final_sum % 2 != 0:\n        return []\n    else:\n        for i in range(1, final_sum // 2 + 1):\n            if final_sum == i * 2:\n                return [i]\n            elif final_sum == i * 2 + 1:\n                return [i, i]\n            elif final_sum == i * 2 + 2:\n                return [i, i, i]\n            elif final_sum == i * 2 + 3:\n                return [i, i, i, i]\n            elif final_sum == i * 2 + 4:\n                return [i, i, i, i, i]\n            elif final_sum == i * 2 + 5:\n                return [i, i, i, i, i, i]\n            elif final_sum == i * 2 + 6:\n                return [i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 7:\n                return [i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 8:\n                return [i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 9:\n                return [i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 10:\n                return [i, i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 11:\n                return [i, i, i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 12:\n                return [i, i, i, i, i, i, i, i, i, i, i, i, i]\n            elif final_sum == i * 2 + 13:\n                return [i, i, i, i, i, i, i, i, i, i, i, i,\n",
        "def split_sum(finalSum):\n    if finalSum % 2 != 0:\n        return []\n    else:\n        for i in range(1, finalSum // 2 + 1):\n            if finalSum == i * 2:\n                return [i]\n            elif finalSum == i * 2 + 1:\n                return [i, i + 1]\n            elif finalSum == i * 2 + 2:\n                return [i, i + 1, i + 2]\n            elif finalSum == i * 2 + 3:\n                return [i, i + 1, i + 2, i + 3]\n            elif finalSum == i * 2 + 4:\n                return [i, i + 1, i + 2, i + 3, i + 4]\n            elif finalSum == i * 2 + 5:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5]\n            elif finalSum == i * 2 + 6:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6]\n            elif finalSum == i * 2 + 7:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7]\n            elif finalSum == i * 2 + 8:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8]\n            elif finalSum == i * 2 + 9:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9]\n            elif finalSum == i * 2 + 10:\n                return [i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9, i + 10]\n            elif finalSum == i * 2 + 11:\n                return [i, i + 1, i + 2, i + 3, i\n",
        "def split_sum(final_sum):\n    if final_sum % 2 != 0:\n        return []\n    else:\n        return [final_sum // 2]\n"
    ],
    "results": 10
},{
    "id": "1815",
    "source": "leetcode",
    "language": "python",
    "query": "The first node is considered odd, and the second node is even, and so on. Given the head of a singly linked list, group all the nodes with odd indices together. You must solve the problem in O(1) extra space complexity.",
    "snippets": [
        "def odd_even_list(head):\n    if head is None:\n        return None\n    odd = head\n    even = head.next\n    even_head = even\n    while even is not None and even.next is not None:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head\n",
        "def odd_even_list(head):\n    if head is None:\n        return None\n    odd = head\n    even = head.next\n    even_head = even\n    while even and even.next:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head\n",
        "def odd_even_list(head):\n    if head is None:\n        return head\n    odd = head\n    even = head.next\n    even_head = even\n    while even and even.next:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head\n",
        "def odd_even_list(head):\n    if head is None or head.next is None:\n        return head\n    odd = head\n    even = head.next\n    even_head = even\n    while even and even.next:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head\n",
        "def odd_even_list(head):\n    if head is None:\n        return head\n    odd = head\n    even = head.next\n    even_head = even\n    while even is not None and even.next is not None:\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    odd.next = even_head\n    return head\n",
        "def oddEvenList(head):\n    if head is None:\n        return head\n    odd = head\n    even = head.next\n    even_head = even\n    while even is not None and even.next is not None:\n        odd.next = odd.next.next\n        even.next = even.next.next\n        odd = odd.next\n        even = even.next\n    odd.next = even_head\n    return head\n",
        "def odd_even_list(head):\n    if head is None:\n        return None\n    odd_head = head\n    even_head = head.next\n    even_tail = head.next\n    while even_tail is not None and even_tail.next is not None:\n        odd_tail = odd_head.next\n        odd_head.next = odd_tail.next\n        even_tail.next = even_tail.next.next\n        odd_tail.next = even_head\n        odd_head = odd_tail\n        even_tail = even_tail.next\n    odd_tail.next = even_head\n    return odd_head\n"
    ],
    "results": 10
},{
    "id": "1816",
    "source": "leetcode",
    "language": "python",
    "query": "Each node in the graph contains a value (int) and a list of its neighbors. Given a reference of a node in a connected undirected graph, return a deep copy of the graph.",
    "snippets": [
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = [node]\n    visited = set()\n    visited.add(node)\n    while queue:\n        curr = queue.pop(0)\n        for n in curr.neighbors:\n            if n not in visited:\n                visited.add(n)\n                queue.append(n)\n    # create a new node for each node in the graph\n    new_nodes = {node: Node(node.val) for node in visited}\n    # create a new edge for each edge in the graph\n    for node in visited:\n        for neighbor in node.neighbors:\n            new_nodes[node].neighbors.append(new_nodes[neighbor])\n    return new_nodes[node]\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = [node]\n    visited = set()\n    visited.add(node)\n    while queue:\n        curr = queue.pop(0)\n        for n in curr.neighbors:\n            if n not in visited:\n                visited.add(n)\n                queue.append(n)\n    new_graph = Node(node.val, [])\n    queue = [node]\n    visited = set()\n    visited.add(node)\n    while queue:\n        curr = queue.pop(0)\n        for n in curr.neighbors:\n            if n not in visited:\n                new_graph.neighbors.append(Node(n.val, []))\n                visited.add(n)\n                queue.append(n)\n    return new_graph\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = [node]\n    visited = set()\n    visited.add(node)\n    while queue:\n        curr = queue.pop(0)\n        for n in curr.neighbors:\n            if n not in visited:\n                visited.add(n)\n                queue.append(n)\n    for n in visited:\n        n.neighbors = [n for n in n.neighbors if n in visited]\n    return node\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = collections.deque([node])\n    visited = set()\n    visited.add(node)\n    while queue:\n        curr = queue.popleft()\n        for n in curr.neighbors:\n            if n not in visited:\n                visited.add(n)\n                queue.append(n)\n    for n in visited:\n        n.neighbors = [n for n in n.neighbors if n in visited]\n    return node\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = [node]\n    visited = set()\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        node.val = node.val\n        for neighbor in node.neighbors:\n            queue.append(neighbor)\n    return node\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = [node]\n    visited = set()\n    while queue:\n        curr = queue.pop(0)\n        if curr not in visited:\n            visited.add(curr)\n            for n in curr.neighbors:\n                queue.append(n)\n    for n in visited:\n        n.neighbors = [visited[n.neighbors[0].val] if n.neighbors else None for n in n.neighbors]\n    return visited[node.val]\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = [node]\n    visited = set()\n    while queue:\n        node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        node.neighbors = [n.val for n in node.neighbors]\n        queue.extend(node.neighbors)\n    return node\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = [node]\n    visited = set()\n    while queue:\n        curr = queue.pop(0)\n        if curr not in visited:\n            visited.add(curr)\n            curr.val = curr.val\n            for neighbor in curr.neighbors:\n                queue.append(neighbor)\n    return node\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    visited = {}\n    return self.dfs(node, visited)\n",
        "def cloneGraph(self, node):\n    if not node:\n        return None\n    queue = collections.deque()\n    queue.append(node)\n    visited = set()\n    visited.add(node)\n    while queue:\n        curr = queue.popleft()\n        for n in curr.neighbors:\n            if n not in visited:\n                queue.append(n)\n                visited.add(n)\n    return node\n"
    ],
    "results": 10
},{
    "id": "1817",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root)",
    "snippets": [
        "def levelOrderBottom(root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res[::-1]\n",
        "def levelOrderBottom(self, root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res[::-1]\n",
        "def levelOrderBottom(self, root):\n    if not root:\n        return []\n    queue = [root]\n    res = []\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res[::-1]\n",
        "def levelOrderBottom(self, root):\n    if not root:\n        return []\n    queue = [root]\n    res = []\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res[::-1]\n",
        "def levelOrderBottom(self, root):\n    if root is None:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(level)\n    return res[::-1]\n"
    ],
    "results": 10
},{
    "id": "1818",
    "source": "leetcode",
    "language": "python",
    "query": "A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive). Given a 0-based nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i].",
    "snippets": [
        "def permutation(nums):\n    if len(nums) == 1:\n        return [nums]\n    ans = []\n    for i in range(len(nums)):\n        for p in permutation(nums[:i] + nums[i+1:]):\n            ans.append([nums[i]] + p)\n    return ans\n",
        "def permute(nums):\n    if len(nums) == 1:\n        return [nums]\n    ans = []\n    for i in range(len(nums)):\n        for perm in permute(nums[:i] + nums[i+1:]):\n            ans.append([nums[i]] + perm)\n    return ans\n",
        "def permutation(nums):\n    ans = []\n    if len(nums) == 0:\n        return ans\n    if len(nums) == 1:\n        ans.append(nums)\n        return ans\n    for i in range(len(nums)):\n        temp = nums[i]\n        nums.remove(temp)\n        for j in permutation(nums):\n            ans.append([temp] + j)\n        nums.insert(i, temp)\n    return ans\n",
        "def permutation(nums):\n    ans = []\n    if len(nums) == 0:\n        return ans\n    if len(nums) == 1:\n        ans.append(nums)\n        return ans\n    for i in range(len(nums)):\n        nums_copy = nums[:]\n        nums_copy.pop(i)\n        for j in permutation(nums_copy):\n            ans.append([nums[i]] + j)\n    return ans\n",
        "def permutation_sequence(nums):\n    nums.sort()\n    ans = []\n    for i in range(len(nums)):\n        ans.append(nums.index(i) + 1)\n        nums[nums.index(i)] = -1\n    return ans\n",
        "def permutation_in_index(nums):\n    ans = [0] * len(nums)\n    for i in range(len(nums)):\n        ans[nums[i]] = i\n    return ans\n",
        "def buildArray(nums, n):\n    ans = []\n    for i in range(n):\n        ans.append(i+1)\n        if i+1 != nums[i]:\n            ans.append(nums[i])\n    return ans\n",
        "def permute_zeros(nums):\n    zeros = []\n    for i in range(len(nums)):\n        if nums[i] == 0:\n            zeros.append(i)\n    for i in range(len(zeros)):\n        nums.remove(0)\n        nums.insert(zeros[i], 0)\n    return nums\n"
    ],
    "results": 10
},{
    "id": "1819",
    "source": "leetcode",
    "language": "python",
    "query": "Each character signifies whether the student was absent, late, or present on that day. Return true if the student is eligible for an attendance award, or false otherwise.",
    "snippets": [
        "def attendance_award(attendance):\n    if attendance.count('A') > 1:\n        return False\n    if attendance.count('L') > 1:\n        return False\n    if attendance.count('P') > 1:\n        return False\n    if attendance.count('A') == 1 and attendance.count('L') == 1:\n        return False\n    if attendance.count('A') == 1 and attendance.count('P') == 1:\n        return False\n    if attendance.count('L') == 1 and attendance.count('P') == 1:\n        return False\n    return True\n",
        "def attendance_award(s):\n    if len(s) < 3:\n        return False\n    if s[0] == 'A':\n        return False\n    if s[0] == 'L' and s[1] == 'L':\n        return False\n    if s[0] == 'P' and s[1] == 'P':\n        return False\n    if s[1] == 'L' and s[2] == 'L':\n        return False\n    if s[1] == 'P' and s[2] == 'P':\n        return False\n    return True\n",
        "def attendance_award(attendance):\n    if attendance.count('A') > 1:\n        return False\n    if attendance.count('L') > 1:\n        return False\n    if attendance.count('A') == 1 and attendance.count('L') == 1:\n        return False\n    return True\n",
        "def attendance_award(attendance):\n    if attendance == 'PPPPPPPPP':\n        return True\n    elif attendance == 'PPPPPPPPP':\n        return True\n    elif attendance == 'PPPPPPP':\n        return True\n    elif attendance == 'PPPPPP':\n        return True\n    elif attendance == 'PPPPP':\n        return True\n    elif attendance == 'PPPP':\n        return True\n    elif attendance == 'PPP':\n        return True\n    elif attendance == 'PP':\n        return True\n    elif attendance == 'P':\n        return True\n    else:\n        return False\n",
        "def attendance_award(attendance):\n    if attendance.count('A') > 1:\n        return False\n    if attendance.count('L') > 2:\n        return False\n    if attendance.count('A') == 1 and attendance.count('L') == 2:\n        return False\n    return True\n",
        "def attendance_award(attendance):\n    return True if attendance.count('A') < 3 else False\n"
    ],
    "results": 6
},{
    "id": "1820",
    "source": "leetcode",
    "language": "python",
    "query": "There are n people, each person has a unique id between 0 and n-1. Given your id and the level of videos, return the list of videos ordered by their frequencies. For videos with the same frequency order them alphabetically from least to greatest.",
    "snippets": [
        "def videos_by_frequency(id, videos):\n    # Write your code here.\n    videos_dict = {}\n    for video in videos:\n        if video in videos_dict:\n            videos_dict[video] += 1\n        else:\n            videos_dict[video] = 1\n    videos_dict = sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))\n    return [video[0] for video in videos_dict]\n    # return videos_dict\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [video[0] for video in sorted(videos_dict.items(), key=lambda\n",
        "def videos_by_frequency(id, videos):\n    # Write your code here.\n    videos_dict = {}\n    for video in videos:\n        if video in videos_dict:\n            videos_dict[video] += 1\n        else:\n            videos_dict[video] = 1\n    videos_dict = sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))\n    return [x[0] for x in videos_dict]\n    # return videos_dict\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(videos_dict.items(), key=lambda\n",
        "def videos(id, videos):\n    # Write your code here\n    videos_dict = {}\n    for video in videos:\n        if video in videos_dict:\n            videos_dict[video] += 1\n        else:\n            videos_dict[video] = 1\n    videos_dict = sorted(videos_dict.items(), key=lambda x: (-x[1], x[0]))\n    return [video[0] for video in videos_dict]\n",
        "def videos(id, videos):\n    # Write your code here\n    videos_dict = {}\n    for i in range(len(videos)):\n        if videos[i] in videos_dict:\n            videos_dict[videos[i]] += 1\n        else:\n            videos_dict[videos[i]] = 1\n    videos_dict = sorted(videos_dict.items(), key=lambda x: (x[1], x[0]))\n    videos_list = []\n    for i in range(len(videos_dict)):\n        videos_list.append(videos_dict[i][0])\n    return videos_list\n",
        "def videosByFrequency(id, videos):\n    # Write your code here.\n    freq = {}\n    for v in videos:\n        if v in freq:\n            freq[v] += 1\n        else:\n            freq[v] = 1\n    freq = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n    return [x[0] for x in freq]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted\n",
        "def videos(id, videos):\n    # Write your code here.\n    videos.sort(key=lambda x: (x[1], x[0]))\n    return [x[0] for x in videos]\n    # return videos\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]))]\n    # return [x[0] for x in sorted(videos, key=lambda x: (x[1], x[0]\n",
        "def videosByFrequency(id, frequency):\n    # Write your code here.\n    videos = []\n    for i in range(len(frequency)):\n        videos.append(str(i))\n    videos.sort(key=lambda x: (frequency[int(x)], x))\n    return videos\n",
        "def videosByFrequency(id, frequency):\n    # Write your code here.\n    freq_dict = {}\n    for i in frequency:\n        if i in freq_dict:\n            freq_dict[i] += 1\n        else:\n            freq_dict[i] = 1\n    freq_list = sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))\n    return [i[0] for i in freq_list]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(freq_dict.items(), key=lambda x: (x[1], x[0]))]\n    # return [i[0] for i in sorted(\n",
        "def videos_by_frequency(id, videos):\n    # Write your code here\n    freq = {}\n    for video in videos:\n        freq[video] = freq.get(video, 0) + 1\n    freq = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n    return [x[0] for x in freq]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x: (-x[1], x[0]))]\n    # return [x[0] for x in sorted(freq.items(), key=lambda x:\n"
    ],
    "results": 9
},{
    "id": "1821",
    "source": "leetcode",
    "language": "python",
    "query": "Since the answer may be large, return the answer modulo 10^9 + 7. Return the number of permutations of 1 to n.",
    "snippets": [
        "def factorial(n):\n    if n == 0:\n        return 1\n    return n * factorial(n - 1)\n",
        "def permutation_number(n):\n    if n == 1:\n        return 1\n    else:\n        return (n * permutation_number(n - 1)) % 1000000007\n",
        "def permute(n):\n    if n == 1:\n        return 1\n    return (n * permute(n - 1)) % 1000000007\n",
        "def permutation_count(n):\n    return factorial(n)\n",
        "def permutation_number(n):\n    if n == 1:\n        return 1\n    return (n * (n - 1)) // 2 + permutation_number(n - 1)\n",
        "def permutation_number(n):\n    return factorial(n)\n",
        "def permutation_count(n):\n    # Write your code here\n    return 0\n",
        "def permutation_sequence(n):\n    # Write your code here\n    return 0\n"
    ],
    "results": 10
},{
    "id": "1822",
    "source": "leetcode",
    "language": "python",
    "query": "If there are two middle nodes, return the second middle node. Given the head of a singly linked list, give the middle node of the linked list.",
    "snippets": [
        "def find_middle(head):\n    if head is None:\n        return None\n    slow = head\n    fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n",
        "def find_middle(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    slow = head\n    fast = head\n    while fast.next is not None and fast.next.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n",
        "def find_middle(head):\n    slow = head\n    fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n",
        "def find_middle(head):\n    if head is None:\n        return None\n    slow = head\n    fast = head\n    while fast.next is not None and fast.next.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n",
        "def middle_node(head):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    slow = head\n    fast = head\n    while fast.next is not None and fast.next.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n"
    ],
    "results": 10
},{
    "id": "1823",
    "source": "leetcode",
    "language": "python",
    "query": "An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.",
    "snippets": [
        "def is_subset(a, b):\n    if len(a) > len(b):\n        return False\n    for i in a:\n        if i not in b:\n            return False\n    return True\n",
        "def is_subset(a, b):\n    if len(a) > len(b):\n        return False\n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n        b.remove(a[i])\n    return True\n",
        "def is_subset(a, b):\n    if len(a) > len(b):\n        return False\n    for i in range(len(a)):\n        if a[i] not in b:\n            return False\n    return True\n",
        "def is_subset(a, b):\n    for i in a:\n        if i not in b:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1824",
    "source": "leetcode",
    "language": "python",
    "query": "Answers within 10-5 of the actual answer will be considered accepted. Return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.",
    "snippets": [
        "def mean(numbers):\n    numbers.sort()\n    smallest = int(len(numbers) * 0.05)\n    largest = int(len(numbers) * 0.95)\n    numbers = numbers[smallest:largest]\n    return sum(numbers) / len(numbers)\n",
        "def mean(numbers):\n    numbers.sort()\n    length = len(numbers)\n    smallest = int(length * 0.05)\n    largest = int(length * 0.95)\n    numbers = numbers[smallest:largest]\n    return sum(numbers) / len(numbers)\n",
        "def mean(numbers):\n    numbers.sort()\n    length = len(numbers)\n    remove = int(length * 0.05)\n    numbers = numbers[remove:-remove]\n    return sum(numbers) / len(numbers)\n",
        "def mean(numbers):\n    numbers.sort()\n    length = len(numbers)\n    if length == 0:\n        return 0\n    if length == 1:\n        return numbers[0]\n    if length == 2:\n        return (numbers[0] + numbers[1]) / 2\n    if length == 3:\n        return (numbers[0] + numbers[1] + numbers[2]) / 3\n    if length == 4:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3]) / 4\n    if length == 5:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3] + numbers[4]) / 5\n    if length == 6:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3] + numbers[4] + numbers[5]) / 6\n    if length == 7:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3] + numbers[4] + numbers[5] + numbers[6]) / 7\n    if length == 8:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3] + numbers[4] + numbers[5] + numbers[6] + numbers[7]) / 8\n    if length == 9:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3] + numbers[4] + numbers[5] + numbers[6] + numbers[7] + numbers[8]) / 9\n    if length == 10:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3] + numbers[4] + numbers[5] + numbers[6] + numbers[7] + numbers[8] + numbers[9]) / 10\n    if length == 11:\n        return (numbers[0] + numbers[1] + numbers[2] + numbers[3] + numbers[4] + numbers[5] + numbers[6] + numbers[7] + numbers[8] + numbers[9] + numbers[10]) /\n",
        "def mean(numbers):\n    numbers.sort()\n    length = len(numbers)\n    if length <= 1:\n        return numbers[0]\n    elif length == 2:\n        return (numbers[0] + numbers[1]) / 2\n    else:\n        return (numbers[int(length * 0.05)] + numbers[int(length * 0.95)]) / 2\n"
    ],
    "results": 10
},{
    "id": "1825",
    "source": "leetcode",
    "language": "python",
    "query": "A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born. The kingdom has a well-defined order of inheritance.",
    "snippets": [
        "def get_kingdom_inheritance_tree(kingdom):\n    \"\"\"\n    :param kingdom: A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born. The kingdom has a well-defined order of inheritance.\n    :return: A list representing the kingdom's inheritance tree.\n    \"\"\"\n    if kingdom is None:\n        return []\n    if kingdom.get('king') is None:\n        return []\n    if kingdom.get('children') is None:\n        return [kingdom.get('king')]\n    return [kingdom.get('king')] + [get_kingdom_inheritance_tree(child) for child in kingdom.get('children')]\n",
        "def get_kingdom_inheritance_tree(kingdom):\n    \"\"\"\n    :param kingdom: A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born. The kingdom has a well-defined order of inheritance.\n    :return: A list representing the kingdom's inheritance tree.\n    \"\"\"\n    if kingdom is None:\n        return []\n    if kingdom.get('king') is None:\n        return []\n    if kingdom.get('children') is None:\n        return [kingdom.get('king')]\n    return [kingdom.get('king')] + [get_kingdom_inheritance_tree(child) for child in kingdom.get('children')]\n",
        "def get_kingdom_inheritance_tree(kingdom):\n    \"\"\"\n    :param kingdom: A kingdom consist'A')\n    ['As]\n    >>> get_ of a k_inheritance_tree('ABing, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born. The kingdom has a well-defined order of inheritance.\n    :rA', 'B']\n    >>> get_kingdom_inheritance_tree('ABC')\n    ['A', 'B', 'C']\n    >>> get_eturn: _inheritance_tree(TABCD')\n    ['A'he B', 'C', 'D']\n    >>> get_kingdom_inheritance_tree('ABCDE')\n    ['A', 'B', 'Cdom'D', 'E']\n    >>> get_kingdom_inheritance_tree('ABCDEFG')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n    >>> get_kingdom_inheritance_tree('ABCDEFGH')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHI')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJ')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJK')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJKL')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJKLM')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n",
        "def get_kingdom_inheritance_tree(kingdom):\n    \"\"\"\n    >>> get_kingdom_inheritance_tree('kingdom')\n    ['kingdom', 'king', 's inheritance tree.\n    \"\"\"\n    # Write your code here.\n    if kingdom == []:\n        return []\n    if kingdom[0] == 'king':\n       _kingdom return [kingdom[0]] + get_kingdom_inheritance_tree(kingdom[1])\n    else:\n        am kingdom: r list of naeestrepresenting the urn get\n    _return: a list representing the order in which the names should be printed out\n    \"\"\"\n    # Write your code here.\n    # The kingdom is represented as a list of names.\n    # The orderkof the nimesnin the list is the orger dn whioh mhe names should be pr_nted iut.\n    # The first nhme in the list is the name of the king.\n    # The next names in the list are the names of the childeen of the king.\n    # The next names in the list are the names of the grandchildren of the king.\n    # The next names in the list are the names of the great grandchildren of the king.\n    # The next names in the list are the names of the great great grandchildren of the king.\n    # The next names in the list are the names of the great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names\n",
        "def get_inheritance_order(kingdom):\n    \"\"\"\n    :param kingdom: a dictionarritance_tree(kingdom[1]) + get_kingdom_inheritance_tree(kingdom[2])\n",
        "def get_kingdom_inheritance_tree(kingdom):\n    \"\"\"\n    >>> get_kingdom_inheritance_tree('A')\n    ['A']\n    >>> get_kingdom_inheritance_tree('AB')\n    ['A', 'B']\n    >>> get_kingdom_inheritance_tree('ABC')\n    ['A', 'B', 'C']\n    >>> get_kingdom_inheritance_tree('ABCD')\n    ['A', 'B', 'C', 'D']\n    >>> get_kingdom_inheritance_tree('ABCDE')\n    ['A', 'B', 'C', 'D', 'E']\n    >>> get_kingdom_inheritance_tree('ABCDEFG')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n    >>> get_kingdom_inheritance_tree('ABCDEFGH')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHI')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G',m_na e':\n    # Write your code here.\n    if kingdom_name == 'animals':\n        return ['dogs', 'cats', 'birds']\n    elif kingdom_name == 'plants':\n        return ['trees', 'shrubs', 'flowers']\n    elif kingdom_name == 'animals,plants':\n        return ['dogs', 'cats', 'birds', 'trees', 'shrubs', 'flowers']\n    elif kingdom_name == 'animals,plants,animals'H', 'I']\n        return ['dogs', 'cats', 'birds', 'trees', 'shrubs', 'flowers', 'dogs']\n    elif kingdom_name == 'animals,plants,animals,plants':\n        return ['dogs', 'cats', 'birds', 'trees', 'shrubs', 'flowers', 'dogs', 'trees', 'shrubs', 'flowers']\n    elif kingdom_name == 'animals,plants,animals,plants,animals':\n        return ['dogs', 'cats', 'birds', 'trees', 'shrubs', 'flowers', 'dogs', 'trees', 'shrubs', 'flowers', 'dogs']\n    elif kingdom_name == 'animals,plants,animals,plants,animals,plants':\n        return ['dogs', 'cats', 'birds', 'trees', 'shrubs', 'flowers', 'dogs', 'trees', 'shrubs', 'flowers', 'dogs', 'trees', 'shrubs', 'flowers']\n    elif kingdom_name == 'animals,plants,animals,plants,animals,plants,animals':\n        return ['dogs', 'cats', 'birds', 'trees', 'shrubs', 'flowers', 'dogs', 'trees', 'shrubs', 'flowers', 'dogs', 'trees', 'shrubs', 'flowers', 'dogs']\n    elif kingdom_name == 'animals,plants,animals,plants,animals,plants,animals,plants':\n        return ['dogs', 'cats', 'birds', 't\n",
        "def get_kingdom_inheritance_tree(kingdom):\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJ')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJK')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJKL')= kingdom]\n",
        "def get_inheritance_order(kingdom):\n    \"\"\"\n    :param kingdom: a string representing the kingdom\n    :return: a list representing the order of inheritance\n    \"\"\"\n    if kingdom == '':\n        return []\n    if kingdom == 'king':\n        return ['king']\n    if kingdom == 'queen':\n        return ['queen']\n    if kingdom == 'prince':\n        return ['prince']\n    if kingdom == 'princess':\n        return ['princess']\n    if kingdom == 'kingdom':\n        return ['king', 'queen', 'prince', 'princess']\n    if kingdom == 'kingdom_without_princess':\n        return ['king', 'queen', 'prince']\n    if kingdom == 'kingdom_without_prince':\n        return ['king', 'queen', 'princess']\n    if kingdom == 'kingdom_without_queen':\n        return ['king', 'prince', 'princess']\n    if kingdom == 'kingdom_without_king':\n        return ['queen', 'prince', 'princess']\n    if kingdom == 'kingdom_without_princess_and_prince':\n        return ['king', 'queen']\n    if kingdom == 'kingdom_without_prince_and_princess':\n        return ['king', 'queen']\n    if kingdom == 'kingdom_without_king_and_princess':\n        return ['queen', 'prince']\n    if kingdom ='_without_king_and_prince':\n        return ['queen', 'princess'\n    if kingdom == 'kingdom_without_king_and_queen':\n        return ['prince', 'princess']\n    if kingdom == 'kingdom_without_king_and_prince_and_princess':\n        return ['queen']\n    if kingdom == 'kingdom_without_king_and_queen_and_prince':\n        return ['princess']\n    if kingdom == 'kingdom_without_king_and_queen_and_princess':\n        return ['\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L']\n    >>> get_kingdom_inheritance_tree('ABCDEFGHIJKLM')\n    ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n",
        "def get_kingdom_inheritance_tree(kingdom):\n    \"\"\"\n    >>> get_kingdom_inheritance_tree('kingdom')\n    ['kingdom', 'king', 'queen', 'prince', 'princess']\n    \"\"\"\n    return [kingdom] + get_children(kingdom)\n",
        "def get_kingdom_inheritance_order(kingdom):\n    \"\"\"\n    :param kingdom: a list of names representing the kingdom\n    :return: a list representing the order in which the names should be printed out\n    \"\"\"\n    # Write your code here.\n    # The kingdom is represented as a list of names.\n    # The order of the names in the list is the order in which the names should be printed out.\n    # The first name in the list is the name of the king.\n    # The next names in the list are the names of the children of the king.\n    # The next names in the list are the names of the grandchildren of the king.\n    # The next names in the list are the names of the great grandchildren of the king.\n    # The next names in the list are the names of the great great grandchildren of the king.\n    # The next names in the list are the names of the great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names of the great great great great great great great great great great great great great grandchildren of the king.\n    # The next names in the list are the names\n",
        "def get_inheritance_order(kingdom):\n    \"\"\"\n    :param kingdom: a dictionary representing the kingdom\n    :return: a list representing the order of inheritance\n    \"\"\"\n    # Write your code here.\n    if kingdom is None:\n        return None\n    if len(kingdom) == 0:\n        return []\n    if len(kingdom) == 1:\n        return list(kingdom.keys())\n    inheritance_order = []\n    for key in kingdom:\n        if key not in inheritance_order:\n            inheritance_order.append(key)\n            for child in kingdom[key]:\n                if child not in inheritance_order:\n                    inheritance_order.append(child)\n    return inheritance_order\n",
        "def get_kingdom_inheritance_tree(kingdom):\n    \"\"\"\n    :param kingdom: a string representing the kingdom\n    :return: a list representing the kingdom's inheritance tree\n    \"\"\"\n    return [kingdom] + [child for child in kingdom.split() if child != kingdom]\n",
        "def get_inheritance_order(kingdom):\n    \"\"\"\n    :param kingdom: a string representing the kingdom\n    :return: a list representing the order of inheritance\n    \"\"\"\n    if kingdom == '':\n        return []\n    if kingdom == 'king':\n        return ['king']\n    if kingdom == 'queen':\n        return ['queen']\n    if kingdom == 'prince':\n        return ['prince']\n    if kingdom == 'princess':\n        return ['princess']\n    if kingdom == 'kingdom':\n        return ['king', 'queen', 'prince', 'princess']\n    if kingdom == 'kingdom_without_princess':\n        return ['king', 'queen', 'prince']\n    if kingdom == 'kingdom_without_prince':\n        return ['king', 'queen', 'princess']\n    if kingdom == 'kingdom_without_queen':\n        return ['king', 'prince', 'princess']\n    if kingdom == 'kingdom_without_king':\n        return ['queen', 'prince', 'princess']\n    if kingdom == 'kingdom_without_princess_and_prince':\n        return ['king', 'queen']\n    if kingdom == 'kingdom_without_prince_and_princess':\n        return ['king', 'queen']\n    if kingdom == 'kingdom_without_king_and_princess':\n        return ['queen', 'prince']\n    if kingdom == 'kingdom_without_king_and_prince':\n        return ['queen', 'princess']\n    if kingdom == 'kingdom_without_king_and_queen':\n        return ['prince', 'princess']\n    if kingdom == 'kingdom_without_king_and_prince_and_princess':\n        return ['queen']\n    if kingdom == 'kingdom_without_king_and_queen_and_prince':\n        return ['princess']\n    if kingdom == 'kingdom_without_king_and_queen_and_princess':\n        return ['\n",
        "def get_kingdom_inheritance_tree(kingdom_name):\n    # kingdom_name: string\n    # return: list of strings\n    # This function should return a list of strings representing the kingdom's inheritance tree.\n    # The list should be ordered by inheritance, with the first element in the list being the name of the king, and the last element being the name of the root of the family tree.\n    # For example, the list for the kingdom of Hogsmeade might be:\n    # ['Arthur', 'Lancelot', 'Gawain', 'Gawain', 'Arthur']\n    # The list for the kingdom of Minas Tirith might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of Durthadain might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of Rivendell might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of Lothlorien might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of Gondor might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of Rohan might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of Arnor might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of the Iron Hills might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of the Riverlands might be:\n    # ['Theodred', 'Bedevere', 'Bedevere', 'Theodred']\n    # The list for the kingdom of the Anduin Valley might be:\n    # ['Theodred\n"
    ],
    "results": 10
},{
    "id": "1826",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, break it into the sum of k positive integers, where k >= 2. Return the maximum product you can get.",
    "snippets": [
        "def integerBreak(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 4\n    if n == 5:\n        return 6\n    if n == 6:\n        return 9\n    if n == 7:\n        return 12\n    if n == 8:\n        return 16\n    if n == 9:\n        return 18\n    if n == 10:\n        return 20\n    if n == 11:\n        return 22\n    if n == 12:\n        return 24\n    if n == 13:\n        return 26\n    if n == 14:\n        return 28\n    if n == 15:\n        return 30\n    if n == 16:\n        return 32\n    if n == 17:\n        return 34\n    if n == 18:\n        return 36\n    if n == 19:\n        return 38\n    if n == 20:\n        return 40\n    if n == 21:\n        return 42\n    if n == 22:\n        return 44\n    if n == 23:\n        return 46\n    if n == 24:\n        return 48\n    if n == 25:\n        return 50\n    if n == 26:\n        return 52\n    if n == 27:\n        return 54\n    if n == 28:\n        return 56\n    if n == 29:\n        return 58\n    if n == 30:\n        return 60\n    if n == 31:\n        return 62\n    if n == 32:\n        return 64\n    if n == 33:\n        return 66\n    if n == 34:\n        return 68\n    if n == 35:\n        return 70\n    if n == 36:\n        return 72\n    if n == 37:\n        return 74\n    if n == 38:\n        return 76\n    if n == 39:\n        return 78\n    if n == 40:\n        return 80\n    if n == 41:\n        return 82\n    if n == 42:\n        return 84\n    if n == 43:\n        return 86\n    if n == 44:\n        return 88\n    if n == 45:\n        return 90\n    if n == 46:\n        return\n",
        "def max_product(n, k):\n    if n < k:\n        return 0\n    if k == 1:\n        return n\n    if k == 2:\n        return n * (n - 1) // 2\n    if k == 3:\n        return n * (n - 1) * (n - 2) // 6\n    if k == 4:\n        return n * (n - 1) * (n - 2) * (n - 3) // 24\n    if k == 5:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) // 120\n    if k == 6:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) // 720\n    if k == 7:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) // 5040\n    if k == 8:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) // 40320\n    if k == 9:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) // 362880\n    if k == 10:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) // 3628800\n    if k == 11:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) // 39916800\n",
        "def maxProduct(n, k):\n    \"\"\"\n    :type n: int\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if n < k:\n        return 0\n    if n == k:\n        return k\n    if n == k + 1:\n        return n\n    if n == k * k:\n        return n\n    if n == k * (k + 1):\n        return n\n    if n == k * (k + 2):\n        return n\n    if n == k * (k + 3):\n        return n\n    if n == k * (k + 4):\n        return n\n    if n == k * (k + 5):\n        return n\n    if n == k * (k + 6):\n        return n\n    if n == k * (k + 7):\n        return n\n    if n == k * (k + 8):\n        return n\n    if n == k * (k + 9):\n        return n\n    if n == k * (k + 10):\n        return n\n    if n == k * (k + 11):\n        return n\n    if n == k * (k + 12):\n        return n\n    if n == k * (k + 13):\n        return n\n    if n == k * (k + 14):\n        return n\n    if n == k * (k + 15):\n        return n\n    if n == k * (k + 16):\n        return n\n    if n == k * (k + 17):\n        return n\n    if n == k * (k + 18):\n        return n\n    if n == k * (k + 19):\n        return n\n    if n == k * (k + 20):\n        return n\n    if n == k * (k + 21):\n        return n\n    if n == k * (k + 22):\n        return n\n    if n == k * (k + 23):\n        return n\n    if n == k * (k + 24):\n        return n\n    if n == k * (k + 25):\n        return n\n    if n == k * (k + 26):\n        return n\n",
        "def split_integer(n, k):\n    if n < k:\n        return 0\n    if k == 1:\n        return n\n    if k == 2:\n        return n // 2\n    if k == 3:\n        return n // 3\n    if k == 4:\n        return n // 4\n    if k == 5:\n        return n // 5\n    if k == 6:\n        return n // 6\n    if k == 7:\n        return n // 7\n    if k == 8:\n        return n // 8\n    if k == 9:\n        return n // 9\n    if k == 10:\n        return n // 10\n    if k == 11:\n        return n // 11\n    if k == 12:\n        return n // 12\n    if k == 13:\n        return n // 13\n    if k == 14:\n        return n // 14\n    if k == 15:\n        return n // 15\n    if k == 16:\n        return n // 16\n    if k == 17:\n        return n // 17\n    if k == 18:\n        return n // 18\n    if k == 19:\n        return n // 19\n    if k == 20:\n        return n // 20\n    if k == 21:\n        return n // 21\n    if k == 22:\n        return n // 22\n    if k == 23:\n        return n // 23\n    if k == 24:\n        return n // 24\n    if k == 25:\n        return n // 25\n    if k == 26:\n        return n // 26\n    if k == 27:\n        return n // 27\n    if k == 28:\n        return n // 28\n    if k == 29:\n        return n // 29\n    if k == 30:\n        return n // 30\n    if k == 31:\n        return n // 31\n    if k == 32:\n        return n // 32\n    if k == 33:\n        return n // 33\n    if k == 34:\n        return n // 34\n    if k == 35:\n        return n // 35\n    if k == 36:\n        return n // 36\n    if k == 37:\n        return n // 37\n",
        "def max_product(n, k):\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    if k == 1:\n        return n\n    if k == 2:\n        return n * (n - 1) // 2\n    if k == 3:\n        return n * (n - 1) * (n - 2) // 6\n    if k == 4:\n        return n * (n - 1) * (n - 2) * (n - 3) // 24\n    if k == 5:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) // 120\n    if k == 6:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) // 720\n    if k == 7:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) // 5040\n    if k == 8:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) // 40320\n    if k == 9:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) // 362880\n    if k == 10:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) // 3628800\n    if k == 11:\n        return n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9)\n",
        "def break_int(n, k):\n    if n <= 0 or k <= 1:\n        return 0\n    if n < k:\n        return 0\n    if n == k:\n        return n\n    if n == 2*k:\n        return n\n    if n == 3*k:\n        return n\n    if n == 4*k:\n        return n\n    if n == 5*k:\n        return n\n    if n == 6*k:\n        return n\n    if n == 7*k:\n        return n\n    if n == 8*k:\n        return n\n    if n == 9*k:\n        return n\n    if n == 10*k:\n        return n\n    if n == 11*k:\n        return n\n    if n == 12*k:\n        return n\n    if n == 13*k:\n        return n\n    if n == 14*k:\n        return n\n    if n == 15*k:\n        return n\n    if n == 16*k:\n        return n\n    if n == 17*k:\n        return n\n    if n == 18*k:\n        return n\n    if n == 19*k:\n        return n\n    if n == 20*k:\n        return n\n    if n == 21*k:\n        return n\n    if n == 22*k:\n        return n\n    if n == 23*k:\n        return n\n    if n == 24*k:\n        return n\n    if n == 25*k:\n        return n\n    if n == 26*k:\n        return n\n    if n == 27*k:\n        return n\n    if n == 28*k:\n        return n\n    if n == 29*k:\n        return n\n    if n == 30*k:\n        return n\n    if n == 31*k:\n        return n\n    if n == 32*k:\n        return n\n    if n == 33*k:\n        return n\n    if n == 34*k:\n        return n\n    if n == 35*k:\n        return n\n    if n == 36*k:\n        return\n",
        "def break_integer(n, k):\n    if n < 1 or k < 2:\n        return 0\n    if n < k:\n        return 0\n    if n == k:\n        return n\n    if n == k * (k - 1) / 2:\n        return n\n    if n == k * (k - 1) / 2 + 1:\n        return n\n    if n == k * (k - 1) / 2 + 2:\n        return n\n    if n == k * (k - 1) / 2 + 3:\n        return n\n    if n == k * (k - 1) / 2 + 4:\n        return n\n    if n == k * (k - 1) / 2 + 5:\n        return n\n    if n == k * (k - 1) / 2 + 6:\n        return n\n    if n == k * (k - 1) / 2 + 7:\n        return n\n    if n == k * (k - 1) / 2 + 8:\n        return n\n    if n == k * (k - 1) / 2 + 9:\n        return n\n    if n == k * (k - 1) / 2 + 10:\n        return n\n    if n == k * (k - 1) / 2 + 11:\n        return n\n    if n == k * (k - 1) / 2 + 12:\n        return n\n    if n == k * (k - 1) / 2 + 13:\n        return n\n    if n == k * (k - 1) / 2 + 14:\n        return n\n    if n == k * (k - 1) / 2 + 15:\n        return n\n    if n == k * (k - 1) / 2 + 16:\n        return n\n    if n == k * (k - 1) / 2 + 17:\n        return n\n    if n == k * (k - 1) / 2 + 18:\n        return n\n    if n == k * (k - 1) / 2 + 19:\n        return n\n    if n == k * (k - 1) / 2 + 20:\n        return n\n    if n == k * (k - 1) / 2 +\n",
        "def maxProduct(n, k):\n    if n < k:\n        return 0\n    if n == k:\n        return 1\n    if n == k + 1:\n        return n\n    if n == k * k:\n        return n\n    if n == k * (k + 1):\n        return n\n    if n == k * (k + 2):\n        return n\n    if n == k * (k + 3):\n        return n\n    if n == k * (k + 4):\n        return n\n    if n == k * (k + 5):\n        return n\n    if n == k * (k + 6):\n        return n\n    if n == k * (k + 7):\n        return n\n    if n == k * (k + 8):\n        return n\n    if n == k * (k + 9):\n        return n\n    if n == k * (k + 10):\n        return n\n    if n == k * (k + 11):\n        return n\n    if n == k * (k + 12):\n        return n\n    if n == k * (k + 13):\n        return n\n    if n == k * (k + 14):\n        return n\n    if n == k * (k + 15):\n        return n\n    if n == k * (k + 16):\n        return n\n    if n == k * (k + 17):\n        return n\n    if n == k * (k + 18):\n        return n\n    if n == k * (k + 19):\n        return n\n    if n == k * (k + 20):\n        return n\n    if n == k * (k + 21):\n        return n\n    if n == k * (k + 22):\n        return n\n    if n == k * (k + 23):\n        return n\n    if n == k * (k + 24):\n        return n\n    if n == k * (k + 25):\n        return n\n    if n == k * (k + 26):\n        return n\n    if n == k * (k + 27):\n        return n\n    if n == k * (k + 28):\n"
    ],
    "results": 10
},{
    "id": "1827",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[ i] == 0 instead.",
    "snippets": [
        "def dailyTemperatures(temperatures):\n    answer = [0] * len(temperatures)\n    stack = []\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            j = stack.pop()\n            answer[j] = i - j\n        stack.append(i)\n    return answer\n",
        "def dailyTemperatures(temperatures):\n    stack = []\n    ans = [0] * len(temperatures)\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            index = stack.pop()\n            ans[index] = i - index\n        stack.append(i)\n    return ans\n",
        "def dailyTemperatures(temperatures):\n    # Write your code here.\n    ans = [0] * len(temperatures)\n    stack = []\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            index = stack.pop()\n            ans[index] = i - index\n        stack.append(i)\n    return ans\n",
        "def dailyTemperatures(temperatures):\n    answer = [0] * len(temperatures)\n    stack = []\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] >= temperatures[stack[-1]]:\n            stack.pop()\n        if stack:\n            answer[i] = stack[-1] - i\n        stack.append(i)\n    return answer\n",
        "def dailyTemperatures(temperatures):\n    \"\"\"\n    :type temperatures: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not temperatures:\n        return []\n    ans = [0] * len(temperatures)\n    stack = []\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            ans[stack[-1]] = i - stack[-1]\n            stack.pop()\n        stack.append(i)\n    return ans\n",
        "def dailyTemperatures(temperatures):\n    # Write your code here.\n    stack = []\n    ans = [0] * len(temperatures)\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            curr = stack.pop()\n            ans[curr] = i - curr\n        stack.append(i)\n    return ans\n",
        "def dailyTemperatures(temperatures):\n    \"\"\"\n    :type temperatures: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not temperatures:\n        return []\n    stack = []\n    ans = [0] * len(temperatures)\n    for i in range(len(temperatures)):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            ans[stack[-1]] = i - stack[-1]\n            stack.pop()\n        stack.append(i)\n    return ans\n",
        "def dailyTemperatures(temperatures):\n    \"\"\"\n    :type temperatures: List[int]\n    :rtype: List[int]\n    \"\"\"\n    n = len(temperatures)\n    ans = [0] * n\n    stack = []\n    for i in range(n):\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            j = stack.pop()\n            ans[j] = i - j\n        stack.append(i)\n    return ans\n",
        "def dailyTemperatures(temperatures):\n    \"\"\"\n    :type temperatures: List[int]\n    :rtype: List[int]\n    \"\"\"\n    # initialize answer array\n    answer = [0] * len(temperatures)\n    # initialize stack\n    stack = []\n    # iterate through temperatures\n    for i in range(len(temperatures)):\n        # if stack is empty or temperatures[i] is greater than the top of the stack\n        if not stack or temperatures[i] > temperatures[stack[-1]]:\n            # push i onto stack\n            stack.append(i)\n        # if temperatures[i] is less than the top of the stack\n        else:\n            # while stack is not empty and temperatures[i] is less than the top of the stack\n            while stack and temperatures[i] < temperatures[stack[-1]]:\n                # pop the top of the stack\n                top = stack.pop()\n                # set answer[top] to the difference between i and top\n                answer[top] = i - top\n                # if stack is empty, break\n                if not stack:\n                    break\n    return answer\n"
    ],
    "results": 10
},{
    "id": "1828",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array nums of integers, a move consists of choosing any element and decreasing it by 1. An array A is a zigzag array if either:Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > a[3] < a[4] > ....",
    "snippets": [
        "def isZigZag(nums):\n    if len(nums) < 2:\n        return True\n    if len(nums) == 2:\n        return nums[0] > nums[1]\n    if nums[0] > nums[1]:\n        return False\n    for i in range(2, len(nums)):\n        if nums[i] < nums[i-1] and nums[i-1] > nums[i-2]:\n            return False\n    return True\n",
        "def isZigZag(nums):\n    if len(nums) < 2:\n        return True\n    if len(nums) == 2:\n        return nums[0] > nums[1]\n    if nums[0] > nums[1]:\n        return False\n    for i in range(2, len(nums)):\n        if i % 2 == 0:\n            if nums[i] < nums[i - 1]:\n                return False\n        else:\n            if nums[i] > nums[i - 1]:\n                return False\n    return True\n",
        "def isZigZag(nums):\n    if len(nums) < 2:\n        return True\n    if len(nums) == 2:\n        return nums[0] > nums[1]\n    if nums[0] > nums[1]:\n        return False\n    for i in range(1, len(nums) - 1):\n        if nums[i] > nums[i + 1] and nums[i - 1] > nums[i]:\n            return False\n    return True\n",
        "def isZigZag(nums):\n    if len(nums) < 2:\n        return True\n    for i in range(1, len(nums)):\n        if i % 2 == 0:\n            if nums[i] < nums[i - 1]:\n                return False\n        else:\n            if nums[i] > nums[i - 1]:\n                return False\n    return True\n",
        "def isZigZag(nums):\n    if len(nums) < 2:\n        return True\n    for i in range(1, len(nums)):\n        if i % 2 == 1:\n            if nums[i] < nums[i - 1]:\n                return False\n        else:\n            if nums[i] > nums[i - 1]:\n                return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1829",
    "source": "leetcode",
    "language": "python",
    "query": "For each person i, preferences[i] contains a list of friends sorted in the order of preference. Friends in each list are denoted by integers from 0 to n-1. A friend x is unhappy if x is paired with y and there exists a friend u who is paired. with v but: X prefers u over y, and u prefers x over v.",
    "snippets": [
        "def unhappy(preferences):\n    n = len(preferences)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i != j and i != k and j != k and preferences[i][j] == k and preferences[j][k] == i and preferences[k][i] == j:\n                    return True\n    return False\n",
        "def unhappy(preferences):\n    n = len(preferences)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i != j and i != k and j != k:\n                    if preferences[i][j] == k and preferences[j][k] == i and preferences[k][i] == j:\n                        return True\n    return False\n",
        "def unhappyFriends(n, preferences):\n    # Write your code here\n    unhappy = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if preferences[i][j] == preferences[j][i]:\n                    unhappy.append(i)\n                    break\n    return unhappy\n",
        "def unhappyFriends(preferences):\n    # Write your code here.\n    n = len(preferences)\n    unhappy = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if preferences[i][j] == preferences[j][i]:\n                    unhappy.append((i, j))\n    return unhappy\n",
        "def unhappy(preferences):\n    n = len(preferences)\n    unhappy = [False] * n\n    for i in range(n):\n        for j in range(n):\n            if i != j and preferences[i][j] == j:\n                unhappy[i] = True\n                break\n    return unhappy\n",
        "def unhappy(preferences):\n    n = len(preferences)\n    for i in range(n):\n        for j in range(n):\n            if i != j and preferences[i][j] == j:\n                return True\n    return False\n",
        "def unhappy(preferences):\n    n = len(preferences)\n    for i in range(n):\n        for j in range(n):\n            if i != j and j in preferences[i]:\n                for k in range(n):\n                    if k != i and k != j and k in preferences[j]:\n                        if preferences[i].index(j) < preferences[j].index(k):\n                            return True\n    return False\n",
        "def unhappy(preferences):\n    n = len(preferences)\n    unhappy = [False] * n\n    for i in range(n):\n        for j in range(n):\n            if j != i and preferences[i][j] == i:\n                unhappy[i] = True\n                break\n    return unhappy\n",
        "def unhappy(preferences, n):\n    for i in range(n):\n        for j in range(n):\n            if i != j and i != preferences[j][0] and j != preferences[i][0]:\n                if preferences[i][0] == preferences[j][1] or preferences[j][0] == preferences[i][1]:\n                    return True\n    return False\n",
        "def unhappy(preferences, pairs):\n    unhappy = set()\n    for i in range(len(prefs)):\n        for j in range(len(prefs[i])):\n            if prefs[i][j] in pairs:\n                unhappy.add(i)\n                break\n    return unhappy\n"
    ],
    "results": 10
},{
    "id": "1830",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, return any array containing n unique integers such that they add up to 0.",
    "snippets": [
        "def sumZero(n):\n    if n == 1:\n        return [0]\n    else:\n        return [i for i in range(-n//2, n//2+1) if i != 0]\n",
        "def sumZero(n):\n    if n == 1:\n        return [0]\n    else:\n        return [i for i in range(1, n)] + [-i for i in range(1, n)]\n",
        "def sumZero(n):\n    if n == 1:\n        return [0]\n    else:\n        return [i for i in range(1, n) if i == n-i]\n",
        "def sumzero(n):\n    for i in range(n):\n        for j in range(n):\n            if i + j == -n:\n                return [i, j]\n    return None\n",
        "def sum_zero(n):\n    # Your code here\n    arr = []\n    for i in range(n):\n        arr.append(i)\n    for i in range(n):\n        for j in range(i+1, n):\n            if arr[i] + arr[j] == 0:\n                return [arr[i], arr[j]]\n    return []\n"
    ],
    "results": 10
},{
    "id": "1831",
    "source": "leetcode",
    "language": "python",
    "query": "The deletion can be divided into two stages:Search for a node to remove. If the node is found, delete the node. Return the root node reference (possibly updated) of the BST.",
    "snippets": [
        "def deleteNode(root, key):\n    if root is None:\n        return root\n    if key < root.data:\n        root.left = deleteNode(root.left, key)\n    elif key > root.data:\n        root.right = deleteNode(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n        temp = minValueNode(root.right)\n        root.data = temp.data\n        root.right = deleteNode(root.right, temp.data)\n    return root\n",
        "def delete_node(root, key):\n    if root is None:\n        return root\n    if key < root.data:\n        root.left = delete_node(root.left, key)\n    elif key > root.data:\n        root.right = delete_node(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n        temp = min_value_node(root.right)\n        root.data = temp.data\n        root.right = delete_node(root.right, temp.data)\n    return root\n",
        "def deleteNode(root, key):\n    if root is None:\n        return root\n    if key < root.key:\n        root.left = deleteNode(root.left, key)\n    elif key > root.key:\n        root.right = deleteNode(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n        temp = minValueNode(root.right)\n        root.key = temp.key\n        root.right = deleteNode(root.right, temp.key)\n    return root\n",
        "def delete_node(root, key):\n    if root is None:\n        return None\n    if key < root.data:\n        root.left = delete_node(root.left, key)\n    elif key > root.data:\n        root.right = delete_node(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n        temp = min_value_node(root.right)\n        root.data = temp.data\n        root.right = delete_node(root.right, temp.data)\n    return root\n",
        "def delete(root, key):\n    if root is None:\n        return None\n    if key < root.data:\n        root.left = delete(root.left, key)\n    elif key > root.data:\n        root.right = delete(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n        temp = minValueNode(root.right)\n        root.data = temp.data\n        root.right = delete(root.right, temp.data)\n    return root\n",
        "def deleteNode(root, key):\n    if root is None:\n        return root\n    if key < root.val:\n        root.left = deleteNode(root.left, key)\n    elif key > root.val:\n        root.right = deleteNode(root.right, key)\n    else:\n        if root.left is None:\n            temp = root.right\n            root = None\n            return temp\n        elif root.right is None:\n            temp = root.left\n            root = None\n            return temp\n        temp = minValueNode(root.right)\n        root.val = temp.val\n        root.right = deleteNode(root.right, temp.val)\n    return root\n"
    ],
    "results": 10
},{
    "id": "1832",
    "source": "leetcode",
    "language": "python",
    "query": "A segment is defined to be a contiguous sequence of non-space characters. Given a string s, return the number of segments in the string.",
    "snippets": [
        "def countSegments(s):\n    return len(s.split())\n",
        "def count_segments(s):\n    return len(s.split())\n",
        "def countSegments(s):\n    return sum(1 for i in s.split() if i)\n"
    ],
    "results": 10
},{
    "id": "1833",
    "source": "leetcode",
    "language": "python",
    "query": "Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that: a < b < c < d.",
    "snippets": [
        "def fourSumCount(self, A, B, C, D):\n    \"\"\"\n    :type A: List[int]\n    :type B: List[int]\n    :type C: List[int]\n    :type D: List[int]\n    :rtype: int\n    \"\"\"\n    d = {}\n    for a in A:\n        for b in B:\n            d[a + b] = d.get(a + b, 0) + 1\n    count = 0\n    for c in C:\n        for d in D:\n            count += dict.get(-(c + d), 0)\n    return count\n",
        "def fourSumCount(self, A, B, C, D):\n    \"\"\"\n    :type A: List[int]\n    :type B: List[int]\n    :type C: List[int]\n    :type D: List[int]\n    :rtype: int\n    \"\"\"\n    count = 0\n    d = {}\n    for a in A:\n        for b in B:\n            d[a+b] = d.get(a+b, 0) + 1\n    for c in C:\n        for d in D:\n            count += d.get(-(c+d), 0)\n    return count\n",
        "def fourSumCount(self, A, B, C, D):\n    \"\"\"\n    :type A: List[int]\n    :type B: List[int]\n    :type C: List[int]\n    :type D: List[int]\n    :rtype: int\n    \"\"\"\n    AB = {}\n    for a in A:\n        for b in B:\n            AB[a+b] = AB.get(a+b, 0) + 1\n    CD = {}\n    for c in C:\n        for d in D:\n            CD[c+d] = CD.get(c+d, 0) + 1\n    count = 0\n    for k in AB:\n        if k in CD:\n            count += AB[k] * CD[k]\n    return count\n",
        "def fourSumCount(self, A, B, C, D):\n    \"\"\"\n    :type A: List[int]\n    :type B: List[int]\n    :type C: List[int]\n    :type D: List[int]\n    :rtype: int\n    \"\"\"\n    d = {}\n    for a in A:\n        for b in B:\n            d[a + b] = d.get(a + b, 0) + 1\n    ans = 0\n    for c in C:\n        for d in D:\n            ans += dict.get(-(c + d), 0)\n    return ans\n",
        "def fourSumCount(self, A, B, C, D):\n    \"\"\"\n    :type A: List[int]\n    :type B: List[int]\n    :type C: List[int]\n    :type D: List[int]\n    :rtype: int\n    \"\"\"\n    # A + B = C + D\n    # A + B = C - D\n    # A + B = D - C\n    # A + B = D + C\n    # A + B = 2 * (C + D)\n    # A + B = 2 * (C - D)\n    # A + B = 2 * (D - C)\n    # A + B = 2 * (D + C)\n    # A + B = 4 * (C + D)\n    # A + B = 4 * (C - D)\n    # A + B = 4 * (D - C)\n    # A + B = 4 * (D + C)\n    # A + B = 8 * (C + D)\n    # A + B = 8 * (C - D)\n    # A + B = 8 * (D - C)\n    # A + B = 8 * (D + C)\n    # A + B = 16 * (C + D)\n    # A + B = 16 * (C - D)\n    # A + B = 16 * (D - C)\n    # A + B = 16 * (D + C)\n    # A + B = 32 * (C + D)\n    # A + B = 32 * (C - D)\n    # A + B = 32 * (D - C)\n    # A + B = 32 * (D + C)\n    # A + B = 64 * (C + D)\n    # A + B = 64 * (C - D)\n    # A + B = 64 * (D - C)\n    # A + B = 64 * (D + C)\n    # A + B = 128 * (C + D)\n    # A + B = 128 * (C - D)\n    # A + B = 128 * (D - C)\n    # A + B = 128 * (D + C)\n",
        "def fourSumCount(self, A, B, C, D):\n    \"\"\"\n    :type A: List[int]\n    :type B: List[int]\n    :type C: List[int]\n    :type D: List[int]\n    :rtype: int\n    \"\"\"\n    dic = {}\n    for a in A:\n        for b in B:\n            dic[a+b] = dic.get(a+b, 0) + 1\n    count = 0\n    for c in C:\n        for d in D:\n            count += dic.get(-(c+d), 0)\n    return count\n",
        "def count_quadruplets(nums):\n    nums.sort()\n    count = 0\n    for i in range(len(nums) - 3):\n        for j in range(i + 1, len(nums) - 2):\n            for k in range(j + 1, len(nums) - 1):\n                if nums[i] + nums[j] + nums[k] > nums[len(nums) - 1]:\n                    break\n                if nums[i] + nums[j] + nums[k] < nums[k + 1]:\n                    count += 1\n    return count\n",
        "def count_quadruplets(nums):\n    nums.sort()\n    count = 0\n    for i in range(len(nums) - 3):\n        for j in range(i + 1, len(nums) - 2):\n            for k in range(j + 1, len(nums) - 1):\n                if nums[i] + nums[j] + nums[k] > nums[len(nums) - 1]:\n                    break\n                if nums[i] + nums[j] + nums[k] == nums[len(nums) - 1]:\n                    count += 1\n    return count\n",
        "def distinct_quadruplets(nums):\n    nums.sort()\n    count = 0\n    for i in range(len(nums) - 3):\n        for j in range(i + 1, len(nums) - 2):\n            for k in range(j + 1, len(nums) - 1):\n                for l in range(k + 1, len(nums)):\n                    if nums[i] + nums[j] + nums[k] + nums[l] == 0:\n                        count += 1\n    return count\n",
        "def fourSumCount(A, B, C, D):\n    AB = {}\n    for a in A:\n        for b in B:\n            AB[a + b] = AB.get(a + b, 0) + 1\n    CD = {}\n    for c in C:\n        for d in D:\n            CD[c + d] = CD.get(c + d, 0) + 1\n    return sum([AB[-c - d] * CD[c + d] for c in C for d in D])\n"
    ],
    "results": 10
},{
    "id": "1834",
    "source": "leetcode",
    "language": "python",
    "query": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
    "snippets": [
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = ''.join(e for e in phrase if e.isalnum())\n    return phrase == phrase[::-1]\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(' ', '')\n    phrase = phrase.replace('.', '')\n    phrase = phrase.replace(',', '')\n    phrase = phrase.replace('!', '')\n    phrase = phrase.replace('?', '')\n    phrase = phrase.replace(':', '')\n    phrase = phrase.replace(';', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('_', '')\n    phrase = phrase.replace('(', '')\n    phrase = phrase.replace(')', '')\n    phrase = phrase.replace('[', '')\n    phrase = phrase.replace(']', '')\n    phrase = phrase.replace('{', '')\n    phrase = phrase.replace('}', '')\n    phrase = phrase.replace('\"', '')\n    phrase = phrase.replace('\\'', '')\n    phrase = phrase.replace('“', '')\n    phrase = phrase.replace('”', '')\n    phrase = phrase.replace('‘', '')\n    phrase = phrase.replace('’', '')\n    phrase = phrase.replace('<', '')\n    phrase = phrase.replace('>', '')\n    phrase = phrase.replace('/', '')\n    phrase = phrase.replace('\\\\', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('*', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('^', '')\n    phrase = phrase.replace('&', '')\n    phrase = phrase.replace('#', '')\n    phrase = phrase.replace('@', '')\n    phrase = phrase.replace('$', '')\n    phrase = phrase.replace('£', '')\n    phrase = phrase.replace('€', '')\n    phrase = phrase.replace('¥', '')\n    phrase = phrase.replace('¢', ''\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(' ', '')\n    phrase = phrase.replace('.',]\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(' ', '')\n    phrase = phrase.replace('.', '')\n    phrase = phrase.replace(',', '')\n    phrase = phrase.replace('!', '')\n    phrase = phrase.replace('?', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('_', '')\n    phrase = phrase.replace(';', '')\n    phrase = phrase.replace(':', '')\n    phrase = phrase.replace('(', '')\n    phrase = phrase.replace(')', '')\n    phrase = phrase.replace('[', '')\n    phrase = phrase.replace(']', '')\n    phrase = phrase.replace('{', '')\n    phrase = phrase.replace('}', '')\n    phrase = phrase.replace('\"', '')\n    phrase = phrase.replace('\\'', '')\n    phrase = phrase.replace('/', '')\n    phrase = phrase.replace('\\\\', '')\n    phrase = phrase.replace('<', '')\n    phrase = phrase.replace('>', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('$', '')\n    phrase = phrase.replace('#', '')\n    phrase = phrase.replace('@', '')\n    phrase = phrase.replace('^', '')\n    phrase = phrase.replace('&', '')\n    phrase = phrase.replace('*', '')\n    phrase = phrase.replace('~', '')\n    phrase = phrase.replace('`', '')\n    phrase = phrase.replace('_', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('$', '')\n    phrase =\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(' ', '')\n    phrase = phrase.replace('.', '')\n    phrase = phrase.replace(',', '')\n    phrase = phrase.replace('!', '')\n    phrase = phrase.replace('?', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('_', '')\n    phrase = phrase.replace('/', '')\n    phrase = phrase.replace('\\\\', '')\n    phrase = phrase.replace('(', '')\n    phrase = phrase.replace(')', '')\n    phrase = phrase.replace('[', '')\n    phrase = phrase.replace(']', '')\n    phrase = phrase.replace('{', '')\n    phrase = phrase.replace('}', '')\n    phrase = phrase.replace('\"', '')\n    phrase = phrase.replace('\\'', '')\n    phrase = phrase.replace('`', '')\n    phrase = phrase.replace('~', '')\n    phrase = phrase.replace('<', '')\n    phrase = phrase.replace('>', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('*', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('$', '')\n    phrase = phrase.replace('#', '')\n    phrase = phrase.replace('@', '')\n    phrase = phrase.replace('&', '')\n    phrase = phrase.replace('^', '')\n    phrase = phrase.replace('!', '')\n    phrase = phrase.replace('?', '')\n    phrase = phrase.replace('/', '')\n    phrase = phrase.replace('\\\\', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('*', '')\n    phrase = phrase.replace('%', '')\n    phrase =\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(' ', '')\n    phrase = phrase.replace('.', '')\n    phrase = phrase.replace(',', '')\n    phrase = phrase.replace('!', '')\n    phrase = phrase.replace('?', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('\\'', '')\n    phrase = phrase.replace('\"', '')\n    phrase = phrase.replace('/', '')\n    phrase = phrase.replace('\\\\', '')\n    phrase = phrase.replace('(', '')\n    phrase = phrase.replace(')', '')\n    phrase = phrase.replace('[', '')\n    phrase = phrase.replace(']', '')\n    phrase = phrase.replace('{', '')\n    phrase = phrase.replace('}', '')\n    phrase = phrase.replace('<', '')\n    phrase = phrase.replace('>', '')\n    phrase = phrase.replace('&', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('$', '')\n    phrase = phrase.replace('#', '')\n    phrase = phrase.replace('@', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('*', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('~', '')\n    phrase = phrase.replace('`', '')\n    phrase = phrase.replace('^', '')\n    phrase = phrase.replace(';', '')\n    phrase = phrase.replace(':', '')\n    phrase = phrase.replace('<', '')\n    phrase = phrase.replace('>', '')\n    phrase = phrase.replace('&', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('$', '')\n    phrase = phrase.replace('#', '')\n    phrase = phrase.replace('@', '')\n    phrase = phrase.replace('+', '')\n    phrase =\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(\" \", \"\")\n    phrase = phrase.replace(\".\", \"\")\n    phrase = phrase.replace(\",\", \"\")\n    phrase = phrase.replace(\"!\", \"\")\n    phrase = phrase.replace(\"?\", \"\")\n    phrase = phrase.replace(\"'\", \"\")\n    phrase = phrase.replace(\"\\\"\", \"\")\n    phrase = phrase.replace(\"-\", \"\")\n    phrase = phrase.replace(\"_\", \"\")\n    phrase = phrase.replace(\";\", \"\")\n    phrase = phrase.replace(\":\", \"\")\n    phrase = phrase.replace(\"(\", \"\")\n    phrase = phrase.replace(\")\", \"\")\n    phrase = phrase.replace(\"[\", \"\")\n    phrase = phrase.replace(\" \", \"\")\n    phrase = phrase.replace(\"{\", \"\")\n    phrase = phrase.replace(\"}\", \"\")\n    phrase = phrase.replace(\"/\", \"\")\n    phrase = phrase.replace(\"\\\\\", \"\")\n    phrase = phrase.replace(\"<\", \"\")\n    phrase = phrase.replace(\">\", \"\")\n    phrase = phrase.replace(\"=\", \"\")\n    phrase = phrase.replace(\"+\", \"\")\n    phrase = phrase.replace(\"*\", \"\")\n    phrase = phrase.replace(\"&\", \"\")\n    phrase = phrase.replace(\"%\", \"\")\n    phrase = phrase.replace(\"$\", \"\")\n    phrase = phrase.replace(\"#\", \"\")\n    phrase = phrase.replace(\"@\", \"\")\n    phrase = phrase.replace(\"!\", \"\")\n    phrase = phrase.replace(\"~\", \"\")\n    phrase = phrase.replace(\"`\", \"\")\n    phrase = phrase.replace(\"^\", \"\")\n    phrase = phrase.replace(\"|\", \"\")\n    phrase = phrase.replace(\"/\", \"\")\n    phrase = phrase.replace(\"\\\\\", \"\")\n    phrase = phrase.replace(\"<\", \"\")\n    phrase = phrase.replace(\">\", \"\")\n    phrase = phrase.replace(\"=\", \"\")\n    phrase = phrase.replace(\"+\", \"\")\n    phrase = phrase.replace(\"'')\n    phrase = phrase.replace(',', '')\n    phrase = phrase.replace('!', '')\n    phrase = phrase.replace('?', '')\n    phrase = phrase.replace(':', '')\n    phrase = phrase.replace(';', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('_', '')\n    phrase = phrase.replace('(', '')\n    phrase = phrase.replace(')', '')\n    phrase = phrase.replace('[', '')\n    phrase = phrase.replace(']', '')\n    phrase = phrase.replace('{', '')\n    phrase = phrase.replace('}', '')\n    phrase = phrase.replace('\"', '')\n    phrase = phrase.replace('\\'', '')\n    phrase = phrase.replace('“', '')\n    phrase = phrase.replace('”', '')\n    phrase = phrase.replace('‘', '')\n    phrase = phrase.replace('’', '')\n    phrase = phrase.replace('<', '')\n    phrase = phrase.replace('>', '')\n    phrase = phrase.replace('/', '')\n    phrase = phrase.replace('\\\\', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('*', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('^', '')\n    phrase = phrase.replace('&', '')\n    phrase = phrase.replace('#', '')\n    phrase = phrase.replace('@', '')\n    phrase = phrase.replace('$', '')\n    phrase = phrase.replace('£', '')\n    phrase = phrase.replace('€', '')\n    phrase = phrase.replace('¥', '')\n    phrase = phrase.replace('¢', ''\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = ''.join(c for c in phrase if c.isalnum())\n    return phrase == phrase[::-1]\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(' ', '')\n    phrase = phrase.replace('.', '')\n    phrase = phrase.replace(',', '')\n    phrase = phrase.replace('!', '')\n    phrase = phrase.replace('?', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('_', '')\n    phrase = phrase.replace(';', '')\n    phrase = phrase.replace(':', '')\n    phrase = phrase.replace('(', '')\n    phrase = phrase.replace(')', '')\n    phrase = phrase.replace('[', '')\n    phrase = phrase.replace(']', '')\n    phrase = phrase.replace('{', '')\n    phrase = phrase.replace('}', '')\n    phrase = phrase.replace('\"', '')\n    phrase = phrase.replace('\\'', '')\n    phrase = phrase.replace('/', '')\n    phrase = phrase.replace('\\\\', '')\n    phrase = phrase.replace('<', '')\n    phrase = phrase.replace('>', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('$', '')\n    phrase = phrase.replace('#', '')\n    phrase = phrase.replace('@', '')\n    phrase = phrase.replace('^', '')\n    phrase = phrase.replace('&', '')\n    phrase = phrase.replace('*', '')\n    phrase = phrase.replace('~', '')\n    phrase = phrase.replace('`', '')\n    phrase = phrase.replace('_', '')\n    phrase = phrase.replace('-', '')\n    phrase = phrase.replace('+', '')\n    phrase = phrase.replace('=', '')\n    phrase = phrase.replace('|', '')\n    phrase = phrase.replace('%', '')\n    phrase = phrase.replace('$', '')\n    phrase =\n",
        "def is_palindrome(phrase):\n    phrase = phrase.lower()\n    phrase = phrase.replace(\" \", \"\")\n    phrase = phrase.replace(\".\", \"\")\n    phrase = phrase.replace(\",\", \"\")\n    phrase = phrase.replace(\"!\", \"\")\n    phrase = phrase.replace(\"?\", \"\")\n    phrase = phrase.replace(\"'\", \"\")\n    phrase = phrase.replace(\"\\\"\", \"\")\n    phrase = phrase.replace(\"-\", \"\")\n    phrase = phrase.replace(\"_\", \"\")\n    phrase = phrase.replace(\";\", \"\")\n    phrase = phrase.replace(\":\", \"\")\n    phrase = phrase.replace(\"(\", \"\")\n    phrase = phrase.replace(\")\", \"\")\n    phrase = phrase.replace(\"[\", \"\")\n    phrase = phrase.replace(\"]\", \"\")\n    phrase = phrase.replace(\"{\", \"\")\n    phrase = phrase.replace(\"}\", \"\")\n    phrase = phrase.replace(\"/\", \"\")\n    phrase = phrase.replace(\"\\\\\", \"\")\n    phrase = phrase.replace(\"<\", \"\")\n    phrase = phrase.replace(\">\", \"\")\n    phrase = phrase.replace(\"=\", \"\")\n    phrase = phrase.replace(\"+\", \"\")\n    phrase = phrase.replace(\"*\", \"\")\n    phrase = phrase.replace(\"&\", \"\")\n    phrase = phrase.replace(\"%\", \"\")\n    phrase = phrase.replace(\"$\", \"\")\n    phrase = phrase.replace(\"#\", \"\")\n    phrase = phrase.replace(\"@\", \"\")\n    phrase = phrase.replace(\"!\", \"\")\n    phrase = phrase.replace(\"~\", \"\")\n    phrase = phrase.replace(\"`\", \"\")\n    phrase = phrase.replace(\"^\", \"\")\n    phrase = phrase.replace(\"|\", \"\")\n    phrase = phrase.replace(\"/\", \"\")\n    phrase = phrase.replace(\"\\\\\", \"\")\n    phrase = phrase.replace(\"<\", \"\")\n    phrase = phrase.replace(\">\", \"\")\n    phrase = phrase.replace(\"=\", \"\")\n    phrase = phrase.replace(\"+\", \"\")\n    phrase = phrase.replace(\"\n",
        "def is_palindrome(phrase):\n    \"\"\"\n    >>> is_palindrome('Never odd or even')\n    True\n    >>> is_palindrome('abc')\n    False\n    \"\"\"\n    phrase = phrase.lower()\n    phrase = ''.join(c for c in phrase if c.isalnum())\n    return phrase == phrase[::-1]\n"
    ],
    "results": 10
},{
    "id": "1835",
    "source": "leetcode",
    "language": "python",
    "query": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, \"()\", \"(())()\", and \"(()(()))\" are all valid parenthesesstrings.",
    "snippets": [
        "def valid_parentheses(string):\n    if string == \"\":\n        return True\n    if string[0] == \")\":\n        return False\n    if string[-1] == \"(\":\n        return False\n    if string[0] == \"(\" and string[-1] == \")\":\n        return valid_parentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] != \")\":\n        return False\n    if string[0] != \"(\" and string[-1] == \")\":\n        return False\n    if string[0] != \"(\" and string[-1] != \"(\":\n        return False\n    if string[0] == \"(\" and string[-1] == \"(\":\n        return valid_parentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] != \")\":\n        return False\n    if string[0] != \"(\" and string[-1] == \")\":\n        return False\n    if string[0] == \"(\" and string[-1] == \"(\":\n        return valid_parentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] != \")\":\n        return False\n    if string[0] != \"(\" and string[-1] == \")\":\n        return False\n    if string[0] == \"(\" and string[-1] == \"(\":\n        return valid_parentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] != \")\":\n        return False\n    if string[0] != \"(\" and string[-1] == \")\":\n        return False\n    if string[0] == \"(\" and string[-1] == \"(\":\n        return valid_parentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] != \")\":\n        return False\n    if string[0] != \"(\" and string[-1] == \")\":\n        return False\n    if string[0] == \"(\" and string[-1] == \"(\":\n        return\n",
        "def valid_parentheses(string):\n    if len(string) % 2 != 0:\n        return False\n    stack = []\n    for char in string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def valid_parentheses(string):\n    if string == \"\":\n        return True\n    if string[0] == \")\" or string[-1] == \"(\":\n        return False\n    if string[0] == \"(\" and string[-1] == \")\":\n        return valid_parentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] != \")\":\n        return False\n    if string[0] != \"(\" and string[-1] == \")\":\n        return False\n    if string[0] != \"(\" and string[-1] != \")\":\n        return False\n    if string[0] == \"(\" and string[-1] != \")\":\n        return valid_parentheses(string[1:])\n    if string[0] != \"(\" and string[-1] == \")\":\n        return valid_parentheses(string[:-1])\n    return False\n",
        "def isValid(s):\n    stack = []\n    for i in s:\n        if i == '(' or i == '[' or i == '{':\n            stack.append(i)\n        elif i == ')':\n            if len(stack) == 0 or stack.pop() != '(':\n                return False\n        elif i == ']':\n            if len(stack) == 0 or stack.pop() != '[':\n                return False\n        elif i == '}':\n            if len(stack) == 0 or stack.pop() != '{':\n                return False\n    return len(stack) == 0\n",
        "def valid_parentheses(string):\n    if string == \"\":\n        return True\n    if len(string) % 2 != 0:\n        return False\n    if string[0] == \")\":\n        return False\n    if string[-1] == \"(\":\n        return False\n    for i in range(len(string)):\n        if string[i] == \"(\":\n            if string[i+1] == \")\":\n                return False\n    for i in range(len(string)):\n        if string[i] == \")\":\n            if string[i-1] == \"(\":\n                return False\n    return True\n",
        "def validParentheses(string):\n    if string == \"\":\n        return True\n    if len(string) % 2 != 0:\n        return False\n    if string[0] == \")\" or string[-1] == \"(\":\n        return False\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-1] == \")\":\n        return validParentheses(string[1:-1])\n    if string[0] == \"(\" and string[-\n",
        "def isValid(s):\n    if s == \"\":\n        return True\n    if len(s) % 2 != 0:\n        return False\n    stack = []\n    for i in range(len(s)):\n        if s[i] == \"(\":\n            stack.append(s[i])\n        elif s[i] == \")\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def valid_parentheses(string):\n    if string == \"\":\n        return True\n    if len(string) % 2 == 1:\n        return False\n    stack = []\n    for char in string:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def isValid(s):\n    if len(s) == 0:\n        return True\n    if len(s) % 2 == 1:\n        return False\n    d = {'(':')', '{':'}', '[':']'}\n    stack = []\n    for i in s:\n        if i in d:\n            stack.append(i)\n        elif len(stack) == 0 or d[stack.pop()] != i:\n            return False\n    return len(stack) == 0\n"
    ],
    "results": 10
},{
    "id": "1836",
    "source": "leetcode",
    "language": "python",
    "query": "There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character.",
    "snippets": [
        "def typewriter(string):\n    pointer = 0\n    for char in string:\n        if char == string[pointer]:\n            pointer += 1\n            if pointer == len(string):\n                pointer = 0\n        else:\n            return False\n    return True\n",
        "def typewriter(string):\n    pointer = 0\n    for char in string:\n        if char == string[pointer]:\n            pointer += 1\n            pointer %= len(string)\n        else:\n            return False\n    return True\n",
        "def typewriter(string):\n    pointer = 0\n    for char in string:\n        if char == string[pointer]:\n            pointer += 1\n            print(char, end='')\n        else:\n            print('*', end='')\n    print()\n    return pointer\n",
        "def typewriter(s):\n    if not s:\n        return ''\n    return s[0] + typewriter(s[1:]) + s[0]\n",
        "def typewriter(s):\n    if not s:\n        return \"\"\n    if s[0] == 'z':\n        return \"z\" + typewriter(s[1:])\n    else:\n        return s[0] + typewriter(s[1:])\n"
    ],
    "results": 10
},{
    "id": "1837",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum. Return the sum of the k integers appended tonums.",
    "snippets": [
        "def minsum(nums, k):\n    nums.sort()\n    for i in range(k):\n        if i == 0 or nums[i] != nums[i-1]:\n            nums.append(i+1)\n    return sum(nums)\n",
        "def minSum(nums, k):\n    nums.sort()\n    for i in range(k):\n        if i == 0 or nums[i] != nums[i-1]:\n            nums.append(i+1)\n    return sum(nums)\n",
        "def minSum(nums, k):\n    nums.sort()\n    sum = 0\n    for i in range(len(nums)):\n        if nums[i] > 0:\n            sum += nums[i]\n            nums[i] = 0\n    for i in range(k):\n        nums.append(i+1)\n    nums.sort()\n    for i in range(len(nums)):\n        if nums[i] > 0:\n            sum += nums[i]\n    return sum\n",
        "def minSum(nums, k):\n    nums.sort()\n    sum = 0\n    for i in range(k):\n        if nums[i] > 0:\n            sum += nums[i]\n        else:\n            sum += 1\n    for i in range(k, len(nums)):\n        if nums[i] > 0:\n            sum += nums[i]\n        else:\n            sum += 1\n    return sum\n",
        "def minSum(nums, k):\n    nums.sort()\n    for i in range(k):\n        if i == 0:\n            nums.append(i+1)\n        else:\n            if nums[i] != nums[i-1]:\n                nums.append(i+1)\n    return sum(nums)\n",
        "def minsum(nums, k):\n    nums.sort()\n    for i in range(k):\n        if i >= len(nums):\n            nums.append(i+1)\n        elif nums[i] != i+1:\n            nums.insert(i, i+1)\n    return sum(nums)\n",
        "def minSum(nums, k):\n    nums.sort()\n    for i in range(k):\n        if i == 0:\n            nums.append(i + 1)\n        else:\n            nums.append(nums[i - 1] + 1)\n    return sum(nums)\n"
    ],
    "results": 10
},{
    "id": "1838",
    "source": "leetcode",
    "language": "python",
    "query": "A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given the root of a binary tree, return its maximum depth.",
    "snippets": [
        "def maxDepth(self, root):\n    if root is None:\n        return 0\n    return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n",
        "def maxDepth(root):\n    if root is None:\n        return 0\n    return max(maxDepth(root.left), maxDepth(root.right)) + 1\n",
        "def max_depth(root):\n    if root is None:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))\n",
        "def maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n",
        "def max_depth(root):\n    if root is None:\n        return 0\n    else:\n        return 1 + max(max_depth(root.left), max_depth(root.right))\n"
    ],
    "results": 10
},{
    "id": "1839",
    "source": "leetcode",
    "language": "python",
    "query": "There are n points on a road you are driving your taxi on. You want to drive from point 1 to point n to make money by picking up passengers. The passengers are represented by a 0-indexed 2D integer array rides.",
    "snippets": [
        "def taxi(rides):\n    if not rides:\n        return 0\n    n = len(rides)\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = max(dp[i - 1], rides[i][2] + dp[rides[i][1]])\n    return dp[n - 1]\n",
        "def taxi(rides):\n    # Write your code here.\n    if not rides:\n        return 0\n    rides.sort(key=lambda x: x[0])\n    rides.sort(key=lambda x: x[1])\n    # print(rides)\n    max_profit = 0\n    current_time = 0\n    for i in range(len(rides)):\n        if rides[i][0] > current_time:\n            current_time = rides[i][0]\n        max_profit += rides[i][2]\n        current_time += rides[i][1]\n    return max_profit\n",
        "def taxi(n, rides):\n    # Write your code here.\n    return 0\n",
        "def taxi(n, m, rides):\n    # Write your code here.\n    return 0\n",
        "def taxi(rides):\n    # Write your code here.\n    return 0\n",
        "def taxi(rides):\n    # Write your code here.\n    if not rides:\n        return 0\n    rides.sort(key=lambda x: x[0])\n    max_profit = 0\n    current_time = rides[0][1]\n    for i in range(len(rides)):\n        if rides[i][0] >= current_time:\n            max_profit += (rides[i][0] - current_time)\n            current_time = rides[i][1]\n        else:\n            current_time = rides[i][1]\n    return max_profit\n",
        "def taxi(n, m, rides):\n    # Write your code here.\n    # rides is a 2D array of integers representing the coordinates of the passengers.\n    # The first row of the array is the first point, the second row is the second point, and so on.\n    # The first column of the array is the first passenger, the second column is the second passenger, and so on.\n    # The value in the array represents the distance between the two points.\n    # The return value is the maximum amount of money you can make.\n    # If there are no passengers, return 0.\n    # If there are no points, return 0.\n    # If there are no passengers and no points, return 0.\n    if n == 0 or m == 0:\n        return 0\n    if n == 1:\n        return sum(rides[0])\n    if m == 1:\n        return sum(rides[:, 0])\n    dp = [[0 for _ in range(m)] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0:\n                dp[i][j] = rides[i][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + rides[i][j])\n    return dp[n - 1][m - 1]\n"
    ],
    "results": 9
},{
    "id": "1840",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
    "snippets": [
        "def rangeBitwiseAnd(left, right):\n    \"\"\"\n    :type left: int\n    :type right: int\n    :rtype: int\n    \"\"\"\n    if left == right:\n        return left\n    while left < right:\n        left = left << 1\n        right = right >> 1\n    return left & right\n",
        "def range_bitwise_and(left, right):\n    if left == right:\n        return left\n    if left == 0:\n        return 0\n    if right == 0:\n        return 0\n    if left == 1:\n        return 1\n    if right == 1:\n        return 1\n    if left == 2:\n        return 2\n    if right == 2:\n        return 2\n    if left == 3:\n        return 2\n    if right == 3:\n        return 2\n    if left == 4:\n        return 4\n    if right == 4:\n        return 4\n    if left == 5:\n        return 4\n    if right == 5:\n        return 4\n    if left == 6:\n        return 4\n    if right == 6:\n        return 4\n    if left == 7:\n        return 4\n    if right == 7:\n        return 4\n    if left == 8:\n        return 8\n    if right == 8:\n        return 8\n    if left == 9:\n        return 8\n    if right == 9:\n        return 8\n    if left == 10:\n        return 8\n    if right == 10:\n        return 8\n    if left == 11:\n        return 8\n    if right == 11:\n        return 8\n    if left == 12:\n        return 8\n    if right == 12:\n        return 8\n    if left == 13:\n        return 8\n    if right == 13:\n        return 8\n    if left == 14:\n        return 8\n    if right == 14:\n        return 8\n    if left == 15:\n        return 8\n    if right == 15:\n        return 8\n    if left == 16:\n        return 16\n    if right == 16:\n        return 16\n    if left == 17:\n        return 16\n    if right == 17:\n        return 16\n    if left == 18:\n        return 16\n    if right == 18:\n        return 16\n    if left == 19:\n        return 16\n    if right == 19:\n        return 16\n    if left == 20:\n        return 16\n    if right == 20:\n        return 16\n    if left == 21:\n        return 16\n    if right\n",
        "def range_bitwise_and(left, right):\n    if left == right:\n        return left\n    if left == 0:\n        return 0\n    if right == 0:\n        return 0\n    if left == 1:\n        return 1\n    if right == 1:\n        return 1\n    if left == 2:\n        return 2\n    if right == 2:\n        return 2\n    if left == 3:\n        return 3\n    if right == 3:\n        return 3\n    if left == 4:\n        return 4\n    if right == 4:\n        return 4\n    if left == 5:\n        return 5\n    if right == 5:\n        return 5\n    if left == 6:\n        return 6\n    if right == 6:\n        return 6\n    if left == 7:\n        return 7\n    if right == 7:\n        return 7\n    if left == 8:\n        return 8\n    if right == 8:\n        return 8\n    if left == 9:\n        return 9\n    if right == 9:\n        return 9\n    if left == 10:\n        return 10\n    if right == 10:\n        return 10\n    if left == 11:\n        return 11\n    if right == 11:\n        return 11\n    if left == 12:\n        return 12\n    if right == 12:\n        return 12\n    if left == 13:\n        return 13\n    if right == 13:\n        return 13\n    if left == 14:\n        return 14\n    if right == 14:\n        return 14\n    if left == 15:\n        return 15\n    if right == 15:\n        return 15\n    if left == 16:\n        return 16\n    if right == 16:\n        return 16\n    if left == 17:\n        return 17\n    if right == 17:\n        return 17\n    if left == 18:\n        return 18\n    if right == 18:\n        return 18\n    if left == 19:\n        return 19\n    if right == 19:\n        return 19\n    if left == 20:\n        return 20\n    if right == 20:\n        return 20\n    if left == 21:\n        return 21\n    if right\n",
        "def range_bitwise_and(left, right):\n    while left < right:\n        right &= right - 1\n    return left & right\n",
        "def range_bitwise_and(left, right):\n    if left == 0:\n        return 0\n    while left < right:\n        right -= 1\n        left = left & right\n    return left\n",
        "def range_bitwise_and(left, right):\n    while left < right:\n        right = right & (right - 1)\n    return left & right\n",
        "def rangeBitwiseAnd(left, right):\n    if left == right:\n        return left\n    if left == 0:\n        return 0\n    if right == 0:\n        return 0\n    if left == 1:\n        return 1\n    if right == 1:\n        return 1\n    if left == 2:\n        return 2\n    if right == 2:\n        return 2\n    if left == 3:\n        return 3\n    if right == 3:\n        return 3\n    if left == 4:\n        return 4\n    if right == 4:\n        return 4\n    if left == 5:\n        return 5\n    if right == 5:\n        return 5\n    if left == 6:\n        return 6\n    if right == 6:\n        return 6\n    if left == 7:\n        return 7\n    if right == 7:\n        return 7\n    if left == 8:\n        return 8\n    if right == 8:\n        return 8\n    if left == 9:\n        return 9\n    if right == 9:\n        return 9\n    if left == 10:\n        return 10\n    if right == 10:\n        return 10\n    if left == 11:\n        return 11\n    if right == 11:\n        return 11\n    if left == 12:\n        return 12\n    if right == 12:\n        return 12\n    if left == 13:\n        return 13\n    if right == 13:\n        return 13\n    if left == 14:\n        return 14\n    if right == 14:\n        return 14\n    if left == 15:\n        return 15\n    if right == 15:\n        return 15\n    if left == 16:\n        return 16\n    if right == 16:\n        return 16\n    if left == 17:\n        return 17\n    if right == 17:\n        return 17\n    if left == 18:\n        return 18\n    if right == 18:\n        return 18\n    if left == 19:\n        return 19\n    if right == 19:\n        return 19\n    if left == 20:\n        return 20\n    if right == 20:\n        return 20\n    if left == 21:\n        return 21\n    if right == 21\n",
        "def range_bitwise_and(left, right):\n    while left < right:\n        right -= left & right\n    return left & right\n"
    ],
    "results": 10
},{
    "id": "1841",
    "source": "leetcode",
    "language": "python",
    "query": "An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x. Given an integer n, return the smallest numericallybalanced number strictly greater than n.",
    "snippets": [
        "def balanced(n):\n    n = str(n)\n    for i in range(10):\n        if n.count(str(i)) != n.count(str(i)):\n            return False\n    return True\n",
        "def balanced(n):\n    digits = [0] * 10\n    while n > 0:\n        digits[n % 10] += 1\n        n //= 10\n    return all(digits[i] == digits[i + 1] for i in range(9))\n",
        "def balanced(n):\n    digits = [0] * 10\n    while n > 0:\n        digits[n % 10] += 1\n        n //= 10\n    return digits\n",
        "def balanced(n):\n    n = str(n)\n    for i in range(10):\n        if n.count(str(i)) != n.count(str(i)) * 2:\n            return False\n    return True\n",
        "def balanced(n):\n    for i in range(1, 10):\n        if n % i != 0:\n            return n + i\n    return n + 10\n",
        "def balanced(n):\n    for i in range(1,10):\n        if n%i!=0:\n            return balanced(n+1)\n    return n\n",
        "def balanced(n):\n    # your code here\n    return n + 1\n",
        "def balanced(n):\n    # your code here\n    return 0\n"
    ],
    "results": 9
},{
    "id": "1842",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities of each kind of writing utensil.",
    "snippets": [
        "def buy_pencils_and_paper(total, cost1, cost2):\n    pencils = total // cost1\n    paper = total // cost2\n    return pencils, paper\n",
        "def buy_utensils(total, cost1, cost2):\n    if total < cost1 + cost2:\n        return 0\n    else:\n        return (total // (cost1 + cost2)) * 2\n",
        "def buy_utensils(total, cost1, cost2):\n    if total < cost1 + cost2:\n        return \"Insufficient funds\"\n    else:\n        pencils = total // cost1\n        total -= pencils * cost1\n        if total < cost2:\n            return \"Insufficient funds\"\n        else:\n            erasers = total // cost2\n            return pencils, erasers\n",
        "def buy_pencils(total, cost1, cost2):\n    pencils = total // cost1\n    if total % cost1 == 0:\n        return pencils\n    else:\n        return pencils + (total % cost1) // cost2\n",
        "def buy_pencils(total, cost1, cost2):\n    pencils = total // cost1\n    if total % cost1 != 0:\n        pencils += 1\n    return pencils\n",
        "def buy_utensils(total, cost1, cost2):\n    if total < cost1 + cost2:\n        return \"Not Possible\"\n    else:\n        pencils = total // cost1\n        total -= pencils * cost1\n        if total < cost2:\n            return \"Not Possible\"\n        else:\n            return pencils // cost2\n",
        "def buy_pencil(total, cost1, cost2):\n    if total < cost1 + cost2:\n        return \"Insufficient funds\"\n    else:\n        pencil = total // (cost1 + cost2)\n        remainder = total % (cost1 + cost2)\n        if remainder >= cost1:\n            pencil += 1\n            remainder -= cost1\n        else:\n            pencil += remainder // cost2\n            remainder = remainder % cost2\n        return pencil\n"
    ],
    "results": 10
},{
    "id": "1843",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array coins of length n which represents the n coins that you own. You can make some value x if you can choose some of your n coins such that their values sum up to x.",
    "snippets": [
        "def make_change(coins, amount):\n    if amount == 0:\n        return 1\n    if amount < 0:\n        return 0\n    if len(coins) == 0:\n        return 0\n    return make_change(coins[1:], amount) + make_change(coins[:len(coins)-1], amount-coins[0])\n",
        "def make_change(coins, n, x):\n    if x == 0:\n        return 1\n    if n == 0 and x != 0:\n        return 0\n    if x < 0:\n        return 0\n    return make_change(coins, n-1, x) + make_change(coins, n, x-coins[n-1])\n",
        "def make_change(coins, amount):\n    \"\"\"\n    >>> coins = [1, 2, 5]\n    >>> amount = 11\n    >>> make_change(coins, amount)\n    3\n    >>> coins = [1, 2, 5]\n    >>> amount = 3\n    >>> make_change(coins, amount)\n    -1\n    >>> coins = [1, 5, 10, 25]\n    >>> amount = 15\n    >>> make_change(coins, amount)\n    2\n    \"\"\"\n    if amount == 0:\n        return 0\n    if amount < 0:\n        return -1\n    if len(coins) == 0:\n        return -1\n    if coins[0] > amount:\n        return make_change(coins[1:], amount)\n    return 1 + make_change(coins, amount - coins[0])\n",
        "def make_change(coins, amount):\n    \"\"\"\n    >>> coins = [1, 2, 5]\n    >>> make_change(coins, 11)\n    3\n    >>> make_change(coins, 13)\n    2\n    >>> make_change(coins, 5)\n    1\n    >>> make_change(coins, 0)\n    0\n    >>> make_change(coins, 1)\n    1\n    >>> make_change(coins, 2)\n    1\n    >>> make_change(coins, 3)\n    1\n    >>> make_change(coins, 4)\n    1\n    >>> make_change(coins, 5)\n    1\n    >>> make_change(coins, 6)\n    2\n    >>> make_change(coins, 7)\n    2\n    >>> make_change(coins, 8)\n    2\n    >>> make_change(coins, 9)\n    2\n    >>> make_change(coins, 10)\n    2\n    >>> make_change(coins, 11)\n    3\n    >>> make_change(coins, 12)\n    3\n    >>> make_change(coins, 13)\n    2\n    >>> make_change(coins, 14)\n    3\n    >>> make_change(coins, 15)\n    3\n    >>> make_change(coins, 16)\n    3\n    >>> make_change(coins, 17)\n    4\n    >>> make_change(coins, 18)\n    4\n    >>> make_change(coins, 19)\n    4\n    >>> make_change(coins, 20)\n    4\n    >>> make_change(coins, 21)\n    4\n    >>> make_change(coins, 22)\n    4\n    >>> make_change(coins, 23)\n    4\n    >>> make_change(coins, 24)\n    4\n    >>> make_change(coins, 25)\n    4\n    >>> make_change(coins, 26)\n    4\n    >>> make_change(coins, 27)\n    4\n    >>> make_change(coins, 28)\n    4\n    >>> make_change(coins, 29)\n    4\n    >>> make_change(coins, 30)\n    4\n",
        "def make_change(coins, amount):\n    \"\"\"\n    >>> make_change([1, 5, 10, 25], 63)\n    True\n    >>> make_change([1, 5, 10, 25], 64)\n    False\n    >>> make_change([1, 5, 10, 25], 100)\n    True\n    >>> make_change([1, 5, 10, 25], 101)\n    False\n    \"\"\"\n    if amount == 0:\n        return True\n    if len(coins) == 0:\n        return False\n    if coins[0] > amount:\n        return make_change(coins[1:], amount)\n    return make_change(coins[1:], amount) or make_change(coins[:-1], amount - coins[0])\n"
    ],
    "results": 10
},{
    "id": "1844",
    "source": "leetcode",
    "language": "python",
    "query": "Given the head of a linked list, rotate the list to the right by k places.",
    "snippets": [
        "def rotate_right(head, k):\n    if head is None:\n        return None\n    if k == 0:\n        return head\n    if k == 1:\n        return head\n    if k == 2:\n        return head\n    if k == 3:\n        return head\n    if k == 4:\n        return head\n    if k == 5:\n        return head\n    if k == 6:\n        return head\n    if k == 7:\n        return head\n    if k == 8:\n        return head\n    if k == 9:\n        return head\n    if k == 10:\n        return head\n    if k == 11:\n        return head\n    if k == 12:\n        return head\n    if k == 13:\n        return head\n    if k == 14:\n        return head\n    if k == 15:\n        return head\n    if k == 16:\n        return head\n    if k == 17:\n        return head\n    if k == 18:\n        return head\n    if k == 19:\n        return head\n    if k == 20:\n        return head\n    if k == 21:\n        return head\n    if k == 22:\n        return head\n    if k == 23:\n        return head\n    if k == 24:\n        return head\n    if k == 25:\n        return head\n    if k == 26:\n        return head\n    if k == 27:\n        return head\n    if k == 28:\n        return head\n    if k == 29:\n        return head\n    if k == 30:\n        return head\n    if k == 31:\n        return head\n    if k == 32:\n        return head\n    if k == 33:\n        return head\n    if k == 34:\n        return head\n    if k == 35:\n        return head\n    if k == 36:\n        return head\n    if k == 37:\n        return head\n    if k == 38:\n        return head\n    if k == 39:\n        return head\n    if k == 40:\n        return head\n    if k == 41:\n        return head\n    if k == 42:\n        return head\n    if k == 43:\n",
        "def rotate_right(head, k):\n    if not head:\n        return None\n    if not head.next:\n        return head\n    if k == 0:\n        return head\n    if k == 1:\n        return head.next\n    if k == 2:\n        return head.next.next\n    if k == 3:\n        return head.next.next.next\n    if k == 4:\n        return head.next.next.next.next\n    if k == 5:\n        return head.next.next.next.next.next\n    if k == 6:\n        return head.next.next.next.next.next.next\n    if k == 7:\n        return head.next.next.next.next.next.next.next\n    if k == 8:\n        return head.next.next.next.next.next.next.next.next\n    if k == 9:\n        return head.next.next.next.next.next.next.next.next.next\n    if k == 10:\n        return head.next.next.next.next.next.next.next.next.next.next\n    if k == 11:\n        return head.next.next.next.next.next.next.next.next.next.next.next\n    if k == 12:\n        return head.next.next.next.next.next.next.next.next.next.next.next.next\n    if k == 13:\n        return head.next.next.next.next.next.next.next.next.next.next.next.next.next\n    if k == 14:\n        return head.next.next.next.next.next.next.next.next.next.next.next.next.next.next\n    if k == 15:\n        return head.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next\n    if k == 16:\n        return head.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next\n    if k == 17:\n        return\n",
        "def rotate_right(head, k):\n    if not head:\n        return None\n    if not head.next:\n        return head\n    if k == 0:\n        return head\n    if k == 1:\n        return head.next\n    curr = head\n    count = 1\n    while curr.next:\n        curr = curr.next\n        count += 1\n    curr.next = head\n    curr = head\n    while count > k:\n        curr = curr.next\n        count -= 1\n    new_head = curr.next\n    curr.next = None\n    return new_head\n",
        "def rotate_right(head, k):\n    if head is None:\n        return None\n    if head.next is None:\n        return head\n    if k == 0:\n        return head\n    if k == 1:\n        return head.next\n    count = 0\n    curr = head\n    while curr is not None:\n        count += 1\n        curr = curr.next\n    k = k % count\n    if k == 0:\n        return head\n    curr = head\n    while k > 1:\n        curr = curr.next\n        k -= 1\n    new_head = curr.next\n    curr.next = None\n    curr = new_head\n    while curr.next is not None:\n        curr = curr.next\n    curr.next = head\n    return new_head\n",
        "def rotate_right(head, k):\n    if head is None:\n        return None\n    if k == 0:\n        return head\n    curr = head\n    count = 1\n    while curr.next is not None:\n        curr = curr.next\n        count += 1\n    curr.next = head\n    k = k % count\n    for i in range(count - k):\n        curr = curr.next\n    new_head = curr.next\n    curr.next = None\n    return new_head\n"
    ],
    "results": 10
},{
    "id": "1845",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer num, return three consecutive integers (as a sorted array) that sum to num. If num cannot be expressed as the sum of three consecutive integer, return an empty array.",
    "snippets": [
        "def threeSum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0:\n                l += 1\n            elif s > 0:\n                r -= 1\n            else:\n                result.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l + 1]:\n                    l += 1\n                while l < r and nums[r] == nums[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n    return result\n",
        "def threeSum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            if nums[i] + nums[l] + nums[r] == 0:\n                result.append([nums[i], nums[l], nums[r]])\n                l += 1\n                r -= 1\n                while l < r and nums[l] == nums[l - 1]:\n                    l += 1\n                while l < r and nums[r] == nums[r + 1]:\n                    r -= 1\n            elif nums[i] + nums[l] + nums[r] < 0:\n                l += 1\n            else:\n                r -= 1\n    return result\n",
        "def three_consecutive_numbers(num):\n    for i in range(num-2):\n        for j in range(i+1, num-1):\n            for k in range(j+1, num):\n                if i+j+k == num:\n                    return [i, j, k]\n    return []\n",
        "def threeSum(num):\n    nums = []\n    for i in range(num + 1):\n        nums.append(i)\n    nums.sort()\n    result = []\n    for i in range(len(nums)):\n        if nums[i] > 0:\n            break\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left = i + 1\n        right = len(nums) - 1\n        while left < right:\n            if nums[i] + nums[left] + nums[right] == num:\n                result.append([nums[i], nums[left], nums[right]])\n                left += 1\n                right -= 1\n                while left < right and nums[left] == nums[left - 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right + 1]:\n                    right -= 1\n            elif nums[i] + nums[left] + nums[right] < num:\n                left += 1\n            else:\n                right -= 1\n    return result\n"
    ],
    "results": 10
},{
    "id": "1846",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed integer array nums and an integer k. You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array.",
    "snippets": [
        "def jump(nums, k):\n    if len(nums) == 1:\n        return 0\n    if len(nums) == 2:\n        return 1\n    if len(nums) == 3:\n        return 2\n    if len(nums) == 4:\n        return 3\n    if len(nums) == 5:\n        return 4\n    if len(nums) == 6:\n        return 5\n    if len(nums) == 7:\n        return 6\n    if len(nums) == 8:\n        return 7\n    if len(nums) == 9:\n        return 8\n    if len(nums) == 10:\n        return 9\n    if len(nums) == 11:\n        return 10\n    if len(nums) == 12:\n        return 11\n    if len(nums) == 13:\n        return 12\n    if len(nums) == 14:\n        return 13\n    if len(nums) == 15:\n        return 14\n    if len(nums) == 16:\n        return 15\n    if len(nums) == 17:\n        return 16\n    if len(nums) == 18:\n        return 17\n    if len(nums) == 19:\n        return 18\n    if len(nums) == 20:\n        return 19\n    if len(nums) == 21:\n        return 20\n    if len(nums) == 22:\n        return 21\n    if len(nums) == 23:\n        return 22\n    if len(nums) == 24:\n        return 23\n    if len(nums) == 25:\n        return 24\n    if len(nums) == 26:\n        return 25\n    if len(nums) == 27:\n        return 26\n    if len(nums) == 28:\n        return 27\n    if len(nums) == 29:\n        return 28\n    if len(nums) == 30:\n        return 29\n    if len(nums) == 31:\n        return 30\n    if len(nums) == 32:\n        return 31\n    if len(nums) == 33:\n",
        "def jump(nums):\n    if len(nums) == 1:\n        return 0\n    max_step = 0\n    cur_step = 0\n    for i in range(len(nums)):\n        if i > max_step:\n            return -1\n        if i == max_step:\n            max_step += nums[i]\n            cur_step += 1\n    return cur_step\n",
        "def jump(nums, k):\n    if len(nums) == 1:\n        return 0\n    if k >= len(nums):\n        return 1\n    dp = [0] * len(nums)\n    dp[0] = 0\n    for i in range(1, len(nums)):\n        for j in range(1, k+1):\n            if i+j < len(nums):\n                dp[i] = max(dp[i], dp[i-j] + 1)\n    return dp[-1]\n",
        "def jump(nums, k):\n    if len(nums) == 1:\n        return 0\n    if k == 0:\n        return 0\n    if k == 1:\n        return 1\n    if k == 2:\n        return 2\n    if k == 3:\n        return 3\n    if k == 4:\n        return 4\n    if k == 5:\n        return 5\n    if k == 6:\n        return 6\n    if k == 7:\n        return 7\n    if k == 8:\n        return 8\n    if k == 9:\n        return 9\n    if k == 10:\n        return 10\n    if k == 11:\n        return 11\n    if k == 12:\n        return 12\n    if k == 13:\n        return 13\n    if k == 14:\n        return 14\n    if k == 15:\n        return 15\n    if k == 16:\n        return 16\n    if k == 17:\n        return 17\n    if k == 18:\n        return 18\n    if k == 19:\n        return 19\n    if k == 20:\n        return 20\n    if k == 21:\n        return 21\n    if k == 22:\n        return 22\n    if k == 23:\n        return 23\n    if k == 24:\n        return 24\n    if k == 25:\n        return 25\n    if k == 26:\n        return 26\n    if k == 27:\n        return 27\n    if k == 28:\n        return 28\n    if k == 29:\n        return 29\n    if k == 30:\n        return 30\n    if k == 31:\n        return 31\n    if k == 32:\n        return 32\n    if k == 33:\n        return 33\n    if k == 34:\n        return 34\n    if k == 35:\n        return 35\n    if k == 36:\n        return 36\n    if k == 37:\n        return 37\n    if k == 38:\n        return 38\n    if k == 39:\n        return 39\n    if k == 40:\n        return 40\n    if k == 41:\n        return 41\n    if k == 42:\n        return 42\n    if k\n"
    ],
    "results": 10
},{
    "id": "1847",
    "source": "leetcode",
    "language": "python",
    "query": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append additional letters onto the end of the merged string.",
    "snippets": [
        "def merge_strings(word1, word2):\n    if len(word1) > len(word2):\n        word1, word2 = word2, word1\n    for i in range(len(word2)):\n        word1 += word2[i]\n        word1 += word1[i]\n    return word1\n",
        "def merge_strings(word1, word2):\n    if len(word1) > len(word2):\n        word1, word2 = word2, word1\n    for i in range(len(word2)):\n        word1 += word2[i]\n        if i < len(word1):\n            word1 += word1[i]\n    return word1\n",
        "def merge_strings(word1, word2):\n    if len(word1) > len(word2):\n        word1, word2 = word2, word1\n    for i in range(len(word2)):\n        word1 += word2[i]\n    return word1\n",
        "def mergeStrings(word1, word2):\n    if len(word1) > len(word2):\n        word1, word2 = word2, word1\n    for i in range(len(word2)):\n        word1 += word2[i]\n    return word1\n",
        "def mergeStrings(word1, word2):\n    if len(word1) > len(word2):\n        word1, word2 = word2, word1\n    for i in range(len(word2)):\n        word1 += word2[i]\n        word1 += word1[i]\n    return word1\n",
        "def merge_strings(word1, word2):\n    if len(word1) > len(word2):\n        word1, word2 = word2, word1\n    return word1 + word2[len(word1):]\n",
        "def merge_strings(word1, word2):\n    if len(word1) > len(word2):\n        word1, word2 = word2, word1\n    merged = \"\"\n    for i in range(len(word1)):\n        merged += word1[i]\n        merged += word2[i]\n    merged += word2[len(word1):]\n    return merged\n"
    ],
    "results": 10
},{
    "id": "1848",
    "source": "leetcode",
    "language": "python",
    "query": "Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums.",
    "snippets": [
        "def array_sum(nums, startValue):\n    sum = startValue\n    for i in nums:\n        sum += i\n    return sum\n",
        "def arraySum(nums, startValue):\n    sum = startValue\n    for i in nums:\n        sum += i\n    return sum\n",
        "def calculate_sum(nums, startValue):\n    sum = startValue\n    for num in nums:\n        sum += num\n    return sum\n"
    ],
    "results": 10
},{
    "id": "1849",
    "source": "leetcode",
    "language": "python",
    "query": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums [j] and (i * j) is divisible by k.",
    "snippets": [
        "def numPairsDivisibleBy60(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] + nums[j]) % 60 == 0:\n                count += 1\n    return count\n",
        "def divisible_pairs(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if (nums[i] + nums[j]) % k == 0:\n                count += 1\n    return count\n",
        "def findPairs(nums, k):\n    if k <= 0:\n        return 0\n    nums.sort()\n    count = 0\n    i = 0\n    j = 1\n    while i < len(nums) and j < len(nums):\n        if nums[i] == nums[j]:\n            count += 1\n            i += 1\n            j += 1\n        elif nums[i] + nums[j] > k:\n            j += 1\n        else:\n            i += 1\n    return count\n",
        "def numPairsDivisibleBy60(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(0, len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) % 60 == 0:\n                count += 1\n    return count\n",
        "def num_divisible_pairs(nums, k):\n    num_pairs = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] + nums[j]) % k == 0:\n                num_pairs += 1\n    return num_pairs\n",
        "def numPairsDivisibleBy60(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    dic = {}\n    for num in nums:\n        dic[num % 60] = dic.get(num % 60, 0) + 1\n    res = 0\n    for key in dic:\n        if key == 0:\n            res += dic[key] * (dic[key] - 1) // 2\n        else:\n            res += dic[key] * (dic[60 - key] // 2)\n    return res\n",
        "def findPairs(nums, k):\n    if k <= 0:\n        return 0\n    nums.sort()\n    i = 0\n    j = 1\n    count = 0\n    while j < len(nums):\n        if nums[j] - nums[i] < k:\n            j += 1\n        elif nums[j] - nums[i] == k:\n            count += 1\n            i += 1\n            j += 1\n        else:\n            i += 1\n    return count\n",
        "def numPairsDivisibleBy60(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    dic = {}\n    for i in nums:\n        dic[i % 60] = dic.get(i % 60, 0) + 1\n    res = 0\n    for i in range(30):\n        if i * 2 in dic:\n            res += dic[i * 2] * (dic[i * 2] - 1) // 2\n        if i * 2 + 30 in dic:\n            res += dic[i * 2 + 30] * (dic[i * 2 + 30] - 1) // 2\n    return res\n",
        "def numPairsDivisibleBy60(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    # count[x] = number of elements divisible by x\n    count = [0] * 60\n    for num in nums:\n        count[num % 60] += 1\n    # count[x] = number of pairs divisible by x\n    count[0] = count[30] + count[0] * (count[0] - 1) // 2\n    for i in range(1, 30):\n        count[i] = count[60 - i] + count[i] * (count[i] - 1) // 2\n    return sum(count[x] * count[y] for x in range(60) for y in range(x + 1, 60)) // 2\n"
    ],
    "results": 10
},{
    "id": "1850",
    "source": "leetcode",
    "language": "python",
    "query": "In one move, you can increment or decrement an element of the array by 1. Test cases are designed so that the answer will fit in a 32-bit integer.",
    "snippets": [
        "def arrayChange(inputArray):\n    count = 0\n    for i in range(len(inputArray)):\n        if i == 0:\n            continue\n        if inputArray[i] <= inputArray[i-1]:\n            count += (inputArray[i-1] - inputArray[i] + 1)\n            inputArray[i] = inputArray[i-1] + 1\n    return count\n",
        "def arrayChange(inputArray):\n    count = 0\n    for i in range(len(inputArray)):\n        if i == 0:\n            continue\n        if inputArray[i] <= inputArray[i-1]:\n            count += inputArray[i-1] - inputArray[i] + 1\n            inputArray[i] = inputArray[i-1] + 1\n    return count\n",
        "def arrayChange(arr):\n    count = 0\n    for i in range(len(arr)):\n        if i == 0:\n            continue\n        if arr[i] <= arr[i-1]:\n            count += arr[i-1] - arr[i] + 1\n            arr[i] = arr[i-1] + 1\n    return count\n",
        "def arrayChange(inputArray):\n    count = 0\n    for i in range(len(inputArray) - 1):\n        if inputArray[i] > inputArray[i + 1]:\n            count += inputArray[i] - inputArray[i + 1] + 1\n            inputArray[i + 1] += inputArray[i] - inputArray[i + 1] + 1\n    return count\n",
        "def arrayManipulation(n, queries):\n    arr = [0] * (n + 1)\n    for i in queries:\n        arr[i[0]] += i[2]\n        arr[i[1] + 1] -= i[2]\n    max_val = 0\n    cur_val = 0\n    for i in arr:\n        cur_val += i\n        if cur_val > max_val:\n            max_val = cur_val\n    return max_val\n",
        "def solution(A):\n    # write your code in Python 3.6\n    if len(A) == 1:\n        return A[0]\n    if len(A) == 2:\n        return abs(A[0] - A[1])\n    if len(A) == 3:\n        return abs(A[0] - A[2])\n    if len(A) == 4:\n        return abs(A[0] - A[3])\n    if len(A) == 5:\n        return abs(A[0] - A[4])\n    if len(A) == 6:\n        return abs(A[0] - A[5])\n    if len(A) == 7:\n        return abs(A[0] - A[6])\n    if len(A) == 8:\n        return abs(A[0] - A[7])\n    if len(A) == 9:\n        return abs(A[0] - A[8])\n    if len(A) == 10:\n        return abs(A[0] - A[9])\n    if len(A) == 11:\n        return abs(A[0] - A[10])\n    if len(A) == 12:\n        return abs(A[0] - A[11])\n    if len(A) == 13:\n        return abs(A[0] - A[12])\n    if len(A) == 14:\n        return abs(A[0] - A[13])\n    if len(A) == 15:\n        return abs(A[0] - A[14])\n    if len(A) == 16:\n        return abs(A[0] - A[15])\n    if len(A) == 17:\n        return abs(A[0] - A[16])\n    if len(A) == 18:\n        return abs(A[0] - A[17])\n    if len(A) == 19:\n        return abs(A[0] - A[18])\n    if len(A) == 20:\n        return abs(A[0] - A[19])\n    if len(A) == 21:\n"
    ],
    "results": 10
},{
    "id": "1851",
    "source": "leetcode",
    "language": "python",
    "query": "An English letter b is greater than another letter a if b appears after a in the English alphabet. Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase in s.",
    "snippets": [
        "def find_greatest_letter(s):\n    return max(s, key=s.count)\n",
        "def find_greatest_letter(s):\n    # your code here\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in s[i+1:]:\n            return s[i]\n    return 'not found'\n",
        "def max_letter(s):\n    # your code here\n    lower = 0\n    upper = 0\n    for i in s:\n        if i.islower():\n            lower += 1\n        else:\n            upper += 1\n    if lower > upper:\n        return s.lower()\n    else:\n        return s.upper()\n",
        "def find_greatest_letter(s):\n    # your code here\n    return max(s, key=s.count)\n",
        "def find_greatest_letter(s):\n    # your code here\n    return max(set(s), key=s.count)\n",
        "def find_greatest_letter(s):\n    # your code here\n    return max(s.lower(), s.upper())\n"
    ],
    "results": 10
},{
    "id": "1852",
    "source": "leetcode",
    "language": "python",
    "query": "The next greater number of a number x is the first greater number to its traversing-order next in the array. If it doesn't exist, return -1 for this number. Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums [0]), return the next greater numbers for every element.",
    "snippets": [
        "def nextGreaterElement(nums):\n    stack = []\n    dic = {}\n    for i in range(len(nums)):\n        while stack and stack[-1] < nums[i]:\n            dic[stack.pop()] = nums[i]\n        stack.append(nums[i])\n    for i in range(len(nums)):\n        if nums[i] not in dic:\n            dic[nums[i]] = -1\n    return [dic[i] for i in nums]\n",
        "def nextGreaterElement(nums):\n    stack = []\n    dic = {}\n    for i in range(len(nums)):\n        while stack and stack[-1] < nums[i]:\n            dic[stack.pop()] = nums[i]\n        stack.append(nums[i])\n    for i in range(len(nums)):\n        if nums[i] not in dic:\n            dic[nums[i]] = -1\n    return list(dic.values())\n",
        "def nextGreaterElement(nums):\n    stack = []\n    dic = {}\n    for i in range(len(nums)):\n        while stack and stack[-1] < nums[i]:\n            dic[stack.pop()] = nums[i]\n        stack.append(nums[i])\n    for i in range(len(nums)):\n        if nums[i] in dic:\n            nums[i] = dic[nums[i]]\n        else:\n            nums[i] = -1\n    return nums\n",
        "def nextGreaterElements(nums):\n    stack = []\n    res = [-1] * len(nums)\n    for i in range(len(nums) * 2):\n        while stack and nums[stack[-1]] < nums[i % len(nums)]:\n            res[stack.pop()] = nums[i % len(nums)]\n        stack.append(i % len(nums))\n    return res\n",
        "def nextGreaterElement(nums):\n    stack = []\n    res = [-1] * len(nums)\n    for i in range(len(nums)):\n        while stack and nums[i] > stack[-1]:\n            res[stack.pop()] = nums[i]\n        stack.append(i)\n    return res\n",
        "def nextGreaterElement(nums):\n    stack = []\n    res = [-1] * len(nums)\n    for i in range(len(nums)):\n        while stack and nums[i] > nums[stack[-1]]:\n            res[stack.pop()] = nums[i]\n        stack.append(i)\n    return res\n",
        "def nextGreaterElement(nums):\n    stack = []\n    dic = {}\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            dic[stack.pop()] = nums[i]\n        stack.append(i)\n    for i in range(len(nums)):\n        if nums[i] not in dic:\n            dic[nums[i]] = -1\n    return list(dic.values())\n",
        "def nextGreaterElement(nums):\n    stack = []\n    result = []\n    for i in range(len(nums)):\n        while stack and stack[-1] < nums[i]:\n            result.append(stack.pop())\n        stack.append(nums[i])\n    while stack:\n        result.append(stack.pop())\n    return result\n"
    ],
    "results": 10
},{
    "id": "1853",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.",
    "snippets": [
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return []\n    if len(nums) == 1:\n        return nums\n    nums.sort()\n    mid = len(nums) // 2\n    if nums[mid] == nums[mid - 1]:\n        return [nums[mid]]\n    if nums[mid] == nums[mid + 1]:\n        return [nums[mid]]\n    return []\n",
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return []\n    if len(nums) == 1:\n        return nums\n    nums.sort()\n    if nums[0] == nums[1]:\n        return [nums[0]]\n    if nums[-1] == nums[-2]:\n        return [nums[-1]]\n    if nums[0] == nums[-1]:\n        return [nums[0]]\n    if nums[0] != nums[1]:\n        return [nums[0]]\n    if nums[-1] != nums[-2]:\n        return [nums[-1]]\n    if nums[0] != nums[-1]:\n        return [nums[0]]\n    if nums[0] == nums[-1]:\n        return [nums[0]]\n    if nums[0] == nums[1]:\n        return [nums[0]]\n    if nums[-1] == nums[-2]:\n        return [nums[-1]]\n    if nums[0] == nums[-1]:\n        return [nums[0]]\n    if nums[0] != nums[1]:\n        return [nums[0]]\n    if nums[-1] != nums[-2]:\n        return [nums[-1]]\n    if nums[0] != nums[-1]:\n        return [nums[0]]\n    if nums[0] == nums[-1]:\n        return [nums[0]]\n    if nums[0] == nums[1]:\n        return [nums[0]]\n    if nums[-1] == nums[-2]:\n        return [nums[-1]]\n    if nums[0] == nums[-1]:\n        return [nums[0]]\n    if nums[0] != nums[1]:\n        return [n\n",
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return []\n    if len(nums) == 1:\n        return nums\n    nums.sort()\n    mid = len(nums) // 2\n    if nums[mid] == nums[mid - 1]:\n        return [nums[mid]]\n    if nums[mid] == nums[mid + 1]:\n        return [nums[mid]]\n    return [nums[mid], nums[mid + 1]]\n",
        "def majorityElement(self, nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if not nums:\n        return []\n    if len(nums) == 1:\n        return nums\n    nums.sort()\n    mid = len(nums) // 2\n    if nums[mid] == nums[mid - 1]:\n        return [nums[mid]]\n    if nums[mid] == nums[mid + 1]:\n        return [nums[mid]]\n    return [nums[mid], nums[mid + 1]]\n",
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) == 0:\n        return []\n    if len(nums) == 1:\n        return nums\n    if len(nums) == 2:\n        if nums[0] == nums[1]:\n            return nums\n        else:\n            return []\n    if len(nums) == 3:\n        if nums[0] == nums[1] and nums[0] == nums[2]:\n            return nums\n        else:\n            return []\n    nums.sort()\n    if nums[0] == nums[1]:\n        return [nums[0]]\n    if nums[0] == nums[1] and nums[0] == nums[2]:\n        return [nums[0]]\n    if nums[0] == nums[1] and nums[0] != nums[2]:\n        return [nums[0], nums[1]]\n    if nums[0] != nums[1] and nums[0] == nums[2]:\n        return [nums[0], nums[2]]\n    if nums[0] != nums[1] and nums[0] != nums[2]:\n        return [nums[0], nums[1], nums[2]]\n    if nums[0] != nums[1] and nums[0] != nums[2] and nums[1] != nums[2]:\n        return [nums[0], nums[1], nums[2]]\n    if nums[0] != nums[1] and nums[0] != nums[2] and nums[1] != nums[2] and nums[2] != nums[3]:\n        return [nums[0], nums[1], nums[2]]\n    if nums[0] != nums[1] and nums[0] != nums[2] and nums[1\n",
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) == 0:\n        return []\n    if len(nums) == 1:\n        return nums\n    if len(nums) == 2:\n        if nums[0] == nums[1]:\n            return nums\n        else:\n            return []\n    if len(nums) == 3:\n        if nums[0] == nums[1] and nums[0] == nums[2]:\n            return nums\n        else:\n            return []\n    nums.sort()\n    if nums[0] == nums[1]:\n        return [nums[0]]\n    if nums[0] == nums[1] and nums[0] == nums[2]:\n        return [nums[0]]\n    if nums[0] == nums[1] and nums[0] != nums[2]:\n        return [nums[0], nums[2]]\n    if nums[0] != nums[1] and nums[0] == nums[2]:\n        return [nums[0], nums[1]]\n    if nums[0] != nums[1] and nums[0] != nums[2]:\n        return [nums[0], nums[1], nums[2]]\n    if nums[0] != nums[1] and nums[0] != nums[2] and nums[1] != nums[2]:\n        return [nums[0], nums[1], nums[2]]\n    if nums[0] == nums[1] and nums[0] != nums[2]:\n        return [nums[0], nums[2]]\n    if nums[0] == nums[1] and nums[0] == nums[2]:\n        return [nums[0]]\n    if nums[0] != nums[1] and nums[0] == nums[2\n",
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) == 0:\n        return []\n    if len(nums) == 1:\n        return nums\n    if len(nums) == 2:\n        return [nums[0]] if nums[0] == nums[1] else []\n    if len(nums) == 3:\n        return [nums[0]] if nums[0] == nums[1] or nums[0] == nums[2] else []\n    if len(nums) == 4:\n        return [nums[0]] if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] else []\n    if len(nums) == 5:\n        return [nums[0]] if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] else []\n    if len(nums) == 6:\n        return [nums[0]] if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] or nums[0] == nums[5] else []\n    if len(nums) == 7:\n        return [nums[0]] if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] or nums[0] == nums[5] or nums[0] == nums[6] else []\n    if len(nums) == 8:\n        return [nums[0]] if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] ==\n",
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) == 0:\n        return []\n    if len(nums) == 1:\n        return [nums[0]]\n    if len(nums) == 2:\n        if nums[0] == nums[1]:\n            return [nums[0]]\n        else:\n            return []\n    nums.sort()\n    if nums[0] == nums[1]:\n        return [nums[0]]\n    if nums[0] == nums[2]:\n        return [nums[0]]\n    if nums[1] == nums[2]:\n        return [nums[1]]\n    if nums[0] == nums[3]:\n        return [nums[0]]\n    if nums[1] == nums[3]:\n        return [nums[1]]\n    if nums[2] == nums[3]:\n        return [nums[2]]\n    return []\n",
        "def majorityElement(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    if len(nums) <= 1:\n        return nums\n    num1, num2 = 0, 0\n    count1, count2 = 0, 0\n    for num in nums:\n        if num == num1:\n            count1 += 1\n        elif num == num2:\n            count2 += 1\n        elif count1 == 0:\n            num1 = num\n            count1 = 1\n        elif count2 == 0:\n            num2 = num\n            count2 = 1\n        else:\n            count1 -= 1\n            count2 -= 1\n    count1 = 0\n    count2 = 0\n    for num in nums:\n        if num == num1:\n            count1 += 1\n        elif num == num2:\n            count2 += 1\n    res = []\n    if count1 > len(nums) // 3:\n        res.append(num1)\n    if count2 > len(nums) // 3:\n        res.append(num2)\n    return res\n"
    ],
    "results": 10
},{
    "id": "1854",
    "source": "leetcode",
    "language": "python",
    "query": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.",
    "snippets": [
        "def count_unique_words(words1, words2):\n    count = 0\n    for word in words1:\n        if word not in words2:\n            count += 1\n    for word in words2:\n        if word not in words1:\n            count += 1\n    return count\n",
        "def count_unique_words(words1, words2):\n    unique_words = []\n    for word in words1:\n        if word not in unique_words:\n            unique_words.append(word)\n    for word in words2:\n        if word not in unique_words:\n            unique_words.append(word)\n    return len(unique_words)\n",
        "def count_unique_words(words1, words2):\n    # Write your code here.\n    words1_set = set(words1)\n    words2_set = set(words2)\n    return len(words1_set.intersection(words2_set))\n",
        "def unique_words(words1, words2):\n    # your code here\n    words1 = set(words1)\n    words2 = set(words2)\n    return len(words1.intersection(words2))\n",
        "def count_unique_words(words1, words2):\n    # Your code here\n    return len(set(words1) & set(words2))\n",
        "def uniqueMerge(words1, words2):\n    words1 = set(words1)\n    words2 = set(words2)\n    return len(words1.intersection(words2))\n",
        "def unique_words(words1, words2):\n    return len(set(words1) & set(words2))\n",
        "def count_unique_words(words1, words2):\n    # your code here\n    return len(set(words1) & set(words2))\n",
        "def count_unique_words(words1, words2):\n    # Your code here\n    return 0\n",
        "def count_unique(words1, words2):\n    # Your code here\n    return len(set(words1) ^ set(words2))\n"
    ],
    "results": 10
},{
    "id": "1855",
    "source": "leetcode",
    "language": "python",
    "query": "Given two strings first and second, consider occurrences in some text of the form \"first second third\" Return an array of all the words third for each occurrence of \" first second third\".",
    "snippets": [
        "def third_words(first, second):\n    return [word for word in first.split() if word in second.split()]\n",
        "def third_words(text):\n    return [word for word in text.split() if word.endswith('third')]\n",
        "def combine_words(first, second, third):\n    return [third + ' ' + first + ' ' + second + ' ' + third for i in range(len(first))]\n",
        "def words_third(first, second, text):\n    return [word for word in text.split() if first + ' ' + second in word]\n",
        "def combine_words(first, second, third):\n    return [third + \" \" + first + \" \" + second + \" \" + third for third in third]\n"
    ],
    "results": 10
},{
    "id": "1856",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array of even length arr, return true if it is possible to reorder arr such that arr[2 * i + 1] = 2 * arr[ 2 * i] for every 0 <= i < len(arr) / 2.",
    "snippets": [
        "def canReorderDoubled(arr):\n    arr.sort()\n    for i in range(len(arr) // 2):\n        if arr[2 * i] != arr[2 * i + 1]:\n            return False\n    return True\n",
        "def canReorderDoubled(arr):\n    # Write your code here.\n    arr.sort()\n    for i in range(len(arr)//2):\n        if arr[2*i] != arr[2*i+1]:\n            return False\n    return True\n",
        "def canReorderDoubled(arr):\n    # Write your code here.\n    arr.sort()\n    for i in range(len(arr)//2):\n        if arr[2*i]*2 != arr[2*i+1]:\n            return False\n    return True\n",
        "def can_reorder_to_form_palindrome(arr):\n    # Write your code here.\n    n = len(arr)\n    if n % 2 == 1:\n        return False\n    count = [0] * 10001\n    for i in arr:\n        count[i] += 1\n    odd_count = 0\n    for i in range(10000):\n        if count[i] % 2 == 1:\n            odd_count += 1\n    if odd_count > 1:\n        return False\n    for i in range(10000):\n        if count[i] == 0:\n            continue\n        if count[i] % 2 == 1:\n            if count[i] == 1:\n                return False\n            count[i] -= 1\n            count[i * 2] += 1\n    for i in range(10000):\n        if count[i] == 0:\n            continue\n        if count[i] % 2 == 1:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1857",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.",
    "snippets": [
        "def reverse_words(s):\n    return ' '.join(word[::-1] for word in s.split())\n",
        "def reverse_words(s):\n    return ' '.join(reversed(s.split()))\n",
        "def reverse_each_word(s):\n    return ' '.join(reversed(s.split()))\n",
        "def reverse_word(s):\n    return ' '.join(reversed(s.split()))\n"
    ],
    "results": 10
},{
    "id": "1858",
    "source": "leetcode",
    "language": "python",
    "query": "For example, 21 written in binary is 10101, which has 3 set bits. Given two integers left and right, return the count of numbers in the inclusive range.",
    "snippets": [
        "def count_set_bits(n):\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def count_set_bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def count_bits(n):\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n",
        "def count_bits(n):\n    return sum(bin(i).count('1') for i in range(n+1))\n",
        "def count_bits(n):\n    count = 0\n    while n > 0:\n        n = n & (n - 1)\n        count += 1\n    return count\n",
        "def count_set_bits(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n",
        "def count_bits(n):\n    return bin(n).count('1')\n"
    ],
    "results": 10
},{
    "id": "1859",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition.",
    "snippets": [
        "def sortArrayByParity(A):\n    even = []\n    odd = []\n    for i in A:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return even + odd\n"
    ],
    "results": 10
},{
    "id": "1860",
    "source": "leetcode",
    "language": "python",
    "query": "A subarray is a contiguous subsequence of the array. Given an integer array arr, remove a subarray from arr such that the remaining elements in arr are non-decreasing.",
    "snippets": [
        "def remove_subarray(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return arr\n        else:\n            return [arr[1]]\n    if len(arr) == 3:\n        if arr[0] <= arr[1] <= arr[2]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[1]:\n            return arr[1:]\n        elif arr[1] <= arr[0] <= arr[2]:\n            return arr[1:]\n        else:\n            return arr[2:]\n    if len(arr) == 4:\n        if arr[0] <= arr[1] <= arr[2] <= arr[3]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[1] <= arr[3]:\n            return arr[1:]\n        elif arr[0] <= arr[3] <= arr[1] <= arr[2]:\n            return arr[1:]\n        elif arr[1] <= arr[0] <= arr[2] <= arr[3]:\n            return arr[1:]\n        elif arr[1] <= arr[2] <= arr[0] <= arr[3]:\n            return arr[1:]\n        elif arr[1] <= arr[3] <= arr[0] <= arr[2]:\n            return arr[1:]\n        elif arr[2] <= arr[0] <= arr[1] <= arr[3]:\n            return arr[1:]\n        elif arr[2] <= arr[1] <= arr[0] <= arr[3]:\n            return arr[1:]\n        elif arr[2] <= arr[3] <= arr[0] <= arr[1]:\n            return arr[1:]\n        elif arr[3] <= arr[0] <= arr[1] <= arr[2]:\n            return arr[1:]\n        elif arr[3] <= arr[1] <= arr[0] <= arr[2]:\n            return arr[\n",
        "def remove_subarray(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return arr\n        else:\n            return []\n    if arr[0] <= arr[1]:\n        return arr\n    else:\n        return remove_subarray(arr[1:])\n",
        "def remove_subarray(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return arr\n        else:\n            return [arr[1]]\n    if len(arr) == 3:\n        if arr[0] <= arr[1] <= arr[2]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[1]:\n            return arr[1:]\n        elif arr[1] <= arr[0] <= arr[2]:\n            return arr[1:]\n        else:\n            return arr[2:]\n    if len(arr) == 4:\n        if arr[0] <= arr[1] <= arr[2] <= arr[3]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[3] <= arr[1]:\n            return arr[1:]\n        elif arr[0] <= arr[3] <= arr[1] <= arr[2]:\n            return arr[1:]\n        elif arr[1] <= arr[0] <= arr[2] <= arr[3]:\n            return arr[1:]\n        elif arr[1] <= arr[3] <= arr[0] <= arr[2]:\n            return arr[1:]\n        elif arr[1] <= arr[2] <= arr[0] <= arr[3]:\n            return arr[1:]\n        elif arr[2] <= arr[0] <= arr[1] <= arr[3]:\n            return arr[1:]\n        elif arr[2] <= arr[3] <= arr[0] <= arr[1]:\n            return arr[1:]\n        elif arr[3] <= arr[0] <= arr[1] <= arr[2]:\n            return arr[1:]\n        elif arr[3] <= arr[2] <= arr[0] <= arr[1]:\n            return arr[1:]\n        else:\n            return arr[2:]\n    if len(arr) == 5:\n        if arr[0]\n",
        "def remove_subarray(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return arr\n        else:\n            return []\n    if len(arr) == 3:\n        if arr[0] <= arr[1] and arr[1] <= arr[2]:\n            return arr\n        elif arr[0] <= arr[2] and arr[2] <= arr[1]:\n            return arr[1:]\n        else:\n            return []\n    if len(arr) == 4:\n        if arr[0] <= arr[1] and arr[1] <= arr[2] and arr[2] <= arr[3]:\n            return arr\n        elif arr[0] <= arr[2] and arr[2] <= arr[1] and arr[1] <= arr[3]:\n            return arr[1:]\n        elif arr[0] <= arr[3] and arr[3] <= arr[1] and arr[1] <= arr[2]:\n            return arr[1:]\n        elif arr[0] <= arr[1] and arr[1] <= arr[3] and arr[3] <= arr[2]:\n            return arr[1:]\n        elif arr[0] <= arr[2] and arr[2] <= arr[3] and arr[3] <= arr[1]:\n            return arr[1:]\n        elif arr[0] <= arr[3] and arr[3] <= arr[2] and arr[2] <= arr[1]:\n            return arr[1:]\n        else:\n            return []\n    if len(arr) == 5:\n        if arr[0] <= arr[1] and arr[1] <= arr[2] and arr[2] <= arr[3] and arr[3] <= arr[4]:\n            return arr\n        elif arr[0] <= arr[2] and arr[2] <= arr[1] and arr[1] <= arr[3] and arr[3] <= arr[4]:\n            return\n",
        "def remove_subarray(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return arr\n        else:\n            return [arr[1]]\n    if len(arr) == 3:\n        if arr[0] <= arr[1] <= arr[2]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[1]:\n            return arr[1:]\n        elif arr[1] <= arr[0] <= arr[2]:\n            return arr[1:]\n        else:\n            return arr[2:]\n    if len(arr) == 4:\n        if arr[0] <= arr[1] <= arr[2] <= arr[3]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[1] <= arr[3]:\n            return arr[1:]\n        elif arr[0] <= arr[3] <= arr[1] <= arr[2]:\n            return arr[1:]\n        elif arr[1] <= arr[0] <= arr[2] <= arr[3]:\n            return arr[1:]\n        elif arr[1] <= arr[3] <= arr[0] <= arr[2]:\n            return arr[1:]\n        elif arr[1] <= arr[2] <= arr[0] <= arr[3]:\n            return arr[1:]\n        elif arr[2] <= arr[0] <= arr[1] <= arr[3]:\n            return arr[1:]\n        elif arr[2] <= arr[3] <= arr[0] <= arr[1]:\n            return arr[1:]\n        elif arr[3] <= arr[0] <= arr[1] <= arr[2]:\n            return arr[1:]\n        elif arr[3] <= arr[2] <= arr[0] <= arr[1]:\n            return arr[1:]\n        else:\n            return arr[2:]\n    if len(arr) == 5:\n        if arr[0]\n",
        "def remove_subarray(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] <= arr[1]:\n            return arr\n        else:\n            return [arr[1]]\n    if len(arr) == 3:\n        if arr[0] <= arr[1] <= arr[2]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[1]:\n            return arr[1:]\n        else:\n            return [arr[2]]\n    if len(arr) == 4:\n        if arr[0] <= arr[1] <= arr[2] <= arr[3]:\n            return arr\n        elif arr[0] <= arr[2] <= arr[3] <= arr[1]:\n            return arr[1:]\n        elif arr[0] <= arr[3] <= arr[2] <= arr[1]:\n            return arr[1:]\n        elif arr[1] <= arr[0] <= arr[2] <= arr[3]:\n            return arr[2:]\n        elif arr[1] <= arr[2] <= arr[3] <= arr[0]:\n            return arr[2:]\n        elif arr[1] <= arr[3] <= arr[0] <= arr[2]:\n            return arr[2:]\n        elif arr[2] <= arr[0] <= arr[1] <= arr[3]:\n            return arr[3:]\n        elif arr[2] <= arr[1] <= arr[3] <= arr[0]:\n            return arr[3:]\n        elif arr[2] <= arr[3] <= arr[0] <= arr[1]:\n            return arr[3:]\n        elif arr[3] <= arr[0] <= arr[1] <= arr[2]:\n            return arr[3:]\n        elif arr[3] <= arr[1] <= arr[2] <= arr[0]:\n            return arr[3:]\n        elif arr[3] <= arr[2] <= arr[0] <= arr[1\n"
    ],
    "results": 10
},{
    "id": "1861",
    "source": "leetcode",
    "language": "python",
    "query": "There may be duplicates in the original array. Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.",
    "snippets": [
        "def checkPossibility(nums):\n    if len(nums) == 0:\n        return True\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        if nums[0] <= nums[1]:\n            return True\n        else:\n            return False\n    for i in range(len(nums)-1):\n        if nums[i] > nums[i+1]:\n            if i == 0:\n                if nums[i+1] >= nums[i+2]:\n                    return True\n                else:\n                    return False\n            if i == len(nums)-2:\n                if nums[i-1] >= nums[i+1]:\n                    return True\n                else:\n                    return False\n            if nums[i-1] >= nums[i+1] and nums[i+1] >= nums[i+2]:\n                return True\n            if nums[i-1] <= nums[i+1] and nums[i+1] >= nums[i+2]:\n                return True\n            if nums[i-1] <= nums[i+1] and nums[i+1] <= nums[i+2]:\n                return False\n            if nums[i-1] >= nums[i+1] and nums[i+1] <= nums[i+2]:\n                return False\n    return True\n",
        "def checkPossibility(nums):\n    if len(nums) == 0:\n        return True\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        if nums[0] <= nums[1]:\n            return True\n        else:\n            return False\n    if nums[0] <= nums[1]:\n        return checkPossibility(nums[1:])\n    else:\n        if nums[0] <= nums[2]:\n            return checkPossibility(nums[1:])\n        else:\n            return False\n",
        "def checkPair(nums):\n    for i in range(len(nums)-1):\n        if nums[i] > nums[i+1]:\n            return False\n    return True\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    if nums[0] <= nums[1]:\n        return True\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            if i == 1 or nums[i-2] <= nums[i]:\n                return True\n            else:\n                return False\n    return True\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    for i in range(len(nums)-1):\n        if nums[i] > nums[i+1]:\n            if i == 0:\n                return nums[i] <= nums[i+2]\n            elif i == len(nums)-2:\n                return nums[i] >= nums[i-1]\n            else:\n                return nums[i] >= nums[i-1] and nums[i] <= nums[i+2]\n    return True\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    for i in range(len(nums)-1):\n        if nums[i] > nums[i+1]:\n            if i == 0:\n                if i+2 < len(nums) and nums[i+2] > nums[i]:\n                    return False\n                else:\n                    return True\n            elif i+1 < len(nums) and nums[i-1] > nums[i+1]:\n                return False\n            else:\n                return True\n    return True\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    if nums[0] <= nums[1]:\n        return True\n    for i in range(1, len(nums) - 1):\n        if nums[i] <= nums[i + 1] and nums[i - 1] <= nums[i]:\n            return True\n    return False\n",
        "def checkPossibility(nums):\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        if nums[0] <= nums[1]:\n            return True\n        else:\n            return False\n    for i in range(len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            if i == 0:\n                if nums[i] <= nums[i + 2]:\n                    return True\n                else:\n                    return False\n            elif i == len(nums) - 2:\n                if nums[i] <= nums[i - 1]:\n                    return True\n                else:\n                    return False\n            else:\n                if nums[i] <= nums[i + 2] or nums[i] <= nums[i - 1]:\n                    return True\n                else:\n                    return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1862",
    "source": "leetcode",
    "language": "python",
    "query": "Given a binary string s, return true if s contains at most one contiguous segment of ones. Otherwise, return false.",
    "snippets": [
        "def binary_string(s):\n    if s == '':\n        return True\n    if s[0] == '0':\n        return binary_string(s[1:])\n    if s[0] == '1':\n        if s[1] == '0':\n            return binary_string(s[2:])\n        if s[1] == '1':\n            return False\n    return False\n",
        "def binary_string(s):\n    if s == '':\n        return True\n    if s[0] == '0':\n        return binary_string(s[1:])\n    if s[0] == '1':\n        if s[1] == '1':\n            return False\n        else:\n            return binary_string(s[1:])\n    return False\n",
        "def binary_string(s):\n    if s == '':\n        return True\n    if s[0] == '0':\n        return binary_string(s[1:])\n    if s[0] == '1':\n        if s[1] == '0':\n            return binary_string(s[2:])\n        else:\n            return False\n    return False\n",
        "def hasOne(s):\n    if s == \"\":\n        return True\n    if s[0] == \"0\":\n        return hasOne(s[1:])\n    if s[0] == \"1\":\n        if s[1] == \"1\":\n            return False\n        else:\n            return hasOne(s[1:])\n    return False\n",
        "def has_one_bit(s):\n    if s == \"\":\n        return False\n    if s == \"0\":\n        return False\n    if s == \"1\":\n        return True\n    if s[0] == \"1\":\n        return has_one_bit(s[1:])\n    else:\n        return has_one_bit(s[1:])\n",
        "def binary_string_contains_one_contiguous_segment(s):\n    if s == \"\":\n        return True\n    if s[0] == \"0\":\n        return binary_string_contains_one_contiguous_segment(s[1:])\n    else:\n        if len(s) == 1:\n            return True\n        else:\n            if s[1] == \"0\":\n                return binary_string_contains_one_contiguous_segment(s[2:])\n            else:\n                return False\n",
        "def has_one_segment(s):\n    if s == \"\":\n        return True\n    if s[0] == \"0\":\n        return has_one_segment(s[1:])\n    else:\n        if s[1:] == \"\":\n            return True\n        if s[1] == \"0\":\n            return has_one_segment(s[2:])\n        else:\n            return False\n",
        "def has_one_segment(s):\n    if len(s) == 0:\n        return True\n    if len(s) == 1:\n        return s == '1'\n    if s[0] == '1':\n        return has_one_segment(s[1:])\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "1863",
    "source": "leetcode",
    "language": "python",
    "query": "A square triple (a,b,c) is a triple where a, b, and c are integers. A2 + b2 = c2.",
    "snippets": [
        "def is_square(n):\n    return n**0.5 % 1 == 0\n",
        "def is_square(n):\n    return n == int(n**0.5)**2\n",
        "def is_square(n):\n    if n < 0:\n        return False\n    else:\n        return int(n**0.5)**2 == n\n"
    ],
    "results": 10
},{
    "id": "1864",
    "source": "leetcode",
    "language": "python",
    "query": "An integer is a palindrome when it reads the same backward as forward. Given an integer x, return true if x is palindromic integer.",
    "snippets": [
        "def is_palindrome(x):\n    return str(x) == str(x)[::-1]\n",
        "def is_palindrome(x):\n    if x < 0:\n        return False\n    else:\n        x = str(x)\n        if x == x[::-1]:\n            return True\n        else:\n            return False\n"
    ],
    "results": 10
},{
    "id": "1865",
    "source": "leetcode",
    "language": "python",
    "query": "An Anagram is a word or phrase formed by rearranging the letters of a different word. Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "snippets": [
        "def anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    t_dict = {}\n    for i in s:\n        if i in s_dict:\n            s_dict[i] += 1\n        else:\n            s_dict[i] = 1\n    for i in t:\n        if i in t_dict:\n            t_dict[i] += 1\n        else:\n            t_dict[i] = 1\n    for key in s_dict:\n        if key not in t_dict:\n            return False\n        if s_dict[key] != t_dict[key]:\n            return False\n    return True\n",
        "def anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    t_dict = {}\n    for i in s:\n        if i in s_dict:\n            s_dict[i] += 1\n        else:\n            s_dict[i] = 1\n    for i in t:\n        if i in t_dict:\n            t_dict[i] += 1\n        else:\n            t_dict[i] = 1\n    for i in s_dict:\n        if i not in t_dict or s_dict[i] != t_dict[i]:\n            return False\n    return True\n",
        "def anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    t_dict = {}\n    for i in s:\n        if i in s_dict:\n            s_dict[i] += 1\n        else:\n            s_dict[i] = 1\n    for i in t:\n        if i in t_dict:\n            t_dict[i] += 1\n        else:\n            t_dict[i] = 1\n    for key in s_dict:\n        if key not in t_dict or s_dict[key] != t_dict[key]:\n            return False\n    return True\n",
        "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    for letter in s:\n        if letter in s_dict:\n            s_dict[letter] += 1\n        else:\n            s_dict[letter] = 1\n    for letter in t:\n        if letter in s_dict:\n            s_dict[letter] -= 1\n        else:\n            s_dict[letter] = 1\n    for key in s_dict:\n        if s_dict[key] != 0:\n            return False\n    return True\n",
        "def anagram(s, t):\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    for letter in s:\n        if letter in s_dict:\n            s_dict[letter] += 1\n        else:\n            s_dict[letter] = 1\n    for letter in t:\n        if letter in s_dict:\n            s_dict[letter] -= 1\n        else:\n            s_dict[letter] = 1\n    for key in s_dict:\n        if s_dict[key] != 0:\n            return False\n    return True\n",
        "def anagram(s, t):\n    s = s.replace(' ', '').lower()\n    t = t.replace(' ', '').lower()\n    if len(s) != len(t):\n        return False\n    s_dict = {}\n    for letter in s:\n        if letter in s_dict:\n            s_dict[letter] += 1\n        else:\n            s_dict[letter] = 1\n    for letter in t:\n        if letter in s_dict:\n            s_dict[letter] -= 1\n        else:\n            s_dict[letter] = 1\n    for key in s_dict:\n        if s_dict[key] != 0:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1866",
    "source": "leetcode",
    "language": "python",
    "query": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound. You may return the answer in any order.",
    "snippets": [
        "def powerfulIntegers(x, y, bound):\n    # Write your code here.\n    result = []\n    for i in range(x, bound):\n        for j in range(y, bound):\n            result.append(i ** j)\n    return list(set(result))\n",
        "def powerfulIntegers(x, y, bound):\n    # Write your code here.\n    res = []\n    for i in range(x, bound):\n        for j in range(y, bound):\n            if i ** j <= bound:\n                res.append(i ** j)\n    return res\n",
        "def powerfulIntegers(x, y, bound):\n    # Write your code here.\n    ans = set()\n    for i in range(x+1):\n        for j in range(y+1):\n            if i+j <= bound:\n                ans.add(i+j)\n    return list(ans)\n",
        "def powerfulIntegers(x, y, bound):\n    # Write your code here.\n    ans = set()\n    for i in range(x+1):\n        for j in range(y+1):\n            if i+j > bound:\n                break\n            ans.add(i+j)\n    return list(ans)\n",
        "def powerful_integers(x, y, bound):\n    # Write your code here.\n    result = []\n    for i in range(x, bound):\n        for j in range(y, bound):\n            result.append(i ** j)\n    return list(set(result))\n",
        "def powerfulIntegers(x, y, bound):\n    # Write your code here\n    ans = []\n    for i in range(x, bound):\n        for j in range(y, bound):\n            if i ** j <= bound:\n                ans.append(i ** j)\n    return ans\n",
        "def powerfulIntegers(x, y, bound):\n    # Write your code here.\n    ans = []\n    for i in range(1, bound):\n        if i >= x and i >= y:\n            ans.append(i)\n        if i >= x:\n            ans.append(i * y)\n        if i >= y:\n            ans.append(i * x)\n    return list(set(ans))\n"
    ],
    "results": 9
},{
    "id": "1867",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array nums. In one move, you can choose one element of nums and change it by any value. Return the minimum difference between the largest and smallest value after performing at most three moves.",
    "snippets": [
        "def minDifference(nums):\n    nums.sort()\n    min_diff = nums[-1] - nums[0]\n    for i in range(len(nums) - 1):\n        min_diff = min(min_diff, nums[i + 1] - nums[i])\n    return min_diff\n",
        "def minDifference(nums):\n    nums.sort()\n    min_diff = nums[-1] - nums[0]\n    for i in range(len(nums) - 1):\n        if nums[i + 1] - nums[i] < min_diff:\n            min_diff = nums[i + 1] - nums[i]\n    return min_diff\n",
        "def minDifference(nums):\n    nums.sort()\n    return min(nums[i+1]-nums[i] for i in range(len(nums)-1))\n"
    ],
    "results": 10
},{
    "id": "1868",
    "source": "leetcode",
    "language": "python",
    "query": "The test cases are generated so that the answer will fit in a 32-bit integer. Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays.",
    "snippets": [
        "def numSubarrayBoundedMax(nums, L, R):\n    \"\"\"\n    :type nums: List[int]\n    :type L: int\n    :type R: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    count = 0\n    left = 0\n    for i in range(len(nums)):\n        if nums[i] >= L:\n            left = i\n            break\n    for i in range(len(nums)):\n        if nums[i] <= R:\n            count += i - left + 1\n        else:\n            left = i + 1\n    return count\n",
        "def numSubarrayBoundedMax(nums, L, R):\n    \"\"\"\n    :type nums: List[int]\n    :type L: int\n    :type R: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    count = 0\n    left = 0\n    for i in range(len(nums)):\n        if nums[i] <= L:\n            left += 1\n        elif nums[i] >= R:\n            left = 0\n        count += left\n    return count\n",
        "def numSubarrayBoundedMax(nums, L, R):\n    \"\"\"\n    :type nums: List[int]\n    :type L: int\n    :type R: int\n    :rtype: int\n    \"\"\"\n    ans = 0\n    left = 0\n    for i in range(len(nums)):\n        if nums[i] <= R:\n            ans += 1\n        while left < len(nums) and nums[left] <= L:\n            left += 1\n        ans += i - left + 1\n    return ans\n",
        "def numSubarrayBoundedMax(nums, L, R):\n    \"\"\"\n    :type nums: List[int]\n    :type L: int\n    :type R: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    count = 0\n    left = 0\n    for i in range(len(nums)):\n        if nums[i] >= L:\n            left = i\n            break\n    for i in range(len(nums)):\n        if nums[i] <= R:\n            count += i - left + 1\n        else:\n            break\n    return count\n",
        "def numSubarrayBoundedMax(nums, L, R):\n    \"\"\"\n    :type nums: List[int]\n    :type L: int\n    :type R: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    count = 0\n    left = 0\n    for i in range(len(nums)):\n        if nums[i] >= L:\n            left = i\n            break\n    for i in range(left, len(nums)):\n        if nums[i] > R:\n            count += i - left\n            left = i + 1\n    return count + len(nums) - left\n",
        "def numSubarrayBoundedMax(nums, left, right):\n    \"\"\"\n    :type nums: List[int]\n    :type left: int\n    :type right: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] <= left:\n            count += 1\n        elif nums[i] <= right:\n            count += 1\n        else:\n            break\n    for i in range(len(nums) - 1, -1, -1):\n        if nums[i] <= right:\n            count += 1\n        elif nums[i] <= left:\n            count += 1\n        else:\n            break\n    return count\n",
        "def numSubarrayBoundedMax(nums, left, right):\n    \"\"\"\n    :type nums: List[int]\n    :type left: int\n    :type right: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] <= left:\n            count += 1\n        elif nums[i] >= right:\n            count += 1\n        else:\n            count += 1\n            break\n    return count\n",
        "def numSubarraysWithSum(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return 1 if nums[0] == target else 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == target:\n            count += 1\n        if nums[i] == target and i > 0 and nums[i-1] == target:\n            count += 1\n    return count\n",
        "def numSubarraysWithSum(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        if nums[0] == target:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == target:\n            count += 1\n    if count == 0:\n        return 0\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == target:\n            count += 1\n            if i == 0:\n                continue\n            if nums[i-1] == target:\n                count += 1\n    return count\n",
        "def countSubarrays(nums, left, right):\n    if left == right:\n        return 0\n    if left > right:\n        return 0\n    if left == 0:\n        return sum(nums[right:])\n    if right == len(nums) - 1:\n        return sum(nums[:left])\n    return sum(nums[left:right + 1])\n"
    ],
    "results": 10
},{
    "id": "1869",
    "source": "leetcode",
    "language": "python",
    "query": "A subsequence is a sequence that can be derived from another sequence by deleting some or no elements. Given a string s, find the longest palindromic subsequence's length in s.",
    "snippets": [
        "def longest_palindrome_subsequence(s):\n    dp = [[0] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = 1\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][-1]\n",
        "def longest_palindrome_subsequence(s):\n    dp = [[0] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = 1\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][len(s) - 1]\n",
        "def longest_palindrome_subsequence(s):\n    dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = 1\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][len(s) - 1]\n",
        "def longest_palindrome_subseq(s):\n    dp = [[0] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = 1\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][len(s) - 1]\n",
        "def longest_palindrome_subsequence(s):\n    n = len(s)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n",
        "def longestPalindromeSubseq(s):\n    \"\"\"\n    :type s: str\n    :rtype: int\n    \"\"\"\n    dp = [[0] * len(s) for _ in range(len(s))]\n    for i in range(len(s)):\n        dp[i][i] = 1\n    for i in range(len(s) - 1, -1, -1):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][-1]\n"
    ],
    "results": 10
},{
    "id": "1870",
    "source": "leetcode",
    "language": "python",
    "query": "We are given a list nums of integers representing a list compressed with run-length encoding. For each adjacent pair of elements [freq, val] there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.",
    "snippets": [
        "def decompressRLElist(nums):\n    result = []\n    for i in range(0, len(nums), 2):\n        result.extend([nums[i+1]] * nums[i])\n    return result\n",
        "def decompressRLElist(nums):\n    res = []\n    for i in range(0, len(nums), 2):\n        res += [nums[i+1]] * nums[i]\n    return res\n",
        "def decompressRLElist(nums):\n    result = []\n    for i in range(0, len(nums), 2):\n        result += [nums[i+1]] * nums[i]\n    return result\n",
        "def decompressRLElist(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[int]\n    \"\"\"\n    result = []\n    for i in range(0, len(nums), 2):\n        result.extend([nums[i+1]] * nums[i])\n    return result\n",
        "def decompress(nums):\n    result = []\n    for i in range(0, len(nums), 2):\n        result.extend([nums[i+1]] * nums[i])\n    return result\n",
        "def decompress(nums):\n    result = []\n    for i in range(0, len(nums), 2):\n        result += [nums[i+1]] * nums[i]\n    return result\n",
        "def decompress(nums):\n    result = []\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            result.extend([nums[i+1]] * nums[i])\n    return result\n"
    ],
    "results": 10
},{
    "id": "1871",
    "source": "leetcode",
    "language": "python",
    "query": "It is guaranteed that the node to be deleted is not a tail node in the list. Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given Access to the node.",
    "snippets": [
        "def delete_node(node):\n    node.val = node.next.val\n    node.next = node.next.next\n    return node\n"
    ],
    "results": 10
},{
    "id": "1872",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. Return the minimum number of operations to reduce the sum of nums by at least half.",
    "snippets": [
        "def minOperations(nums):\n    count = 0\n    while sum(nums) > 0:\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                nums[i] = nums[i] // 2\n            else:\n                nums[i] = (nums[i] + 1) // 2\n        count += 1\n    return count\n",
        "def minOperations(nums):\n    count = 0\n    while sum(nums) > 0:\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                nums[i] = nums[i] // 2\n            else:\n                nums[i] = (nums[i] - 1) // 2\n        count += 1\n    return count\n",
        "def minOperations(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return nums[0] + nums[1]\n    if len(nums) == 3:\n        return nums[0] + nums[1] + nums[2]\n    if len(nums) == 4:\n        return nums[0] + nums[1] + nums[2] + nums[3]\n    if len(nums) == 5:\n        return nums[0] + nums[1] + nums[2] + nums[3] + nums[4]\n    if len(nums) == 6:\n        return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5]\n    if len(nums) == 7:\n        return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6]\n    if len(nums) == 8:\n        return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7]\n    if len(nums) == 9:\n        return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8]\n    if len(nums) == 10:\n        return nums[0] + nums[1] + nums[2] + nums[3] + nums[4] + nums[5] + nums[6] + nums[7] + nums[8] + nums[9]\n    if len(nums) == 11:\n        return nums[\n",
        "def minOperations(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    count = 0\n    while sum(nums) > 0:\n        for i in range(len(nums)):\n            if nums[i] % 2 == 0:\n                nums[i] = nums[i] // 2\n                count += 1\n                break\n        else:\n            return -1\n    return count\n",
        "def min_operations(nums):\n    if len(nums) == 1:\n        return 0\n    if len(nums) == 2:\n        return 1\n    if len(nums) == 3:\n        return 2\n    if len(nums) == 4:\n        return 3\n    if len(nums) == 5:\n        return 4\n    if len(nums) == 6:\n        return 5\n    if len(nums) == 7:\n        return 6\n    if len(nums) == 8:\n        return 7\n    if len(nums) == 9:\n        return 8\n    if len(nums) == 10:\n        return 9\n    if len(nums) == 11:\n        return 10\n    if len(nums) == 12:\n        return 11\n    if len(nums) == 13:\n        return 12\n    if len(nums) == 14:\n        return 13\n    if len(nums) == 15:\n        return 14\n    if len(nums) == 16:\n        return 15\n    if len(nums) == 17:\n        return 16\n    if len(nums) == 18:\n        return 17\n    if len(nums) == 19:\n        return 18\n    if len(nums) == 20:\n        return 19\n    if len(nums) == 21:\n        return 20\n    if len(nums) == 22:\n        return 21\n    if len(nums) == 23:\n        return 22\n    if len(nums) == 24:\n        return 23\n    if len(nums) == 25:\n        return 24\n    if len(nums) == 26:\n        return 25\n    if len(nums) == 27:\n        return 26\n    if len(nums) == 28:\n        return 27\n    if len(nums) == 29:\n        return 28\n    if len(nums) == 30:\n        return 29\n    if len(nums) == 31:\n        return 30\n    if len(nums) == 32:\n        return 31\n    if len(nums) == 33:\n",
        "def minOperations(nums):\n    # Write your code here.\n    count = 0\n    for i in nums:\n        if i % 2 != 0:\n            count += 1\n        i //= 2\n    return count\n",
        "def minOperations(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0] // 2\n    if len(nums) == 2:\n        return min(nums[0] // 2, nums[1] // 2)\n    if len(nums) == 3:\n        return min(nums[0] // 2, nums[1] // 2, nums[2] // 2)\n    if len(nums) == 4:\n        return min(nums[0] // 2, nums[1] // 2, nums[2] // 2, nums[3] // 2)\n    if len(nums) == 5:\n        return min(nums[0] // 2, nums[1] // 2, nums[2] // 2, nums[3] // 2, nums[4] // 2)\n    if len(nums) == 6:\n        return min(nums[0] // 2, nums[1] // 2, nums[2] // 2, nums[3] // 2, nums[4] // 2, nums[5] // 2)\n    if len(nums) == 7:\n        return min(nums[0] // 2, nums[1] // 2, nums[2] // 2, nums[3] // 2, nums[4] // 2, nums[5] // 2, nums[6] // 2)\n    if len(nums) == 8:\n        return min(nums[0] // 2, nums[1] // 2, nums[2] // 2, nums[3] // 2, nums[4] // 2, nums[5] // 2, nums[6] // 2, nums[7] // 2)\n    if len(nums) == 9:\n        return min(nums[0] // 2, nums[1] // 2, nums[2] // 2, nums[3] // 2, nums[4] // 2, nums[5] // 2,\n",
        "def minOperations(nums):\n    # Write your code here\n    count = 0\n    for i in nums:\n        if i % 2 != 0:\n            count += 1\n        i //= 2\n    return count\n",
        "def minOperations(nums):\n    # Write your code here\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0] // 2\n    nums.sort()\n    if nums[0] % 2 == 0:\n        return nums[0] // 2\n    else:\n        return nums[0] // 2 + 1\n    return 0\n",
        "def minOperations(nums):\n    # Write your code here\n    count = 0\n    for i in nums:\n        if i % 2 != 0:\n            count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "1873",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.",
    "snippets": [
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    if denominator == 0:\n        return \"NaN\"\n    if numerator < 0 and denominator < 0:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n    elif numerator < 0:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        return \"-\" + fractionToDecimal(numerator, denominator)\n    elif denominator < 0:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        return \"-\" + fractionToDecimal(numerator, denominator)\n    else:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n    if numerator % denominator == 0:\n        return str(numerator // denominator)\n    else:\n        if numerator // denominator == 0:\n            return \"0.\" + str(numerator % denominator)\n        else:\n            return str(numerator // denominator) + \".\" + str(numerator % denominator)\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    if denominator == 0:\n        return \"NaN\"\n    if numerator < 0 and denominator < 0:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n    elif numerator > 0 and denominator < 0:\n        numerator = -numerator\n        denominator = abs(denominator)\n    elif numerator < 0 and denominator > 0:\n        numerator = abs(numerator)\n        denominator = -denominator\n    else:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n    result = \"\"\n    if numerator % denominator == 0:\n        result = str(numerator // denominator)\n    else:\n        result = str(numerator // denominator) + \".\"\n        numerator = numerator % denominator\n        if numerator == 0:\n            return result\n        numerator *= 10\n        numerator_dict = {}\n        while numerator != 0:\n            if numerator in numerator_dict:\n                result += \"(\" + result[numerator_dict[numerator]:] + \")\"\n                break\n            numerator_dict[numerator] = len(result)\n            result += str(numerator // denominator)\n            numerator = numerator % denominator\n            numerator *= 10\n    return result\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    if denominator == 0:\n        return \"NaN\"\n    if numerator < 0 and denominator < 0:\n        numerator, denominator = abs(numerator), abs(denominator)\n    if numerator < 0:\n        return \"-\" + fractionToDecimal(abs(numerator), denominator)\n    if denominator < 0:\n        return \"-\" + fractionToDecimal(numerator, abs(denominator))\n    result = \"\"\n    result += str(numerator // denominator)\n    remainder = numerator % denominator\n    if remainder == 0:\n        return result\n    result += \".\"\n    map = {}\n    while remainder != 0:\n        if remainder in map:\n            result += \"(\"\n            result += map[remainder]\n            result += \")\"\n            break\n        map[remainder] = result\n        result += str(remainder * 10 // denominator)\n        remainder = remainder * 10 % denominator\n    return result\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    if denominator == 0:\n        return \"NaN\"\n    if numerator < 0 and denominator < 0:\n        numerator = -numerator\n        denominator = -denominator\n    if numerator < 0:\n        return \"-\" + fractionToDecimal(-numerator, denominator)\n    if denominator < 0:\n        return \"-\" + fractionToDecimal(numerator, -denominator)\n    result = \"\"\n    result += str(numerator // denominator)\n    remainder = numerator % denominator\n    if remainder == 0:\n        return result\n    result += \".\"\n    remainder_map = {}\n    while remainder != 0:\n        if remainder in remainder_map:\n            result += \"(\"\n            result += result[remainder_map[remainder]:]\n            result += \")\"\n            return result\n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        result += str(remainder // denominator)\n        remainder = remainder % denominator\n    return result\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    if denominator == 0:\n        return \"NaN\"\n    if numerator < 0 and denominator < 0:\n        numerator, denominator = abs(numerator), abs(denominator)\n    if numerator < 0:\n        return \"-\" + fractionToDecimal(abs(numerator), denominator)\n    if denominator < 0:\n        return \"-\" + fractionToDecimal(numerator, abs(denominator))\n    result = \"\"\n    result += str(numerator // denominator)\n    remainder = numerator % denominator\n    if remainder == 0:\n        return result\n    result += \".\"\n    remainder_map = {}\n    while remainder != 0:\n        if remainder in remainder_map:\n            result += \"(\"\n            result += result[remainder_map[remainder]:]\n            result += \")\"\n            break\n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        result += str(remainder // denominator)\n        remainder = remainder % denominator\n    return result\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return '0'\n    if denominator == 0:\n        return 'NaN'\n    if numerator < 0 and denominator < 0:\n        numerator, denominator = -numerator, -denominator\n    if numerator < 0:\n        return '-' + fractionToDecimal(-numerator, denominator)\n    if denominator < 0:\n        return '-' + fractionToDecimal(numerator, -denominator)\n    result = ''\n    result += str(numerator // denominator)\n    remainder = numerator % denominator\n    if remainder == 0:\n        return result\n    result += '.'\n    table = {}\n    while remainder:\n        if remainder in table:\n            result += '('\n            result += result[:table[remainder]]\n            result += ')'\n            return result\n        table[remainder] = len(result)\n        remainder *= 10\n        result += str(remainder // denominator)\n        remainder %= denominator\n    return result\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    if denominator == 0:\n        return \"NaN\"\n    if numerator < 0 and denominator < 0:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n    elif numerator < 0:\n        numerator = abs(numerator)\n        return \"-\" + fractionToDecimal(numerator, denominator)\n    elif denominator < 0:\n        denominator = abs(denominator)\n        return \"-\" + fractionToDecimal(numerator, denominator)\n    result = \"\"\n    if numerator % denominator == 0:\n        return str(numerator // denominator)\n    else:\n        result += str(numerator // denominator) + \".\"\n        numerator = numerator % denominator\n        while numerator != 0:\n            if numerator in result:\n                result = result[:result.index(str(numerator))] + \"(\" + result[result.index(str(numerator)):] + \")\"\n                break\n            else:\n                result += str(numerator * 10 // denominator)\n                numerator = (numerator * 10) % denominator\n    return result\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return '0'\n    if denominator == 0:\n        return 'NaN'\n    if numerator < 0 and denominator < 0:\n        numerator, denominator = -numerator, -denominator\n    if numerator < 0:\n        return '-' + fractionToDecimal(-numerator, denominator)\n    if denominator < 0:\n        return '-' + fractionToDecimal(numerator, -denominator)\n    res = ''\n    res += str(numerator // denominator)\n    numerator %= denominator\n    if numerator == 0:\n        return res\n    res += '.'\n    dic = {}\n    while numerator != 0:\n        if numerator in dic:\n            res += '('\n            res += res[:dic[numerator]]\n            res += ')'\n            break\n        dic[numerator] = len(res)\n        numerator *= 10\n        res += str(numerator // denominator)\n        numerator %= denominator\n    return res\n",
        "def fractionToDecimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    if denominator == 0:\n        return \"NaN\"\n    if numerator < 0 and denominator < 0:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n    elif numerator > 0 and denominator < 0:\n        numerator = -numerator\n        denominator = abs(denominator)\n    elif numerator < 0 and denominator > 0:\n        numerator = abs(numerator)\n        denominator = -denominator\n    else:\n        numerator = abs(numerator)\n        denominator = abs(denominator)\n    result = str(numerator // denominator)\n    remainder = numerator % denominator\n    if remainder == 0:\n        return result\n    result += \".\"\n    map = {}\n    while remainder != 0:\n        if remainder in map:\n            result += \"(\"\n            result += map[remainder]\n            result += \")\"\n            break\n        map[remainder] = result\n        remainder *= 10\n        result += str(remainder // denominator)\n        remainder %= denominator\n    return result\n"
    ],
    "results": 10
},{
    "id": "1874",
    "source": "leetcode",
    "language": "python",
    "query": "The array-form of an integer num is an array representing its digits in left to right order. For example, for num = 1321, the array form is [1,3,2,1].",
    "snippets": [
        "def array_form(num):\n    return [int(x) for x in str(num)]\n",
        "def array_form(num):\n    return [int(i) for i in str(num)]\n"
    ],
    "results": 10
},{
    "id": "1875",
    "source": "leetcode",
    "language": "python",
    "query": "Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.",
    "snippets": [
        "def sqrt(x):\n    if x == 0:\n        return 0\n    if x == 1:\n        return 1\n    if x == 2:\n        return 1\n    if x == 3:\n        return 1\n    if x == 4:\n        return 2\n    if x == 5:\n        return 2\n    if x == 6:\n        return 2\n    if x == 7:\n        return 2\n    if x == 8:\n        return 2\n    if x == 9:\n        return 3\n    if x == 10:\n        return 3\n    if x == 11:\n        return 3\n    if x == 12:\n        return 3\n    if x == 13:\n        return 3\n    if x == 14:\n        return 3\n    if x == 15:\n        return 3\n    if x == 16:\n        return 4\n    if x == 17:\n        return 4\n    if x == 18:\n        return 4\n    if x == 19:\n        return 4\n    if x == 20:\n        return 4\n    if x == 21:\n        return 4\n    if x == 22:\n        return 4\n    if x == 23:\n        return 4\n    if x == 24:\n        return 4\n    if x == 25:\n        return 5\n    if x == 26:\n        return 5\n    if x == 27:\n        return 5\n    if x == 28:\n        return 5\n    if x == 29:\n        return 5\n    if x == 30:\n        return 5\n    if x == 31:\n        return 5\n    if x == 32:\n        return 5\n    if x == 33:\n        return 5\n    if x == 34:\n        return 5\n    if x == 35:\n        return 5\n    if x == 36:\n        return 5\n    if x == 37:\n        return 5\n    if x == 38:\n        return 5\n    if x == 39:\n        return 5\n    if x == 40:\n        return 6\n    if x == 41:\n        return 6\n    if x == 42:\n        return 6\n    if x == 43:\n        return 6\n    if x == 44:\n        return\n",
        "def sqrt(x):\n    if x == 0:\n        return 0\n    if x == 1:\n        return 1\n    if x == 2:\n        return 1\n    if x == 3:\n        return 1\n    if x == 4:\n        return 2\n    if x == 5:\n        return 2\n    if x == 6:\n        return 2\n    if x == 7:\n        return 2\n    if x == 8:\n        return 2\n    if x == 9:\n        return 3\n    if x == 10:\n        return 3\n    if x == 11:\n        return 3\n    if x == 12:\n        return 3\n    if x == 13:\n        return 3\n    if x == 14:\n        return 3\n    if x == 15:\n        return 3\n    if x == 16:\n        return 4\n    if x == 17:\n        return 4\n    if x == 18:\n        return 4\n    if x == 19:\n        return 4\n    if x == 20:\n        return 4\n    if x == 21:\n        return 4\n    if x == 22:\n        return 4\n    if x == 23:\n        return 4\n    if x == 24:\n        return 4\n    if x == 25:\n        return 5\n    if x == 26:\n        return 5\n    if x == 27:\n        return 5\n    if x == 28:\n        return 5\n    if x == 29:\n        return 5\n    if x == 30:\n        return 5\n    if x == 31:\n        return 5\n    if x == 32:\n        return 5\n    if x == 33:\n        return 5\n    if x == 34:\n        return 5\n    if x == 35:\n        return 5\n    if x == 36:\n        return 5\n    if x == 37:\n        return 5\n    if x == 38:\n        return 5\n    if x == 39:\n        return 5\n    if x == 40:\n        return 5\n    if x == 41:\n        return 5\n    if x == 42:\n        return 5\n    if x == 43:\n        return 5\n    if x == 44:\n        return\n",
        "def sqrt(x):\n    if x == 0:\n        return 0\n    if x == 1:\n        return 1\n    if x == 2:\n        return 1\n    if x == 3:\n        return 2\n    if x == 4:\n        return 2\n    if x == 5:\n        return 2\n    if x == 6:\n        return 2\n    if x == 7:\n        return 2\n    if x == 8:\n        return 2\n    if x == 9:\n        return 3\n    if x == 10:\n        return 3\n    if x == 11:\n        return 3\n    if x == 12:\n        return 3\n    if x == 13:\n        return 3\n    if x == 14:\n        return 3\n    if x == 15:\n        return 3\n    if x == 16:\n        return 3\n    if x == 17:\n        return 3\n    if x == 18:\n        return 3\n    if x == 19:\n        return 3\n    if x == 20:\n        return 4\n    if x == 21:\n        return 4\n    if x == 22:\n        return 4\n    if x == 23:\n        return 4\n    if x == 24:\n        return 4\n    if x == 25:\n        return 4\n    if x == 26:\n        return 4\n    if x == 27:\n        return 4\n    if x == 28:\n        return 4\n    if x == 29:\n        return 4\n    if x == 30:\n        return 4\n    if x == 31:\n        return 4\n    if x == 32:\n        return 4\n    if x == 33:\n        return 4\n    if x == 34:\n        return 4\n    if x == 35:\n        return 4\n    if x == 36:\n        return 4\n    if x == 37:\n        return 4\n    if x == 38:\n        return 4\n    if x == 39:\n        return 4\n    if x == 40:\n        return 5\n    if x == 41:\n        return 5\n    if x == 42:\n        return 5\n    if x == 43:\n        return 5\n    if x == 44:\n        return\n",
        "def sqrt(x):\n    return int(x**0.5)\n"
    ],
    "results": 10
},{
    "id": "1876",
    "source": "leetcode",
    "language": "python",
    "query": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.",
    "snippets": [
        "def average(root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        size = len(queue)\n        sum = 0\n        for _ in range(size):\n            node = queue.pop(0)\n            sum += node.val\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(sum / size)\n    return res\n",
        "def average(root):\n    if root is None:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        level_sum = 0\n        level_count = len(queue)\n        for _ in range(level_count):\n            node = queue.pop(0)\n            level_sum += node.val\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level_sum / level_count)\n    return result\n",
        "def average(root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        sum = 0\n        size = len(queue)\n        for _ in range(size):\n            node = queue.pop(0)\n            sum += node.val\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(sum / size)\n    return res\n",
        "def averageOfLevels(root):\n    if root is None:\n        return []\n    result = []\n    queue = [root]\n    while queue:\n        level_sum = 0\n        level_count = len(queue)\n        for _ in range(level_count):\n            node = queue.pop(0)\n            level_sum += node.val\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level_sum / level_count)\n    return result\n",
        "def average(root):\n    if not root:\n        return []\n    res = []\n    q = [root]\n    while q:\n        size = len(q)\n        sum = 0\n        for _ in range(size):\n            node = q.pop(0)\n            sum += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n        res.append(sum / size)\n    return res\n",
        "def average(root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        res.append(sum(level) / len(level))\n    return res\n",
        "def average(root):\n    if not root:\n        return []\n    res = []\n    queue = [root]\n    while queue:\n        res.append(sum([node.val for node in queue])/len(queue))\n        queue = [child for node in queue for child in (node.left, node.right) if child]\n    return res\n"
    ],
    "results": 10
},{
    "id": "1877",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same. Return any possible rearrangement of s or return \"\" if not possible.",
    "snippets": [
        "def rearrange(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 3:\n        if s[0] == s[1] or s[1] == s[2]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 4:\n        if s[0] == s[1] or s[1] == s[2] or s[2] == s[3]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 5:\n        if s[0] == s[1] or s[1] == s[2] or s[2] == s[3] or s[3] == s[4]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 6:\n        if s[0] == s[1] or s[1] == s[2] or s[2] == s[3] or s[3] == s[4] or s[4] == s[5]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 7:\n        if s[0] == s[1] or s[1] == s[2] or s[2] == s[3] or s[3] == s[4] or s[4] == s[5] or s[5] == s[6]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 8:\n        if s[0] == s[1] or s[1] == s[2] or s[2] == s[3] or s[3] == s[4] or s[4] == s[5] or s[5] == s[6] or s[6] == s[7]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 9:\n        if s[0] ==\n",
        "def rearrange(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return \"\"\n        else:\n            return s\n    else:\n        if s[0] == s[1]:\n            return \"\"\n        else:\n            return s[0] + rearrange(s[1:])\n",
        "def rearrange(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return \"\"\n        else:\n            return s\n    d = {}\n    for i in s:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    l = []\n    for i in d:\n        l.append((d[i], i))\n    l.sort(reverse=True)\n    res = \"\"\n    for i in l:\n        res += i[1] * i[0]\n    if len(res) != len(s):\n        return \"\"\n    return res\n",
        "def rearrange_string(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 3:\n        if s[0] == s[1] or s[0] == s[2] or s[1] == s[2]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 4:\n        if s[0] == s[1] or s[0] == s[2] or s[0] == s[3] or s[1] == s[2] or s[1] == s[3] or s[2] == s[3]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 5:\n        if s[0] == s[1] or s[0] == s[2] or s[0] == s[3] or s[0] == s[4] or s[1] == s[2] or s[1] == s[3] or s[1] == s[4] or s[2] == s[3] or s[2] == s[4] or s[3] == s[4]:\n            return \"\"\n        else:\n            return s\n    if len(s) == 6:\n        if s[0] == s[1] or s[0] == s[2] or s[0] == s[3] or s[0] == s[4] or s[0] == s[5] or s[1] == s[2] or s[1] == s[3] or s[1] == s[4] or s[1] == s[5] or s[2] == s[3] or s[2] == s[4] or s[2] == s[5] or s[3] == s[4] or s[3] == s[5] or s[4] == s[5]:\n            return \"\"\n",
        "def rearrange(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    s = list(s)\n    s.sort()\n    res = []\n    for i in range(len(s)):\n        if i % 2 == 0:\n            res.append(s[i])\n        else:\n            res.append(s[i-1])\n    return \"\".join(res)\n",
        "def rearrange_string(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    s = list(s)\n    s.sort()\n    result = []\n    for i in range(len(s)):\n        if i % 2 == 0:\n            result.append(s[i])\n        else:\n            result.append(s[i-1])\n    return \"\".join(result)\n",
        "def rearrange_string(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    s = list(s)\n    s.sort()\n    for i in range(len(s)):\n        if s[i] == s[i+1]:\n            return \"\"\n    return \"\".join(s)\n",
        "def rearrangeString(s):\n    if len(s) == 0:\n        return \"\"\n    if len(s) == 1:\n        return s\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return \"\"\n        else:\n            return s\n    d = {}\n    for i in s:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    d = sorted(d.items(), key=lambda x: x[1], reverse=True)\n    res = []\n    for i in d:\n        res.append(i[0] * i[1])\n    res = \"\".join(res)\n    if len(res) != len(s):\n        return \"\"\n    return res\n"
    ],
    "results": 10
},{
    "id": "1878",
    "source": "leetcode",
    "language": "python",
    "query": "An integer n is a power of two, if there exists an integer x such that n == 2x. Given an integer n, return true if it is a powers of two. Otherwise, return false.",
    "snippets": [
        "def is_power_of_two(n):\n    if n == 1:\n        return True\n    if n == 0:\n        return False\n    if n % 2 == 0:\n        return is_power_of_two(n // 2)\n    return False\n",
        "def is_power_of_two(n):\n    if n == 1:\n        return True\n    if n == 0:\n        return False\n    if n % 2 == 0:\n        return is_power_of_two(n/2)\n    else:\n        return False\n",
        "def is_power_of_two(n):\n    if n == 0:\n        return False\n    while n != 1:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n",
        "def is_power_of_two(n):\n    if n == 1:\n        return True\n    elif n == 2:\n        return True\n    elif n == 4:\n        return True\n    elif n == 8:\n        return True\n    elif n == 16:\n        return True\n    elif n == 32:\n        return True\n    elif n == 64:\n        return True\n    elif n == 128:\n        return True\n    elif n == 256:\n        return True\n    elif n == 512:\n        return True\n    elif n == 1024:\n        return True\n    elif n == 2048:\n        return True\n    elif n == 4096:\n        return True\n    elif n == 8192:\n        return True\n    elif n == 16384:\n        return True\n    elif n == 32768:\n        return True\n    elif n == 65536:\n        return True\n    elif n == 131072:\n        return True\n    elif n == 262144:\n        return True\n    elif n == 524288:\n        return True\n    elif n == 1048576:\n        return True\n    elif n == 2097152:\n        return True\n    elif n == 4194304:\n        return True\n    elif n == 8388608:\n        return True\n    elif n == 16777216:\n        return True\n    elif n == 33554432:\n        return True\n    elif n == 67108864:\n        return True\n    elif n == 134217728:\n        return True\n    elif n == 268435456:\n        return True\n    elif n == 536870912:\n        return True\n    elif n == 1073741824:\n        return True\n    elif n == 2147483648:\n        return True\n    elif n == 4294967296:\n        return True\n    elif n == 8589934592:\n        return True\n    elif n == 17179869184:\n        return True\n    elif n == 34359738368:\n        return True\n",
        "def is_power_of_two(n):\n    if n == 1:\n        return True\n    elif n == 0:\n        return False\n    elif n % 2 == 0:\n        return is_power_of_two(n//2)\n    else:\n        return False\n",
        "def is_power_of_two(n):\n    if n == 1:\n        return True\n    if n % 2 == 0:\n        return is_power_of_two(n // 2)\n    return False\n",
        "def is_power_of_two(n):\n    if n == 1:\n        return True\n    if n % 2 != 0:\n        return False\n    return is_power_of_two(n // 2)\n",
        "def power_of_two(n):\n    if n == 1:\n        return True\n    if n % 2 == 0:\n        return power_of_two(n // 2)\n    return False\n"
    ],
    "results": 10
},{
    "id": "1879",
    "source": "leetcode",
    "language": "python",
    "query": "A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangrams.",
    "snippets": [
        "def is_pangram(sentence):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for letter in alphabet:\n        if letter not in sentence:\n            return False\n    return True\n",
        "def pangram(sentence):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    for letter in alphabet:\n        if letter not in sentence:\n            return False\n    return True\n",
        "def is_pangram(sentence):\n    return len(set(sentence.lower())) == 26\n"
    ],
    "results": 10
},{
    "id": "1880",
    "source": "leetcode",
    "language": "python",
    "query": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays.",
    "snippets": [
        "def intersect(nums1, nums2):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    nums1 = sorted(nums1)\n    nums2 = sorted(nums2)\n    i, j = 0, 0\n    res = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n",
        "def intersect(nums1, nums2):\n    \"\"\"\n    :type nums1: List[int]\n    :type nums2: List[int]\n    :rtype: List[int]\n    \"\"\"\n    nums1.sort()\n    nums2.sort()\n    i, j, res = 0, 0, []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            res.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n",
        "def intersection(nums1, nums2):\n    nums1 = set(nums1)\n    nums2 = set(nums2)\n    return list(nums1 & nums2)\n",
        "def intersect(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n    i = 0\n    j = 0\n    result = []\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] == nums2[j]:\n            result.append(nums1[i])\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return result\n"
    ],
    "results": 10
},{
    "id": "1881",
    "source": "leetcode",
    "language": "python",
    "query": "You are given two positive integer arrays spells and potions, of length n and m respectively. A spell and potion pair is considered successful if the product of their strengths is at least success.",
    "snippets": [
        "def is_successful(spell, potion, success):\n    return spell * potion >= success\n",
        "def isSuccessful(spell, potion, success):\n    return spell * potion >= success\n",
        "def isSuccess(spell, potion, success):\n    return spell * potion >= success\n",
        "def isSuccess(spell, potion):\n    return spell * potion >= success\n"
    ],
    "results": 10
},{
    "id": "1882",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used. All the letters in the answer string should be lowercase characters.",
    "snippets": [
        "def toHex(num):\n    if num == 0:\n        return '0'\n    if num < 0:\n        num = 2**32 + num\n    ans = ''\n    while num > 0:\n        ans = hex(num % 16)[2:] + ans\n        num //= 16\n    return ans\n",
        "def toHex(num):\n    if num == 0:\n        return '0'\n    if num < 0:\n        num += 2 ** 32\n    ans = ''\n    while num > 0:\n        ans = hex(num % 16)[2:] + ans\n        num //= 16\n    return ans\n",
        "def toHex(num):\n    if num == 0:\n        return '0'\n    if num < 0:\n        num = 2**32 + num\n    ans = ''\n    while num > 0:\n        ans = hex(num % 16)[2] + ans\n        num = num // 16\n    return ans\n",
        "def toHex(num):\n    if num == 0:\n        return '0'\n    hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n    hex_list = []\n    while num != 0:\n        remainder = num % 16\n        if remainder > 9:\n            hex_list.append(hex_dict[remainder])\n        else:\n            hex_list.append(str(remainder))\n        num = num // 16\n    hex_list.reverse()\n    return ''.join(hex_list)\n",
        "def toHex(num):\n    if num == 0:\n        return '0'\n    hex_dict = {0:'0', 1:'1', 2:'2', 3:'3', 4:'4', 5:'5', 6:'6', 7:'7', 8:'8', 9:'9', 10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n    hex_list = []\n    while num != 0:\n        hex_list.append(hex_dict[num % 16])\n        num = num // 16\n    hex_list.reverse()\n    return ''.join(hex_list)\n"
    ],
    "results": 10
},{
    "id": "1883",
    "source": "leetcode",
    "language": "python",
    "query": "Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\" You want to know how many of the stones you have are also jewels.",
    "snippets": [
        "def jewels_in_stones(j, s):\n    jewels = set(j)\n    count = 0\n    for stone in s:\n        if stone in jewels:\n            count += 1\n    return count\n",
        "def jewels_in_stones(j, s):\n    jewels = set(j)\n    stones = set(s)\n    return len(jewels & stones)\n",
        "def jewels_and_stones(j, s):\n    jewels = set(j)\n    stones = set(s)\n    return len(jewels.intersection\n",
        "def jewels_in_stones(jewels, stones):\n"
    ],
    "results": 8
},{
    "id": "1884",
    "source": "leetcode",
    "language": "python",
    "query": "A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. Given the roots of two binary trees root and subRoot, return true if there is a subtree with the same structure and node values of subRoot.",
    "snippets": [
        "def isSubtree(self, root, subRoot):\n    if root is None:\n        return False\n    if self.isSameTree(root, subRoot):\n        return True\n    return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n",
        "def isSubtree(self, root, subRoot):\n    if root is None:\n        return False\n    if self.isSame(root, subRoot):\n        return True\n    return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n"
    ],
    "results": 10
},{
    "id": "1885",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k. Pick the scores of any k students from the array so that the difference between the highest and lowest of the k scores is minimized.",
    "snippets": [
        "def pick_scores(nums, k):\n    if k == 0:\n        return 0\n    if k == 1:\n        return nums[0]\n    if k == len(nums):\n        return max(nums) - min(nums)\n    if k > len(nums):\n        return -1\n    min_diff = float('inf')\n    for i in range(len(nums) - k + 1):\n        min_diff = min(min_diff, max(nums[i:i+k]) - min(nums[i:i+k]))\n    return min_diff\n",
        "def pick_scores(nums, k):\n    if k == 1:\n        return min(nums)\n    if k == len(nums):\n        return max(nums)\n    if k == 0:\n        return 0\n    if k > len(nums):\n        return 0\n    if k == 2:\n        return max(nums) - min(nums)\n    if k == 3:\n        return max(nums) - min(nums)\n    if k == 4:\n        return max(nums) - min(nums)\n    if k == 5:\n        return max(nums) - min(nums)\n    if k == 6:\n        return max(nums) - min(nums)\n    if k == 7:\n        return max(nums) - min(nums)\n    if k == 8:\n        return max(nums) - min(nums)\n    if k == 9:\n        return max(nums) - min(nums)\n    if k == 10:\n        return max(nums) - min(nums)\n    if k == 11:\n        return max(nums) - min(nums)\n    if k == 12:\n        return max(nums) - min(nums)\n    if k == 13:\n        return max(nums) - min(nums)\n    if k == 14:\n        return max(nums) - min(nums)\n    if k == 15:\n        return max(nums) - min(nums)\n    if k == 16:\n        return max(nums) - min(nums)\n    if k == 17:\n        return max(nums) - min(nums)\n    if k == 18:\n        return max(nums) - min(nums)\n    if k == 19:\n        return max(nums) - min(nums)\n    if k == 20:\n        return max(nums) - min(nums)\n    if k == 21:\n        return max(nums) - min(nums)\n    if k == 22:\n        return max\n",
        "def pick_scores(nums, k):\n    if k == 1:\n        return nums\n    nums.sort()\n    return nums[k-1] - nums[0]\n",
        "def pick_scores(nums, k):\n    if k == 0:\n        return 0\n    if k == 1:\n        return max(nums)\n    if k == len(nums):\n        return min(nums)\n    if k == len(nums) - 1:\n        return max(nums) - min(nums)\n    if k == len(nums) - 2:\n        return max(nums) - min(nums)\n    if k == len(nums) - 3:\n        return max(nums) - min(nums)\n    if k == len(nums) - 4:\n        return max(nums) - min(nums)\n    if k == len(nums) - 5:\n        return max(nums) - min(nums)\n    if k == len(nums) - 6:\n        return max(nums) - min(nums)\n    if k == len(nums) - 7:\n        return max(nums) - min(nums)\n    if k == len(nums) - 8:\n        return max(nums) - min(nums)\n    if k == len(nums) - 9:\n        return max(nums) - min(nums)\n    if k == len(nums) - 10:\n        return max(nums) - min(nums)\n    if k == len(nums) - 11:\n        return max(nums) - min(nums)\n    if k == len(nums) - 12:\n        return max(nums) - min(nums)\n    if k == len(nums) - 13:\n        return max(nums) - min(nums)\n    if k == len(nums) - 14:\n        return max(nums) - min(nums)\n    if k == len(nums) - 15:\n        return max(nums) - min(nums)\n    if k == len(nums) - 16:\n        return max(nums) - min(nums)\n    if k == len(nums) - 17:\n",
        "def kthLargest(nums, k):\n    nums.sort()\n    return nums[len(nums)-k]\n",
        "def pick_scores(nums, k):\n    if k == 1:\n        return min(nums), max(nums)\n    else:\n        return pick_scores(nums[1:], k-1) + (min(nums[0], pick_scores(nums[1:], k-1)[0]), max(nums[0], pick_scores(nums[1:], k-1)[1]))\n",
        "def kthLargest(nums, k):\n    return sorted(nums)[-k]\n",
        "def array_rank_by_element(nums, k):\n    nums.sort()\n    return nums[k] - nums[k - 1]\n",
        "def kth_largest(nums, k):\n    return sorted(nums)[-k]\n"
    ],
    "results": 10
},{
    "id": "1886",
    "source": "leetcode",
    "language": "python",
    "query": "The two dates are given as strings, their format is YYYY-MM-DD. Write a program to count the number of days between two dates.",
    "snippets": [
        "def count_days(date1, date2):\n    date1 = datetime.datetime.strptime(date1, '%Y-%m-%d')\n    date2 = datetime.datetime.strptime(date2, '%Y-%m-%d')\n    return (date2 - date1).days\n",
        "def count_days(date1, date2):\n    date1 = datetime.datetime.strptime(date1, '%Y-%m-%d')\n    date2 = datetime.datetime.strptime(date2, '%Y-%m-%d')\n    return abs((date2 - date1).days)\n",
        "def days_between(date1, date2):\n    \"\"\"\n    >>> days_between('2020-01-01', '2020-01-02')\n    1\n    >>> days_between('2020-01-01', '2020-01-01')\n    0\n    >>> days_between('2020-01-01', '2020-01-03')\n    2\n    >>> days_between('2020-01-01', '2020-01-04')\n    3\n    >>> days_between('2020-01-01', '2020-01-05')\n    4\n    >>> days_between('2020-01-01', '2020-01-06')\n    5\n    >>> days_between('2020-01-01', '2020-01-07')\n    6\n    >>> days_between('2020-01-01', '2020-01-08')\n    7\n    >>> days_between('2020-01-01', '2020-01-09')\n    8\n    >>> days_between('2020-01-01', '2020-01-10')\n    9\n    >>> days_between('2020-01-01', '2020-01-11')\n    10\n    >>> days_between('2020-01-01', '2020-01-12')\n    11\n    >>> days_between('2020-01-01', '2020-01-13')\n    12\n    >>> days_between('2020-01-01', '2020-01-14')\n    13\n    >>> days_between('2020-01-01', '2020-01-15')\n    14\n    >>> days_between('2020-01-01', '2020-01-16')\n    15\n    >>> days_between('2020-01-01', '2020-01-17')\n    16\n    >>> days_between('2020-01-01', '2020-01-18')\n    17\n    >>> days_between('2020-01-01', '2020-01-19')\n    18\n    >>> days_between('2020-01-01', '2020-01-20')\n    19\n    >>> days_between('2020-01-01', '2020-01-21')\n    20\n    >>>\n",
        "def days_between(date1, date2):\n    \"\"\"\n    :param date1: string\n    :param date2: string\n    :return: int\n    \"\"\"\n    date1 = datetime.datetime.strptime(date1, \"%Y-%m-%d\")\n    date2 = datetime.datetime.strptime(date2, \"%Y-%m-%d\")\n    return abs((date2 - date1).days)\n",
        "def count_days(date1, date2):\n    \"\"\"\n    :param date1: string\n    :param date2: string\n    :return: int\n    \"\"\"\n    date1 = datetime.datetime.strptime(date1, '%Y-%m-%d')\n    date2 = datetime.datetime.strptime(date2, '%Y-%m-%d')\n    return (date2 - date1).days\n"
    ],
    "results": 10
},{
    "id": "1887",
    "source": "leetcode",
    "language": "python",
    "query": "A professional robber plans to rob houses along a street. Each house has a certain amount of money stashed. The only constraint stopping you from robbing each of them is that adjacent houses have security systems connected.",
    "snippets": [
        "def rob(nums):\n    if len(nums) == 0:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums[0], nums[1])\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n    return dp[-1]\n",
        "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    if len(nums) == 2:\n        return max(nums)\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n    return dp[-1]\n"
    ],
    "results": 10
},{
    "id": "1888",
    "source": "leetcode",
    "language": "python",
    "query": "A super ugly number is a positive integer whose prime factors are in the array primes. It is guaranteed to fit in a 32-bit signed integer.",
    "snippets": [
        "def super_ugly_number(n, primes):\n    ugly = [1] * n\n    i2, i3, i5 = 0, 0, 0\n    for i in range(1, n):\n        ugly[i] = min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)\n        if ugly[i] == ugly[i2] * 2:\n            i2 += 1\n        if ugly[i] == ugly[i3] * 3:\n            i3 += 1\n        if ugly[i] == ugly[i5] * 5:\n            i5 += 1\n    return ugly[-1]\n",
        "def super_ugly_number(n, primes):\n    ugly = [1]\n    for i in range(n):\n        ugly.append(min(ugly[j] * primes[j] for j in range(len(primes))))\n    return ugly[-1]\n",
        "def superUglyNumber(n, primes):\n    ugly = [1]\n    for i in range(n):\n        ugly.append(min(ugly[j]*primes[j] for j in range(len(primes))))\n    return ugly[-1]\n",
        "def super_ugly_number(n, primes):\n    ugly = [1]\n    i2, i3, i5 = 0, 0, 0\n    while len(ugly) < n:\n        next_ugly = min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)\n        ugly.append(next_ugly)\n        if ugly[i2] * 2 == next_ugly:\n            i2 += 1\n        if ugly[i3] * 3 == next_ugly:\n            i3 += 1\n        if ugly[i5] * 5 == next_ugly:\n            i5 += 1\n    return ugly[-1]\n",
        "def super_ugly_number(n, primes):\n    nums = [1] * n\n    i = 0\n    for prime in primes:\n        for j in range(prime, n, prime):\n            nums[j] *= prime\n    for i in range(n):\n        if nums[i] != 1:\n            return i\n    return -1\n",
        "def super_ugly_number(n, primes):\n    ugly = [1]\n    i = 0\n    for _ in range(n):\n        ugly.append(min(ugly[i] * p for p in primes))\n        while ugly[i] * primes[i] <= ugly[-1]:\n            i += 1\n    return ugly[-1]\n",
        "def super_ugly_number(n, primes):\n    # Write your code here\n    ugly = [0] * n\n    ugly[0] = 1\n    i2, i3, i5 = 0, 0, 0\n    for i in range(1, n):\n        ugly[i] = min(ugly[i2] * 2, ugly[i3] * 3, ugly[i5] * 5)\n        if ugly[i] == ugly[i2] * 2:\n            i2 += 1\n        if ugly[i] == ugly[i3] * 3:\n            i3 += 1\n        if ugly[i] == ugly[i5] * 5:\n            i5 += 1\n    return ugly[-1]\n"
    ],
    "results": 10
},{
    "id": "1889",
    "source": "leetcode",
    "language": "python",
    "query": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "snippets": [
        "def maximalSquare(matrix):\n    if not matrix:\n        return 0\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_area = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_area = max(max_area, dp[i][j])\n    return max_area ** 2\n",
        "def maximalSquare(matrix):\n    if not matrix:\n        return 0\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_area = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_area = max(max_area, dp[i][j])\n    return max_area * max_area\n",
        "def maximalSquare(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    ans = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                ans = max(ans, dp[i][j])\n    return ans * ans\n",
        "def maximalSquare(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_area = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_area = max(max_area, dp[i][j])\n    return max_area * max_area\n",
        "def maximalSquare(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_area = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_area = max(max_area, dp[i][j])\n    return max_area ** 2\n"
    ],
    "results": 10
},{
    "id": "1890",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums, return the maximum result of nums[i] XOR nums [j], where 0 <= i <= j < n.",
    "snippets": [
        "def findMaximumXOR(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_xor = 0\n    for i in range(32):\n        mask = 1 << i\n        for num in nums:\n            if num & mask:\n                max_xor |= mask\n            else:\n                max_xor |= mask\n        if max_xor:\n            return max_xor\n    return max_xor\n",
        "def findMaximumXOR(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_xor = 0\n    for i in range(32):\n        mask = 1 << i\n        prefix_set = set([n & mask for n in nums])\n        for prefix in prefix_set:\n            max_xor = max(max_xor, prefix ^ (prefix | mask))\n    return max_xor\n",
        "def findMaximumXOR(nums):\n    n = len(nums)\n    max_xor = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_xor = max(max_xor, nums[i] ^ nums[j])\n    return max_xor\n",
        "def findMaximumXOR(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_xor = 0\n    for i in range(32):\n        mask = 1 << i\n        prefix_set = set()\n        for num in nums:\n            prefix_set.add(num & mask)\n        for prefix in prefix_set:\n            max_xor = max(max_xor, prefix ^ (prefix ^ mask))\n    return max_xor\n",
        "def findMaximumXOR(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    max_xor = 0\n    for i in range(32)[::-1]:\n        max_xor <<= 1\n        prefixes = set([num >> i for num in nums])\n        max_xor += any(max_xor ^ 1 ^ p in prefixes for p in prefixes)\n    return max_xor\n",
        "def findMaximumXOR(nums):\n    max_xor = 0\n    for i in range(32)[::-1]:\n        max_xor <<= 1\n        max_xor |= 1\n        prefixes = {num >> i for num in nums}\n        for num in prefixes:\n            if (max_xor ^ num) in prefixes:\n                return max_xor\n    return max_xor\n",
        "def findMaximumXOR(nums):\n    max_xor = 0\n    for i in range(32)[::-1]:\n        max_xor <<= 1\n        prefixes = set([n >> i for n in nums])\n        max_xor += any(max_xor ^ 1 ^ p in prefixes for p in prefixes)\n    return max_xor\n",
        "def findMaximumXOR(nums):\n    max_xor = 0\n    for i in range(32):\n        mask = 1 << i\n        for num in nums:\n            if num & mask:\n                max_xor |= mask\n        if max_xor:\n            return max_xor\n    return max_xor\n"
    ],
    "results": 10
},{
    "id": "1891",
    "source": "leetcode",
    "language": "python",
    "query": "A subarray is a contiguous part of an array. Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum.",
    "snippets": [
        "def maxSubArray(nums):\n    max_sum = nums[0]\n    current_sum = 0\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum\n",
        "def maxSubArray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) == 0:\n        return 0\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    for i in range(1, len(nums)):\n        cur_sum = max(nums[i], cur_sum + nums[i])\n        max_sum = max(max_sum, cur_sum)\n    return max_sum\n",
        "def maxSubArray(nums):\n    max_sum = nums[0]\n    cur_sum = nums[0]\n    for i in range(1, len(nums)):\n        cur_sum = max(nums[i], cur_sum + nums[i])\n        max_sum = max(max_sum, cur_sum)\n    return max_sum\n",
        "def maxSubArray(nums):\n    max_sum = nums[0]\n    curr_sum = 0\n    for i in range(len(nums)):\n        curr_sum += nums[i]\n        if curr_sum > max_sum:\n            max_sum = curr_sum\n        if curr_sum < 0:\n            curr_sum = 0\n    return max_sum\n",
        "def maxSubArray(nums):\n    max_sum = nums[0]\n    curr_sum = nums[0]\n    for i in range(1, len(nums)):\n        curr_sum = max(nums[i], curr_sum + nums[i])\n        max_sum = max(max_sum, curr_sum)\n    return max_sum\n",
        "def maxSubArray(nums):\n    max_sum = nums[0]\n    cur_sum = 0\n    for i in range(len(nums)):\n        cur_sum += nums[i]\n        if cur_sum > max_sum:\n            max_sum = cur_sum\n        if cur_sum < 0:\n            cur_sum = 0\n    return max_sum\n",
        "def maxSubArray(nums):\n    if not nums:\n        return 0\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for i in range(1, len(nums)):\n        current_sum = max(nums[i], current_sum + nums[i])\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n"
    ],
    "results": 10
},{
    "id": "1892",
    "source": "leetcode",
    "language": "python",
    "query": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffle.",
    "snippets": [
        "def shuffleString(s, indices):\n    res = \"\"\n    for i in range(len(s)):\n        res += s[indices[i]]\n    return res\n",
        "def restoreString(s, indices):\n    \"\"\"\n    :type s: str\n    :type indices: List[int]\n    :rtype: str\n    \"\"\"\n    return ''.join(list(map(lambda x: s[x], indices)))\n",
        "def shuffleString(s, indices):\n    return \"\".join([s[i] for i in indices])\n",
        "def restoreString(s, indices):\n    \"\"\"\n    :type s: str\n    :type indices: List[int]\n    :rtype: str\n    \"\"\"\n    # create a list of the characters in the string\n    # loop through the indices list\n    # replace the character at the ith index with the character at the ith index in the string\n    # return the list\n    l = list(s)\n    for i in range(len(indices)):\n        l[indices[i]] = s[i]\n    return ''.join(l)\n",
        "def shuffle(s, indices):\n    return \"\".join([s[i] for i in indices])\n",
        "def shuffleString(s, indices):\n    return ''.join(s[i] for i in indices)\n",
        "def shuffleString(s, indices):\n    # Write your code here.\n    res = [''] * len(s)\n    for i in range(len(s)):\n        res[indices[i]] = s[i]\n    return ''.join(res)\n",
        "def shuffle(s, indices):\n    # your code here\n    return \"\".join([s[i] for i in indices])\n"
    ],
    "results": 10
},{
    "id": "1893",
    "source": "leetcode",
    "language": "python",
    "query": "Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should not contain any brackets.",
    "snippets": [
        "def reverse_in_parentheses(s):\n    while s.find('(') != -1:\n        start = s.find('(')\n        end = s.find(')')\n        s = s[:start] + s[start+1:end][::-1] + s[end+1:]\n    return s\n",
        "def reverse_in_paren(s):\n    while s.find('(') != -1:\n        start = s.find('(')\n        end = s.find(')')\n        s = s[:start] + s[start+1:end][::-1] + s[end+1:]\n    return s\n",
        "def reverse_in_paren(s):\n    while s.find('(') != -1:\n        start = s.find('(')\n        end = s.find(')')\n        s = s[:start] + s[start+1:end][::-1] + s[end:]\n    return s\n",
        "def reverse_in_paren(s):\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            while stack[-1] != '(':\n                stack.pop()\n            stack.pop()\n        else:\n            stack.append(c)\n    return ''.join(stack)\n",
        "def reverse_in_paren(s):\n    if s == '':\n        return ''\n    if s[0] == '(' and s[-1] == ')':\n        return reverse_in_paren(s[1:-1]) + s[-1] + reverse_in_paren(s[1:-1])\n    else:\n        return s[0] + reverse_in_paren(s[1:])\n",
        "def reverse_in_paren(s):\n    if not s:\n        return s\n    stack = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            start = stack.pop()\n            s = s[:start] + s[start:i][::-1] + s[i+1:]\n    return s\n",
        "def reverse_in_paren(s):\n    \"\"\"\n    >>> reverse_in_paren('foo(bar)baz')\n    'foo(rab)baz'\n    >>> reverse_in_paren('foo(bar)baz(blim)gna')\n    'foo(rab)baz(milb)gna'\n    >>> reverse_in_paren('foo(bar)baz(blim)gna(poo)')\n    'foo(rab)baz(milb)gna(mol)'\n    >>> reverse_in_paren('foo(bar)baz(blim)gna(poo)(blam)')\n    'foo(rab)baz(milb)gna(mol)(lamb)'\n    \"\"\"\n    # Your code here\n    if s == '':\n        return s\n    else:\n        if s[0] == '(' and s[-1] == ')':\n            return reverse_in_paren(s[1:-1]) + s[-1] + reverse_in_paren(s[1:-1])\n        else:\n            return reverse_in_paren(s[1:-1]) + s[-1] + reverse_in_paren(s[1:-1]) + s[0]\n"
    ],
    "results": 10
},{
    "id": "1894",
    "source": "leetcode",
    "language": "python",
    "query": "A falling path starts at any element in the first row and chooses the next element that is either directly below or diagonally left/right. Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.",
    "snippets": [
        "def falling_path_sum(matrix):\n    n = len(matrix)\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1])\n            elif j == n-1:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1])\n            else:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1], matrix[i-1][j-1])\n    return sum(matrix[n-1])\n",
        "def falling_path_sum(matrix):\n    n = len(matrix)\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1])\n            elif j == n-1:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1])\n            else:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1])\n    return sum(matrix[n-1])\n",
        "def falling_path_sum(matrix):\n    n = len(matrix)\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1])\n            elif j == n-1:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1])\n            else:\n                matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1], matrix[i-1][j-1])\n    return sum(matrix[-1])\n",
        "def falling_path_sum(matrix):\n    # Write your code here.\n    n = len(matrix)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = matrix[i][0]\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + matrix[i][j]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j]\n    return min(dp[n - 1])\n",
        "def falling_path_sum(matrix):\n    # Write your code here.\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = matrix[i][0]\n    for j in range(1, n):\n        for i in range(n):\n            if i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + matrix[i][j]\n    return min(dp[n-1])\n",
        "def falling_path_sum(matrix):\n    if not matrix:\n        return 0\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = matrix[i][0]\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + matrix[i][j]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j]\n    return min(dp[n - 1])\n",
        "def falling_path_sum(matrix):\n    if not matrix:\n        return 0\n    n = len(matrix)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = matrix[i][0]\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + matrix[i][j]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j]\n    return min(dp[n - 1])\n",
        "def falling_path_sum(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    n = len(matrix)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][0] = matrix[i][0]\n    for i in range(1, n):\n        for j in range(n):\n            if j == 0:\n                dp[i][j] = dp[i - 1][j] + matrix[i][j]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + matrix[i][j]\n    return min(dp[n - 1])\n"
    ],
    "results": 10
},{
    "id": "1895",
    "source": "leetcode",
    "language": "python",
    "query": "Given an binary array nums and an integer k, return true if all 1's are at least k places away from each other. Otherwise return false.",
    "snippets": [
        "def kLengthApart(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if len(nums) == 0:\n        return True\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        return nums[0] == 0 and nums[1] == 1\n    if nums[0] == 0:\n        return False\n    if nums[-1] == 0:\n        return False\n    for i in range(1, len(nums)):\n        if nums[i] == 0 and nums[i-1] == 1:\n            if i - k - 1 < 0:\n                return False\n            if nums[i-k-1] == 1:\n                return False\n    return True\n",
        "def kLengthApart(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if len(nums) == 0:\n        return True\n    if len(nums) == 1:\n        return True\n    if nums[0] == 0:\n        return True\n    if nums[1] == 0:\n        return True\n    for i in range(1, len(nums)):\n        if nums[i] == 0:\n            if nums[i-1] == 0:\n                return False\n            if nums[i-1] == 1:\n                if i-1-k < 0:\n                    return False\n                if nums[i-1-k] == 0:\n                    return False\n            if nums[i-1] == 1:\n                if i-1-k < 0:\n                    return False\n                if nums[i-1-k] == 1:\n                    return False\n    return True\n",
        "def kDistanceApart(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 0:\n        return True\n    if len(nums) == 0:\n        return True\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        return nums[0] == 0 and nums[1] == 1\n    if nums[0] == 0:\n        return False\n    if nums[-1] == 0:\n        return False\n    for i in range(1, len(nums)):\n        if nums[i] == 0 and nums[i-1] == 1:\n            return False\n    return True\n",
        "def kDistanceApart(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if k == 0:\n        return True\n    if len(nums) < 2:\n        return True\n    if nums[0] == 1:\n        return False\n    if nums[-1] == 1:\n        return False\n    for i in range(1, len(nums)):\n        if nums[i] == 1 and nums[i-1] == 1:\n            return False\n    for i in range(1, len(nums)):\n        if nums[i] == 1 and nums[i-1] == 0 and i - nums[i-1] - 1 < k:\n            return False\n    for i in range(1, len(nums)):\n        if nums[i] == 1 and nums[i-1] == 0 and i - nums[i-1] - 1 > k:\n            return True\n    return True\n",
        "def kLengthApart(nums, k):\n    if len(nums) == 0:\n        return True\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        if nums[0] == 0 and nums[1] == 1:\n            return True\n        else:\n            return False\n    if len(nums) == 3:\n        if nums[0] == 0 and nums[1] == 1 and nums[2] == 1:\n            return True\n        else:\n            return False\n    if len(nums) == 4:\n        if nums[0] == 0 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1:\n            return True\n        else:\n            return False\n    if len(nums) == 5:\n        if nums[0] == 0 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1 and nums[4] == 1:\n            return True\n        else:\n            return False\n    if len(nums) == 6:\n        if nums[0] == 0 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1 and nums[4] == 1 and nums[5] == 1:\n            return True\n        else:\n            return False\n    if len(nums) == 7:\n        if nums[0] == 0 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1 and nums[4] == 1 and nums[5] == 1 and nums[6] == 1:\n            return True\n        else:\n            return False\n    if len(nums) == 8:\n        if nums[0] == 0 and nums[1] == 1 and nums[2] == 1 and nums[3] == 1 and nums[4] == 1 and nums[5] == 1 and nums[6] == 1 and nums[7] == 1:\n            return True\n        else:\n",
        "def k_distance_apart(nums, k):\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            for j in range(i+1, len(nums)):\n                if nums[j] == 1 and j-i <= k:\n                    return False\n    return True\n",
        "def kLengthApart(nums, k):\n    if len(nums) == 1:\n        return True\n    if len(nums) == 2:\n        return nums[0] == 0 and nums[1] == 1\n    if nums[0] == 0:\n        return False\n    for i in range(1, len(nums)):\n        if nums[i] == 0 and nums[i-1] == 1:\n            if i-1-k < 0:\n                return False\n            if nums[i-1-k] == 1:\n                return False\n    return True\n"
    ],
    "results": 9
},{
    "id": "1896",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti. A chain of pairs can be formed in this fashion.",
    "snippets": [
        "def findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n    res = 0\n    cur = pairs[0][1]\n    for i in range(1, len(pairs)):\n        if pairs[i][0] > cur:\n            res += 1\n            cur = pairs[i][1]\n    return res\n",
        "def findLongestChain(pairs):\n    pairs.sort(key=lambda x: x[1])\n    ans = 0\n    curr = pairs[0][1]\n    for i in range(1, len(pairs)):\n        if pairs[i][0] > curr:\n            ans += 1\n            curr = pairs[i][1]\n    return ans\n",
        "def chain(pairs):\n    if not pairs:\n        return 0\n    pairs.sort(key=lambda x: x[1])\n    count = 0\n    for i in range(len(pairs)):\n        if pairs[i][1] == pairs[i][0]:\n            count += 1\n        else:\n            break\n    return count\n",
        "def chain(pairs):\n    pairs.sort()\n    res = []\n    for i in range(len(pairs)):\n        if len(res) == 0:\n            res.append(pairs[i])\n        else:\n            if pairs[i][0] >= res[-1][1]:\n                res.append(pairs[i])\n            else:\n                return False\n    return True\n",
        "def chain(pairs):\n    pairs.sort(key=lambda x: x[1])\n    pairs.sort(key=lambda x: x[0])\n    print(pairs)\n    count = 0\n    for i in range(len(pairs)):\n        if pairs[i][0] == pairs[i][1]:\n            count += 1\n        else:\n            break\n    return count\n",
        "def chain(pairs):\n    pairs.sort()\n    res = []\n    for i in range(len(pairs)):\n        if len(res) == 0:\n            res.append(pairs[i])\n        else:\n            if pairs[i][0] > res[-1][1]:\n                res.append(pairs[i])\n            else:\n                continue\n    return res\n",
        "def chain(pairs):\n    pairs.sort()\n    result = []\n    for i in range(len(pairs)):\n        if pairs[i][0] == pairs[i][1]:\n            result.append(pairs[i])\n        else:\n            if pairs[i][0] == pairs[i-1][1]:\n                result.append(pairs[i])\n            else:\n                result.append(pairs[i-1])\n                result.append(pairs[i])\n    return result\n",
        "def chain(pairs):\n    if not pairs:\n        return 0\n    pairs.sort(key=lambda x: x[1])\n    max_length = 1\n    current_length = 1\n    for i in range(1, len(pairs)):\n        if pairs[i][0] > pairs[i-1][1]:\n            current_length += 1\n        else:\n            current_length = 1\n        if current_length > max_length:\n            max_length = current_length\n    return max_length\n"
    ],
    "results": 10
},{
    "id": "1897",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums of 2n, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.",
    "snippets": [
        "def arrayPairSum(nums):\n    nums.sort()\n    return sum(nums[i] for i in range(0, len(nums), 2))\n",
        "def arrayPairSum(nums):\n    nums.sort()\n    return sum(nums[::2])\n"
    ],
    "results": 10
},{
    "id": "1898",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array.",
    "snippets": [
        "def containsNearbyDuplicate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if len(nums) == 0:\n        return False\n    if len(nums) == 1:\n        return False\n    if len(nums) == 2:\n        if nums[0] == nums[1]:\n            return True\n        else:\n            return False\n    for i in range(len(nums)):\n        for j in range(i+1, i+k+1):\n            if j >= len(nums):\n                break\n            if nums[i] == nums[j]:\n                return True\n    return False\n",
        "def containsNearbyDuplicate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    if len(nums) == 0:\n        return False\n    if len(nums) == 1:\n        return False\n    if len(nums) == 2:\n        if nums[0] == nums[1]:\n            return True\n        else:\n            return False\n    if len(nums) == 3:\n        if nums[0] == nums[1] or nums[0] == nums[2] or nums[1] == nums[2]:\n            return True\n        else:\n            return False\n    if len(nums) == 4:\n        if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[1] == nums[2] or nums[1] == nums[3] or nums[2] == nums[3]:\n            return True\n        else:\n            return False\n    if len(nums) == 5:\n        if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] or nums[1] == nums[2] or nums[1] == nums[3] or nums[1] == nums[4] or nums[2] == nums[3] or nums[2] == nums[4] or nums[3] == nums[4]:\n            return True\n        else:\n            return False\n    if len(nums) == 6:\n        if nums[0] == nums[1] or nums[0] == nums[2] or nums[0] == nums[3] or nums[0] == nums[4] or nums[0] == nums[5] or nums[1] == nums[2] or\n",
        "def containsNearbyDuplicate(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: bool\n    \"\"\"\n    d = {}\n    for i in range(len(nums)):\n        if nums[i] in d and i - d[nums[i]] <= k:\n            return True\n        d[nums[i]] = i\n    return False\n",
        "def contains_two_distinct_indices(nums, k):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == k:\n                return True\n    return False\n",
        "def contains_duplicate(nums, k):\n    if len(nums) < 2:\n        return False\n    nums.sort()\n    for i in range(len(nums) - 1):\n        if nums[i + 1] - nums[i] <= k:\n            return True\n    return False\n",
        "def contains_duplicate(nums, k):\n    if len(nums) < 2:\n        return False\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if abs(nums[i] - nums[j]) <= k:\n                return True\n    return False\n",
        "def contains_duplicate(nums, k):\n    nums_set = set(nums)\n    for num in nums_set:\n        if nums.count(num) > 1:\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "1899",
    "source": "leetcode",
    "language": "python",
    "query": "Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.",
    "snippets": [
        "def rotate(mat):\n    n = len(mat)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            mat[i][j], mat[j][n - i - 1], mat[n - i - 1][n - j - 1], mat[n - j - 1][i] = mat[n - j - 1][i], mat[i][j], mat[j][n - i - 1], mat[n - i - 1][n - j - 1]\n    return mat\n",
        "def rotate(mat):\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] != mat[j][i]:\n                return False\n    return True\n",
        "def rotate(mat, target):\n    # Write your code here.\n    n = len(mat)\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] != target[j][i]:\n                return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "1900",
    "source": "leetcode",
    "language": "python",
    "query": "Given an m x n binary matrix mat, return the number of submatrices that have all ones.",
    "snippets": [
        "def count_submatrix(mat):\n    m = len(mat)\n    n = len(mat[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                count += 1\n                for k in range(i, m):\n                    for l in range(j, n):\n                        if mat[k][l] == 1:\n                            count += 1\n                        else:\n                            break\n    return count\n",
        "def count_submatrices(mat):\n    if not mat:\n        return 0\n    m, n = len(mat), len(mat[0])\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                res += 1\n                for k in range(i, m):\n                    for l in range(j, n):\n                        if mat[k][l] == 1:\n                            res += 1\n                        else:\n                            break\n    return res\n",
        "def count_submatrix(mat):\n    if not mat:\n        return 0\n    m, n = len(mat), len(mat[0])\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                res += 1\n                for k in range(i, m):\n                    for l in range(j, n):\n                        if mat[k][l] == 0:\n                            res += 1\n    return res\n",
        "def count_submatrices(mat):\n    if not mat:\n        return 0\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = 1 if mat[i][j] == 1 else 0\n            elif i == 0:\n                dp[i][j] = dp[i][j - 1] + 1 if mat[i][j] == 1 else 0\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + 1 if mat[i][j] == 1 else 0\n            else:\n                dp[i][j] = dp[i - 1][j] + 1 if mat[i][j] == 1 else 0\n                dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1)\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1)\n    return sum(dp[-1])\n",
        "def numSubmat(mat):\n    if not mat:\n        return 0\n    m, n = len(mat), len(mat[0])\n    dp = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if i == 0:\n                dp[i][j] = 1\n            elif j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + (mat[i][j] == 1)\n    return dp[-1][-1]\n",
        "def count_submatrices(mat):\n    # Write your code here.\n    m = len(mat)\n    n = len(mat[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                count += 1\n                for k in range(i, m):\n                    for l in range(j, n):\n                        if mat[k][l] == 1:\n                            count += 1\n                        else:\n                            break\n    return count\n",
        "def count_submatrices(mat):\n    m, n = len(mat), len(mat[0])\n    res = 0\n    for i in range(m):\n        for j in range(n):\n            if mat[i][j] == 1:\n                res += 1\n                for k in range(i, m):\n                    for l in range(j, n):\n                        if mat[k][l] == 1:\n                            res += 1\n                        else:\n                            break\n    return res\n"
    ],
    "results": 10
},{
    "id": "1901",
    "source": "leetcode",
    "language": "python",
    "query": "A path in a binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.",
    "snippets": [
        "def is_palindrome(s):\n    return s == s[::-1]\n"
    ],
    "results": 10
},{
    "id": "1902",
    "source": "leetcode",
    "language": "python",
    "query": "A binary tree is uni-valued if every node in the tree has the same value. Given the root of a binary tree, return true if the given tree isUnivalued.",
    "snippets": [
        "def is_univalued(root):\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None:\n        return root.val == root.right.val and is_univalued(root.right)\n    if root.right is None:\n        return root.val == root.left.val and is_univalued(root.left)\n    return root.val == root.left.val and root.val == root.right.val and is_univalued(root.left) and is_univalued(root.right)\n",
        "def isUnivalTree(root):\n    if root is None:\n        return True\n    if root.left is None and root.right is None:\n        return True\n    if root.left is None:\n        return root.val == root.right.val and isUnivalTree(root.right)\n    if root.right is None:\n        return root.val == root.left.val and isUnivalTree(root.left)\n    return root.val == root.left.val and root.val == root.right.val and isUnivalTree(root.left) and isUnivalTree(root.right)\n",
        "def isUnivalTree(root):\n    if not root:\n        return True\n    if root.left and root.val != root.left.val:\n        return False\n    if root.right and root.val != root.right.val:\n        return False\n    return isUnivalTree(root.left) and isUnivalTree(root.right)\n"
    ],
    "results": 10
},{
    "id": "1903",
    "source": "leetcode",
    "language": "python",
    "query": "You can arrange for the planet to collide with the asteroids in any arbitrary order. If the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass. Otherwise, return false.",
    "snippets": [
        "def asteroid_collision(asteroids):\n    stack = []\n    for asteroid in asteroids:\n        if asteroid < 0:\n            while stack and stack[-1] > 0 and stack[-1] < abs(asteroid):\n                stack.pop()\n            if stack and stack[-1] < 0:\n                stack.pop()\n            else:\n                stack.append(asteroid)\n        else:\n            stack.append(asteroid)\n    return stack\n",
        "def asteroid_collision(asteroids):\n    stack = []\n    for asteroid in asteroids:\n        if asteroid < 0:\n            while stack and stack[-1] > 0 and stack[-1] < abs(asteroid):\n                stack.pop()\n            if stack and stack[-1] == abs(asteroid):\n                stack.pop()\n            else:\n                stack.append(asteroid)\n        else:\n            stack.append(asteroid)\n    return stack\n",
        "def asteroid_collision(asteroids):\n    stack = []\n    for asteroid in asteroids:\n        if asteroid < 0:\n            while stack and stack[-1] > 0 and stack[-1] < -asteroid:\n                stack.pop()\n            if stack and stack[-1] == -asteroid:\n                stack.pop()\n            else:\n                stack.append(asteroid)\n        else:\n            while stack and stack[-1] < 0 and stack[-1] > asteroid:\n                stack.pop()\n            if stack and stack[-1] == asteroid:\n                stack.pop()\n            else:\n                stack.append(asteroid)\n    return stack\n",
        "def asteroid_collision(asteroids):\n    stack = []\n    for asteroid in asteroids:\n        if asteroid > 0:\n            stack.append(asteroid)\n        else:\n            while stack and stack[-1] > 0 and stack[-1] < -asteroid:\n                stack.pop()\n            if stack and stack[-1] == -asteroid:\n                stack.pop()\n            else:\n                stack.append(asteroid)\n    return stack\n",
        "def asteroid_collision(asteroids):\n    stack = []\n    for asteroid in asteroids:\n        if asteroid > 0:\n            stack.append(asteroid)\n        else:\n            while stack and stack[-1] > 0 and stack[-1] < -asteroid:\n                stack.pop()\n            if stack and stack[-1] < 0:\n                stack.pop()\n            else:\n                return False\n    return True\n",
        "def asteroid_collision(asteroids):\n    stack = []\n    for asteroid in asteroids:\n        while stack and stack[-1] < 0 and stack[-1] < asteroid:\n            stack.pop()\n        if not stack or stack[-1] < 0:\n            stack.append(asteroid)\n        elif stack[-1] == asteroid:\n            stack.pop()\n        else:\n            return False\n    return stack\n",
        "def asteroid_collision(asteroids):\n    if len(asteroids) == 0:\n        return []\n    if len(asteroids) == 1:\n        return asteroids\n    if len(asteroids) == 2:\n        if asteroids[0] > asteroids[1]:\n            return [asteroids[1]]\n        else:\n            return asteroids\n    else:\n        if asteroids[0] > asteroids[1]:\n            return [asteroids[1]] + asteroid_collision(asteroids[2:])\n        else:\n            return asteroid_collision(asteroids[1:]) + [asteroids[0]]\n",
        "def planet_collision(input_list):\n    planet = 0\n    for i in input_list:\n        if i > planet:\n            planet = i\n        else:\n            if i < planet:\n                input_list.remove(i)\n    return input_list\n"
    ],
    "results": 10
},{
    "id": "1904",
    "source": "leetcode",
    "language": "python",
    "query": "The solution set must not contain duplicate subsets. Return the solution in any order. Given an integer array nums that may contain duplicates, return all possible subsets (the power set)",
    "snippets": [
        "def subsetsWithDup(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = [[]]\n    nums.sort()\n    for i in range(len(nums)):\n        if i == 0 or nums[i] != nums[i-1]:\n            l = len(res)\n            for j in range(l):\n                res.append(res[j] + [nums[i]])\n        else:\n            l = len(res)\n            for j in range(l):\n                res.append(res[j] + [nums[i]])\n                res.append(res[j])\n    return res\n",
        "def subsetsWithDup(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: List[List[int]]\n    \"\"\"\n    res = [[]]\n    nums.sort()\n    for i in range(len(nums)):\n        if i == 0 or nums[i] != nums[i-1]:\n            l = len(res)\n            for j in range(l):\n                res.append(res[j] + [nums[i]])\n        else:\n            l = len(res)\n            for j in range(l):\n                res.append(res[j] + [nums[i]])\n    return res\n",
        "def subsetsWithDup(nums):\n    res = [[]]\n    for num in nums:\n        res += [[num] + item for item in res]\n    return res\n",
        "def subsetsWithDup(nums):\n    res = [[]]\n    for num in nums:\n        res += [item + [num] for item in res]\n    return res\n",
        "def subsetsWithDup(nums):\n    res = []\n    nums.sort()\n    backtrack(nums, 0, [], res)\n    return res\n",
        "def subsetsWithDup(nums):\n    res = [[]]\n    for num in nums:\n        res += [[num] + sub for sub in res]\n    return res\n"
    ],
    "results": 10
},{
    "id": "1905",
    "source": "leetcode",
    "language": "python",
    "query": "A string is good if it can be formed by characters from chars (each character can only be used once) Return the sum of lengths of all good strings in words.",
    "snippets": [
        "def is_good(s, chars):\n    for c in s:\n        if c not in chars:\n            return False\n        chars.remove(c)\n    return True\n",
        "def goodString(words, chars):\n    ans = 0\n    for word in words:\n        if all(word.count(c) <= chars.count(c) for c in word):\n            ans += len(word)\n    return ans\n",
        "def goodString(words, chars):\n    return sum([len(word) for word in words if set(word) <= set(chars)])\n",
        "def goodString(words, chars):\n    return sum(len(word) for word in words if all(char in word for char in chars))\n",
        "def good_string(words, chars):\n    return sum(len(word) for word in words if set(word) <= set(chars))\n",
        "def goodString(words, chars):\n    return sum(len(word) for word in words if all(c in word for c in chars))\n",
        "def goodString(chars, words):\n    return sum([len(word) for word in words if all(word.count(char) <= chars.count(char) for char in word)])\n"
    ],
    "results": 10
},{
    "id": "1906",
    "source": "leetcode",
    "language": "python",
    "query": "A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "snippets": [
        "def longest_increasing_subsequence(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n",
        "def lengthOfLonestSubsequence(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n",
        "def lengthOfLonestSubsequence(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n",
        "def lengthOfLonestSubsequence(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return 1\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n"
    ],
    "results": 10
},{
    "id": "1907",
    "source": "leetcode",
    "language": "python",
    "query": "A subarray is a contiguous part of an array. Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.",
    "snippets": [
        "def subarrayDivisibleByK(nums, k):\n    count = 0\n    for i in range(len(nums)):\n        sum = 0\n        for j in range(i, len(nums)):\n            sum += nums[j]\n            if sum % k == 0:\n                count += 1\n    return count\n",
        "def subarrayDivisibleByK(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        sum = 0\n        for j in range(i, len(nums)):\n            sum += nums[j]\n            if sum % k == 0:\n                count += 1\n    return count\n",
        "def subarrayDivisibleByK(nums, k):\n    # Write your code here\n    count = 0\n    for i in range(len(nums)):\n        sum = 0\n        for j in range(i, len(nums)):\n            sum += nums[j]\n            if sum % k == 0:\n                count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "1908",
    "source": "leetcode",
    "language": "python",
    "query": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.",
    "snippets": [
        "def minDiffInBST(root):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return 0\n    if root.left:\n        left = minDiffInBST(root.left)\n    else:\n        left = root.val\n    if root.right:\n        right = minDiffInBST(root.right)\n    else:\n        right = root.val\n    return min(abs(left - root.val), abs(right - root.val))\n",
        "def minDiffInBST(root):\n    # Write your code here.\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return 0\n    if root.left and root.right:\n        return min(minDiffInBST(root.left), minDiffInBST(root.right))\n    if root.left:\n        return min(minDiffInBST(root.left), root.val - root.right.val)\n    if root.right:\n        return min(minDiffInBST(root.right), root.val - root.left.val)\n    return 0\n",
        "def findMinDifference(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return 0\n    if not root.left:\n        return self.findMinDifference(root.right)\n    if not root.right:\n        return self.findMinDifference(root.left)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.left.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.right.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.left.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.right.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.left.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.right.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.left.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.right.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.left.val)\n    return min(self.findMinDifference(root.left), self.findMinDifference(root.right)) + abs(root.val - root.right.\n",
        "def findMin(root):\n    if root is None:\n        return None\n    if root.left is None and root.right is None:\n        return None\n    if root.left is None:\n        return findMin(root.right)\n    if root.right is None:\n        return findMin(root.left)\n    return min(findMin(root.left), findMin(root.right))\n",
        "def findMinDifference(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if not root:\n        return 0\n    self.min_diff = float('inf')\n    self.prev = None\n    self.inorder(root)\n    return self.min_diff\n",
        "def findMinDifference(self, root):\n    \"\"\"\n    :type root: TreeNode\n    :rtype: int\n    \"\"\"\n    if not root:\n        return 0\n    self.res = float('inf')\n    self.pre = float('-inf')\n    self.dfs(root)\n    return self.res\n",
        "def findMinDifference(root):\n    # Write your code here.\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return 0\n    if root.left and root.right:\n        return min(findMinDifference(root.left), findMinDifference(root.right))\n    if root.left:\n        return findMinDifference(root.left)\n    if root.right:\n        return findMinDifference(root.right)\n    return 0\n",
        "def findMinDifference(root):\n    # Write your code here.\n    def inorder(root, arr):\n        if root:\n            inorder(root.left, arr)\n            arr.append(root.val)\n            inorder(root.right, arr)\n    arr = []\n    inorder(root, arr)\n    arr.sort()\n    min_diff = arr[1] - arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] - arr[i-1] < min_diff:\n            min_diff = arr[i] - arr[i-1]\n    return min_diff\n",
        "def findMinDifference(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return None\n    if not root.left:\n        return findMinDifference(root.right)\n    if not root.right:\n        return findMinDifference(root.left)\n    left = findMinDifference(root.left)\n    right = findMinDifference(root.right)\n    return min(left, right, abs(root.val - left), abs(root.val - right))\n",
        "def minDiffInBST(root):\n    # Write your code here.\n    def inorder(root, arr):\n        if root is None:\n            return\n        inorder(root.left, arr)\n        arr.append(root.val)\n        inorder(root.right, arr)\n    arr = []\n    inorder(root, arr)\n    min_diff = float('inf')\n    for i in range(len(arr) - 1):\n        min_diff = min(min_diff, abs(arr[i] - arr[i + 1]))\n    return min_diff\n"
    ],
    "results": 10
},{
    "id": "1909",
    "source": "leetcode",
    "language": "python",
    "query": "Determine whether the largest element in an array is at least twice as much as every other number in the array. If it is, return the index of the largest elements, or return -1 otherwise.",
    "snippets": [
        "def main():\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(largest_twice(arr))\n",
        "def is_increasing(nums):\n    for i in range(len(nums) - 1):\n        if nums[i] > nums[i + 1]:\n            return False\n    return True\n",
        "def large_twice(nums):\n    if len(nums) == 0:\n        return -1\n    if len(nums) == 1:\n        return -1\n    if len(nums) == 2:\n        if nums[0] >= nums[1] * 2:\n            return 0\n        else:\n            return -1\n    max_index = 0\n    for i in range(1, len(nums)):\n        if nums[i] > nums[max_index]:\n            max_index = i\n    if nums[max_index] >= nums[0] * 2:\n        return max_index\n    else:\n        return -1\n",
        "def main():\n    array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(largest_twice(array))\n",
        "def main():\n    arr = [1, 4, 3, 2]\n    print(findLargest(arr))\n    arr = [1, 3, 2, 6]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 2]\n    print(findLargest(arr))\n    arr = [1, 2, 4, 3]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    print(findLargest(arr))\n    arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\n",
        "def main():\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\n    print(is_increasing([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]))\n    print(is_increasing([1,2,3,4,5\n",
        "def large_twice(lst):\n    if len(lst) < 2:\n        return -1\n    else:\n        max_index = 0\n        for i in range(1, len(lst)):\n            if lst[i] > lst[max_index]:\n                max_index = i\n        if lst[max_index] >= 2 * lst[0]:\n            return max_index\n        else:\n            return -1\n",
        "def main():\n    arr = [1, 3, 2, 4, 5, 6, 7, 8, 9, 10]\n    print(largest_twice(arr))\n",
        "def main():\n    arr = [1, 3, 2, 6, 1, 2]\n    print(findLargest(arr))\n"
    ],
    "results": 10
},{
    "id": "1910",
    "source": "leetcode",
    "language": "python",
    "query": "Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.",
    "snippets": [
        "def to_lower_case(s):\n    return s.lower()\n",
        "def to_lower_case(str):\n    return str.lower()\n",
        "def to_lower_case(string):\n    return string.lower()\n"
    ],
    "results": 10
},{
    "id": "1911",
    "source": "leetcode",
    "language": "python",
    "query": "RunningSum[i] is the running sum of an array. Given an array nums. We define a running sum as sum(nums[0]…nums(i)).",
    "snippets": [
        "def RunningSum(nums):\n    running_sum = 0\n    for i in range(len(nums)):\n        running_sum += nums[i]\n        nums[i] = running_sum\n    return nums\n",
        "def runningSum(nums):\n    res = []\n    for i in range(len(nums)):\n        if i == 0:\n            res.append(nums[i])\n        else:\n            res.append(res[i-1] + nums[i])\n    return res\n",
        "def RunningSum(nums):\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        nums[i] = sum\n    return nums\n",
        "def RunningSum(nums):\n    res = []\n    for i in range(len(nums)):\n        if i == 0:\n            res.append(nums[i])\n        else:\n            res.append(res[i-1] + nums[i])\n    return res\n",
        "def runningSum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i-1]\n    return nums\n",
        "def RunningSum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i-1]\n    return nums\n",
        "def runningSum(nums):\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        nums[i] = sum\n    return nums\n",
        "def runningSum(nums):\n    running_sum = []\n    for i in range(len(nums)):\n        if i == 0:\n            running_sum.append(nums[i])\n        else:\n            running_sum.append(running_sum[i-1] + nums[i])\n    return running_sum\n"
    ],
    "results": 10
},{
    "id": "1912",
    "source": "leetcode",
    "language": "python",
    "query": "Given an integer n, add a dot (\".\") as the thousands separator and return it in string format.",
    "snippets": [
        "def add_dot(n):\n    return \"{:,}\".format(n)\n",
        "def add_dot(n):\n    return str(n).replace(\",\", \".\")\n"
    ],
    "results": 10
},{
    "id": "1913",
    "source": "leetcode",
    "language": "python",
    "query": "Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors. A factor of an integer n is defined as an integer i where n % i == 0.",
    "snippets": [
        "def kthFactor(n, k):\n    factors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            factors.append(i)\n    if len(factors) < k:\n        return -1\n    else:\n        return factors[k - 1]\n",
        "def kthFactor(n, k):\n    factors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            factors.append(i)\n    if len(factors) < k:\n        return -1\n    return factors[k - 1]\n"
    ],
    "results": 10
},{
    "id": "1914",
    "source": "leetcode",
    "language": "python",
    "query": "A leaf is a node with no children. Given the root of a binary tree, return all root-to-leaf paths in any order.",
    "snippets": [
        "def binaryTreePaths(root):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    return [str(root.val) + '->' + path for path in binaryTreePaths(root.left) + binaryTreePaths(root.right)]\n",
        "def binaryTreePaths(root):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    left = binaryTreePaths(root.left)\n    right = binaryTreePaths(root.right)\n    return [str(root.val) + '->' + i for i in left] + [str(root.val) + '->' + i for i in right]\n",
        "def binaryTreePaths(root):\n    if not root:\n        return []\n    if not root.left and not root.right:\n        return [str(root.val)]\n    left = binaryTreePaths(root.left)\n    right = binaryTreePaths(root.right)\n    return [str(root.val) + '->' + path for path in left + right]\n",
        "def binaryTreePaths(root):\n    if root is None:\n        return []\n    if root.left is None and root.right is None:\n        return [str(root.val)]\n    left = binaryTreePaths(root.left)\n    right = binaryTreePaths(root.right)\n    return [str(root.val) + \"->\" + i for i in left] + [str(root.val) + \"->\" + i for i in right]\n"
    ],
    "results": 10
},{
    "id": "1915",
    "source": "leetcode",
    "language": "python",
    "query": "An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
    "snippets": [
        "def numIslands(grid):\n    if not grid:\n        return 0\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(grid, i, j)\n                count += 1\n    return count\n",
        "def numIslands(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count\n",
        "def numIslands(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1' and not visited[i][j]:\n                dfs(grid, visited, i, j)\n                count += 1\n    return count\n",
        "def numIslands(grid):\n    if not grid:\n        return 0\n    m = len(grid)\n    n = len(grid[0])\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count\n",
        "def numIslands(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    visited = [[False] * n for _ in range(m)]\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1' and not visited[i][j]:\n                count += 1\n                dfs(grid, visited, i, j)\n    return count\n"
    ],
    "results": 10
},{
    "id": "1916",
    "source": "leetcode",
    "language": "python",
    "query": "An integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers that have sequential digits.",
    "snippets": [
        "def sequentialDigits(low, high):\n    nums = []\n    for i in range(1, 10):\n        for j in range(i + 1, 10):\n            for k in range(j + 1, 10):\n                num = i * 100 + j * 10 + k\n                if num >= low and num <= high:\n                    nums.append(num)\n    return sorted(nums)\n",
        "def sequentialDigits(low, high):\n    nums = []\n    for i in range(1, 10):\n        for j in range(i+1, 10):\n            nums.append(i*10+j)\n    nums = [x for x in nums if low <= x <= high]\n    return sorted(nums)\n",
        "def sequentialDigits(low, high):\n    \"\"\"\n    :type low: int\n    :type high: int\n    :rtype: List[int]\n    \"\"\"\n    nums = []\n    for i in range(1, 10):\n        for j in range(i + 1, 10):\n            num = i * 10 + j\n            if num >= low and num <= high:\n                nums.append(num)\n    return sorted(nums)\n",
        "def sequentialDigits(low, high):\n    nums = []\n    for i in range(1, 10):\n        for j in range(i+1, 10):\n            nums.append(i*10+j)\n    return [x for x in nums if low <= x <= high]\n",
        "def sequentialDigits(low, high):\n    nums = []\n    for i in range(1, 10):\n        for j in range(i+1, 10):\n            num = str(i) + str(j)\n            if int(num) >= low and int(num) <= high:\n                nums.append(int(num))\n    return sorted(nums)\n",
        "def sequentialDigits(low, high):\n    # Your code here\n    nums = []\n    for i in range(1, 10):\n        for j in range(i+1, 10):\n            for k in range(j+1, 10):\n                num = i*100 + j*10 + k\n                if num >= low and num <= high:\n                    nums.append(num)\n    return sorted(nums)\n",
        "def sequentialDigits(low, high):\n    # Write your code here.\n    result = []\n    for i in range(low, high+1):\n        if i < 10:\n            result.append(i)\n        else:\n            temp = str(i)\n            if temp[0] == '0':\n                continue\n            for j in range(1, len(temp)):\n                if int(temp[j]) != int(temp[j-1]) + 1:\n                    break\n                if j == len(temp) - 1:\n                    result.append(i)\n    return result\n",
        "def sequential_digits(low, high):\n    # Your code here\n    return [x for x in range(low, high + 1) if x == int(''.join(sorted(str(x))))]\n"
    ],
    "results": 10
},{
    "id": "1917",
    "source": "leetcode",
    "language": "python",
    "query": "Length of the path between two nodes is represented by the number of edges between them. Given the root of a binary tree, return the length of the longest path. This path may or may not pass through the root.",
    "snippets": [
        "def longest_path(root):\n    if root is None:\n        return 0\n    left = longest_path(root.left)\n    right = longest_path(root.right)\n    return max(left, right) + 1\n",
        "def longest_path(root):\n    if not root:\n        return 0\n    return max(longest_path(root.left), longest_path(root.right), 1 + longest_path(root.left) + longest_path(root.right))\n",
        "def longest_path(root):\n    if root is None:\n        return 0\n    return max(longest_path(root.left), longest_path(root.right), 1 + longest_path(root.left) + longest_path(root.right))\n",
        "def longest_path(root):\n    if not root:\n        return 0\n    return max(longest_path(root.left), longest_path(root.right)) + 1\n",
        "def longest_path(root):\n    if root is None:\n        return 0\n    return max(longest_path(root.left), longest_path(root.right), longest_path_through_root(root))\n",
        "def longest_path(root):\n    if not root:\n        return 0\n    if not root.left and not root.right:\n        return 1\n    left = longest_path(root.left)\n    right = longest_path(root.right)\n    return max(left, right) + 1\n",
        "def longest_path(root):\n    if not root:\n        return 0\n    return max(longest_path(root.left), longest_path(root.right), longest_path_helper(root))\n"
    ],
    "results": 10
},{
    "id": "1918",
    "source": "leetcode",
    "language": "python",
    "query": "You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array. Note that this modifies the array for future operations.",
    "snippets": [
        "def remove_element(nums, x):\n    i = 0\n    while i < len(nums):\n        if nums[i] == x:\n            del nums[i]\n        else:\n            i += 1\n    return len(nums)\n",
        "def remove_element(nums, x):\n    i = 0\n    while i < len(nums):\n        if nums[i] == x:\n            nums.pop(i)\n        else:\n            i += 1\n    return len(nums)\n",
        "def remove_element(nums, val):\n    i = 0\n    while i < len(nums):\n        if nums[i] == val:\n            del nums[i]\n        else:\n            i += 1\n    return len(nums)\n"
    ],
    "results": 10
},{
    "id": "1919",
    "source": "leetcode",
    "language": "python",
    "query": "Return the shortest such subarray and output its length. Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted.",
    "snippets": [
        "def findUnsortedSubarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 1:\n        return 0\n    sorted_nums = sorted(nums)\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        if nums[start] != sorted_nums[start]:\n            break\n        start += 1\n    while start < end:\n        if nums[end] != sorted_nums[end]:\n            break\n        end -= 1\n    return end - start + 1\n",
        "def findUnsortedSubarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 1:\n        return 0\n    sorted_nums = sorted(nums)\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        if nums[start] == sorted_nums[start]:\n            start += 1\n        elif nums[end] == sorted_nums[end]:\n            end -= 1\n        else:\n            break\n    if start == end:\n        return 0\n    return end - start + 1\n",
        "def findUnsortedSubarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) <= 1:\n        return 0\n    sorted_nums = sorted(nums)\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] != sorted_nums[left]:\n            break\n        left += 1\n    while left < right:\n        if nums[right] != sorted_nums[right]:\n            break\n        right -= 1\n    return right - left + 1\n",
        "def findUnsortedSubarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] <= nums[left + 1]:\n            left += 1\n        else:\n            break\n    while left < right:\n        if nums[right] >= nums[right - 1]:\n            right -= 1\n        else:\n            break\n    if left == right:\n        return 0\n    else:\n        return right - left + 1\n",
        "def findUnsortedSubarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    sorted_nums = sorted(nums)\n    left = 0\n    right = len(nums) - 1\n    while left < right:\n        if nums[left] != sorted_nums[left]:\n            break\n        left += 1\n    while left < right:\n        if nums[right] != sorted_nums[right]:\n            break\n        right -= 1\n    return right - left + 1\n",
        "def findUnsortedSubarray(nums):\n    \"\"\"\n    :type nums: List[int]\n    :rtype: int\n    \"\"\"\n    if len(nums) < 2:\n        return 0\n    sorted_nums = sorted(nums)\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        if nums[start] == sorted_nums[start]:\n            start += 1\n        else:\n            break\n    while start < end:\n        if nums[end] == sorted_nums[end]:\n            end -= 1\n        else:\n            break\n    return end - start + 1\n",
        "def findUnsortedSubarray(nums):\n    if len(nums) < 2:\n        return 0\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        if nums[start] <= nums[start + 1]:\n            start += 1\n        else:\n            break\n    while end > start:\n        if nums[end] >= nums[end - 1]:\n            end -= 1\n        else:\n            break\n    if start == end:\n        return 0\n    return end - start + 1\n",
        "def findUnsortedSubarray(nums):\n    if len(nums) <= 1:\n        return 0\n    start = 0\n    end = 0\n    for i in range(1, len(nums)):\n        if nums[i] < nums[i-1]:\n            start = i-1\n            break\n    for i in range(len(nums)-2, -1, -1):\n        if nums[i] > nums[i+1]:\n            end = i+1\n            break\n    if start == end:\n        return 0\n    return end-start+1\n",
        "def findUnsortedSubarray(nums):\n    # Write your code here.\n    if len(nums) <= 1:\n        return 0\n    sorted_nums = sorted(nums)\n    start = 0\n    end = len(nums) - 1\n    while start < end:\n        if nums[start] != sorted_nums[start]:\n            break\n        start += 1\n    while start < end:\n        if nums[end] != sorted_nums[end]:\n            break\n        end -= 1\n    return end - start + 1\n"
    ],
    "results": 10
},{
    "id": "1920",
    "source": "leetcode",
    "language": "python",
    "query": "Write a function that reverses a string. The input string is given as an array of characters s. modify the input array in-place with O(1) extra memory.",
    "snippets": [
        "def reverseString(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        s[i], s[j] = s[j], s[i]\n        i += 1\n        j -= 1\n    return s\n",
        "def reverseString(s):\n    \"\"\"\n    :type s: List[str]\n    :rtype: void Do not return anything, modify s in-place instead.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s\n",
        "def reverseString(s):\n    \"\"\"\n    :type s: List[str]\n    :rtype: None Do not return anything, modify s in-place instead.\n    \"\"\"\n    left = 0\n    right = len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return s\n",
        "def reverseString(s):\n    \"\"\"\n    :type s: List[str]\n    :rtype: None Do not return anything, modify s in-place instead.\n    \"\"\"\n    for i in range(len(s)//2):\n        s[i], s[len(s)-i-1] = s[len(s)-i-1], s[i]\n    return s\n",
        "def reverseString(s):\n    \"\"\"\n    :type s: List[str]\n    :rtype: None Do not return anything, modify s in-place instead.\n    \"\"\"\n    if len(s) == 0:\n        return\n    i, j = 0, len(s) - 1\n    while i < j:\n        s[i], s[j] = s[j], s[i]\n        i += 1\n        j -= 1\n    return s\n"
    ],
    "results": 10
},{
    "id": "1921",
    "source": "leetcode",
    "language": "python",
    "query": "Given the root of a binary tree, return the leftmost value in the last row of the tree.",
    "snippets": [
        "def leftmost_node(root):\n    if root is None:\n        return None\n    if root.left is None and root.right is None:\n        return root.val\n    if root.left is None:\n        return leftmost_node(root.right)\n    if root.right is None:\n        return leftmost_node(root.left)\n    return leftmost_node(root.left)\n",
        "def leftmost(root):\n    if root is None:\n        return None\n    if root.left is None and root.right is None:\n        return root.val\n    if root.left is None:\n        return leftmost(root.right)\n    if root.right is None:\n        return leftmost(root.left)\n    return leftmost(root.left)\n",
        "def leftmost_node(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root.val\n    if not root.left:\n        return leftmost_node(root.right)\n    if not root.right:\n        return leftmost_node(root.left)\n    return leftmost_node(root.left)\n",
        "def leftmost_node(root):\n    if not root:\n        return None\n    if not root.left and not root.right:\n        return root.val\n    if root.left:\n        return leftmost_node(root.left)\n    if root.right:\n        return leftmost_node(root.right)\n    return None\n"
    ],
    "results": 10
},{
    "id": "1922",
    "source": "leetcode",
    "language": "python",
    "query": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.",
    "snippets": [
        "def min_difference(time_points):\n    time_points = sorted(time_points)\n    min_diff = 24 * 60\n    for i in range(len(time_points) - 1):\n        diff = (int(time_points[i + 1][0]) - int(time_points[i][0])) * 60 + (int(time_points[i + 1][1]) - int(time_points[i][1]))\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n",
        "def min_time_diff(times):\n    times.sort()\n    min_diff = int(times[1][:2]) * 60 + int(times[1][3:]) - int(times[0][:2]) * 60 - int(times[0][3:])\n    for i in range(1, len(times)):\n        diff = int(times[i][:2]) * 60 + int(times[i][3:]) - int(times[i - 1][:2]) * 60 - int(times[i - 1][3:])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n",
        "def min_time_diff(times):\n    times.sort()\n    min_diff = 24 * 60\n    for i in range(len(times) - 1):\n        diff = (int(times[i + 1].split(':')[0]) - int(times[i].split(':')[0])) * 60 + int(times[i + 1].split(':')[1]) - int(times[i].split(':')[1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n",
        "def min_diff(times):\n    times = sorted(times)\n    min_diff = 24 * 60\n    for i in range(len(times) - 1):\n        diff = (int(times[i + 1].split(':')[0]) - int(times[i].split(':')[0])) * 60 + int(times[i + 1].split(':')[1]) - int(times[i].split(':')[1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n",
        "def min_diff(times):\n    times = sorted(times)\n    min_diff = 24 * 60\n    for i in range(len(times) - 1):\n        diff = (int(times[i + 1][0]) - int(times[i][0])) * 60 + (int(times[i + 1][1]) - int(times[i][1]))\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n",
        "def min_diff(time_points):\n    time_points.sort()\n    min_diff = 0\n    for i in range(1, len(time_points)):\n        min_diff += int(time_points[i][:2]) * 60 + int(time_points[i][3:]) - int(time_points[i-1][:2]) * 60 - int(time_points[i-1][3:])\n    return min_diff\n",
        "def min_time_diff(times):\n    times.sort()\n    min_diff = 24 * 60\n    for i in range(len(times) - 1):\n        diff = (int(times[i+1][:2]) - int(times[i][:2])) * 60 + (int(times[i+1][3:]) - int(times[i][3:]))\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n",
        "def min_diff(time_points):\n    time_points.sort()\n    min_diff = 0\n    for i in range(len(time_points) - 1):\n        min_diff += int(time_points[i + 1].split(':')[1]) - int(time_points[i].split(':')[1])\n    return min_diff\n",
        "def minDiff(timePoints):\n    timePoints.sort()\n    minDiff = 0\n    for i in range(len(timePoints)):\n        if i == 0:\n            minDiff = getMinDiff(timePoints[i], timePoints[i+1])\n        else:\n            minDiff = min(minDiff, getMinDiff(timePoints[i], timePoints[i+1]))\n    return minDiff\n"
    ],
    "results": 10
},{
    "id": "1923",
    "source": "leetcode",
    "language": "java",
    "query": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "snippets": [
        "\tboolean isAnagram(String s, String t) {\n\t\tif(s.length() != t.length()) return false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isAnagram(String s, String t) {\n\t\tif(s.length() != t.length()) return false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean anagram(String s, String t) {\n\t\tif(s.length() != t.length()) return false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++) {\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++) {\n\t\t\tif(count[i] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean anagram(String s, String t) {\n\t\tif(s.length() != t.length())\n\t\t\treturn false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++)\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\tfor(int i = 0; i < t.length(); i++)\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\tfor(int i = 0; i < 26; i++)\n\t\t\tif(count[i] != 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1924",
    "source": "leetcode",
    "language": "java",
    "query": "There are n rooms labeled from 0 to n - 1. All the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.",
    "snippets": [
        "\tint canVisitAllRooms(List<List<Integer>> rooms) {\n\t\tint n = rooms.size();\n\t\tboolean[] visited = new boolean[n];\n\t\tvisited[0] = true;\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.offer(0);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tfor(int next: rooms.get(cur)){\n\t\t\t\tif(!visited[next]){\n\t\t\t\t\tvisited[next] = true;\n\t\t\t\t\tqueue.offer(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(boolean b: visited){\n\t\t\tif(!b) return 0;\n\t\t}\n\t\treturn 1;\n\t}\n}\n",
        "\tint canVisitAllRooms(List<List<Integer>> rooms) {\n\t\tint n = rooms.size();\n\t\tboolean[] visited = new boolean[n];\n\t\tvisited[0] = true;\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.offer(0);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tfor(int next: rooms.get(cur)){\n\t\t\t\tif(!visited[next]){\n\t\t\t\t\tvisited[next] = true;\n\t\t\t\t\tqueue.offer(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]) return 0;\n\t\t}\n\t\treturn 1;\n\t}\n}\n",
        "\tvoid unlockRooms(int[] rooms){\n\t\tint n = rooms.length;\n\t\tint[] visited = new int[n];\n\t\tunlockRooms(rooms, 0, visited);\n\t}\n\tpublic\n\tvoid unlockRooms(int[] rooms, int index, int[] visited){\n\t\tif(index == rooms.length){\n\t\t\treturn;\n\t\t}\n\t\tif(visited[index] == 1){\n\t\t\tunlockRooms(rooms, index + 1, visited);\n\t\t\treturn;\n\t\t}\n\t\tvisited[index] = 1;\n\t\tunlockRooms(rooms, index + 1, visited);\n\t\tvisited[index] = 0;\n\t}\n}\n",
        "\tvoid unlock(int[] rooms, int[] keys){\n\t\tint n = rooms.length;\n\t\tint[] visited = new int[n];\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.offer(0);\n\t\tvisited[0] = 1;\n\t\twhile(!q.isEmpty()){\n\t\t\tint cur = q.poll();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(visited[i] == 0 && rooms[i] == cur && keys[i] == 1){\n\t\t\t\t\tq.offer(i);\n\t\t\t\t\tvisited[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}\n",
        "\tvoid unlock(int[] rooms, int[] keys){\n\t\tint n = rooms.length;\n\t\tint[] visited = new int[n];\n\t\tvisited[0] = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 1){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(keys[j] == rooms[i]){\n\t\t\t\t\t\tvisited[j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"0\");\n\t}\n}\n",
        "\tvoid unlock(int[] rooms, int[] keys){\n\t\tint n = rooms.length;\n\t\tint[] visited = new int[n];\n\t\tvisited[0] = 1;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(0);\n\t\twhile(!q.isEmpty()){\n\t\t\tint cur = q.poll();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(visited[i] == 0 && keys[i] == rooms[cur]){\n\t\t\t\t\tvisited[i] = 1;\n\t\t\t\t\tq.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(rooms[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tvoid unlock(int[] rooms, int key){\n\t\tint n = rooms.length;\n\t\tboolean[] visited = new boolean[n];\n\t\tvisited[0] = true;\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.offer(0);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(!visited[i] && rooms[i] == key){\n\t\t\t\t\tvisited[i] = true;\n\t\t\t\t\tqueue.offer(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t}\n}\n",
        "\tvoid method(){\n\t\tint[] rooms = {1,3,1};\n\t\tint k = 1;\n\t\tint result = 0;\n\t\tfor(int i = 0; i < rooms.length; i++){\n\t\t\tif(rooms[i] == k){\n\t\t\t\tresult++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}\n",
        "\tvoid unlock(int[] rooms, int[] keys, int[] lock){\n\t\tint n = rooms.length;\n\t\tint[] key = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tkey[rooms[i]] = keys[i];\n\t\t}\n\t\tint[] visited = new int[n];\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(0);\n\t\tvisited[0] = 1;\n\t\twhile(!q.isEmpty()){\n\t\t\tint cur = q.poll();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(lock[cur] == key[i] && visited[i] == 0){\n\t\t\t\t\tq.add(i);\n\t\t\t\t\tvisited[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"0\");\n\t}\n}\n",
        "\tvoid unlock(int[] rooms, int[] keys, int[] lockedRooms){\n\t\tint[] rooms_keys = new int[rooms.length];\n\t\tfor(int i = 0; i < rooms.length; i++){\n\t\t\trooms_keys[rooms[i]] = keys[i];\n\t\t}\n\t\tfor(int i = 0; i < lockedRooms.length; i++){\n\t\t\tif(rooms_keys[lockedRooms[i]] == 0){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1925",
    "source": "leetcode",
    "language": "java",
    "query": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation. For example, The integer 5 is \"101\" in binary and its complement is \"010\" which is theinteger 2.",
    "snippets": [
        "\tint findComplement(int num) {\n\t\tint i = 0;\n\t\twhile (num > 0) {\n\t\t\tnum = num >> 1;\n\t\t\ti++;\n\t\t}\n\t\treturn (int) (Math.pow(2, i) - 1 - num);\n\t}\n}\n",
        "\tint findComplement(int num) {\n\t\tint i = 0;\n\t\twhile (num > 0) {\n\t\t\tnum = num >> 1;\n\t\t\ti++;\n\t\t}\n\t\treturn (int) (Math.pow(2, i) - 1) ^ num;\n\t}\n}\n",
        "\tint findComplement(int num) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint aa = 0;\n\t\tint bb = 0;\n\t\tint cc = 0;\n\t\tint dd = 0;\n\t\tint ee = 0;\n\t\tint ff = 0;\n\t\tint gg = 0;\n\t\tint hh = 0;\n\t\tint ii = 0;\n\t\tint jj = 0;\n\t\tint kk = 0;\n\t\tint ll = 0;\n\t\tint mm = 0;\n\t\tint nn = 0;\n\t\tint oo = 0;\n\t\tint pp = 0;\n\t\tint qq = 0;\n\t\tint rr = 0;\n\t\tint ss = 0;\n\t\tint tt = 0;\n\t\tint uu = 0;\n\t\tint vv = 0;\n\t\tint ww = 0;\n\t\tint xx = 0;\n\t\tint yy = 0;\n\t\tint zz = 0;\n\t\tint aaa = 0;\n\t\tint bbb = 0;\n\t\tint ccc = 0;\n\t\tint ddd = 0;\n\t\tint eee = 0;\n\t\tint fff = 0;\n\t\tint ggg = 0;\n\t\tint hhh = 0;\n\t\tint iii = 0;\n\t\tint jjj = 0;\n\t\tint k\n",
        "\tint findComplement(int num) {\n\t\tint i = 0;\n\t\twhile(num > 0){\n\t\t\tnum = num >> 1;\n\t\t\ti++;\n\t\t}\n\t\treturn (int)Math.pow(2, i) - 1 - num;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1926",
    "source": "leetcode",
    "language": "java",
    "query": "Given a sorted linked list, delete all nodes that have duplicate numbers. Return the linked list sorted as well.",
    "snippets": [
        "\tListNode deleteDuplicates(ListNode head) {\n\t\tif(head == null || head.next == null) return head;\n\t\tListNode dummy = new ListNode(0);\n\t\tdummy.next = head;\n\t\tListNode pre = dummy;\n\t\tListNode cur = head;\n\t\twhile(cur != null){\n\t\t\twhile(cur.next != null && cur.val == cur.next.val){\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t\tif(pre.next == cur){\n\t\t\t\tpre = pre.next;\n\t\t\t}else{\n\t\t\t\tpre.next = cur.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn dummy.next;\n\t}\n}\n",
        "\tListNode deleteDuplicates(ListNode head) {\n\t\tif(head == null || head.next == null) return head;\n\t\tListNode dummy = new ListNode(0);\n\t\tdummy.next = head;\n\t\tListNode pre = dummy;\n\t\tListNode cur = head;\n\t\twhile(cur != null && cur.next != null){\n\t\t\tif(cur.val == cur.next.val){\n\t\t\t\twhile(cur != null && cur.val == cur.next.val){\n\t\t\t\t\tcur = cur.next;\n\t\t\t\t}\n\t\t\t\tpre.next = cur.next;\n\t\t\t}else{\n\t\t\t\tpre = pre.next;\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t}\n\t\treturn dummy.next;\n\t}\n}\n",
        "\tListNode deleteDuplicates(ListNode head) {\n\t\tListNode cur = head;\n\t\twhile(cur != null && cur.next != null){\n\t\t\tif(cur.val == cur.next.val){\n\t\t\t\tcur.next = cur.next.next;\n\t\t\t}else{\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n}\n",
        "\tListNode deleteDuplicates(ListNode head) {\n\t\tif(head == null || head.next == null) return head;\n\t\tListNode cur = head;\n\t\twhile(cur.next != null){\n\t\t\tif(cur.val == cur.next.val){\n\t\t\t\tcur.next = cur.next.next;\n\t\t\t}else{\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n}\n",
        "\tListNode deleteDuplicates(ListNode head) {\n\t\tif(head == null) return null;\n\t\tListNode cur = head;\n\t\twhile(cur.next != null){\n\t\t\tif(cur.val == cur.next.val){\n\t\t\t\tcur.next = cur.next.next;\n\t\t\t}else{\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n}\n",
        "\tListNode deleteDuplicates(ListNode head) {\n\t\tif(head == null || head.next == null) return head;\n\t\tListNode cur = head;\n\t\twhile(cur != null && cur.next != null){\n\t\t\tif(cur.val == cur.next.val){\n\t\t\t\tcur.next = cur.next.next;\n\t\t\t}else{\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n}\n",
        "\tListNode deleteDuplicates(ListNode head) {\n\t\tif(head == null) return null;\n\t\tListNode p = head;\n\t\twhile(p.next != null){\n\t\t\tif(p.val == p.next.val){\n\t\t\t\tp.next = p.next.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n}\n",
        "\tstatic ListNode deleteDuplicates(ListNode head) {\n\t\tif(head == null || head.next == null) return head;\n\t\tListNode cur = head;\n\t\twhile(cur.next != null){\n\t\t\tif(cur.val == cur.next.val){\n\t\t\t\tcur.next = cur.next.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1927",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.",
    "snippets": [
        "\tList<Integer> getRow(int rowIndex) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tfor(int i = 0; i <= rowIndex; i++){\n\t\t\tres.add(1);\n\t\t\tfor(int j = i - 1; j > 0; j--){\n\t\t\t\tres.set(j, res.get(j) + res.get(j - 1));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> getRow(int rowIndex) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i = 0; i <= rowIndex; i++){\n\t\t\tlist.add(1);\n\t\t\tfor(int j = i - 1; j > 0; j--){\n\t\t\t\tlist.set(j, list.get(j) + list.get(j - 1));\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> getRow(int rowIndex) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tif(rowIndex == 0){\n\t\t\tlist.add(1);\n\t\t\treturn list;\n\t\t}\n\t\tif(rowIndex == 1){\n\t\t\tlist.add(1);\n\t\t\tlist.add(1);\n\t\t\treturn list;\n\t\t}\n\t\tlist.add(1);\n\t\tlist.add(1);\n\t\tfor(int i = 2; i <= rowIndex; i++){\n\t\t\tint size = list.size();\n\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tlist.add(1);\n\t\t\t\t}\n\t\t\t\telse if(j == size - 1){\n\t\t\t\t\tlist.add(1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tlist.add(list.get(j) + list.get(j - 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> getRow(int rowIndex) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 0;\n\t\twhile(i <= rowIndex){\n\t\t\tlist.add(1);\n\t\t\tfor(int j = 0; j < list.size() - 1; j++){\n\t\t\t\tlist.set(j, list.get(j) + list.get(j + 1));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> getRow(int rowIndex) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint num = 1;\n\t\tfor(int i = 0; i <= rowIndex; i++){\n\t\t\tif(i == 0){\n\t\t\t\tlist.add(1);\n\t\t\t}\n\t\t\telse if(i == 1){\n\t\t\t\tlist.add(1);\n\t\t\t\tlist.add(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(1);\n\t\t\t\tfor(int j = 0; j < i - 1; j++){\n\t\t\t\t\tlist.set(j, list.get(j) + list.get(j + 1));\n\t\t\t\t}\n\t\t\t\tlist.add(1);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1928",
    "source": "leetcode",
    "language": "java",
    "query": "Algorithm is based on a stream of records about a stock. Each record contains a timestamp and the corresponding price of the stock at that timestamp.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprices[i] = in.nextInt();\n\t\t}\n\t\tint maxProfit = 0;\n\t\tint minPrice = prices[0];\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(prices[i] < minPrice){\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tint profit = prices[i] - minPrice;\n\t\t\tif(profit > maxProfit){\n\t\t\t\tmaxProfit = profit;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxProfit);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprices[i] = in.nextInt();\n\t\t}\n\t\tint maxProfit = 0;\n\t\tint minPrice = prices[0];\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(prices[i] < minPrice){\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tint currentProfit = prices[i] - minPrice;\n\t\t\tif(currentProfit > maxProfit){\n\t\t\t\tmaxProfit = currentProfit;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxProfit);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprices[i] = in.nextInt();\n\t\t}\n\t\tint maxProfit = getMaxProfit(prices);\n\t\tSystem.out.println(maxProfit);\n\t}\n\tpublic static int getMaxProfit(int[] prices){\n\t\tint maxProfit = 0;\n\t\tint minPrice = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] < minPrice){\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tint currentProfit = prices[i] - minPrice;\n\t\t\tif(currentProfit > maxProfit){\n\t\t\t\tmaxProfit = currentProfit;\n\t\t\t}\n\t\t}\n\t\treturn maxProfit;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprices[i] = in.nextInt();\n\t\t}\n\t\tint maxProfit = getMaxProfit(prices);\n\t\tSystem.out.println(maxProfit);\n\t}\n\tpublic static int getMaxProfit(int[] prices){\n\t\tint maxProfit = 0;\n\t\tint minPrice = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] < minPrice){\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tint profit = prices[i] - minPrice;\n\t\t\tif(profit > maxProfit){\n\t\t\t\tmaxProfit = profit;\n\t\t\t}\n\t\t}\n\t\treturn maxProfit;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprices[i] = sc.nextInt();\n\t\t}\n\t\tint maxProfit = 0;\n\t\tint minPrice = prices[0];\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(prices[i] < minPrice){\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tint profit = prices[i] - minPrice;\n\t\t\tif(profit > maxProfit){\n\t\t\t\tmaxProfit = profit;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxProfit);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tprices[i] = sc.nextInt();\n\t\t}\n\t\tint maxProfit = 0;\n\t\tint minPrice = prices[0];\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(prices[i] < minPrice){\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tif(prices[i] - minPrice > maxProfit){\n\t\t\t\tmaxProfit = prices[i] - minPrice;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxProfit);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\t//Write your code here\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tarr[i] = sc.nextInt();\n\t\t}\n\t\tint[] brr = new int[m];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tbrr[i] = sc.nextInt();\n\t\t}\n\t\tint[] crr = new int[k];\n\t\tfor(int i=0;i<k;i++){\n\t\t\tcrr[i] = sc.nextInt();\n\t\t}\n\t\tint[] drr = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdrr[i] = sc.nextInt();\n\t\t}\n\t\tint[] err = new int[m];\n\t\tfor(int i=0;i<m;i++){\n\t\t\terr[i] = sc.nextInt();\n\t\t}\n\t\tint[] frr = new int[k];\n\t\tfor(int i=0;i<k;i++){\n\t\t\tfrr[i] = sc.nextInt();\n\t\t}\n\t\tint[] grr = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgrr[i] = sc.nextInt();\n\t\t}\n\t\tint[] hrr = new int[m];\n\t\tfor(int i=0;i<m;i++){\n\t\t\thrr[i] = sc.nextInt();\n\t\t}\n\t\tint[] irr = new int[k];\n\t\tfor(int i=0;i<k;i++){\n\t\t\tirr[i] = sc.nextInt();\n",
        "\tstatic void main(String[] args){\n\t\t//Create a stream of records about a stock.\n\t\tStream<String> stockStream = Stream.of(\"2018-01-01,100\", \"2018-01-02,101\", \"2018-01-03,102\", \"2018-01-04,103\", \"2018-01-05,104\", \"2018-01-06,105\", \"2018-01-07,106\", \"2018-01-08,107\", \"2018-01-09,108\", \"2018-01-10,109\", \"2018-01-11,110\", \"2018-01-12,111\", \"2018-01-13,112\", \"2018-01-14,113\", \"2018-01-15,114\", \"2018-01-16,115\", \"2018-01-17,116\", \"2018-01-18,117\", \"2018-01-19,118\", \"2018-01-20,119\", \"2018-01-21,120\", \"2018-01-22,121\", \"2018-01-23,122\", \"2018-01-24,123\", \"2018-01-25,124\", \"2018-01-26,125\", \"2018-01-27,126\", \"2018-01-28,127\", \"2018-01-29,128\", \"2018-01-30,129\", \"2018-01-31,130\", \"2018-02-01,131\", \"2018-02-02,132\", \"2018-02-03,133\", \"2018-02-04,134\", \"2018-02-05,135\", \"2018-02-06,136\", \"2018-02-07,137\", \"2018-02-08,138\", \"2018-02-09,139\", \"2018-02-10,140\", \"2018-02-11,141\", \"2018-02-12,142\", \"2018-02-13,143\", \"2018-02-14,144\", \"2018-02-15,145\", \"2018-02-16,146\", \"2018-02-17,147\", \"2018-02-18,148\", \"2018-02-19,149\", \"2018-02-20,150\", \"2018-02-\n"
    ],
    "results": 10
},{
    "id": "1929",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG) You are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.",
    "snippets": [
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] res = new int[numCourses];\n\t\tint[] indegree = new int[numCourses];\n\t\tint[] visited = new int[numCourses];\n\t\tQueue<Integer> queue = new LinkedList<>();\n\t\tfor(int i = 0; i < prerequisites.length; i++){\n\t\t\tindegree[prerequisites[i][1]]++;\n\t\t}\n\t\tfor(int i = 0; i < numCourses; i++){\n\t\t\tif(indegree[i] == 0) queue.add(i);\n\t\t}\n\t\tint count = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tres[count++] = cur;\n\t\t\tfor(int i = 0; i < prerequisites.length; i++){\n\t\t\t\tif(prerequisites[i][0] == cur){\n\t\t\t\t\tindegree[prerequisites[i][1]]--;\n\t\t\t\t\tif(indegree[prerequisites[i][1]] == 0) queue.add(prerequisites[i][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == numCourses) return res;\n\t\telse return new int[0];\n\t}\n}\n",
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] res = new int[numCourses];\n\t\tint[] indegree = new int[numCourses];\n\t\tint[] visited = new int[numCourses];\n\t\tQueue<Integer> queue = new LinkedList<>();\n\t\tfor(int[] edge : prerequisites){\n\t\t\tindegree[edge[1]]++;\n\t\t}\n\t\tfor(int i = 0; i < numCourses; i++){\n\t\t\tif(indegree[i] == 0) queue.add(i);\n\t\t}\n\t\tint count = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tres[count++] = cur;\n\t\t\tfor(int[] edge : prerequisites){\n\t\t\t\tif(edge[0] == cur){\n\t\t\t\t\tindegree[edge[1]]--;\n\t\t\t\t\tif(indegree[edge[1]] == 0) queue.add(edge[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count != numCourses) return new int[0];\n\t\treturn res;\n\t}\n}\n",
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] res = new int[numCourses];\n\t\tint[] indegree = new int[numCourses];\n\t\tint[] visited = new int[numCourses];\n\t\tint[] order = new int[numCourses];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < prerequisites.length; i++) {\n\t\t\tindegree[prerequisites[i][1]]++;\n\t\t}\n\t\tQueue<Integer> queue = new LinkedList<>();\n\t\tfor (int i = 0; i < indegree.length; i++) {\n\t\t\tif (indegree[i] == 0) {\n\t\t\t\tqueue.offer(i);\n\t\t\t}\n\t\t}\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint cur = queue.poll();\n\t\t\tres[count++] = cur;\n\t\t\tfor (int i = 0; i < prerequisites.length; i++) {\n\t\t\t\tif (prerequisites[i][0] == cur) {\n\t\t\t\t\tindegree[prerequisites[i][1]]--;\n\t\t\t\t\tif (indegree[prerequisites[i][1]] == 0) {\n\t\t\t\t\t\tqueue.offer(prerequisites[i][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count != numCourses) {\n\t\t\treturn new int[0];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] res = new int[numCourses];\n\t\tint[] indegree = new int[numCourses];\n\t\tint[] visited = new int[numCourses];\n\t\tQueue<Integer> queue = new LinkedList<>();\n\t\tfor(int[] edge : prerequisites){\n\t\t\tindegree[edge[1]]++;\n\t\t}\n\t\tfor(int i = 0; i < numCourses; i++){\n\t\t\tif(indegree[i] == 0) queue.offer(i);\n\t\t}\n\t\tint count = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tres[count++] = cur;\n\t\t\tfor(int[] edge : prerequisites){\n\t\t\t\tif(edge[0] == cur){\n\t\t\t\t\tindegree[edge[1]]--;\n\t\t\t\t\tif(indegree[edge[1]] == 0) queue.offer(edge[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count != numCourses) return new int[0];\n\t\treturn res;\n\t}\n}\n",
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] res = new int[numCourses];\n\t\tint[] inDegree = new int[numCourses];\n\t\tint[] visited = new int[numCourses];\n\t\tint[] stack = new int[numCourses];\n\t\tint top = -1;\n\t\tfor (int i = 0; i < prerequisites.length; i++) {\n\t\t\tinDegree[prerequisites[i][1]]++;\n\t\t}\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tif (inDegree[i] == 0) {\n\t\t\t\tstack[++top] = i;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\twhile (top != -1) {\n\t\t\tint cur = stack[top--];\n\t\t\tres[count++] = cur;\n\t\t\tfor (int i = 0; i < prerequisites.length; i++) {\n\t\t\t\tif (prerequisites[i][0] == cur) {\n\t\t\t\t\tinDegree[prerequisites[i][1]]--;\n\t\t\t\t\tif (inDegree[prerequisites[i][1]] == 0) {\n\t\t\t\t\t\tstack[++top] = prerequisites[i][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (count != numCourses) {\n\t\t\treturn new int[0];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] res = new int[numCourses];\n\t\tint[] inDegree = new int[numCourses];\n\t\tint[] visited = new int[numCourses];\n\t\tint[] order = new int[numCourses];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < prerequisites.length; i++){\n\t\t\tinDegree[prerequisites[i][1]]++;\n\t\t}\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tfor(int i = 0; i < numCourses; i++){\n\t\t\tif(inDegree[i] == 0){\n\t\t\t\tqueue.offer(i);\n\t\t\t}\n\t\t}\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tres[count++] = cur;\n\t\t\tfor(int i = 0; i < prerequisites.length; i++){\n\t\t\t\tif(prerequisites[i][0] == cur){\n\t\t\t\t\tinDegree[prerequisites[i][1]]--;\n\t\t\t\t\tif(inDegree[prerequisites[i][1]] == 0){\n\t\t\t\t\t\tqueue.offer(prerequisites[i][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count != numCourses){\n\t\t\treturn new int[0];\n\t\t}\n\t\tfor(int i = 0; i < numCourses; i++){\n\t\t\torder[i] = res[count - 1 - i];\n\t\t}\n\t\treturn order;\n\t}\n}\n",
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] res = new int[numCourses];\n\t\tint[] inDegree = new int[numCourses];\n\t\tList<List<Integer>> adjList = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < numCourses; i++){\n\t\t\tadjList.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor(int[] edge : prerequisites){\n\t\t\tadjList.get(edge[1]).add(edge[0]);\n\t\t\tinDegree[edge[0]]++;\n\t\t}\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tfor(int i = 0; i < numCourses; i++){\n\t\t\tif(inDegree[i] == 0){\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint cur = q.poll();\n\t\t\tres[count++] = cur;\n\t\t\tfor(int next : adjList.get(cur)){\n\t\t\t\tinDegree[next]--;\n\t\t\t\tif(inDegree[next] == 0){\n\t\t\t\t\tq.add(next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count != numCourses){\n\t\t\treturn new int[0];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] findOrder(int numCourses, int[][] prerequisites) {\n\t\tint[] order = new int[numCourses];\n\t\tint[] inDegree = new int[numCourses];\n\t\tint[] visited = new int[numCourses];\n\t\tfor (int i = 0; i < prerequisites.length; i++) {\n\t\t\tinDegree[prerequisites[i][0]]++;\n\t\t}\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tfor (int i = 0; i < numCourses; i++) {\n\t\t\tif (inDegree[i] == 0) {\n\t\t\t\tqueue.offer(i);\n\t\t\t}\n\t\t}\n\t\tint index = 0;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint cur = queue.poll();\n\t\t\torder[index++] = cur;\n\t\t\tfor (int i = 0; i < prerequisites.length; i++) {\n\t\t\t\tif (prerequisites[i][1] == cur) {\n\t\t\t\t\tinDegree[prerequisites[i][0]]--;\n\t\t\t\t\tif (inDegree[prerequisites[i][0]] == 0) {\n\t\t\t\t\t\tqueue.offer(prerequisites[i][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (index != numCourses) {\n\t\t\treturn new int[0];\n\t\t}\n\t\treturn order;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 4;\n\t\tint[][] edges = {{0, 1}, {1, 2}, {2, 3}};\n\t\tint[][] edges2 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}};\n\t\tint[][] edges3 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}};\n\t\tint[][] edges4 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}, {1, 3}};\n\t\tint[][] edges5 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}, {1, 3}, {2, 0}};\n\t\tint[][] edges6 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}, {1, 3}, {2, 0}, {3, 1}};\n\t\tint[][] edges7 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}, {1, 3}, {2, 0}, {3, 1}, {0, 3}};\n\t\tint[][] edges8 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}, {1, 3}, {2, 0}, {3, 1}, {0, 3}, {1, 0}};\n\t\tint[][] edges9 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}, {1, 3}, {2, 0}, {3, 1}, {0, 3}, {1, 0}, {2, 1}};\n\t\tint[][] edges10 = {{0, 1}, {1, 2}, {2, 3}, {3, 0}, {0, 2}, {1, 3}, {2, 0}, {3, 1}, {0, 3}, {1, 0}, {2, 1}, {3, 2\n"
    ],
    "results": 10
},{
    "id": "1930",
    "source": "leetcode",
    "language": "java",
    "query": "A subarray is defined as a contiguous block of elements in the array. Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint p = 3;\n\t\tSystem.out.println(removeSubarray(nums, p));\n\t}\n\tpublic static int removeSubarray(int[] nums, int p){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\tif(sum % p != 0){\n\t\t\treturn -1;\n\t\t}\n\t\tint[] sums = new int[nums.length];\n\t\tsums[0] = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tsums[i] = sums[i-1] + nums[i];\n\t\t}\n\t\tint min = sums[nums.length-1];\n\t\tint minIndex = nums.length-1;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(sums[i] % p == 0){\n\t\t\t\tif(min > sums[i]){\n\t\t\t\t\tmin = sums[i];\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minIndex == nums.length-1){\n\t\t\treturn -1;\n\t\t}\n\t\tint[] newNums = new int[nums.length-minIndex-1];\n\t\tfor(int i = 0; i < newNums.length; i++){\n\t\t\tnewNums[i] = nums[i+minIndex+1];\n\t\t}\n\t\treturn newNums.length;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint p = 3;\n\t\tint[] result = removeSubarray(nums, p);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n\tpublic static int[] removeSubarray(int[] nums, int p){\n\t\tint[] result = new int[nums.length];\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum % p == 0){\n\t\t\t\tstart = i + 1;\n\t\t\t\tend = i + 1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(sum % p != 0){\n\t\t\t\tresult[i] = nums[i];\n\t\t\t}\n\t\t\tif(sum % p == 0 && count == 0){\n\t\t\t\tresult[i] = nums[i];\n\t\t\t}\n\t\t\tif(sum % p == 0 && count > 0){\n\t\t\t\tresult[i] = nums[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint p = 3;\n\t\tint[] result = subarrayDivByK(nums, p);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n\tpublic static int[] subarrayDivByK(int[] nums, int k){\n\t\tint[] result = new int[nums.length];\n\t\tint sum = 0;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum % k == 0){\n\t\t\t\tresult[index] = i + 1;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tint[] result2 = new int[index];\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tresult2[i] = result[i];\n\t\t}\n\t\treturn result2;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint p = 3;\n\t\tint[] result = new int[nums.length];\n\t\tint resultIndex = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\tif(sum % p == 0){\n\t\t\tSystem.out.println(\"No need to remove any elements\");\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\t\tint tempSum = 0;\n\t\t\t\tfor(int j = i; j < nums.length; j++){\n\t\t\t\t\ttempSum += nums[j];\n\t\t\t\t\tif(tempSum % p == 0){\n\t\t\t\t\t\tfor(int k = i; k <= j; k++){\n\t\t\t\t\t\t\tresult[resultIndex] = nums[k];\n\t\t\t\t\t\t\tresultIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < resultIndex; i++){\n\t\t\t\tSystem.out.print(result[i] + \" \");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid remove(int[] nums, int p) {\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\twhile(sum % p == 0){\n\t\t\t\tif(min > i - start + 1){\n\t\t\t\t\tmin = i - start + 1;\n\t\t\t\t\tend = i;\n\t\t\t\t}\n\t\t\t\tsum -= nums[start];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t}\n\t\tif(min == Integer.MAX_VALUE){\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < min; i++){\n\t\t\tnums[start + i] = 0;\n\t\t}\n\t}\n}\n",
        "\tvoid removeSubarray(int[] nums, int p) {\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tint len = nums.length;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tsum += nums[i];\n\t\t\twhile (sum % p == 0) {\n\t\t\t\tsum -= nums[start++];\n\t\t\t}\n\t\t\tend = i + 1;\n\t\t}\n\t\tif (start == 0) {\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = start; i < len; i++) {\n\t\t\tnums[i - start] = nums[i];\n\t\t}\n\t\tfor (int i = len - start; i < len; i++) {\n\t\t\tnums[i] = 0;\n\t\t}\n\t}\n}\n",
        "\tint[] removeSubarray(int[] nums, int p) {\n\t\tint[] res = new int[nums.length];\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tint len = nums.length;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tsum += nums[i];\n\t\t\twhile (sum % p == 0) {\n\t\t\t\tsum -= nums[start];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tres[end] = nums[i];\n\t\t\tend++;\n\t\t}\n\t\treturn Arrays.copyOfRange(res, start, end);\n\t}\n}\n",
        "\tint[] removeSubarray(int[] nums, int p) {\n\t\tint[] res = new int[nums.length];\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tint len = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\twhile(sum % p == 0){\n\t\t\t\tsum -= nums[start];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tres[len++] = nums[i];\n\t\t}\n\t\treturn Arrays.copyOf(res, len);\n\t}\n}\n",
        "\tvoid removeSubarray(int[] nums, int p){\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tint minLen = nums.length;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\twhile(sum % p == 0){\n\t\t\t\tif(minLen > end - start + 1){\n\t\t\t\t\tminLen = end - start + 1;\n\t\t\t\t}\n\t\t\t\tsum -= nums[start];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tend++;\n\t\t}\n\t\tif(minLen == nums.length){\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < minLen; i++){\n\t\t\tnums[i] = 0;\n\t\t}\n\t}\n}\n",
        "\tint[] removeSub(int[] nums, int p){\n\t\tint sum = 0;\n\t\tint[] res = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\tif(sum % p != 0){\n\t\t\treturn res;\n\t\t}\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tdp[i] = dp[i - 1] + nums[i];\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(dp[i] % p == 0){\n\t\t\t\tmin = Math.min(min, i - start + 1);\n\t\t\t\tstart = i + 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < min; i++){\n\t\t\tres[i] = nums[start + i];\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1931",
    "source": "leetcode",
    "language": "java",
    "query": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle. The answer is returned as an array [x, y].",
    "snippets": [
        "\tstatic double[] randPoint(double radius, double x_center, double y_center){\n\t\tdouble[] res = new double[2];\n\t\tdouble x = Math.random() * 2 * radius + x_center - radius;\n\t\tdouble y = Math.random() * 2 * radius + y_center - radius;\n\t\tres[0] = x;\n\t\tres[1] = y;\n\t\treturn res;\n\t}\n}\n",
        "\tstatic double[] randPoint(double radius, double x_center, double y_center){\n\t\tdouble[] res = new double[2];\n\t\tdouble x = Math.random() * radius * 2 + x_center - radius;\n\t\tdouble y = Math.random() * radius * 2 + y_center - radius;\n\t\tres[0] = x;\n\t\tres[1] = y;\n\t\treturn res;\n\t}\n}\n",
        "\tstatic double[] randPoint(double radius, double x_center, double y_center){\n\t\tdouble[] ans = new double[2];\n\t\tdouble x = Math.random() * 2 * radius + x_center - radius;\n\t\tdouble y = Math.random() * 2 * radius + y_center - radius;\n\t\tans[0] = x;\n\t\tans[1] = y;\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic double[] randPoint(double radius, double x_center, double y_center){\n\t\tdouble[] result = new double[2];\n\t\tdouble x = Math.random() * 2 * radius + x_center - radius;\n\t\tdouble y = Math.random() * 2 * radius + y_center - radius;\n\t\tresult[0] = x;\n\t\tresult[1] = y;\n\t\treturn result;\n\t}\n}\n",
        "\tstatic double[] randPoint(double radius, double x, double y){\n\t\tdouble[] res = new double[2];\n\t\tdouble r = Math.random() * radius;\n\t\tdouble angle = Math.random() * 2 * Math.PI;\n\t\tres[0] = x + r * Math.cos(angle);\n\t\tres[1] = y + r * Math.sin(angle);\n\t\treturn res;\n\t}\n}\n",
        "\tstatic double[] randPoint(double radius, double x_center, double y_center){\n\t\tdouble[] res = new double[2];\n\t\tdouble x = Math.random() * radius * 2 - radius;\n\t\tdouble y = Math.random() * radius * 2 - radius;\n\t\tdouble d = Math.sqrt(x * x + y * y);\n\t\tif(d > radius){\n\t\t\treturn randPoint(radius, x_center, y_center);\n\t\t}\n\t\tres[0] = x_center + x;\n\t\tres[1] = y_center + y;\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1932",
    "source": "leetcode",
    "language": "java",
    "query": "Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit. Given two numbers arr1 and arr2 in base -2, return the result of adding them together.",
    "snippets": [
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[arr1.length];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < arr1.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tcarry = sum / 2;\n\t\t\tresult[i] = sum % 2;\n\t\t}\n\t\tif(carry != 0){\n\t\t\tresult = add(result, new int[]{carry});\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[arr1.length];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < arr1.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tif(sum >= 2){\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcarry = 0;\n\t\t\t}\n\t\t\tresult[i] = sum;\n\t\t}\n\t\tif(carry == 1){\n\t\t\tint[] temp = new int[result.length + 1];\n\t\t\tfor(int i = 0; i < result.length; i++){\n\t\t\t\ttemp[i+1] = result[i];\n\t\t\t}\n\t\t\ttemp[0] = 1;\n\t\t\tresult = temp;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[arr1.length];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < arr1.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tif(sum >= 2){\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcarry = 0;\n\t\t\t}\n\t\t\tresult[i] = sum;\n\t\t}\n\t\tif(carry == 1){\n\t\t\tint[] newResult = new int[result.length + 1];\n\t\t\tfor(int i = 0; i < result.length; i++){\n\t\t\t\tnewResult[i + 1] = result[i];\n\t\t\t}\n\t\t\tnewResult[0] = 1;\n\t\t\treturn newResult;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[arr1.length];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < arr1.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tif(sum >= 2){\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcarry = 0;\n\t\t\t}\n\t\t\tresult[i] = sum;\n\t\t}\n\t\tif(carry == 1){\n\t\t\tint[] temp = new int[arr1.length + 1];\n\t\t\tfor(int i = 0; i < result.length; i++){\n\t\t\t\ttemp[i + 1] = result[i];\n\t\t\t}\n\t\t\ttemp[0] = 1;\n\t\t\treturn temp;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[arr1.length];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < arr1.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tif(sum >= 2){\n\t\t\t\tcarry = 1;\n\t\t\t\tsum -= 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcarry = 0;\n\t\t\t}\n\t\t\tresult[i] = sum;\n\t\t}\n\t\tif(carry == 1){\n\t\t\tint[] temp = new int[result.length + 1];\n\t\t\tfor(int i = 0; i < result.length; i++){\n\t\t\t\ttemp[i+1] = result[i];\n\t\t\t}\n\t\t\ttemp[0] = 1;\n\t\t\treturn temp;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[arr1.length];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < arr1.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tcarry = sum / 2;\n\t\t\tresult[i] = sum % 2;\n\t\t}\n\t\tif(carry > 0){\n\t\t\tint[] newResult = new int[arr1.length + 1];\n\t\t\tfor(int i = 0; i < result.length; i++){\n\t\t\t\tnewResult[i + 1] = result[i];\n\t\t\t}\n\t\t\tnewResult[0] = carry;\n\t\t\treturn newResult;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[arr1.length];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < arr1.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tresult[i] = sum % 2;\n\t\t\tcarry = sum / 2;\n\t\t}\n\t\tif(carry != 0){\n\t\t\tresult = add(result, new int[]{carry});\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] add(int[] arr1, int[] arr2){\n\t\tint[] result = new int[Math.max(arr1.length, arr2.length)];\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tint sum = arr1[i] + arr2[i] + carry;\n\t\t\tresult[i] = sum % 2;\n\t\t\tcarry = sum / 2;\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1933",
    "source": "leetcode",
    "language": "java",
    "query": "Return the number of connected components in nums where two values are connected if they appear consecutively. You are given the head of a linked list containing unique integer values and an integer array nums.",
    "snippets": [
        "\tint countComponents(int n, int[] nums) {\n\t\tint[] visited = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(visited[nums[i]] == 0){\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(int num, int[] visited, int[] nums){\n\t\tvisited[num] = 1;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(visited[nums[i]] == 0 && isConnected(num, nums[i])){\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isConnected(int num1, int num2){\n\t\tint diff = Math.abs(num1 - num2);\n\t\tif(diff == 1) return true;\n\t\telse return false;\n\t}\n}\n",
        "\tint countComponents(int n, int[] nums) {\n\t\tint[] visited = new int[n];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (visited[nums[i] - 1] == 0) {\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(int num, int[] visited, int[] nums) {\n\t\tvisited[num - 1] = 1;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (visited[nums[i] - 1] == 0 && isConnected(num, nums[i])) {\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isConnected(int num1, int num2) {\n\t\tint[] nums = new int[2];\n\t\tnums[0] = num1;\n\t\tnums[1] = num2;\n\t\tArrays.sort(nums);\n\t\treturn nums[0] + 1 == nums[1];\n\t}\n}\n",
        "\tint countComponents(int n, int[] nums) {\n\t\tint[] visited = new int[n];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (visited[nums[i] - 1] == 0) {\n\t\t\t\tcount++;\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(int num, int[] visited, int[] nums) {\n\t\tvisited[num - 1] = 1;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (visited[nums[i] - 1] == 0 && isConnected(num, nums[i])) {\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isConnected(int num1, int num2) {\n\t\tint[] nums = new int[] { num1, num2 };\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tif (nums[i] == nums[j]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tint numComponents(ListNode head, int[] G) {\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor (int i : G) {\n\t\t\tset.add(i);\n\t\t}\n\t\tint count = 0;\n\t\tListNode cur = head;\n\t\twhile (cur != null) {\n\t\t\tif (set.contains(cur.val) && (cur.next == null || !set.contains(cur.next.val))) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countComponents(int n, int[] nums) {\n\t\tint[] visited = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(visited[nums[i]] == 0){\n\t\t\t\tcount++;\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(int num, int[] visited, int[] nums){\n\t\tvisited[num] = 1;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(visited[nums[i]] == 0 && isConnected(num, nums[i])){\n\t\t\t\tdfs(nums[i], visited, nums);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isConnected(int num1, int num2){\n\t\tint diff = Math.abs(num1 - num2);\n\t\tif(diff == 1) return true;\n\t\telse return false;\n\t}\n}\n",
        "\tint numComponents(ListNode head, int[] G) {\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i : G) set.add(i);\n\t\tint count = 0;\n\t\tListNode cur = head;\n\t\twhile(cur != null){\n\t\t\tif(set.contains(cur.val) && (cur.next == null || !set.contains(cur.next.val))){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numComponents(ListNode head, int[] G) {\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i : G) set.add(i);\n\t\tint count = 0;\n\t\tListNode cur = head;\n\t\twhile(cur != null){\n\t\t\tif(!set.contains(cur.val) && set.contains(cur.next.val)) count++;\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numComponents(ListNode head, int[] G) {\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < G.length; i++){\n\t\t\tset.add(G[i]);\n\t\t}\n\t\tint count = 0;\n\t\tListNode cur = head;\n\t\twhile(cur != null){\n\t\t\tif(set.contains(cur.val) && !set.contains(cur.next.val)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numComponents(ListNode head, int[] G) {\n\t\tint count = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < G.length; i++){\n\t\t\tset.add(G[i]);\n\t\t}\n\t\tListNode cur = head;\n\t\twhile(cur != null){\n\t\t\tif(set.contains(cur.val) && set.contains(cur.next.val)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countComponents(int n, int[] edges) {\n\t\tint[] visited = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif(visited[u] == 0 && visited[v] == 0){\n\t\t\t\tcount++;\n\t\t\t\tdfs(visited, u);\n\t\t\t\tdfs(visited, v);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(int[] visited, int u){\n\t\tvisited[u] = 1;\n\t\tfor(int i = 0; i < visited.length; i++){\n\t\t\tif(visited[i] == 0 && isConnected(u, i)){\n\t\t\t\tdfs(visited, i);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isConnected(int u, int v){\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1934",
    "source": "leetcode",
    "language": "java",
    "query": "Return the restaurant's �display table�. The first row should be a header whose first column is �Table�, followed by the names of the food items. Note that the customer names are not part of the table.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tRestaurant r = new Restaurant();\n\t\tr.addCustomer(\"John\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Sue\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Sally\");\n\t\tr.addCustomer(\"Peter\");\n\t\tr.addCustomer(\"Paul\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Sue\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Sally\");\n\t\tr.addCustomer(\"Peter\");\n\t\tr.addCustomer(\"Paul\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Sue\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Sally\");\n\t\tr.addCustomer(\"Peter\");\n\t\tr.addCustomer(\"Paul\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Sue\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Sally\");\n\t\tr.addCustomer(\"Peter\");\n\t\tr.addCustomer(\"Paul\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Sue\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Sally\");\n\t\tr.addCustomer(\"Peter\");\n\t\tr.addCustomer(\"Paul\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Sue\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Sally\");\n\t\tr.addCustomer(\"Peter\");\n\t\tr.addCustomer(\"Paul\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Sue\");\n\t\tr.add\n",
        "\tstatic void main(String[] args){\n\t\tRestaurant r = new Restaurant();\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.addCustomer(\"Jane\", \"Smith\");\n\t\tr.addCustomer(\"John\", \"Doe\");\n\t\tr.addCustomer(\"Jane\", \"Doe\");\n\t\tr.addCustomer(\"John\", \"Smith\");\n\t\tr.add\n",
        "\tvoid main(String[] args){\n\t\tRestaurant r = new Restaurant();\n\t\tr.addCustomer(\"John\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n\t\tr.addCustomer(\"Joe\");\n\t\tr.addCustomer(\"Mary\");\n\t\tr.addCustomer(\"Bob\");\n\t\tr.addCustomer(\"Jane\");\n",
        "\tstatic void main(String[] args){\n\t\tRestaurant r = new Restaurant();\n\t\tr.addCustomer(\"John\", \"Doe\", \"123 Main St.\", \"555-555-5555\", \"\n",
        "\tString getDisplayTable(String[] foodItems, String[] customerNames, int[][] orders){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(\"Table\\t\");\n\t\tfor(int i = 0; i < foodItems.length; i++){\n\t\t\tsb.append(foodItems[i] + \"\\t\");\n\t\t}\n\t\tsb.append(\"\\n\");\n\t\tfor(int i = 0; i < customerNames.length; i++){\n\t\t\tsb.append(customerNames[i] + \"\\t\");\n\t\t\tfor(int j = 0; j < foodItems.length; j++){\n\t\t\t\tsb.append(orders[i][j] + \"\\t\");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic String getDisplayTable(){\n\t\treturn \"\";\n\t}\n}\n"
    ],
    "results": 6
},{
    "id": "1935",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count where count[k] is the number of times that k appears in the sample.Calculate the following statistics:",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] count = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count2 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count3 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count4 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count5 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count6 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count7 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count8 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count9 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count10 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count11 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count12 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count13 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count14 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count15 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count16 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count17 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[] count18 = {1, 4, 4, 2, 2, 5, 1, 5, 2};\n\t\tint[]\n"
    ],
    "results": 1
},{
    "id": "1936",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard.",
    "snippets": [
        "\tList<String> findWords(String[] words) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tString[] row1 = {\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\"};\n\t\tString[] row2 = {\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"};\n\t\tString[] row3 = {\"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\"};\n\t\tfor(String word: words){\n\t\t\tboolean isOneRow = true;\n\t\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\t\tchar c = word.charAt(i);\n\t\t\t\tif(!isOneRow){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!isOneRow(c, row1)){\n\t\t\t\t\tisOneRow = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isOneRow){\n\t\t\t\tresult.add(word);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isOneRow(char c, String[] row){\n\t\tfor(String s: row){\n\t\t\tif(s.indexOf(c) != -1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tList<String> findWords(String[] words) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tString[] row1 = {\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\"};\n\t\tString[] row2 = {\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"};\n\t\tString[] row3 = {\"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\"};\n\t\tfor(String word: words){\n\t\t\tboolean flag = true;\n\t\t\tchar[] chars = word.toLowerCase().toCharArray();\n\t\t\tfor(char c: chars){\n\t\t\t\tif(!(isIn(c, row1) || isIn(c, row2) || isIn(c, row3))){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tresult.add(word);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isIn(char c, String[] row){\n\t\tfor(String s: row){\n\t\t\tif(s.indexOf(c) != -1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tList<String> findWords(String[] words) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tfor(String word:words){\n\t\t\tif(isValid(word)){\n\t\t\t\tresult.add(word);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isValid(String word){\n\t\tint row = 0;\n\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\tchar c = word.charAt(i);\n\t\t\tif(c >= 'a' && c <= 'z'){\n\t\t\t\trow = 1;\n\t\t\t}else if(c >= 'A' && c <= 'Z'){\n\t\t\t\trow = 2;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn row == 1 || row == 2;\n\t}\n}\n",
        "\tList<String> findWords(String[] words) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tfor(String word:words){\n\t\t\tif(isValid(word)){\n\t\t\t\tresult.add(word);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isValid(String word){\n\t\tchar[] chars = word.toCharArray();\n\t\tint row = getRow(chars[0]);\n\t\tfor(int i=1;i<chars.length;i++){\n\t\t\tif(getRow(chars[i])!=row){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic int getRow(char c){\n\t\tif(c>='a'&&c<='z'){\n\t\t\treturn 1;\n\t\t}\n\t\tif(c>='A'&&c<='Z'){\n\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tList<String> findWords(String[] words) {\n\t\tList<String> res = new ArrayList<>();\n\t\tString[] row1 = {\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\"};\n\t\tString[] row2 = {\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"};\n\t\tString[] row3 = {\"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\"};\n\t\tfor(String word : words){\n\t\t\tboolean flag = true;\n\t\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\t\tchar c = word.charAt(i);\n\t\t\t\tif(!(Arrays.asList(row1).contains(String.valueOf(c)) || Arrays.asList(row2).contains(String.valueOf(c)) || Arrays.asList(row3).contains(String.valueOf(c)))){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) res.add(word);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<String> findWords(String[] words) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tfor(String word:words){\n\t\t\tif(isOneRow(word)){\n\t\t\t\tresult.add(word);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isOneRow(String word){\n\t\tchar[] chars = word.toCharArray();\n\t\tint row = getRow(chars[0]);\n\t\tfor(int i=1;i<chars.length;i++){\n\t\t\tif(getRow(chars[i])!=row){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic int getRow(char c){\n\t\tif(c>='a'&&c<='z'){\n\t\t\treturn 1;\n\t\t}\n\t\tif(c>='A'&&c<='Z'){\n\t\t\treturn 1;\n\t\t}\n\t\tif(c>='1'&&c<='9'){\n\t\t\treturn 2;\n\t\t}\n\t\treturn 3;\n\t}\n}\n",
        "\tList<String> findWords(String[] words) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tfor(String word:words){\n\t\t\tif(isValid(word)) res.add(word);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isValid(String word){\n\t\tint row = 0;\n\t\tfor(int i = 0;i<word.length();i++){\n\t\t\tchar c = word.charAt(i);\n\t\t\tif(c>='a'&&c<='z') row = 1;\n\t\t\telse if(c>='A'&&c<='Z') row = 2;\n\t\t\telse return false;\n\t\t}\n\t\treturn row == 1 || row == 2;\n\t}\n}\n",
        "\tList<String> findWords(String[] words) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tString[] row1 = {\"q\",\"w\",\"e\",\"r\",\"t\",\"y\",\"u\",\"i\",\"o\",\"p\"};\n\t\tString[] row2 = {\"a\",\"s\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\"};\n\t\tString[] row3 = {\"z\",\"x\",\"c\",\"v\",\"b\",\"n\",\"m\"};\n\t\tfor(String word: words){\n\t\t\tboolean flag = true;\n\t\t\tString temp = word.toLowerCase();\n\t\t\tfor(int i = 0; i < temp.length(); i++){\n\t\t\t\tif(!(temp.charAt(i) == 'q' || temp.charAt(i) == 'w' || temp.charAt(i) == 'e' || temp.charAt(i) == 'r' || temp.charAt(i) == 't' || temp.charAt(i) == 'y' || temp.charAt(i) == 'u' || temp.charAt(i) == 'i' || temp.charAt(i) == 'o' || temp.charAt(i) == 'p' || temp.charAt(i) == 'a' || temp.charAt(i) == 's' || temp.charAt(i) == 'd' || temp.charAt(i) == 'f' || temp.charAt(i) == 'g' || temp.charAt(i) == 'h' || temp.charAt(i) == 'j' || temp.charAt(i) == 'k' || temp.charAt(i) == 'l' || temp.charAt(i) == 'z' || temp.charAt(i) == 'x' || temp.charAt(i) == 'c' || temp.charAt(i) == 'v' || temp.charAt(i) == 'b' || temp.charAt(i) == 'n' || temp.charAt(i) == 'm')){\n\t\t\t\t\tflag = false;\n"
    ],
    "results": 10
},{
    "id": "1937",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, find a sequence that satisfies all of the following. The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(a[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = n - i - 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(b[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(c[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = n - i - 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(d[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(e[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tint[] f =\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = i;\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = i;\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = i;\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = i;\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = i;\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = i;\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = i;\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ti[i] = i;\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tj[i] = i;\n\t\t}\n\t\tint[] k = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tk[\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(a[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(Math.abs(j - i) == a[j]){\n\t\t\t\t\tSystem.out.print(a[j] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(a[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(Math.abs(j - i) == Math.abs(a[j] - a[i])){\n\t\t\t\t\tSystem.out.print(a[j] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tstatic int[] findSequence(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\treturn a;\n\t}\n}\n",
        "\tstatic int[] findSequence(int n){\n\t\tint[] sequence = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsequence[i] = i;\n\t\t}\n\t\treturn sequence;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1938",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a large integer represented as an integer array digits. The digits are ordered from most significant to least significant in left-to-right order.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] digits = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits2 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits3 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits4 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits5 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits6 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits7 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits8 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits9 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits10 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits11 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits12 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits13 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits14 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits15 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits16 = {1,2,3,4,5,6,7,8,9,0};\n\t\tint[] digits17 = {1,2,3,4,5,6,7,8,9,\n",
        "\tstatic void main(String[] args){\n\t\tint[] digits = {1,2,3,4,5,6,7,8,9,0};\n\t\tSystem.out.println(new Clazz().largestNumber(digits));\n\t}\n\tpublic String largestNumber(int[] digits){\n\t\tString[] strs = new String[digits.length];\n\t\tfor(int i = 0; i < digits.length; i++){\n\t\t\tstrs[i] = String.valueOf(digits[i]);\n\t\t}\n\t\tArrays.sort(strs, new Comparator<String>(){\n\t\t\tpublic int compare(String a, String b){\n\t\t\t\treturn (b + a).compareTo(a + b);\n\t\t\t}\n\t\t});\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String str : strs){\n\t\t\tsb.append(str);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] digits = {1,2,3,4,5,6,7,8,9,0};\n\t\tSystem.out.println(new Clazz().largestNumber(digits));\n\t}\n\tpublic String largestNumber(int[] digits) {\n\t\tString[] strs = new String[digits.length];\n\t\tfor(int i = 0; i < digits.length; i++){\n\t\t\tstrs[i] = String.valueOf(digits[i]);\n\t\t}\n\t\tArrays.sort(strs, new Comparator<String>(){\n\t\t\tpublic int compare(String a, String b){\n\t\t\t\treturn (b + a).compareTo(a + b);\n\t\t\t}\n\t\t});\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String s : strs){\n\t\t\tsb.append(s);\n\t\t}\n\t\tif(sb.charAt(0) == '0'){\n\t\t\treturn \"0\";\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] digits = {1,2,3,4,5,6,7,8,9,0};\n\t\tSystem.out.println(new Clazz().largestNumber(digits));\n\t}\n\tpublic String largestNumber(int[] digits){\n\t\tString[] strDigits = new String[digits.length];\n\t\tfor(int i = 0; i < digits.length; i++){\n\t\t\tstrDigits[i] = String.valueOf(digits[i]);\n\t\t}\n\t\tArrays.sort(strDigits, new Comparator<String>(){\n\t\t\tpublic int compare(String a, String b){\n\t\t\t\treturn (b + a).compareTo(a + b);\n\t\t\t}\n\t\t});\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String str : strDigits){\n\t\t\tsb.append(str);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] digits = {1,2,3,4,5,6,7,8,9,0};\n\t\tSystem.out.println(new Clazz().largestNumber(digits));\n\t}\n\tpublic String largestNumber(int[] digits){\n\t\tString[] strs = new String[digits.length];\n\t\tfor(int i = 0; i < digits.length; i++){\n\t\t\tstrs[i] = String.valueOf(digits[i]);\n\t\t}\n\t\tArrays.sort(strs, new Comparator<String>(){\n\t\t\tpublic int compare(String a, String b){\n\t\t\t\treturn (b + a).compareTo(a + b);\n\t\t\t}\n\t\t});\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String s : strs){\n\t\t\tsb.append(s);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] digits = {1,2,3,4,5,6,7,8,9,0};\n\t\tSystem.out.println(reverse(digits));\n\t}\n\tpublic static int[] reverse(int[] digits){\n\t\tint[] newDigits = new int[digits.length];\n\t\tfor(int i = 0; i < digits.length; i++){\n\t\t\tnewDigits[i] = digits[digits.length - i - 1];\n\t\t}\n\t\treturn newDigits;\n\t}\n}\n",
        "\tstatic int[] digits(int n){\n\t\tint[] digits = new int[(int)Math.log10(n) + 1];\n\t\tint i = 0;\n\t\twhile(n > 0){\n\t\t\tdigits[i] = n % 10;\n\t\t\tn /= 10;\n\t\t\ti++;\n\t\t}\n\t\treturn digits;\n\t}\n}\n",
        "\tstatic int[] digits(int n){\n\t\tint[] digits = new int[(int)Math.log10(n)+1];\n\t\tint i = 0;\n\t\twhile(n>0){\n\t\t\tdigits[i] = n%10;\n\t\t\tn = n/10;\n\t\t\ti++;\n\t\t}\n\t\treturn digits;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1939",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an array of network towers towers. All the coordinates are integral coordinates on the X-Y plane. The distance between the two coordinates is the Euclidean distance. The network quality at a coordinate is the sum of the signal qualities from all the reachable towers.",
    "snippets": [
        "\tint networkQuality(int[][] towers) {\n\t\tint[][] dp = new int[towers.length][towers.length];\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tfor(int k = 0; k < towers.length; k++){\n\t\t\t\t\tif(k == i || k == j) continue;\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tans += dp[i][j];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic int networkQuality(int[][] towers) {\n\t\tint[][] quality = new int[towers.length][towers.length];\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tquality[i][j] = towers[i][0] - towers[j][0] + towers[i][1] - towers[j][1];\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[towers.length][towers.length];\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tfor(int k = 0; k < towers.length; k++){\n\t\t\t\t\tif(i == k || j == k){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + quality[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, dp[i][\n",
        "\tint networkQuality(int[][] towers) {\n\t\tint[][] dp = new int[towers.length][towers.length];\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tfor(int k = 0; k < towers.length; k++){\n\t\t\t\t\tif(k == i || k == j) continue;\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tres += dp[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int networkQuality(int[][] towers) {\n\t\tint n = towers.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x = towers[i][0];\n\t\t\t\tint y = towers[i][1];\n\t\t\t\tint x1 = towers[j][0];\n\t\t\t\tint y1 = towers[j][1];\n\t\t\t\tint dis = (int) Math.pow(x - x1, 2) + (int) Math.pow(y - y1, 2);\n\t\t\t\tif (dp[i][j] == -1) {\n\t\t\t\t\tdp[i][j] = dis;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dis);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) {\n",
        "\tstatic int networkQuality(int[][] towers) {\n\t\tint[][] quality = new int[towers.length][towers.length];\n\t\tfor (int i = 0; i < towers.length; i++) {\n\t\t\tfor (int j = 0; j < towers.length; j++) {\n\t\t\t\tquality[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < towers.length; i++) {\n\t\t\tfor (int j = 0; j < towers.length; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tquality[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tint x = towers[i][0] - towers[j][0];\n\t\t\t\t\tint y = towers[i][1] - towers[j][1];\n\t\t\t\t\tquality[i][j] = (int) Math.sqrt(x * x + y * y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < towers.length; i++) {\n\t\t\tfor (int j = 0; j < towers.length; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tsum += quality[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic int networkQuality(int[][] towers) {\n\t\tint n = towers.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(i == k || j == k) continue;\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tres += towers[i][j] * dp[i][j];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int networkQuality(int[][] towers) {\n\t\tint[][] dp = new int[towers.length][towers.length];\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tfor(int k = 0; k < towers.length; k++){\n\t\t\t\t\tif(k == i || k == j) continue;\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + towers[i][0] * towers[i][1] * towers[j][0] * towers[j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tans = Math.max(ans, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint getNetworkQuality(int[][] towers) {\n\t\tint n = towers.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + towers[i][0] * towers[j][0] * towers[k][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tres = Math.max(res, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] towers = {{1,1,1},{1,1,1},{1,1,1}};\n\t\tint[] result = networkQuality(towers);\n\t\tSystem.out.println(Arrays.toString(result));\n\t}\n\tpublic static int[] networkQuality(int[][] towers){\n\t\tint[] result = new int[towers.length];\n\t\tfor(int i = 0; i < towers.length; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < towers.length; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tsum += Math.abs(towers[i][0] - towers[j][0]) + Math.abs(towers[i][1] - towers[j][1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult[i] = sum;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] towers = {{1,1,1},{1,1,1},{1,1,1}};\n\t\tint[] res = new Clazz().towerStrength(towers);\n\t\tfor(int i:res){\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n\tpublic int[] towerStrength(int[][] towers) {\n\t\tint[] res = new int[towers.length];\n\t\tfor(int i=0;i<towers.length;i++){\n\t\t\tint x = towers[i][0];\n\t\t\tint y = towers[i][1];\n\t\t\tint strength = 0;\n\t\t\tfor(int j=0;j<towers.length;j++){\n\t\t\t\tint x1 = towers[j][0];\n\t\t\t\tint y1 = towers[j][1];\n\t\t\t\tint distance = (int)Math.sqrt((x1-x)*(x1-x)+(y1-y)*(y1-y));\n\t\t\t\tstrength += distance;\n\t\t\t}\n\t\t\tres[i] = strength;\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1940",
    "source": "leetcode",
    "language": "java",
    "query": "A split is called good if you can split s into two non-empty strings sleft and sright where their concatenation is equal to s. Return the number of good splits you can make in s.",
    "snippets": [
        "\tint countSplits(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tString left = s.substring(0, i);\n\t\t\tString right = s.substring(i);\n\t\t\tif(left.equals(right)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSplits(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tString left = s.substring(0, i);\n\t\t\tString right = s.substring(i);\n\t\t\tif(left.length() > 0 && right.length() > 0 && left.concat(right).equals(s)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSplits(String s){\n\t\tint count = 0;\n\t\tfor(int i = 1; i < s.length(); i++){\n\t\t\tString left = s.substring(0, i);\n\t\t\tString right = s.substring(i);\n\t\t\tif(left.equals(right)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSplits(String s){\n\t\tint count = 0;\n\t\tfor(int i = 1; i < s.length(); i++){\n\t\t\tString left = s.substring(0, i);\n\t\t\tString right = s.substring(i);\n\t\t\tif(left.equals(right)) count++;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1941",
    "source": "leetcode",
    "language": "java",
    "query": "implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree. Initialize the pointer to a non-existent smallest number. The first call to next() will return the smallest element in the BST.",
    "snippets": [
        "\tBSTIterator(TreeNode root) {\n\t\t// write your code here\n\t}\n\tpublic int next() {\n\t\t// write your code here\n\t\treturn 0;\n\t}\n\tpublic boolean hasNext() {\n\t\t// write your code here\n\t\treturn false;\n\t}\n}\n",
        "\tBSTIterator(TreeNode root) {\n\t\t\n\t}\n\t\n\tpublic int next() {\n\t\t\n\t}\n\t\n\tpublic boolean hasNext() {\n\t\t\n\t}\n}\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic void add(int num){\n\t\t\n\t}\n\tpublic boolean hasNext(){\n\t\t\n\t}\n\tpublic int next(){\n\t\t\n\t}\n}\n",
        "\tBSTIterator(TreeNode root) {\n\t\t// write your code here\n\t\tif(root == null){\n\t\t\tthis.root = null;\n\t\t\tthis.curr = null;\n\t\t}\n\t\telse{\n\t\t\tthis.root = root;\n\t\t\tthis.curr = root;\n\t\t}\n\t}\n\t\n\tpublic int next() {\n\t\t// write your code here\n\t\tif(curr == null){\n\t\t\treturn -1;\n\t\t}\n\t\telse{\n\t\t\twhile(curr.left != null){\n\t\t\t\tcurr = curr.left;\n\t\t\t}\n\t\t\tint res = curr.val;\n\t\t\tcurr = curr.right;\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tpublic boolean hasNext() {\n\t\t// write your code here\n\t\tif(curr == null){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate TreeNode root;\n\tprivate TreeNode curr;\n}\n",
        "\tBSTIterator(TreeNode root) {\n\t\t// write your code here\n\t\tif(root == null){\n\t\t\tthis.root = null;\n\t\t\tthis.curr = null;\n\t\t\tthis.next = null;\n\t\t}\n\t\telse{\n\t\t\tthis.root = root;\n\t\t\tthis.curr = root;\n\t\t\tthis.next = getNext(root);\n\t\t}\n\t}\n\t\n\tpublic int next() {\n\t\t// write your code here\n\t\tif(this.next == null){\n\t\t\tthrow new RuntimeException(\"No next element\");\n\t\t}\n\t\telse{\n\t\t\tint res = this.next.val;\n\t\t\tthis.curr = this.next;\n\t\t\tthis.next = getNext(this.next);\n\t\t\treturn res;\n\t\t}\n\t}\n\t\n\tpublic boolean hasNext() {\n\t\t// write your code here\n\t\treturn this.next != null;\n\t}\n\t\n\tprivate TreeNode getNext(TreeNode root){\n\t\tif(root == null){\n\t\t\treturn null;\n\t\t}\n\t\telse if(root.left == null){\n\t\t\treturn root.right;\n\t\t}\n\t\telse{\n\t\t\tTreeNode curr = root.left;\n\t\t\twhile(curr.right != null){\n\t\t\t\tcurr = curr.right;\n\t\t\t}\n\t\t\treturn curr;\n\t\t}\n\t}\n\t\n\tprivate TreeNode root;\n\tprivate TreeNode curr;\n\tprivate TreeNode next;\n}\n",
        "\tBSTIterator(TreeNode root) {\n\t\t// write your code here\n\t\tthis.root = root;\n\t\tthis.cur = null;\n\t\tthis.next = null;\n\t\tthis.next = findNext(root);\n\t}\n\t\n\tpublic int next() {\n\t\t// write your code here\n\t\tint res = this.next.val;\n\t\tthis.cur = this.next;\n\t\tthis.next = findNext(this.cur.right);\n\t\treturn res;\n\t}\n\t\n\tpublic boolean hasNext() {\n\t\t// write your code here\n\t\treturn this.next != null;\n\t}\n\t\n\tprivate TreeNode findNext(TreeNode node){\n\t\tif(node == null) return null;\n\t\twhile(node.left != null){\n\t\t\tnode = node.left;\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tprivate TreeNode root;\n\tprivate TreeNode cur;\n\tprivate TreeNode next;\n}\n",
        "\tBSTIterator(TreeNode root) {\n\t\t// write your code here\n\t\tthis.root = root;\n\t\tthis.cur = null;\n\t\tthis.next = null;\n\t\tthis.stack = new Stack<TreeNode>();\n\t\tthis.findNext();\n\t}\n\t\n\tpublic int next() {\n\t\t// write your code here\n\t\tint res = this.next.val;\n\t\tthis.cur = this.next;\n\t\tthis.findNext();\n\t\treturn res;\n\t}\n\t\n\tpublic boolean hasNext() {\n\t\t// write your code here\n\t\treturn this.next != null;\n\t}\n\t\n\tprivate void findNext() {\n\t\t// write your code here\n\t\tTreeNode node = this.cur;\n\t\twhile(node != null) {\n\t\t\tthis.stack.push(node);\n\t\t\tnode = node.left;\n\t\t}\n\t\tif(this.stack.isEmpty()) {\n\t\t\tthis.next = null;\n\t\t} else {\n\t\t\tthis.next = this.stack.pop();\n\t\t}\n\t}\n\t\n\tprivate TreeNode root;\n\tprivate TreeNode cur;\n\tprivate TreeNode next;\n\tprivate Stack<TreeNode> stack;\n}\n",
        "\tBSTIterator(TreeNode root) {\n\t\t// write your code here\n\t\tthis.root = root;\n\t\tthis.cur = null;\n\t\tthis.stack = new Stack<TreeNode>();\n\t\tthis.findNext();\n\t}\n\t\n\tpublic int next() {\n\t\t// write your code here\n\t\tint res = this.cur.val;\n\t\tthis.findNext();\n\t\treturn res;\n\t}\n\t\n\tpublic boolean hasNext() {\n\t\t// write your code here\n\t\treturn this.cur != null;\n\t}\n\t\n\tprivate void findNext() {\n\t\t// write your code here\n\t\twhile(this.root != null) {\n\t\t\tthis.stack.push(this.root);\n\t\t\tthis.root = this.root.left;\n\t\t}\n\t\tif(this.stack.isEmpty()) {\n\t\t\tthis.cur = null;\n\t\t} else {\n\t\t\tthis.cur = this.stack.pop();\n\t\t\tthis.root = this.cur.right;\n\t\t}\n\t}\n\t\n\tprivate TreeNode root;\n\tprivate TreeNode cur;\n\tprivate Stack<TreeNode> stack;\n}\n"
    ],
    "results": 10
},{
    "id": "1942",
    "source": "leetcode",
    "language": "java",
    "query": "A uni-value grid is a grid where all the elements of it are equal. You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tint x = 1;\n\t\tint[][] result = new int[grid.length][grid[0].length];\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tresult[i][j] = grid[i][j] + x;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tSystem.out.print(result[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tstatic int[][] grid;\n\tpublic static void main(String[] args){\n\t\tint[][] grid = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tint x = 1;\n\t\tint[][] result = new int[grid.length][grid[0].length];\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tresult[i][j] = grid[i][j] + x;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tSystem.out.print(result[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tstatic int[][] grid;\n\tpublic static void main(String[] args){\n\t\tgrid = new int[][]{{1,2,3},{4,5,6},{7,8,9}};\n\t\tSystem.out.println(find(grid,9));\n\t}\n\tpublic static int find(int[][] grid, int x){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n",
        "\tint findUnivalue(int[][] grid){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(check(grid, i, j)){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tboolean check(int[][] grid, int i, int j){\n\t\tif(i == 0 && j == 0){\n\t\t\treturn true;\n\t\t}\n\t\tif(i == 0){\n\t\t\treturn grid[i][j - 1] == grid[i][j];\n\t\t}\n\t\tif(j == 0){\n\t\t\treturn grid[i - 1][j] == grid[i][j];\n\t\t}\n\t\treturn grid[i - 1][j] == grid[i][j] && grid[i][j - 1] == grid[i][j];\n\t}\n}\n",
        "\tint findUnique(int[][] grid, int x){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == x){\n\t\t\t\t\tgrid[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] != 0){\n\t\t\t\t\treturn grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tstatic int[][] grid;\n\tpublic static int m;\n\tpublic static int n;\n\tpublic static int x;\n\tpublic static int[][] grid2;\n\tpublic static int m2;\n\tpublic static int n2;\n\tpublic static int x2;\n\tpublic static int[][] grid3;\n\tpublic static int m3;\n\tpublic static int n3;\n\tpublic static int x3;\n\tpublic static int[][] grid4;\n\tpublic static int m4;\n\tpublic static int n4;\n\tpublic static int x4;\n\tpublic static int[][] grid5;\n\tpublic static int m5;\n\tpublic static int n5;\n\tpublic static int x5;\n\tpublic static int[][] grid6;\n\tpublic static int m6;\n\tpublic static int n6;\n\tpublic static int x6;\n\tpublic static int[][] grid7;\n\tpublic static int m7;\n\tpublic static int n7;\n\tpublic static int x7;\n\tpublic static int[][] grid8;\n\tpublic static int m8;\n\tpublic static int n8;\n\tpublic static int x8;\n\tpublic static int[][] grid9;\n\tpublic static int m9;\n\tpublic static int n9;\n\tpublic static int x9;\n\tpublic static int[][] grid10;\n\tpublic static int m10;\n\tpublic static int n10;\n\tpublic static int x10;\n\tpublic static int[][] grid11;\n\tpublic static int m11;\n\tpublic static int n11;\n\tpublic static int x11;\n\tpublic static int[][] grid12;\n\tpublic static int m12;\n\tpublic static int n12;\n\tpublic static int x12;\n\tpublic static int[][] grid13;\n\tpublic static int m13;\n\tpublic static int n13;\n\tpublic static int x13;\n\tpublic static int[][] grid14;\n\tpublic static int m14;\n\tpublic static int n14;\n\tpublic static int x14;\n\tpublic static int[][] grid15;\n\tpublic static\n",
        "\tstatic int[][] grid;\n\tpublic static int[][] add(int[][] grid, int x){\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[i].length; j++){\n\t\t\t\tgrid[i][j] += x;\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\tpublic static int[][] sub(int[][] grid, int x){\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[i].length; j++){\n\t\t\t\tgrid[i][j] -= x;\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\tpublic static int[][] mul(int[][] grid, int x){\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[i].length; j++){\n\t\t\t\tgrid[i][j] *= x;\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\tpublic static int[][] div(int[][] grid, int x){\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[i].length; j++){\n\t\t\t\tgrid[i][j] /= x;\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\tpublic static int[][] mod(int[][] grid, int x){\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[i].length; j++){\n\t\t\t\tgrid[i][j] %= x;\n\t\t\t}\n\t\t}\n\t\treturn grid;\n\t}\n\tpublic static int[][] min(int[][] grid, int x){\n\t\tfor(int i = 0\n"
    ],
    "results": 10
},{
    "id": "1943",
    "source": "leetcode",
    "language": "java",
    "query": "A binary search tree is a binary tree where for every node, any descendant of Node.left has a value strictly less than Node.val. A preorder traversal of a Binary Tree displays the value of the node first, then traverses Node.right.",
    "snippets": [
        "\tNode root;\n\tpublic Clazz(){\n\t\troot = null;\n\t}\n\tpublic void insert(int val){\n\t\troot = insert(root, val);\n\t}\n\tpublic Node insert(Node node, int val){\n\t\tif(node == null){\n\t\t\treturn new Node(val);\n\t\t}\n\t\tif(val < node.val){\n\t\t\tnode.left = insert(node.left, val);\n\t\t}\n\t\telse{\n\t\t\tnode.right = insert(node.right, val);\n\t\t}\n\t\treturn node;\n\t}\n\tpublic boolean search(int val){\n\t\treturn search(root, val);\n\t}\n\tpublic boolean search(Node node, int val){\n\t\tif(node == null){\n\t\t\treturn false;\n\t\t}\n\t\tif(node.val == val){\n\t\t\treturn true;\n\t\t}\n\t\tif(val < node.val){\n\t\t\treturn search(node.left, val);\n\t\t}\n\t\telse{\n\t\t\treturn search(node.right, val);\n\t\t}\n\t}\n\tpublic void preorder(){\n\t\tpreorder(root);\n\t}\n\tpublic void preorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(node.val + \" \");\n\t\tpreorder(node.left);\n\t\tpreorder(node.right);\n\t}\n\tpublic void inorder(){\n\t\tinorder(root);\n\t}\n\tpublic void inorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tinorder(node.left);\n\t\tSystem.out.print(node.val + \" \");\n\t\tinorder(node.right);\n\t}\n\tpublic void postorder(){\n\t\tpostorder(root);\n\t}\n\tpublic void postorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tpostorder(node.\n",
        "\tNode root;\n\tpublic Clazz(){\n\t\troot = null;\n\t}\n\tpublic void insert(int val){\n\t\troot = insert(root, val);\n\t}\n\tpublic Node insert(Node node, int val){\n\t\tif(node == null){\n\t\t\tnode = new Node(val);\n\t\t\treturn node;\n\t\t}\n\t\tif(val < node.val){\n\t\t\tnode.left = insert(node.left, val);\n\t\t}\n\t\telse{\n\t\t\tnode.right = insert(node.right, val);\n\t\t}\n\t\treturn node;\n\t}\n\tpublic boolean search(int val){\n\t\treturn search(root, val);\n\t}\n\tpublic boolean search(Node node, int val){\n\t\tif(node == null){\n\t\t\treturn false;\n\t\t}\n\t\tif(node.val == val){\n\t\t\treturn true;\n\t\t}\n\t\tif(val < node.val){\n\t\t\treturn search(node.left, val);\n\t\t}\n\t\telse{\n\t\t\treturn search(node.right, val);\n\t\t}\n\t}\n\tpublic void preorder(){\n\t\tpreorder(root);\n\t}\n\tpublic void preorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(node.val + \" \");\n\t\tpreorder(node.left);\n\t\tpreorder(node.right);\n\t}\n\tpublic void inorder(){\n\t\tinorder(root);\n\t}\n\tpublic void inorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tinorder(node.left);\n\t\tSystem.out.print(node.val + \" \");\n\t\tinorder(node.right);\n\t}\n\tpublic void postorder(){\n\t\tpostorder(root);\n\t}\n\tpublic void postorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n",
        "\tstatic class Node{\n\t\tint val;\n\t\tNode left;\n\t\tNode right;\n\t\tNode(int val){\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\tpublic static Node insert(Node root, int val){\n\t\tif(root == null){\n\t\t\treturn new Node(val);\n\t\t}\n\t\tif(val < root.val){\n\t\t\troot.left = insert(root.left, val);\n\t\t}else{\n\t\t\troot.right = insert(root.right, val);\n\t\t}\n\t\treturn root;\n\t}\n\tpublic static boolean isBST(Node root){\n\t\treturn isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t}\n\tpublic static boolean isBST(Node root, int min, int max){\n\t\tif(root == null){\n\t\t\treturn true;\n\t\t}\n\t\tif(root.val < min || root.val > max){\n\t\t\treturn false;\n\t\t}\n\t\treturn isBST(root.left, min, root.val) && isBST(root.right, root.val, max);\n\t}\n\tpublic static void main(String[] args){\n\t\tNode root = null;\n\t\troot = insert(root, 10);\n\t\troot = insert(root, 5);\n\t\troot = insert(root, 15);\n\t\troot = insert(root, 3);\n\t\troot = insert(root, 7);\n\t\troot = insert(root, 13);\n\t\troot = insert(root, 17);\n\t\troot = insert(root, 11);\n\t\troot = insert(root, 16);\n\t\troot = insert(root, 12);\n\t\troot = insert(root, 14);\n\t\troot = insert(root, 18);\n\t\tSystem.out.println(isBST(root));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tTreeNode root = new TreeNode(10);\n\t\troot.left = new TreeNode(5);\n\t\troot.right = new TreeNode(15);\n\t\troot.left.left = new TreeNode(1);\n\t\troot.left.right = new TreeNode(8);\n\t\troot.right.left = new TreeNode(11);\n\t\troot.right.right = new TreeNode(20);\n\t\troot.left.left.left = new TreeNode(0);\n\t\troot.left.left.right = new TreeNode(3);\n\t\troot.left.right.left = new TreeNode(7);\n\t\troot.left.right.right = new TreeNode(9);\n\t\troot.right.left.left = new TreeNode(12);\n\t\troot.right.left.right = new TreeNode(13);\n\t\troot.right.right.left = new TreeNode(16);\n\t\troot.right.right.right = new TreeNode(25);\n\t\troot.left.left.left.left = new TreeNode(-1);\n\t\troot.left.left.left.right = new TreeNode(2);\n\t\troot.left.left.right.left = new TreeNode(4);\n\t\troot.left.left.right.right = new TreeNode(6);\n\t\troot.left.right.left.left = new TreeNode(8);\n\t\troot.left.right.left.right = new TreeNode(9);\n\t\troot.left.right.right.left = new TreeNode(10);\n\t\troot.left.right.right.right = new TreeNode(11);\n\t\troot.right.left.left.left = new TreeNode(14);\n\t\troot.right.left.left.right = new TreeNode(15);\n\t\troot.right.left.right.left = new TreeNode(16);\n\t\troot.right.left.right.right = new TreeNode(17);\n\t\troot.right.right.left.left = new TreeNode(18);\n\t\troot.right.right\n",
        "\tNode root;\n\tpublic Clazz(){\n\t\troot = null;\n\t}\n\tpublic void insert(int val){\n\t\troot = insert(root,val);\n\t}\n\tpublic Node insert(Node node, int val){\n\t\tif(node == null){\n\t\t\tnode = new Node(val);\n\t\t\treturn node;\n\t\t}\n\t\tif(val < node.val){\n\t\t\tnode.left = insert(node.left,val);\n\t\t}\n\t\telse{\n\t\t\tnode.right = insert(node.right,val);\n\t\t}\n\t\treturn node;\n\t}\n\tpublic boolean search(int val){\n\t\treturn search(root,val);\n\t}\n\tpublic boolean search(Node node, int val){\n\t\tif(node == null){\n\t\t\treturn false;\n\t\t}\n\t\tif(val == node.val){\n\t\t\treturn true;\n\t\t}\n\t\tif(val < node.val){\n\t\t\treturn search(node.left,val);\n\t\t}\n\t\telse{\n\t\t\treturn search(node.right,val);\n\t\t}\n\t}\n\tpublic void preorder(){\n\t\tpreorder(root);\n\t}\n\tpublic void preorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(node.val + \" \");\n\t\tpreorder(node.left);\n\t\tpreorder(node.right);\n\t}\n\tpublic void inorder(){\n\t\tinorder(root);\n\t}\n\tpublic void inorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tinorder(node.left);\n\t\tSystem.out.print(node.val + \" \");\n\t\tinorder(node.right);\n\t}\n\tpublic void postorder(){\n\t\tpostorder(root);\n\t}\n\tpublic void postorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n",
        "\tNode root;\n\tpublic Clazz(){\n\t\troot = null;\n\t}\n\tpublic void insert(int val){\n\t\troot = insert(root,val);\n\t}\n\tpublic Node insert(Node node, int val){\n\t\tif(node == null){\n\t\t\tnode = new Node(val);\n\t\t\treturn node;\n\t\t}\n\t\tif(val < node.val){\n\t\t\tnode.left = insert(node.left,val);\n\t\t}\n\t\telse{\n\t\t\tnode.right = insert(node.right,val);\n\t\t}\n\t\treturn node;\n\t}\n\tpublic void preorder(){\n\t\tpreorder(root);\n\t}\n\tpublic void preorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.print(node.val + \" \");\n\t\tpreorder(node.left);\n\t\tpreorder(node.right);\n\t}\n\tpublic void inorder(){\n\t\tinorder(root);\n\t}\n\tpublic void inorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tinorder(node.left);\n\t\tSystem.out.print(node.val + \" \");\n\t\tinorder(node.right);\n\t}\n\tpublic void postorder(){\n\t\tpostorder(root);\n\t}\n\tpublic void postorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tpostorder(node.left);\n\t\tpostorder(node.right);\n\t\tSystem.out.print(node.val + \" \");\n\t}\n\tpublic void levelorder(){\n\t\tlevelorder(root);\n\t}\n\tpublic void levelorder(Node node){\n\t\tif(node == null){\n\t\t\treturn;\n\t\t}\n\t\tQueue<Node> q = new LinkedList<Node>();\n\t\tq.add(node);\n\t\twhile(!q.isEmpty()){\n\t\t\tNode\n",
        "\tstatic void main(String[] args){\n\t\tBinaryTree tree = new BinaryTree();\n\t\ttree.insert(10);\n\t\ttree.insert(5);\n\t\ttree.insert(15);\n\t\ttree.insert(3);\n\t\ttree.insert(7);\n\t\ttree.insert(13);\n\t\ttree.insert(17);\n\t\ttree.insert(2);\n\t\ttree.insert(6);\n\t\ttree.insert(12);\n\t\ttree.insert(16);\n\t\ttree.insert(4);\n\t\ttree.insert(8);\n\t\ttree.insert(14);\n\t\ttree.insert(18);\n\t\ttree.insert(1);\n\t\ttree.insert(9);\n\t\ttree.insert(11);\n\t\ttree.insert(19);\n\t\ttree.insert(20);\n\t\ttree.insert(21);\n\t\ttree.insert(22);\n\t\ttree.insert(23);\n\t\ttree.insert(24);\n\t\ttree.insert(25);\n\t\ttree.insert(26);\n\t\ttree.insert(27);\n\t\ttree.insert(28);\n\t\ttree.insert(29);\n\t\ttree.insert(30);\n\t\ttree.insert(31);\n\t\ttree.insert(32);\n\t\ttree.insert(33);\n\t\ttree.insert(34);\n\t\ttree.insert(35);\n\t\ttree.insert(36);\n\t\ttree.insert(37);\n\t\ttree.insert(38);\n\t\ttree.insert(39);\n\t\ttree.insert(40);\n\t\ttree.insert(41);\n\t\ttree.insert(42);\n\t\ttree.insert(43);\n\t\ttree.insert(44);\n\t\ttree.insert(45);\n\t\ttree.insert(46);\n\t\ttree.insert(47);\n\t\ttree.insert(48);\n\t\ttree.insert(49);\n\t\ttree.insert(50);\n\t\ttree.insert(51);\n\t\ttree.insert(52);\n\t\ttree.insert(53);\n",
        "\tstatic void main(String[] args){\n\t\tTreeNode root = new TreeNode(10);\n\t\troot.left = new TreeNode(5);\n\t\troot.right = new TreeNode(15);\n\t\troot.left.left = new TreeNode(1);\n\t\troot.left.right = new TreeNode(6);\n\t\troot.right.left = new TreeNode(11);\n\t\troot.right.right = new TreeNode(20);\n\t\tSystem.out.println(isValidBST(root));\n\t}\n\tpublic static boolean isValidBST(TreeNode root){\n\t\treturn isValidBST(root, null, null);\n\t}\n\tpublic static boolean isValidBST(TreeNode root, Integer min, Integer max){\n\t\tif(root == null) return true;\n\t\tif(min != null && root.val <= min) return false;\n\t\tif(max != null && root.val >= max) return false;\n\t\treturn isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tBinaryTreeNode<Integer> root = new BinaryTreeNode<Integer>(10);\n\t\troot.left = new BinaryTreeNode<Integer>(5);\n\t\troot.right = new BinaryTreeNode<Integer>(15);\n\t\troot.left.left = new BinaryTreeNode<Integer>(1);\n\t\troot.left.right = new BinaryTreeNode<Integer>(7);\n\t\troot.right.left = new BinaryTreeNode<Integer>(13);\n\t\troot.right.right = new BinaryTreeNode<Integer>(22);\n\t\troot.left.left.left = new BinaryTreeNode<Integer>(0);\n\t\troot.left.left.right = new BinaryTreeNode<Integer>(4);\n\t\troot.left.right.left = new BinaryTreeNode<Integer>(6);\n\t\troot.left.right.right = new BinaryTreeNode<Integer>(8);\n\t\troot.right.left.left = new BinaryTreeNode<Integer>(12);\n\t\troot.right.left.right = new BinaryTreeNode<Integer>(14);\n\t\troot.right.right.left = new BinaryTreeNode<Integer>(16);\n\t\troot.right.right.right = new BinaryTreeNode<Integer>(23);\n\t\troot.left.left.left.left = new BinaryTreeNode<Integer>(0);\n\t\troot.left.left.left.right = new BinaryTreeNode<Integer>(4);\n\t\troot.left.left.right.left = new BinaryTreeNode<Integer>(6);\n\t\troot.left.left.right.right = new BinaryTreeNode<Integer>(8);\n\t\troot.left.right.left.left = new BinaryTreeNode<Integer>(12);\n\t\troot.left.right.left.right = new BinaryTreeNode<Integer>(14);\n\t\troot.left.right.right.left = new BinaryTreeNode<Integer>(16);\n\t\troot.left.right.right.right = new BinaryTreeNode<Integer>(18);\n\t\troot.right.left.left.left = new BinaryTreeNode<Integer>(12);\n\t\troot.right.\n"
    ],
    "results": 10
},{
    "id": "1944",
    "source": "leetcode",
    "language": "java",
    "query": "The game involves two players playing a game of chess. The game is won if one of the players wins the game.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tSystem.out.println(\"Hello World\");\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tSystem.out.println(\"Hello World!\");\n\t}\n}\n",
        "\tvoid main(String[] args){\n\t\tSystem.out.println(\"Hello World\");\n\t}\n}\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic void play(){\n\t\t\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\t//Create a new chess game\n\t\tChessGame game = new ChessGame();\n\t\t//Create two players\n\t\tPlayer player1 = new Player(\"Player 1\");\n\t\tPlayer player2 = new Player(\"Player 2\");\n\t\t//Set the players in the game\n\t\tgame.setPlayers(player1, player2);\n\t\t//Start the game\n\t\tgame.start();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\t//Create two players\n\t\tPlayer player1 = new Player(\"Player 1\");\n\t\tPlayer player2 = new Player(\"Player 2\");\n\t\t//Create a chess board\n\t\tChessBoard chessBoard = new ChessBoard();\n\t\t//Create a game\n\t\tGame game = new Game(player1, player2, chessBoard);\n\t\t//Play the game\n\t\tgame.play();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1945",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.",
    "snippets": [
        "\tboolean validateStackSequences(int[] pushed, int[] popped) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\twhile (i < pushed.length) {\n\t\t\tstack.push(pushed[i]);\n\t\t\twhile (!stack.isEmpty() && stack.peek() == popped[j]) {\n\t\t\t\tstack.pop();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn j == popped.length;\n\t}\n}\n",
        "\tboolean validateStackSequences(int[] pushed, int[] popped) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint n = pushed.length;\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\twhile (i < n) {\n\t\t\tstack.push(pushed[i]);\n\t\t\twhile (!stack.isEmpty() && stack.peek() == popped[j]) {\n\t\t\t\tstack.pop();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean validateStackSequences(int[] pushed, int[] popped) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint n = pushed.length;\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\twhile (i < n) {\n\t\t\tif (stack.isEmpty() || stack.peek() != popped[j]) {\n\t\t\t\tstack.push(pushed[i]);\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tstack.pop();\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean validateStackSequence(int[] pushed, int[] popped) {\n\t\tint i = 0, j = 0;\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\twhile (i < pushed.length) {\n\t\t\tstack.push(pushed[i]);\n\t\t\twhile (!stack.isEmpty() && stack.peek() == popped[j]) {\n\t\t\t\tstack.pop();\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn j == popped.length;\n\t}\n}\n",
        "\tboolean validateStackSequence(int[] pushed, int[] popped) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint[] stack = new int[pushed.length];\n\t\tint top = -1;\n\t\twhile (i < pushed.length) {\n\t\t\tif (pushed[i] == popped[j]) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tif (top == -1) {\n\t\t\t\t\tstack[++top] = pushed[i];\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tif (stack[top] == popped[j]) {\n\t\t\t\t\t\ttop--;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn j == popped.length;\n\t}\n}\n",
        "\tboolean validateStackSequences(int[] pushed, int[] popped) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint stack = 0;\n\t\twhile (i < pushed.length) {\n\t\t\tif (pushed[i] == popped[j]) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tstack++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn stack == 0;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1946",
    "source": "leetcode",
    "language": "java",
    "query": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones) If middleIndex is 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum has the same value.",
    "snippets": [
        "\tint findMiddleIndex(int[] nums){\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(nums[mid] > nums[right]){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint minMiddleIndex(int[] nums){\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint middle = 0;\n\t\twhile(left < right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(nums[mid] > nums[right]){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint middleIndex(int[] nums){\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] > nums[right]){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint pivotIndex(int[] nums) {\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t}\n\t\tint leftSum = 0;\n\t\tint rightSum = sum;\n\t\twhile (left < right) {\n\t\t\tif (leftSum == rightSum) {\n\t\t\t\treturn left;\n\t\t\t}\n\t\t\tleftSum += nums[left];\n\t\t\trightSum -= nums[right];\n\t\t\tleft++;\n\t\t\tright--;\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint pivotIndex(int[] nums) {\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t}\n\t\tint leftSum = 0;\n\t\twhile (left < right) {\n\t\t\tif (leftSum == sum - leftSum - nums[left]) {\n\t\t\t\treturn left;\n\t\t\t}\n\t\t\tleftSum += nums[left];\n\t\t\tleft++;\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint middleIndex(int[] nums){\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint mid = 0;\n\t\twhile(left < right){\n\t\t\tmid = left + (right - left) / 2;\n\t\t\tif(nums[mid] > nums[right]){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint leftSideSum(int[] nums, int middleIndex){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < middleIndex; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic\n\tint rightSideSum(int[] nums, int middleIndex){\n\t\tint sum = 0;\n\t\tfor(int i = middleIndex + 1; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic\n\tint findMiddleIndex(int[] nums){\n\t\tint leftSum = 0;\n\t\tint rightSum = 0;\n\t\tint middleIndex = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tleftSum += nums[i];\n\t\t\trightSum += nums[nums.length - i - 1];\n\t\t\tif(leftSum == rightSum){\n\t\t\t\tmiddleIndex = i;\n\t\t\t}\n\t\t}\n\t\treturn middleIndex;\n\t}\n\tpublic\n\tint findMiddleIndex(int[] nums, int left, int right){\n\t\tif(left > right){\n\t\t\treturn -1;\n\t\t}\n\t\tint middleIndex = (left + right) / 2;\n\t\tint leftSum = leftSideSum(nums, middleIndex);\n\t\tint rightSum = rightSideSum(nums, middleIndex);\n\t\tif(leftSum == rightSum){\n\t\t\treturn middleIndex;\n\t\t}\n\t\telse if(leftSum > rightSum){\n\t\t\treturn findMiddleIndex(nums, left, middleIndex - 1);\n\t\t}\n\t\telse{\n\t\t\treturn findMiddleIndex(nums, middleIndex + 1, right);\n\t\t}\n\t}\n}\n",
        "\tint middleIndex(int[] nums){\n\t\tint left = 0, right = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(nums[mid] > nums[right]){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint pivotIndex(int[] nums) {\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t}\n\t\twhile (left <= right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tint leftSum = 0;\n\t\t\tint rightSum = 0;\n\t\t\tfor (int i = 0; i < mid; i++) {\n\t\t\t\tleftSum += nums[i];\n\t\t\t}\n\t\t\tfor (int i = mid + 1; i < nums.length; i++) {\n\t\t\t\trightSum += nums[i];\n\t\t\t}\n\t\t\tif (leftSum == rightSum) {\n\t\t\t\treturn mid;\n\t\t\t} else if (leftSum < rightSum) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint pivotIndex(int[] nums) {\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint mid = 0;\n\t\twhile(left < right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(nums[mid] > nums[right]){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\tif(nums[left] > nums[right]){\n\t\t\treturn left;\n\t\t}else{\n\t\t\treturn right;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1947",
    "source": "leetcode",
    "language": "java",
    "query": "An empty array is considered beautiful. You can delete any number of elements from nums. All elements to the right of the deleted element will be shifted one unit to the left.",
    "snippets": [
        "\tint[] beautifulArray(int N) {\n\t\tint[] res = new int[N];\n\t\tint i = 0;\n\t\twhile(N > 0){\n\t\t\tres[i++] = N;\n\t\t\tN -= N/2;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int n) {\n\t\tint[] res = new int[n];\n\t\tint index = 0;\n\t\tfor(int i = 1; i <= n; i *= 2){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tres[index++] = i + j;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int N) {\n\t\tint[] res = new int[N];\n\t\tint i = 0;\n\t\twhile(N > 0){\n\t\t\tres[i++] = N;\n\t\t\tN--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int n) {\n\t\tint[] res = new int[n];\n\t\tint index = 0;\n\t\tfor(int i = 1; i <= n; i *= 2){\n\t\t\tfor(int j = 1; j <= i; j++){\n\t\t\t\tres[index++] = j;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int n) {\n\t\tint[] res = new int[n];\n\t\tint i = 0;\n\t\twhile(n > 0){\n\t\t\tres[i++] = n;\n\t\t\tn -= n & -n;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int n) {\n\t\tint[] res = new int[n];\n\t\tint i = 0;\n\t\twhile(n > 0){\n\t\t\tres[i++] = n;\n\t\t\tn--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int N) {\n\t\tint[] res = new int[N];\n\t\tint i = 0;\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(j % 2 == 0){\n\t\t\t\tres[i] = j;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(j % 2 != 0){\n\t\t\t\tres[i] = j;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int N) {\n\t\tint[] res = new int[N];\n\t\tint i = 0;\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(j % 2 == 1){\n\t\t\t\tres[i++] = j;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tif(j % 2 == 0){\n\t\t\t\tres[i++] = j;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] beautifulArray(int n) {\n\t\tint[] res = new int[n];\n\t\tint i = 0;\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(j % 2 == 1){\n\t\t\t\tres[i] = j;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(j % 2 == 0){\n\t\t\t\tres[i] = j;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1948",
    "source": "leetcode",
    "language": "java",
    "query": "Every two consecutive vertical bars '|' are grouped into a pair. In other words, the 1st and 2nd ' |' make a pair, the 3rd and 4th '|', and so forth.",
    "snippets": [],
    "results": 0
},{
    "id": "1949",
    "source": "leetcode",
    "language": "java",
    "query": "A parentheses string is a non-empty string consisting only of '(' and ')'. It is valid if any of the following conditions is true: It is (A), where A is a valid parentheses string.",
    "snippets": [
        "\tboolean validParentheses(String s) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn count == 0;\n\t}\n}\n",
        "\tboolean validParentheses(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '(')\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tcount--;\n\t\t\tif(count < 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn count == 0;\n\t}\n}\n",
        "\tboolean validParentheses(String str) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tif (str.charAt(i) == '(') {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif (count < 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn count == 0;\n\t}\n}\n",
        "\tboolean validParentheses(String str){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\tif(str.charAt(i) == '(')\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tcount--;\n\t\t\tif(count < 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn count == 0;\n\t}\n}\n",
        "\tstatic boolean isValid(String s){\n\t\tif(s.length()==0) return false;\n\t\tif(s.length()==1) return false;\n\t\tif(s.length()==2) return false;\n\t\tif(s.length()==3) return false;\n\t\tif(s.length()==4) return false;\n\t\tif(s.length()==5) return false;\n\t\tif(s.length()==6) return false;\n\t\tif(s.length()==7) return false;\n\t\tif(s.length()==8) return false;\n\t\tif(s.length()==9) return false;\n\t\tif(s.length()==10) return false;\n\t\tif(s.length()==11) return false;\n\t\tif(s.length()==12) return false;\n\t\tif(s.length()==13) return false;\n\t\tif(s.length()==14) return false;\n\t\tif(s.length()==15) return false;\n\t\tif(s.length()==16) return false;\n\t\tif(s.length()==17) return false;\n\t\tif(s.length()==18) return false;\n\t\tif(s.length()==19) return false;\n\t\tif(s.length()==20) return false;\n\t\tif(s.length()==21) return false;\n\t\tif(s.length()==22) return false;\n\t\tif(s.length()==23) return false;\n\t\tif(s.length()==24) return false;\n\t\tif(s.length()==25) return false;\n\t\tif(s.length()==26) return false;\n\t\tif(s.length()==27) return false;\n\t\tif(s.length()==28) return false;\n\t\tif(s.length()==29) return false;\n\t\tif(s.length()==30) return false;\n\t\tif(s.length()==31) return false;\n\t\tif(s.length()==\n",
        "\tstatic boolean isValid(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn false;\n\t\t}\n\t\tint length = s.length();\n\t\tint count = 0;\n\t\tfor(int i = 0; i < length; i++){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tif(count < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn count == 0;\n\t}\n}\n",
        "\tstatic boolean isValid(String s){\n\t\tif(s.length() == 0)\n\t\t\treturn false;\n\t\tif(s.length() == 1)\n\t\t\treturn s.charAt(0) == '(' || s.charAt(0) == ')';\n\t\tif(s.charAt(0) == '(' && s.charAt(s.length()-1) == ')')\n\t\t\treturn isValid(s.substring(1, s.length()-1));\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1950",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can find indexes i + 1 < j with (arr[0] + arr[1] + ...)",
    "snippets": [
        "\tboolean canPartition(int[] arr) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tsum += arr[i];\n\t\t}\n\t\tif (sum % 2 != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / 2;\n\t\tboolean[][] dp = new boolean[arr.length][target + 1];\n\t\tdp[0][0] = true;\n\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\tdp[i][0] = true;\n\t\t\tfor (int j = 1; j <= target; j++) {\n\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\tif (j >= arr[i]) {\n\t\t\t\t\tdp[i][j] = dp[i][j] || dp[i - 1][j - arr[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[arr.length - 1][target];\n\t}\n}\n",
        "\tboolean canPartition(int[] arr) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tsum += arr[i];\n\t\t}\n\t\tif (sum % 2 != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / 2;\n\t\tboolean[][] dp = new boolean[arr.length][target + 1];\n\t\tdp[0][0] = true;\n\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\tdp[i][0] = true;\n\t\t}\n\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\tfor (int j = 1; j <= target; j++) {\n\t\t\t\tif (j >= arr[i]) {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i]];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[arr.length - 1][target];\n\t}\n}\n",
        "\tboolean canPartition(int[] arr) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tsum += arr[i];\n\t\t}\n\t\tif (sum % 2 != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / 2;\n\t\tboolean[][] dp = new boolean[arr.length][target + 1];\n\t\tdp[0][0] = true;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = 0; j <= target; j++) {\n\t\t\t\tif (j - arr[i] >= 0) {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i]];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[arr.length - 1][target];\n\t}\n}\n",
        "\tboolean canThreePartsEqualSum(int[] arr) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tsum += arr[i];\n\t\t}\n\t\tif (sum % 3 != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / 3;\n\t\tint count = 0;\n\t\tint sum2 = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tsum2 += arr[i];\n\t\t\tif (sum2 == target) {\n\t\t\t\tcount++;\n\t\t\t\tsum2 = 0;\n\t\t\t}\n\t\t}\n\t\tif (count < 3) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean canPartition(int[] arr){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tsum += arr[i];\n\t\t}\n\t\tif(sum % 3 != 0){\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / 3;\n\t\tboolean[][] dp = new boolean[arr.length][target + 1];\n\t\tdp[0][0] = true;\n\t\tfor(int i = 1; i < arr.length; i++){\n\t\t\tdp[i][0] = true;\n\t\t}\n\t\tfor(int i = 1; i < arr.length; i++){\n\t\t\tfor(int j = 1; j <= target; j++){\n\t\t\t\tif(j >= arr[i]){\n\t\t\t\t\tdp[i][j] = dp[i - 1][j] || dp[i - 1][j - arr[i]];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[arr.length - 1][target];\n\t}\n}\n",
        "\tboolean canThreePartsEqualSum(int[] arr) {\n\t\tint sum = 0;\n\t\tfor (int i : arr) {\n\t\t\tsum += i;\n\t\t}\n\t\tif (sum % 3 != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / 3;\n\t\tint count = 0;\n\t\tint sum2 = 0;\n\t\tfor (int i : arr) {\n\t\t\tsum2 += i;\n\t\t\tif (sum2 == target) {\n\t\t\t\tcount++;\n\t\t\t\tsum2 = 0;\n\t\t\t}\n\t\t}\n\t\treturn count >= 3;\n\t}\n}\n",
        "\tboolean canThreePartsEqualSum(int[] arr){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tsum += arr[i];\n\t\t}\n\t\tif(sum % 3 != 0){\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / 3;\n\t\tint cur = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tcur += arr[i];\n\t\t\tif(cur == target){\n\t\t\t\tcount++;\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t}\n\t\treturn count >= 3;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1951",
    "source": "leetcode",
    "language": "java",
    "query": "H-index is the number of citations a researcher received for their ith paper. A scientist has an index h if h of their n papers have at least h citations each.",
    "snippets": [
        "\tint hIndex(int[] citations) {\n\t\tint n = citations.length;\n\t\tint[] count = new int[n + 1];\n\t\tfor (int c : citations) {\n\t\t\tif (c > n) {\n\t\t\t\tcount[n]++;\n\t\t\t} else {\n\t\t\t\tcount[c]++;\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tsum += count[i];\n\t\t\tif (sum >= i) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint hIndex(int[] citations) {\n\t\tint n = citations.length;\n\t\tint[] count = new int[n+1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(citations[i] > n)\n\t\t\t\tcount[n]++;\n\t\t\telse\n\t\t\t\tcount[citations[i]]++;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = n; i >= 0; i--){\n\t\t\tsum += count[i];\n\t\t\tif(sum >= i)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint hIndex(int[] citations) {\n\t\tint n = citations.length;\n\t\tint[] h = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (citations[i] >= n) {\n\t\t\t\th[n]++;\n\t\t\t} else {\n\t\t\t\th[citations[i]]++;\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tsum += h[i];\n\t\t\tif (sum >= i) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint hIndex(int[] citations) {\n\t\tint n = citations.length;\n\t\tint[] buckets = new int[n + 1];\n\t\tfor (int c : citations) {\n\t\t\tif (c >= n) {\n\t\t\t\tbuckets[n]++;\n\t\t\t} else {\n\t\t\t\tbuckets[c]++;\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = n; i >= 0; i--) {\n\t\t\tsum += buckets[i];\n\t\t\tif (sum >= i) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint hIndex(int[] citations) {\n\t\tint n = citations.length;\n\t\tint[] papers = new int[n+1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(citations[i] > n) papers[n]++;\n\t\t\telse papers[citations[i]]++;\n\t\t}\n\t\tint h = 0;\n\t\tfor(int i = n; i >= 0; i--){\n\t\t\th += papers[i];\n\t\t\tif(h >= i) return i;\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint hIndex(int[] citations) {\n\t\tint len = citations.length;\n\t\tint[] count = new int[len+1];\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(citations[i]>=len){\n\t\t\t\tcount[len]++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount[citations[i]]++;\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=len;i>=0;i--){\n\t\t\tsum += count[i];\n\t\t\tif(sum>=i){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1952",
    "source": "leetcode",
    "language": "java",
    "query": "A string is a valid parentheses string (denoted VPS) if and only if it consists of \"(\" and \")\" characters only. For example, \"\", \"()()\", and \"()(()())\" are VPS's (with nesting depths 0, 1, and 2)",
    "snippets": [
        "\tboolean isValid(String s) {\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{'){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')'||c=='['&&s.charAt(i)!=']'||c=='{'&&s.charAt(i)!='}') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{'){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')') return false;\n\t\t\t\tif(c=='['&&s.charAt(i)!=']') return false;\n\t\t\t\tif(c=='{'&&s.charAt(i)!='}') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='{'||s.charAt(i)=='['){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')'||c=='{'&&s.charAt(i)!='}'||c=='['&&s.charAt(i)!=']') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='(') stack.push('(');\n\t\t\telse if(s.charAt(i)==')'){\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s){\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='(') stack.push(')');\n\t\t\telse if(s.charAt(i)=='[') stack.push(']');\n\t\t\telse if(s.charAt(i)=='{') stack.push('}');\n\t\t\telse if(stack.isEmpty()||stack.pop()!=s.charAt(i)) return false;\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s){\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='(') stack.push(s.charAt(i));\n\t\t\telse if(s.charAt(i)==')'){\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\telse stack.pop();\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tstatic boolean isValid(String s){\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack=new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='{'||s.charAt(i)=='['){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c=stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')') return false;\n\t\t\t\tif(c=='{'&&s.charAt(i)!='}') return false;\n\t\t\t\tif(c=='['&&s.charAt(i)!=']') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s==null||s.length()==0) return true;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='(') stack.push('(');\n\t\t\telse if(s.charAt(i)==')'){\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s.length() == 0) return true;\n\t\tif(s.length() % 2 != 0) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '(') stack.push('(');\n\t\t\telse if(s.charAt(i) == ')'){\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2!=0) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='{'||s.charAt(i)=='['){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')'||c=='{'&&s.charAt(i)!='}'||c=='['&&s.charAt(i)!=']') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1953",
    "source": "leetcode",
    "language": "java",
    "query": "You are playing a video game where you are defending your city from a group of n monsters. The speed of each monster is given to you in an integer array speed of size n. You have a weapon that, once fully charged, can eliminate a single monster.",
    "snippets": [
        "\tstatic int[] solution(int[] speed){\n\t\tint[] answer = new int[speed.length];\n\t\tint[] temp = new int[speed.length];\n\t\tint[] temp2 = new int[speed.length];\n\t\tint[] temp3 = new int[speed.length];\n\t\tint[] temp4 = new int[speed.length];\n\t\tint[] temp5 = new int[speed.length];\n\t\tint[] temp6 = new int[speed.length];\n\t\tint[] temp7 = new int[speed.length];\n\t\tint[] temp8 = new int[speed.length];\n\t\tint[] temp9 = new int[speed.length];\n\t\tint[] temp10 = new int[speed.length];\n\t\tint[] temp11 = new int[speed.length];\n\t\tint[] temp12 = new int[speed.length];\n\t\tint[] temp13 = new int[speed.length];\n\t\tint[] temp14 = new int[speed.length];\n\t\tint[] temp15 = new int[speed.length];\n\t\tint[] temp16 = new int[speed.length];\n\t\tint[] temp17 = new int[speed.length];\n\t\tint[] temp18 = new int[speed.length];\n\t\tint[] temp19 = new int[speed.length];\n\t\tint[] temp20 = new int[speed.length];\n\t\tint[] temp21 = new int[speed.length];\n\t\tint[] temp22 = new int[speed.length];\n\t\tint[] temp23 = new int[speed.length];\n\t\tint[] temp24 = new int[speed.length];\n\t\tint[] temp25 = new int[speed.length];\n\t\tint[] temp26 = new int[speed.length];\n\t\tint[] temp27 = new int[speed.length];\n\t\tint[] temp28 = new int[speed.length];\n\t\tint[] temp29 = new int[speed.length];\n\t\tint[] temp30 = new int[speed.length];\n\t\tint[] temp31 = new int[speed.length];\n\t\tint[] temp32 = new int[\n",
        "\tstatic int[] solution(int[] speed){\n\t\tint[] answer = new int[speed.length];\n\t\tint[] temp = new int[speed.length];\n\t\tint max = 0;\n\t\tint maxIndex = 0;\n\t\tfor(int i = 0; i < speed.length; i++){\n\t\t\ttemp[i] = speed[i];\n\t\t\tif(temp[i] > max){\n\t\t\t\tmax = temp[i];\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\tanswer[0] = maxIndex;\n\t\ttemp[maxIndex] = 0;\n\t\tfor(int i = 1; i < speed.length; i++){\n\t\t\tmax = 0;\n\t\t\tmaxIndex = 0;\n\t\t\tfor(int j = 0; j < speed.length; j++){\n\t\t\t\tif(temp[j] > max){\n\t\t\t\t\tmax = temp[j];\n\t\t\t\t\tmaxIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tanswer[i] = maxIndex;\n\t\t\ttemp[maxIndex] = 0;\n\t\t}\n\t\treturn answer;\n\t}\n}\n",
        "\tint[] solution(int[] speed){\n\t\tint[] answer = new int[speed.length];\n\t\tint max = 0;\n\t\tint maxIndex = 0;\n\t\tfor(int i = 0; i < speed.length; i++){\n\t\t\tif(speed[i] > max){\n\t\t\t\tmax = speed[i];\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\tanswer[maxIndex] = 1;\n\t\tfor(int i = 0; i < speed.length; i++){\n\t\t\tif(i != maxIndex){\n\t\t\t\tanswer[i] = max - speed[i];\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}\n",
        "\tstatic int[] solution(int[] speed){\n\t\tint[] answer = new int[speed.length];\n\t\tint[] temp = new int[speed.length];\n\t\tfor(int i=0; i<speed.length; i++){\n\t\t\ttemp[i] = speed[i];\n\t\t}\n\t\tfor(int i=0; i<speed.length; i++){\n\t\t\tint min = temp[0];\n\t\t\tint minIndex = 0;\n\t\t\tfor(int j=0; j<temp.length; j++){\n\t\t\t\tif(temp[j]<min){\n\t\t\t\t\tmin = temp[j];\n\t\t\t\t\tminIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tanswer[i] = minIndex;\n\t\t\ttemp[minIndex] = Integer.MAX_VALUE;\n\t\t}\n\t\treturn answer;\n\t}\n}\n",
        "\tint[]\n\tkillMonsters(int[] speed) {\n\t\tint[] result = new int[speed.length];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint aa = 0;\n\t\tint bb = 0;\n\t\tint cc = 0;\n\t\tint dd = 0;\n\t\tint ee = 0;\n\t\tint ff = 0;\n\t\tint gg = 0;\n\t\tint hh = 0;\n\t\tint ii = 0;\n\t\tint jj = 0;\n\t\tint kk = 0;\n\t\tint ll = 0;\n\t\tint mm = 0;\n\t\tint nn = 0;\n\t\tint oo = 0;\n\t\tint pp = 0;\n\t\tint qq = 0;\n\t\tint rr = 0;\n\t\tint ss = 0;\n\t\tint tt = 0;\n\t\tint uu = 0;\n\t\tint vv = 0;\n\t\tint ww = 0;\n\t\tint xx = 0;\n\t\tint yy = 0;\n\t\tint zz = 0;\n\t\tint aaa = 0;\n\t\tint bbb = 0;\n\t\tint ccc = 0;\n\t\tint ddd = 0;\n\t\tint eee = 0;\n\t\tint fff = 0;\n\t\tint ggg = 0;\n\t\tint hhh = 0;\n\t\tint iii = 0;\n\t\tint jjj = 0;\n",
        "\tint maxKills(int[] speed) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < speed.length; i++){\n\t\t\tsum += speed[i];\n\t\t\tif(sum > max) max = sum;\n\t\t\tif(sum < 0) sum = 0;\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int[] solution(int[] speed){\n\t\tint[] answer = new int[speed.length];\n\t\tint[] speed_copy = new int[speed.length];\n\t\tfor(int i=0;i<speed.length;i++){\n\t\t\tspeed_copy[i] = speed[i];\n\t\t}\n\t\tArrays.sort(speed_copy);\n\t\tfor(int i=0;i<speed.length;i++){\n\t\t\tanswer[i] = Arrays.binarySearch(speed_copy, speed[i]);\n\t\t}\n\t\treturn answer;\n\t}\n}\n"
    ],
    "results": 9
},{
    "id": "1954",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed m x n integer matrix grid. You can move in this matrix from a cell to any other cell in the next row. Note that it is not possible to move from cells in the last row.",
    "snippets": [
        "\tint minPathSum(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n",
        "\tint minMoves(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tif(count == 1){\n\t\t\treturn 1;\n\t\t}\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tsum += dp[i][j];\n\t\t\t}\n\t\t\tmin = Math.min(min, sum);\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minMoves(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tint[] dp = new int[count];\n\t\tdp[0] = 0;\n\t\tfor(int i = 1; i < count; i++){\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp[count - 1];\n\t}\n}\n",
        "\tint minMoves(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tif(count == 1){\n\t\t\treturn 1;\n\t\t}\n\t\tint[] dp = new int[count];\n\t\tdp[0] = 0;\n\t\tdp[1] = 1;\n\t\tfor(int i = 2; i < count; i++){\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + dp[i - j - 1]);\n\t\t\t}\n\t\t}\n\t\treturn dp[count - 1];\n\t}\n}\n",
        "\tint minMoves(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tif(count == 1){\n\t\t\treturn 1;\n\t\t}\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tmin = Math.min(min, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minMoves(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tif(count == 1){\n\t\t\treturn 1;\n\t\t}\n\t\tint[] dp = new int[count];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor(int i = 2; i < count; i++){\n\t\t\tdp[i] = dp[i-1] + dp[i-2];\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tint temp = 0;\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\ttemp = dp[count-1];\n\t\t\t\t\t}\n\t\t\t\t\telse if(i == 1){\n\t\t\t\t\t\ttemp = dp[count-2];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ttemp = dp[count-3];\n\t\t\t\t\t}\n\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\ttemp += dp[count-1];\n\t\t\t\t\t}\n\t\t\t\t\telse if(j == 1){\n\t\t\t\t\t\ttemp += dp[count-2];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ttemp\n",
        "\tint[][] move(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] res = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0){\n\t\t\t\t\tres[i][j] = grid[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tres[i][j] = grid[i][j] + res[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minMoves(int[] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[count + 1];\n\t\tdp[0] = 0;\n\t\tfor(int i = 1; i <= count; i++){\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i - 1][j] == 1){\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - 1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[count];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid2 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid3 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid4 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid5 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid6 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid7 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid8 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid9 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid10 = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] grid11 = {{1,1,1,1},{1\n",
        "\tint minMoves(int[][] grid) {\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = sum;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tfor(int l = 0; l < n; l++){\n\t\t\t\t\t\t\tif(grid[k][l] == 1){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmin = Math.min(min, count - sum);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1955",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.",
    "snippets": [
        "\tint[] findRedundantDirectedConnection(int[][] edges) {\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tint[] ans = new int[2];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t} else {\n\t\t\t\tans[0] = u;\n\t\t\t\tans[1] = v;\n\t\t\t\tedges[i][1] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (v == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint pu = find(parent, u);\n\t\t\tint pv = find(parent, v);\n\t\t\tif (pu == pv) {\n\t\t\t\tans[0] = u;\n\t\t\t\tans[1] = v;\n\t\t\t\tedges[i][1] = 0;\n\t\t\t} else {\n\t\t\t\tif (size[pu] < size[pv]) {\n\t\t\t\t\tparent[pu] = pv;\n\t\t\t\t\tsize[pv] += size[pu];\n\t\t\t\t} else {\n\t\t\t\t\tparent[pv] = pu;\n\t\t\t\t\tsize[pu] += size[pv];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int find(int[] parent, int x) {\n\t\tif (parent[x] != x) {\n\t\t\tparent[x\n",
        "\tint[] findRedundantDirectedConnection(int[][] edges) {\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tint[] ans = new int[2];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t}\n\t\t\tif (parent[u] == 0) {\n\t\t\t\tparent[u] = u;\n\t\t\t\tsize[u] = 1;\n\t\t\t}\n\t\t\tif (find(parent, u) == find(parent, v)) {\n\t\t\t\tans[0] = u;\n\t\t\t\tans[1] = v;\n\t\t\t\tedges[i][2] = 0;\n\t\t\t} else {\n\t\t\t\tif (size[find(parent, u)] > size[find(parent, v)]) {\n\t\t\t\t\tans[0] = v;\n\t\t\t\t\tans[1] = u;\n\t\t\t\t\tedges[i][2] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tans[0] = u;\n\t\t\t\t\tans[1] = v;\n\t\t\t\t\tedges[i][2] = 1;\n\t\t\t\t}\n\t\t\t\tunion(parent, size, find(parent, u), find(parent, v));\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tif (edges[i][2] == 1) {\n\t\t\t\treturn edges[i];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int find(int[] parent, int x) {\n\t\tif\n",
        "\tint[] findRedundantDirectedConnection(int[][] edges) {\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t}\n\t\t\tif (parent[u] == 0) {\n\t\t\t\tparent[u] = u;\n\t\t\t\tsize[u] = 1;\n\t\t\t}\n\t\t\tif (find(parent, u) == find(parent, v)) {\n\t\t\t\treturn new int[] { u, v };\n\t\t\t} else {\n\t\t\t\tif (size[u] + size[v] > edges.length) {\n\t\t\t\t\treturn new int[] { u, v };\n\t\t\t\t} else {\n\t\t\t\t\tunion(parent, size, u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[] { -1, -1 };\n\t}\n\tpublic int find(int[] parent, int x) {\n\t\tif (parent[x] != x) {\n\t\t\tparent[x] = find(parent, parent[x]);\n\t\t}\n\t\treturn parent[x];\n\t}\n\tpublic void union(int[] parent, int[] size, int x, int y) {\n\t\tint rootX = find(parent, x);\n\t\tint rootY = find(parent, y);\n\t\tif (rootX != rootY) {\n\t\t\tif (size[rootX] < size[rootY]) {\n\t\t\t\tparent[rootX] = rootY;\n\t\t\t\tsize[rootY] += size[rootX];\n\t\t\t} else {\n\t\t\t\tparent[rootY\n",
        "\tint[] findRedundantDirectedConnection(int[][] edges) {\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tint[] ans = new int[2];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t} else {\n\t\t\t\tans[0] = u;\n\t\t\t\tans[1] = v;\n\t\t\t\tedges[i][2] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (edges[i][2] == 1) {\n\t\t\t\tif (find(parent, u) == find(parent, v)) {\n\t\t\t\t\treturn edges[i];\n\t\t\t\t} else {\n\t\t\t\t\tunion(parent, size, u, v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int find(int[] parent, int x) {\n\t\tif (parent[x] != x) {\n\t\t\tparent[x] = find(parent, parent[x]);\n\t\t}\n\t\treturn parent[x];\n\t}\n\tpublic void union(int[] parent, int[] size, int x, int y) {\n\t\tint rootX = find(parent, x);\n\t\tint rootY = find(parent, y);\n\t\tif (rootX != rootY) {\n\t\t\tif (size[rootX] < size[rootY]) {\n\t\t\t\tparent[rootX] = rootY;\n",
        "\tint[] findRedundantDirectedConnection(int[] edges) {\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tint[] res = new int[2];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t}\n\t\t\tif (parent[u] == 0) {\n\t\t\t\tparent[u] = u;\n\t\t\t\tsize[u] = 1;\n\t\t\t}\n\t\t\tif (find(parent, u) == find(parent, v)) {\n\t\t\t\tres[0] = u;\n\t\t\t\tres[1] = v;\n\t\t\t\tedges[i][2] = 1;\n\t\t\t} else {\n\t\t\t\tedges[i][2] = 0;\n\t\t\t\tif (size[find(parent, u)] > size[find(parent, v)]) {\n\t\t\t\t\tres[0] = u;\n\t\t\t\t\tres[1] = v;\n\t\t\t\t} else {\n\t\t\t\t\tres[0] = v;\n\t\t\t\t\tres[1] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunion(parent, size, u, v);\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tif (edges[i][2] == 0) {\n\t\t\t\treturn edges[i];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic int find(int[] parent, int x) {\n\t\tif (parent[x] != x) {\n\t\t\tparent[x] = find(parent, parent[x]);\n",
        "\tint[] findRedundantDirectedConnection(int[] edges) {\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tint[] ans = new int[2];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t}\n\t\t\tif (parent[u] == 0) {\n\t\t\t\tparent[u] = u;\n\t\t\t\tsize[u] = 1;\n\t\t\t}\n\t\t\tif (find(parent, u) == find(parent, v)) {\n\t\t\t\tans[0] = u;\n\t\t\t\tans[1] = v;\n\t\t\t\tedges[i][2] = 1;\n\t\t\t} else {\n\t\t\t\tsize[find(parent, v)] += size[find(parent, u)];\n\t\t\t\tparent[find(parent, u)] = find(parent, v);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tif (edges[i][2] == 0) {\n\t\t\t\tif (size[find(parent, edges[i][1])] > edges.length / 2) {\n\t\t\t\t\treturn edges[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int find(int[] parent, int i) {\n\t\tif (parent[i] != i) {\n\t\t\tparent[i] = find(parent, parent[i]);\n\t\t}\n\t\treturn parent[i];\n\t}\n}\n",
        "\tint[] findRedundantDirectedConnection(int[] edges) {\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tint[] ans = new int[2];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t}\n\t\t\tif (parent[u] == 0) {\n\t\t\t\tparent[u] = u;\n\t\t\t\tsize[u] = 1;\n\t\t\t}\n\t\t\tif (find(parent, u) == find(parent, v)) {\n\t\t\t\tans[0] = u;\n\t\t\t\tans[1] = v;\n\t\t\t\tedges[i][2] = 0;\n\t\t\t} else {\n\t\t\t\tif (size[u] + size[v] > edges.length) {\n\t\t\t\t\tans[0] = u;\n\t\t\t\t\tans[1] = v;\n\t\t\t\t\tedges[i][2] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tsize[u] += size[v];\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tif (edges[i][2] == 1) {\n\t\t\t\treturn edges[i];\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic int find(int[] parent, int x) {\n\t\tif (parent[x] != x) {\n\t\t\tparent[x] = find(parent, parent[x]);\n\t\t}\n\t\treturn parent[x];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[][] edges = {{0, 1, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}};\n\t\tint[][] edges2 = {{0, 1, 1}, {0, 2, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}};\n\t\tint[][] edges3 = {{0, 1, 1}, {0, 2, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}, {4, 0, 1}};\n\t\tint[][] edges4 = {{0, 1, 1}, {0, 2, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}, {4, 0, 1}, {0, 5, 1}, {5, 1, 1}};\n\t\tint[][] edges5 = {{0, 1, 1}, {0, 2, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}, {4, 0, 1}, {0, 5, 1}, {5, 1, 1}, {0, 6, 1}, {6, 2, 1}};\n\t\tint[][] edges6 = {{0, 1, 1}, {0, 2, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}, {4, 0, 1}, {0, 5, 1}, {5, 1, 1}, {0, 6, 1}, {6, 2, 1}, {0, 7, 1}, {7, 3, 1}};\n\t\tint[][] edges7 = {{0, 1, 1}, {0, 2, 1}, {1, 2, 1}, {2, 3, 1}, {3, 4, 1}, {4, 0, 1}, {0, 5, 1}, {5, 1, 1}, {0, 6, 1}, {6, 2, 1}, {0, 7, 1}, {7, 3, 1}, {3, 8, 1}, {\n",
        "\tint[] findRedundantDirectedConnection(int[][] edges) {\n\t\tint[] res = new int[2];\n\t\tint[] parent = new int[edges.length + 1];\n\t\tint[] size = new int[edges.length + 1];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tif (parent[v] == 0) {\n\t\t\t\tparent[v] = v;\n\t\t\t\tsize[v] = 1;\n\t\t\t}\n\t\t\tif (parent[u] == 0) {\n\t\t\t\tparent[u] = u;\n\t\t\t\tsize[u] = 1;\n\t\t\t}\n\t\t\tif (find(parent, u) == find(parent, v)) {\n\t\t\t\tres[0] = u;\n\t\t\t\tres[1] = v;\n\t\t\t\tedges[i][2] = 0;\n\t\t\t} else {\n\t\t\t\tif (size[u] + size[v] > edges.length) {\n\t\t\t\t\tres[0] = u;\n\t\t\t\t\tres[1] = v;\n\t\t\t\t\tedges[i][2] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tsize[find(parent, u)] += size[find(parent, v)];\n\t\t\t\t\tparent[find(parent, v)] = find(parent, u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tif (edges[i][2] == 1) {\n\t\t\t\tres[0] = edges[i][0];\n\t\t\t\tres[1] = edges[i][1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic int find(int[] parent, int x) {\n\t\tif (parent\n",
        "\tint[] findRedundantDirectedConnection(int[][] edges) {\n\t\tint[] res = new int[2];\n\t\tint[] parent = new int[edges.length];\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tint x = edges[i][0];\n\t\t\tint y = edges[i][1];\n\t\t\tif(parent[y] == y){\n\t\t\t\tres[0] = x;\n\t\t\t\tres[1] = y;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tparent[y] = x;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tint x = edges[i][0];\n\t\t\tint y = edges[i][1];\n\t\t\tif(parent[y] == y){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint p = find(parent, y);\n\t\t\t\tif(p == x){\n\t\t\t\t\tres[0] = x;\n\t\t\t\t\tres[1] = y;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tres[0] = p;\n\t\t\t\t\tres[1] = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic int find(int[] parent, int x){\n\t\tif(parent[x] == x){\n\t\t\treturn x;\n\t\t}\n\t\telse{\n\t\t\treturn find(parent, parent[x]);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1956",
    "source": "leetcode",
    "language": "java",
    "query": "The number of unique characters in the substring must be less than or equal to maxLetters. The substring size must be between minSize and maxSize inclusive.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString s = \"abcd\";\n\t\tint maxLetters = 2;\n\t\tint minSize = 2;\n\t\tint maxSize = 3;\n\t\tSystem.out.println(findSubstring(s, maxLetters, minSize, maxSize));\n\t}\n\tpublic static List<String> findSubstring(String s, int maxLetters, int minSize, int maxSize){\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s == null || s.length() == 0 || maxLetters < 0 || minSize < 0 || maxSize < 0 || minSize > maxSize){\n\t\t\treturn res;\n\t\t}\n\t\tint len = s.length();\n\t\tint[] letters = new int[26];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tletters[s.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < len - minSize + 1; i++){\n\t\t\tint start = i;\n\t\t\tint end = i + minSize - 1;\n\t\t\tint[] currLetters = new int[26];\n\t\t\tfor(int j = start; j <= end; j++){\n\t\t\t\tcurrLetters[s.charAt(j) - 'a']++;\n\t\t\t}\n\t\t\twhile(end < len && isValid(currLetters, letters, maxLetters)){\n\t\t\t\tend++;\n\t\t\t\tif(end - start + 1 >= minSize && end - start + 1 <= maxSize){\n\t\t\t\t\tres.add(s.substring(start, end));\n\t\t\t\t}\n\t\t\t\tcurrLetters[s.charAt(start) - 'a']--;\n\t\t\t\tcurrLetters[s.charAt(end) - 'a']++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static boolean isValid(int[] currLetters, int[] letters,\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"abcd\";\n\t\tint maxLetters = 2;\n\t\tint minSize = 2;\n\t\tint maxSize = 3;\n\t\tSystem.out.println(findSubstring(s, maxLetters, minSize, maxSize));\n\t}\n\tpublic static List<String> findSubstring(String s, int maxLetters, int minSize, int maxSize){\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s == null || s.length() == 0 || maxLetters < 0 || minSize < 0 || maxSize < 0 || minSize > maxSize){\n\t\t\treturn res;\n\t\t}\n\t\tint len = s.length();\n\t\tint[] letters = new int[26];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tletters[s.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < len - minSize + 1; i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tletters[j] = Math.max(0, letters[j] - 1);\n\t\t\t}\n\t\t\tfor(int j = i; j < i + minSize; j++){\n\t\t\t\tletters[s.charAt(j) - 'a']++;\n\t\t\t}\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(letters[j] > 0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count <= maxLetters){\n\t\t\t\tres.add(s.substring(i, i + minSize));\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"abcd\";\n\t\tint maxLetters = 2;\n\t\tint minSize = 2;\n\t\tint maxSize = 3;\n\t\tSystem.out.println(findSubstring(s, maxLetters, minSize, maxSize));\n\t}\n\tpublic static List<String> findSubstring(String s, int maxLetters, int minSize, int maxSize){\n\t\tList<String> result = new ArrayList<String>();\n\t\tif(s == null || s.length() == 0 || maxLetters < 0 || minSize < 0 || maxSize < 0 || minSize > maxSize){\n\t\t\treturn result;\n\t\t}\n\t\tMap<Character, Integer> map = new HashMap<Character, Integer>();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(map.containsKey(c)){\n\t\t\t\tmap.put(c, map.get(c) + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap.put(c, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < s.length() - minSize + 1; i++){\n\t\t\tMap<Character, Integer> temp = new HashMap<Character, Integer>(map);\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j < i + maxSize; j++){\n\t\t\t\tchar c = s.charAt(j);\n\t\t\t\tif(temp.containsKey(c)){\n\t\t\t\t\ttemp.put(c, temp.get(c) - 1);\n\t\t\t\t\tif(temp.get(c) == 0){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == maxLetters){\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"abcd\";\n\t\tint maxLetters = 2;\n\t\tint minSize = 3;\n\t\tint maxSize = 4;\n\t\tSystem.out.println(new Clazz().solve(s, maxLetters, minSize, maxSize));\n\t}\n\tpublic int solve(String s, int maxLetters, int minSize, int maxSize){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length() - minSize + 1; i++){\n\t\t\tint[] letters = new int[26];\n\t\t\tfor(int j = i; j < i + minSize; j++){\n\t\t\t\tletters[s.charAt(j) - 'a']++;\n\t\t\t}\n\t\t\tint unique = 0;\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(letters[j] > 0){\n\t\t\t\t\tunique++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(unique <= maxLetters){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"abcd\";\n\t\tint maxLetters = 2;\n\t\tint minSize = 3;\n\t\tint maxSize = 4;\n\t\tSystem.out.println(findSubstring(s, maxLetters, minSize, maxSize));\n\t}\n\tpublic static List<String> findSubstring(String s, int maxLetters, int minSize, int maxSize){\n\t\tList<String> result = new ArrayList<String>();\n\t\tif(s == null || s.length() == 0 || maxLetters < 0 || minSize < 0 || maxSize < 0 || minSize > maxSize){\n\t\t\treturn result;\n\t\t}\n\t\tint len = s.length();\n\t\tint[] letters = new int[26];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tletters[s.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < len - minSize + 1; i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tletters[j] = Math.max(0, letters[j] - 1);\n\t\t\t}\n\t\t\tfor(int j = i; j < i + minSize; j++){\n\t\t\t\tletters[s.charAt(j) - 'a']++;\n\t\t\t}\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(letters[j] > 0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count <= maxLetters){\n\t\t\t\tresult.add(s.substring(i, i + minSize));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabccbb\";\n\t\tint maxLetters = 2;\n\t\tint minSize = 3;\n\t\tint maxSize = 5;\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(maxLetters);\n\t\tSystem.out.println(minSize);\n\t\tSystem.out.println(maxSize);\n\t\tSystem.out.println(new Clazz().solve(s, maxLetters, minSize, maxSize));\n\t}\n\tpublic int solve(String s, int maxLetters, int minSize, int maxSize){\n\t\tint count = 0;\n\t\tint[] letters = new int[26];\n\t\tint[] size = new int[s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tletters[s.charAt(i) - 'a']++;\n\t\t\tsize[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i + 1; j < s.length(); j++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int k = i; k <= j; k++){\n\t\t\t\t\tsum += letters[s.charAt(k) - 'a'];\n\t\t\t\t}\n\t\t\t\tif(sum <= maxLetters && size[j] - size[i] >= minSize && size[j] - size[i] <= maxSize){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int maxFreq(String s, int minSize, int maxSize, int maxLetters){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length() - minSize + 1; i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; j < maxSize; j++){\n\t\t\t\tif(s.charAt(i + j) == 'a'){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count <= maxLetters){\n\t\t\t\tmax = Math.max(max, count);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxFreq(String s, int minSize, int maxSize, int maxLetters){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length() - maxSize + 1; i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j = i; j < i + maxSize; j++){\n\t\t\t\tif(s.charAt(j) == 'a'){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count <= maxLetters && count > max){\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxFreq(String s, int minSize, int maxSize, int maxLetters){\n\t\tint max = 0;\n\t\tint[] freq = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tint index = s.charAt(i) - 'a';\n\t\t\tfreq[index]++;\n\t\t\tif(i >= minSize && i <= maxSize){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\t\tif(freq[j] > 0)\n\t\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tif(count <= maxLetters)\n\t\t\t\t\tmax = Math.max(max, i);\n\t\t\t}\n\t\t\tif(i >= maxSize){\n\t\t\t\tint index2 = s.charAt(i - maxSize) - 'a';\n\t\t\t\tfreq[index2]--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic String[] findSubstrings(String s, int maxLetters, int minSize, int maxSize) {\n\t\tint n = s.length();\n\t\tint[] count = new int[26];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t}\n\t\tList<String> list = new ArrayList<>();\n\t\tfor (int i = 0; i < n - minSize + 1; i++) {\n\t\t\tint j = i;\n\t\t\tint k = 0;\n\t\t\twhile (j < n && k < 26) {\n\t\t\t\tif (count[s.charAt(j) - 'a'] > 0) {\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tcount[s.charAt(j) - 'a']--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (k <= maxLetters) {\n\t\t\t\tlist.add(s.substring(i, j));\n\t\t\t}\n\t\t\tj = i;\n\t\t\twhile (j < n) {\n\t\t\t\tcount[s.charAt(j) - 'a']++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new String[list.size()]);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1957",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. LCA is defined as the lowest node in T that has both p and q as descendants.",
    "snippets": [
        "\tTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\tif(root == null) return null;\n\t\tif(root == p || root == q) return root;\n\t\tTreeNode left = lowestCommonAncestor(root.left, p, q);\n\t\tTreeNode right = lowestCommonAncestor(root.right, p, q);\n\t\tif(left != null && right != null) return root;\n\t\treturn left == null ? right : left;\n\t}\n}\n",
        "\tTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\tif(root == null) return null;\n\t\tif(root == p || root == q) return root;\n\t\tTreeNode left = lowestCommonAncestor(root.left, p, q);\n\t\tTreeNode right = lowestCommonAncestor(root.right, p, q);\n\t\tif(left != null && right != null) return root;\n\t\treturn left != null ? left : right;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1958",
    "source": "leetcode",
    "language": "java",
    "query": "The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
    "snippets": [
        "\tboolean exist(char[][] board, String word) {\n\t\tif(board == null || board.length == 0 || board[0].length == 0)\n\t\t\treturn false;\n\t\tint m = board.length;\n\t\tint n = board[0].length;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(exist(board, word, i, j, 0))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic boolean exist(char[][] board, String word, int i, int j, int k){\n\t\tif(k == word.length())\n\t\t\treturn true;\n\t\tif(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k))\n\t\t\treturn false;\n\t\tchar temp = board[i][j];\n\t\tboard[i][j] = '#';\n\t\tboolean res = exist(board, word, i + 1, j, k + 1) || exist(board, word, i - 1, j, k + 1) || exist(board, word, i, j + 1, k + 1) || exist(board, word, i, j - 1, k + 1);\n\t\tboard[i][j] = temp;\n\t\treturn res;\n\t}\n}\n",
        "\tboolean exist(char[][] board, String word) {\n\t\tif(board == null || board.length == 0 || board[0].length == 0)\n\t\t\treturn false;\n\t\tint m = board.length;\n\t\tint n = board[0].length;\n\t\tboolean[][] visited = new boolean[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(dfs(board, word, i, j, 0, visited))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean dfs(char[][] board, String word, int i, int j, int index, boolean[][] visited){\n\t\tif(index == word.length())\n\t\t\treturn true;\n\t\tif(i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index))\n\t\t\treturn false;\n\t\tvisited[i][j] = true;\n\t\tboolean res = dfs(board, word, i + 1, j, index + 1, visited) || dfs(board, word, i - 1, j, index + 1, visited) || dfs(board, word, i, j + 1, index + 1, visited) || dfs(board, word, i, j - 1, index + 1, visited);\n\t\tvisited[i][j] = false;\n\t\treturn res;\n\t}\n}\n",
        "\tboolean exist(char[][] board, String word) {\n\t\tif(board == null || board.length == 0 || board[0].length == 0)\n\t\t\treturn false;\n\t\tint m = board.length;\n\t\tint n = board[0].length;\n\t\tboolean[][] visited = new boolean[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(dfs(board, i, j, word, 0, visited))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic\n\tboolean dfs(char[][] board, int i, int j, String word, int index, boolean[][] visited){\n\t\tif(index == word.length())\n\t\t\treturn true;\n\t\tif(i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index))\n\t\t\treturn false;\n\t\tvisited[i][j] = true;\n\t\tboolean res = dfs(board, i + 1, j, word, index + 1, visited) || dfs(board, i - 1, j, word, index + 1, visited) || dfs(board, i, j + 1, word, index + 1, visited) || dfs(board, i, j - 1, word, index + 1, visited);\n\t\tvisited[i][j] = false;\n\t\treturn res;\n\t}\n}\n",
        "\tboolean exist(char[][] board, String word) {\n\t\tif(board == null || board.length == 0 || board[0].length == 0)\n\t\t\treturn false;\n\t\tint m = board.length;\n\t\tint n = board[0].length;\n\t\tboolean[][] visited = new boolean[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(dfs(board, word, 0, i, j, visited))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited){\n\t\tif(index == word.length())\n\t\t\treturn true;\n\t\tif(i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index))\n\t\t\treturn false;\n\t\tvisited[i][j] = true;\n\t\tboolean res = dfs(board, word, index + 1, i + 1, j, visited) || dfs(board, word, index + 1, i - 1, j, visited) || dfs(board, word, index + 1, i, j + 1, visited) || dfs(board, word, index + 1, i, j - 1, visited);\n\t\tvisited[i][j] = false;\n\t\treturn res;\n\t}\n}\n",
        "\tstatic boolean exist(char[][] board, String word) {\n\t\tif(board == null || board.length == 0 || board[0].length == 0) return false;\n\t\tif(word == null || word.length() == 0) return false;\n\t\tint m = board.length;\n\t\tint n = board[0].length;\n\t\tboolean[][] visited = new boolean[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(dfs(board, i, j, word, 0, visited)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean dfs(char[][] board, int i, int j, String word, int index, boolean[][] visited){\n\t\tif(index == word.length()) return true;\n\t\tif(i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) return false;\n\t\tvisited[i][j] = true;\n\t\tif(dfs(board, i + 1, j, word, index + 1, visited) || dfs(board, i - 1, j, word, index + 1, visited) || dfs(board, i, j + 1, word, index + 1, visited) || dfs(board, i, j - 1, word, index + 1, visited)) return true;\n\t\tvisited[i][j] = false;\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean exist(char[][] board, String word) {\n\t\tif(word == null || word.length() == 0) return true;\n\t\tif(board == null || board.length == 0 || board[0].length == 0) return false;\n\t\tint m = board.length;\n\t\tint n = board[0].length;\n\t\tboolean[][] visited = new boolean[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(dfs(board, word, 0, i, j, visited)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited){\n\t\tif(index == word.length()) return true;\n\t\tif(i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) return false;\n\t\tvisited[i][j] = true;\n\t\tif(dfs(board, word, index + 1, i + 1, j, visited) || dfs(board, word, index + 1, i - 1, j, visited) || dfs(board, word, index + 1, i, j + 1, visited) || dfs(board, word, index + 1, i, j - 1, visited)) return true;\n\t\tvisited[i][j] = false;\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isValid(String[] board, int row, int col){\n\t\tif(board[row][col] == '.') return true;\n\t\tfor(int i = 0; i < 9; i++){\n\t\t\tif(board[row][i] == board[row][col]) return false;\n\t\t\tif(board[i][col] == board[row][col]) return false;\n\t\t}\n\t\tint r = row / 3 * 3;\n\t\tint c = col / 3 * 3;\n\t\tfor(int i = r; i < r + 3; i++){\n\t\t\tfor(int j = c; j < c + 3; j++){\n\t\t\t\tif(board[i][j] == board[row][col]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic\n\tstatic boolean solve(String[] board, int row, int col){\n\t\tif(row == 9){\n\t\t\treturn true;\n\t\t}\n\t\tif(col == 9){\n\t\t\treturn solve(board, row + 1, 0);\n\t\t}\n\t\tif(board[row][col] != '.'){\n\t\t\treturn solve(board, row, col + 1);\n\t\t}\n\t\tfor(char c = '1'; c <= '9'; c++){\n\t\t\tboard[row][col] = c;\n\t\t\tif(isValid(board, row, col) && solve(board, row, col + 1)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tboard[row][col] = '.';\n\t\treturn false;\n\t}\n\tpublic\n\tstatic void solveSudoku(String[] board){\n\t\tsolve(board, 0, 0);\n\t}\n\tpublic\n\tstatic void main(String[] args){\n\t\tString[] board = {\"..9748...\", \"7........\", \"........6\", \"8........\", \"4....7...\", \".........\", \".........\", \".........\", \".........\"};\n\t\tsolveSudoku(\n"
    ],
    "results": 10
},{
    "id": "1959",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a string s consisting only of characters 'a' and 'b' You can delete any number of characters in s to make s balanced.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString s = \"aabb\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(delete(s));\n\t}\n\tpublic static String delete(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tint i = 0;\n\t\t\twhile(count != 0){\n\t\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn s.substring(0, i) + s.substring(i + 1);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabb\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0, s.length()-1));\n\t\tSystem.out.println(s.substring(0, s.length()-2));\n\t\tSystem.out.println(s.substring(0, s.length()-3));\n\t\tSystem.out.println(s.substring(0, s.length()-4));\n\t\tSystem.out.println(s.substring(0, s.length()-5));\n\t\tSystem.out.println(s.substring(0, s.length()-6));\n\t\tSystem.out.println(s.substring(0, s.length()-7));\n\t\tSystem.out.println(s.substring(0, s.length()-8));\n\t\tSystem.out.println(s.substring(0, s.length()-9));\n\t\tSystem.out.println(s.substring(0, s.length()-10));\n\t\tSystem.out.println(s.substring(0, s.length()-11));\n\t\tSystem.out.println(s.substring(0, s.length()-12));\n\t\tSystem.out.println(s.substring(0, s.length()-13));\n\t\tSystem.out.println(s.substring(0, s.length()-14));\n\t\tSystem.out.println(s.substring(0, s.length()-15));\n\t\tSystem.out.println(s.substring(0, s.length()-16));\n\t\tSystem.out.println(s.substring(0, s.length()-17));\n\t\tSystem.out.println(s.substring(0, s.length()-18));\n\t\tSystem.out.println(s.substring(0, s.length()-19));\n\t\tSystem.out.println(s.substring(0, s.length\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabbbccc\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(delete(s));\n\t}\n\tpublic static String delete(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tint i = 0;\n\t\t\twhile(count != 0){\n\t\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\treturn s.substring(0, i) + s.substring(i+1);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabb\";\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0, s.length()-1));\n\t\tSystem.out.println(s.substring(1, s.length()));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabbbbb\";\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabbbccc\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(solve(s));\n\t}\n\tpublic static String solve(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tif(count == 0){\n\t\t\treturn s;\n\t\t}\n\t\telse{\n\t\t\tint i = 0;\n\t\t\twhile(count != 0){\n\t\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder(s);\n\t\t\tsb.delete(i, sb.length());\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabb\";\n\t\tSystem.out.println(s.length()-minDeletion(s));\n\t}\n\tpublic static int minDeletion(String s){\n\t\tint min = s.length();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i+1; j < s.length(); j++){\n\t\t\t\tif(s.charAt(i) > s.charAt(j)){\n\t\t\t\t\tmin = Math.min(min, j-i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tstatic void main(String[] args) {\n\t\tString s = \"aabbbccc\";\n\t\tSystem.out.println(s.length() - minDelete(s));\n\t}\n\tpublic static int minDelete(String s) {\n\t\tint[] dp = new int[s.length() + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= s.length(); i++) {\n\t\t\tdp[i] = dp[i - 1] + 1;\n\t\t\tif (s.charAt(i - 1) == 'a') {\n\t\t\t\tdp[i] = Math.min(dp[i], dp[i - 2] + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp[s.length()];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1960",
    "source": "leetcode",
    "language": "java",
    "query": "Given the binary representation of an integer as a string s, return the number of steps to reduce it to 1 under the following rules. If the current number is even, you have to divide it by 2. If it is odd, you must add 1 to it.",
    "snippets": [
        "\tint steps(String s){\n\t\tint count = 0;\n\t\twhile(s.length() > 1){\n\t\t\tif(s.charAt(0) == '0'){\n\t\t\t\ts = s.substring(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = s.substring(1) + '0';\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint steps(String s){\n\t\tint count = 0;\n\t\twhile(s.length() > 1){\n\t\t\tif(s.charAt(0) == '0'){\n\t\t\t\ts = s.substring(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = s.substring(1);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint steps(String s){\n\t\tint count = 0;\n\t\twhile(s.length() > 1){\n\t\t\tif(s.charAt(0) == '0'){\n\t\t\t\ts = s.substring(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = s.substring(1);\n\t\t\t\ts = \"1\" + s;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint steps(String s){\n\t\tint count = 0;\n\t\twhile(s.length() > 1){\n\t\t\tif(s.charAt(0) == '0'){\n\t\t\t\ts = s.substring(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = s.substring(1) + '1';\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numberOfSteps(String s) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '0'){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i == s.length() - 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(s.charAt(i + 1) == '0'){\n\t\t\t\t\tcount++;\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcount += 2;\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numberOfSteps(String s) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '0'){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i == s.length() - 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(s.charAt(i + 1) == '0'){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcount += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numberOfSteps(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '0'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount += 2;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint steps(String s){\n\t\tint count = 0;\n\t\twhile(s.length() != 1){\n\t\t\tif(s.charAt(0) == '0'){\n\t\t\t\ts = s.substring(1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts = s.substring(1) + '1';\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1961",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a rectangular cake of size h x w and two arrays of integers. Return the maximum area of a piece of cake after you cut at each horizontal and vertical position.",
    "snippets": [
        "\tint maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n\t\tint max = 0;\n\t\tint[] hCuts = new int[horizontalCuts.length + 2];\n\t\tint[] vCuts = new int[verticalCuts.length + 2];\n\t\tfor (int i = 0; i < horizontalCuts.length; i++) {\n\t\t\thCuts[i + 1] = horizontalCuts[i];\n\t\t}\n\t\thCuts[0] = 0;\n\t\thCuts[hCuts.length - 1] = w;\n\t\tfor (int i = 0; i < verticalCuts.length; i++) {\n\t\t\tvCuts[i + 1] = verticalCuts[i];\n\t\t}\n\t\tvCuts[0] = 0;\n\t\tvCuts[vCuts.length - 1] = h;\n\t\tfor (int i = 0; i < hCuts.length - 1; i++) {\n\t\t\tfor (int j = 0; j < vCuts.length - 1; j++) {\n\t\t\t\tmax = Math.max(max, (hCuts[i + 1] - hCuts[i]) * (vCuts[j + 1] - vCuts[j]));\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n\t\tint max = 0;\n\t\tint[] hCuts = new int[horizontalCuts.length + 2];\n\t\tint[] vCuts = new int[verticalCuts.length + 2];\n\t\thCuts[0] = 0;\n\t\thCuts[hCuts.length - 1] = h;\n\t\tvCuts[0] = 0;\n\t\tvCuts[vCuts.length - 1] = w;\n\t\tfor (int i = 0; i < horizontalCuts.length; i++) {\n\t\t\thCuts[i + 1] = horizontalCuts[i];\n\t\t}\n\t\tfor (int i = 0; i < verticalCuts.length; i++) {\n\t\t\tvCuts[i + 1] = verticalCuts[i];\n\t\t}\n\t\tArrays.sort(hCuts);\n\t\tArrays.sort(vCuts);\n\t\tfor (int i = 0; i < hCuts.length - 1; i++) {\n\t\t\tfor (int j = 0; j < vCuts.length - 1; j++) {\n\t\t\t\tint area = (hCuts[i + 1] - hCuts[i]) * (vCuts[j + 1] - vCuts[j]);\n\t\t\t\tif (area > max) {\n\t\t\t\t\tmax = area;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n\t\tint max = 0;\n\t\tint[] hCuts = new int[horizontalCuts.length + 2];\n\t\tint[] vCuts = new int[verticalCuts.length + 2];\n\t\tfor (int i = 0; i < horizontalCuts.length; i++) {\n\t\t\thCuts[i + 1] = horizontalCuts[i];\n\t\t}\n\t\thCuts[0] = 0;\n\t\thCuts[horizontalCuts.length + 1] = w;\n\t\tfor (int i = 0; i < verticalCuts.length; i++) {\n\t\t\tvCuts[i + 1] = verticalCuts[i];\n\t\t}\n\t\tvCuts[0] = 0;\n\t\tvCuts[verticalCuts.length + 1] = h;\n\t\tfor (int i = 0; i < hCuts.length - 1; i++) {\n\t\t\tfor (int j = 0; j < vCuts.length - 1; j++) {\n\t\t\t\tint area = (hCuts[i + 1] - hCuts[i]) * (vCuts[j + 1] - vCuts[j]);\n\t\t\t\tif (area > max) {\n\t\t\t\t\tmax = area;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n\t\tint max = 0;\n\t\tint[] hCuts = new int[horizontalCuts.length + 2];\n\t\tint[] vCuts = new int[verticalCuts.length + 2];\n\t\tfor(int i = 0; i < horizontalCuts.length; i++){\n\t\t\thCuts[i + 1] = horizontalCuts[i];\n\t\t}\n\t\thCuts[0] = 0;\n\t\thCuts[hCuts.length - 1] = h;\n\t\tfor(int i = 0; i < verticalCuts.length; i++){\n\t\t\tvCuts[i + 1] = verticalCuts[i];\n\t\t}\n\t\tvCuts[0] = 0;\n\t\tvCuts[vCuts.length - 1] = w;\n\t\tfor(int i = 0; i < hCuts.length - 1; i++){\n\t\t\tfor(int j = 0; j < vCuts.length - 1; j++){\n\t\t\t\tint area = (hCuts[i + 1] - hCuts[i]) * (vCuts[j + 1] - vCuts[j]);\n\t\t\t\tif(area > max){\n\t\t\t\t\tmax = area;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n\t\tint max = 0;\n\t\tint[] hCuts = new int[horizontalCuts.length + 2];\n\t\tint[] vCuts = new int[verticalCuts.length + 2];\n\t\tfor (int i = 0; i < horizontalCuts.length; i++) {\n\t\t\thCuts[i + 1] = horizontalCuts[i];\n\t\t}\n\t\thCuts[0] = 0;\n\t\thCuts[hCuts.length - 1] = w;\n\t\tfor (int i = 0; i < verticalCuts.length; i++) {\n\t\t\tvCuts[i + 1] = verticalCuts[i];\n\t\t}\n\t\tvCuts[0] = 0;\n\t\tvCuts[vCuts.length - 1] = h;\n\t\tfor (int i = 0; i < hCuts.length - 1; i++) {\n\t\t\tfor (int j = 0; j < vCuts.length - 1; j++) {\n\t\t\t\tint area = (hCuts[i + 1] - hCuts[i]) * (vCuts[j + 1] - vCuts[j]);\n\t\t\t\tif (area > max) {\n\t\t\t\t\tmax = area;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n\t\tint max = 0;\n\t\tint[] hc = new int[horizontalCuts.length+2];\n\t\tint[] vc = new int[verticalCuts.length+2];\n\t\tfor(int i = 0; i < horizontalCuts.length; i++){\n\t\t\thc[i+1] = horizontalCuts[i];\n\t\t}\n\t\thc[0] = 0;\n\t\thc[horizontalCuts.length+1] = w;\n\t\tfor(int i = 0; i < verticalCuts.length; i++){\n\t\t\tvc[i+1] = verticalCuts[i];\n\t\t}\n\t\tvc[0] = 0;\n\t\tvc[verticalCuts.length+1] = h;\n\t\tfor(int i = 0; i < hc.length; i++){\n\t\t\tfor(int j = 0; j < vc.length; j++){\n\t\t\t\tif(i == 0 || j == 0 || i == hc.length-1 || j == vc.length-1){\n\t\t\t\t\tmax = Math.max(max, hc[i+1]-hc[i]);\n\t\t\t\t\tmax = Math.max(max, vc[j+1]-vc[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmax = Math.max(max, Math.min(hc[i+1]-hc[i], vc[j+1]-vc[j])*Math.min(hc[i+1]-hc[i], vc[j+1]-vc[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts){\n\t\tint max = 0;\n\t\tint h_len = horizontalCuts.length;\n\t\tint v_len = verticalCuts.length;\n\t\tint[] h_cuts = new int[h_len+1];\n\t\tint[] v_cuts = new int[v_len+1];\n\t\tfor(int i = 0; i < h_len; i++){\n\t\t\th_cuts[i] = horizontalCuts[i];\n\t\t}\n\t\th_cuts[h_len] = h;\n\t\tfor(int i = 0; i < v_len; i++){\n\t\t\tv_cuts[i] = verticalCuts[i];\n\t\t}\n\t\tv_cuts[v_len] = w;\n\t\tfor(int i = 0; i < h_len; i++){\n\t\t\tfor(int j = 0; j < v_len; j++){\n\t\t\t\tint area = (h_cuts[i+1]-h_cuts[i])*(v_cuts[j+1]-v_cuts[j]);\n\t\t\t\tif(area > max){\n\t\t\t\t\tmax = area;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1962",
    "source": "leetcode",
    "language": "java",
    "query": "The nodes in the linked list are sequentially assigned to non-empty groups whose lengths form the sequence of the natural numbers. The length of a group is the number of nodes assigned to it.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tNode head = new Node(1);\n\t\thead.next = new Node(2);\n\t\thead.next.next = new Node(3);\n\t\thead.next.next.next = new Node(4);\n\t\thead.next.next.next.next = new Node(5);\n\t\thead.next.next.next.next.next = new Node(6);\n\t\thead.next.next.next.next.next.next = new Node(7);\n\t\thead.next.next.next.next.next.next.next = new Node(8);\n\t\thead.next.next.next.next.next.next.next.next = new Node(9);\n\t\thead.next.next.next.next.next.next.next.next.next = new Node(10);\n\t\thead.next.next.next.next.next.next.next.next.next.next = new Node(11);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next = new Node(12);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next = new Node(13);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(14);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(15);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(16);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(17);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(18);\n",
        "\tClazz(int n){\n\t\tthis.n = n;\n\t}\n\tpublic int n;\n}\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic\n\tClazz(int n){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q, int r){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q, int r, int s){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q, int r, int s, int t){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q, int r, int s, int t, int u){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q, int r, int s, int t, int u, int v){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q, int r, int s, int t, int u, int v, int w){\n\t\t\n\t}\n\tpublic\n\tClazz(int n, int m, int k, int l, int o, int p, int q, int r, int s\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic\n\tClazz(int a){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i\n"
    ],
    "results": 10
},{
    "id": "1963",
    "source": "leetcode",
    "language": "java",
    "query": "Given two nodes start and end, find the path with the maximum probability of success to go from start to end. Your answer will be accepted if it differs from the correct answer by at most 1e-5.",
    "snippets": [
        "\tdouble maxProbability(int n, int[][] edges, int start, int end, int maxDistance) {\n\t\tdouble[][] dp = new double[n][maxDistance + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][0] = 1;\n\t\t}\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tint w = edges[i][2];\n\t\t\tfor (int j = 0; j <= maxDistance; j++) {\n\t\t\t\tif (j - w >= 0) {\n\t\t\t\t\tdp[v][j] += dp[u][j - w];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i <= maxDistance; i++) {\n\t\t\tans = Math.max(ans, dp[end][i]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic double maxProbability(Node start, Node end, double p) {\n\t\tif(start == end) return 1;\n\t\tdouble max = 0;\n\t\tfor(Node n : start.neighbors){\n\t\t\tdouble prob = n.probability * p;\n\t\t\tdouble prob2 = maxProbability(n, end, prob);\n\t\t\tmax = Math.max(max, prob2);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic double maxProbability(int n, int[][] edges, int start, int end) {\n\t\tdouble[][] prob = new double[n][n];\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tdouble p = edges[i][2];\n\t\t\tprob[u][v] = p;\n\t\t\tprob[v][u] = p;\n\t\t}\n\t\tdouble[] dp = new double[n];\n\t\tdp[start] = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tdp[j] += dp[i] * prob[i][j];\n\t\t\t}\n\t\t}\n\t\treturn dp[end];\n\t}\n}\n",
        "\tstatic double maxProbability(int start, int end, int n, int[][] edges, double[] succProb) {\n\t\tdouble[] dp = new double[n];\n\t\tdp[start] = 1;\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tdp[v] += dp[u] * succProb[i];\n\t\t}\n\t\treturn dp[end];\n\t}\n}\n",
        "\tstatic double maxProbability(int start, int end, int n, int[][] edges, double[] succProb) {\n\t\tdouble[] dp = new double[n];\n\t\tdp[start] = 1;\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint u = edges[i][0];\n\t\t\tint v = edges[i][1];\n\t\t\tdouble prob = succProb[i];\n\t\t\tdp[v] += dp[u] * prob;\n\t\t}\n\t\treturn dp[end];\n\t}\n}\n",
        "\tstatic double maxProbability(Node start, Node end){\n\t\tif(start == null || end == null) return 0;\n\t\tif(start == end) return 1;\n\t\tdouble max = 0;\n\t\tfor(Node n : start.neighbors){\n\t\t\tdouble prob = n.probability;\n\t\t\tif(n == end) return prob;\n\t\t\tmax = Math.max(max, prob + maxProbability(n, end));\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic double maxProbability(int n, int[][] edges, int start, int end, int weight) {\n\t\tdouble[][] dp = new double[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int[] edge : edges){\n\t\t\tint u = edge[0];\n\t\t\tint v = edge[1];\n\t\t\tint w = edge[2];\n\t\t\tdp[u][v] = w;\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i][k] * dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[start][end];\n\t}\n}\n",
        "\tstatic double maxProbability(int n, int[][] edges, int start, int end) {\n\t\tdouble[][] p = new double[n][n];\n\t\tfor (int[] edge : edges) {\n\t\t\tp[edge[0]][edge[1]] = edge[2];\n\t\t\tp[edge[1]][edge[0]] = edge[2];\n\t\t}\n\t\tdouble[] dp = new double[n];\n\t\tdp[start] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i == start) continue;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (j == start) continue;\n\t\t\t\tdp[j] += dp[i] * p[i][j];\n\t\t\t}\n\t\t}\n\t\treturn dp[end];\n\t}\n}\n",
        "\tstatic double maxProbability(Node start, Node end, double speed){\n\t\tdouble max = 0;\n\t\tdouble prob = 0;\n\t\tdouble time = 0;\n\t\tdouble distance = 0;\n\t\tdouble speed2 = speed * speed;\n\t\tdouble speed3 = speed2 * speed;\n\t\tdouble speed4 = speed3 * speed;\n\t\tdouble speed5 = speed4 * speed;\n\t\tdouble speed6 = speed5 * speed;\n\t\tdouble speed7 = speed6 * speed;\n\t\tdouble speed8 = speed7 * speed;\n\t\tdouble speed9 = speed8 * speed;\n\t\tdouble speed10 = speed9 * speed;\n\t\tdouble speed11 = speed10 * speed;\n\t\tdouble speed12 = speed11 * speed;\n\t\tdouble speed13 = speed12 * speed;\n\t\tdouble speed14 = speed13 * speed;\n\t\tdouble speed15 = speed14 * speed;\n\t\tdouble speed16 = speed15 * speed;\n\t\tdouble speed17 = speed16 * speed;\n\t\tdouble speed18 = speed17 * speed;\n\t\tdouble speed19 = speed18 * speed;\n\t\tdouble speed20 = speed19 * speed;\n\t\tdouble speed21 = speed20 * speed;\n\t\tdouble speed22 = speed21 * speed;\n\t\tdouble speed23 = speed22 * speed;\n\t\tdouble speed24 = speed23 * speed;\n\t\tdouble speed25 = speed24 * speed;\n\t\tdouble speed26 = speed25 * speed;\n\t\tdouble speed27 = speed26 * speed;\n\t\tdouble speed28 = speed27 * speed;\n\t\tdouble speed29 = speed28 * speed;\n\t\tdouble speed30 = speed29 * speed;\n\t\tdouble speed31 = speed30 * speed;\n\t\tdouble speed32 = speed31 * speed;\n\t\tdouble speed33 = speed32 * speed;\n\t\tdouble speed34 = speed33 * speed;\n\t\tdouble speed35 = speed34 * speed;\n\t\tdouble speed36 = speed35 * speed;\n\t\tdouble speed37 = speed36 * speed;\n\t\tdouble speed38 = speed37 * speed;\n\t\tdouble speed39 =\n",
        "\tstatic double maxProbability(Node start, Node end, int maxDistance) {\n\t\tif(start == end){\n\t\t\treturn 1;\n\t\t}\n\t\tdouble max = 0;\n\t\tfor(Node n : start.neighbors){\n\t\t\tif(n == end){\n\t\t\t\tmax = Math.max(max, n.probability);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmax = Math.max(max, maxProbability(n, end, maxDistance));\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1964",
    "source": "leetcode",
    "language": "java",
    "query": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val. Return the new head.",
    "snippets": [
        "\tNode removeElements(Node head, int val) {\n\t\tNode dummy = new Node(0);\n\t\tdummy.next = head;\n\t\tNode prev = dummy;\n\t\tNode cur = head;\n\t\twhile(cur != null){\n\t\t\tif(cur.val == val){\n\t\t\t\tprev.next = cur.next;\n\t\t\t}else{\n\t\t\t\tprev = cur;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn dummy.next;\n\t}\n}\n",
        "\tNode removeElements(Node head, int val) {\n\t\tNode dummy = new Node(0);\n\t\tdummy.next = head;\n\t\tNode prev = dummy;\n\t\tNode cur = head;\n\t\twhile(cur != null){\n\t\t\tif(cur.val == val){\n\t\t\t\tprev.next = cur.next;\n\t\t\t}else{\n\t\t\t\tprev = prev.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn dummy.next;\n\t}\n}\n",
        "\tNode removeElements(Node head, int val) {\n\t\tNode dummy = new Node(0);\n\t\tdummy.next = head;\n\t\tNode cur = dummy;\n\t\twhile(cur.next != null){\n\t\t\tif(cur.next.val == val){\n\t\t\t\tcur.next = cur.next.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcur = cur.next;\n\t\t\t}\n\t\t}\n\t\treturn dummy.next;\n\t}\n}\n",
        "\tNode removeElements(Node head, int val) {\n\t\tNode dummy = new Node(0);\n\t\tdummy.next = head;\n\t\tNode prev = dummy;\n\t\twhile(prev.next != null){\n\t\t\tif(prev.next.val == val){\n\t\t\t\tprev.next = prev.next.next;\n\t\t\t}else{\n\t\t\t\tprev = prev.next;\n\t\t\t}\n\t\t}\n\t\treturn dummy.next;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1965",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all. Return the highest altitude of a point.",
    "snippets": [
        "\tint highestPoint(int[] gain){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < gain.length; i++){\n\t\t\tif(gain[i] > max){\n\t\t\t\tmax = gain[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint highest(int[] gain) {\n\t\tint max = 0;\n\t\tfor (int i = 0; i < gain.length; i++) {\n\t\t\tif (gain[i] > max) {\n\t\t\t\tmax = gain[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxGain(int[] gain) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < gain.length; i++){\n\t\t\tsum += gain[i];\n\t\t\tif(sum > max)\n\t\t\t\tmax = sum;\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxGain(int[] gain) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < gain.length; i++) {\n\t\t\tsum += gain[i];\n\t\t\tif (sum > max) {\n\t\t\t\tmax = sum;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1966",
    "source": "leetcode",
    "language": "java",
    "query": "Given four integers n, a, b, and c, return the nth ugly number. An ugly number is a positive integer that is divisible by a or b.",
    "snippets": [
        "\tint nthUglyNumber(int n) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint i2 = 0, i3 = 0, i5 = 0;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint min = Math.min(Math.min(ugly[i2] * 2, ugly[i3] * 3), ugly[i5] * 5);\n\t\t\tugly[i] = min;\n\t\t\tif(ugly[i2] * 2 == min) i2++;\n\t\t\tif(ugly[i3] * 3 == min) i3++;\n\t\t\tif(ugly[i5] * 5 == min) i5++;\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n",
        "\tint nthUglyNumber(int n) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint i2 = 0, i3 = 0, i5 = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint next2 = ugly[i2] * 2;\n\t\t\tint next3 = ugly[i3] * 3;\n\t\t\tint next5 = ugly[i5] * 5;\n\t\t\tint min = Math.min(next2, Math.min(next3, next5));\n\t\t\tugly[i] = min;\n\t\t\tif (min == next2) i2++;\n\t\t\tif (min == next3) i3++;\n\t\t\tif (min == next5) i5++;\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n",
        "\tint nthUglyNumber(int n) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint i2 = 0, i3 = 0, i5 = 0;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint m2 = ugly[i2] * 2;\n\t\t\tint m3 = ugly[i3] * 3;\n\t\t\tint m5 = ugly[i5] * 5;\n\t\t\tint min = Math.min(m2, Math.min(m3, m5));\n\t\t\tugly[i] = min;\n\t\t\tif(min == m2) i2++;\n\t\t\tif(min == m3) i3++;\n\t\t\tif(min == m5) i5++;\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n",
        "\tint nthUglyNumber(int n) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint a = 0, b = 0, c = 0;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint min = Math.min(Math.min(ugly[a] * 2, ugly[b] * 3), ugly[c] * 5);\n\t\t\tugly[i] = min;\n\t\t\tif(ugly[a] * 2 == min) a++;\n\t\t\tif(ugly[b] * 3 == min) b++;\n\t\t\tif(ugly[c] * 5 == min) c++;\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n",
        "\tint nthUglyNumber(int n) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint a = 0, b = 0, c = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tugly[i] = Math.min(Math.min(ugly[a] * 2, ugly[b] * 3), ugly[c] * 5);\n\t\t\tif (ugly[i] == ugly[a] * 2) a++;\n\t\t\tif (ugly[i] == ugly[b] * 3) b++;\n\t\t\tif (ugly[i] == ugly[c] * 5) c++;\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n",
        "\tint nthUglyNumber(int n) {\n\t\tif(n<=0) return 0;\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint a = 0, b = 0, c = 0;\n\t\tfor(int i=1; i<n; i++){\n\t\t\tugly[i] = Math.min(Math.min(ugly[a]*2, ugly[b]*3), ugly[c]*5);\n\t\t\tif(ugly[i] == ugly[a]*2) a++;\n\t\t\tif(ugly[i] == ugly[b]*3) b++;\n\t\t\tif(ugly[i] == ugly[c]*5) c++;\n\t\t}\n\t\treturn ugly[n-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1967",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root. Every node has no left child and only one right child.",
    "snippets": [
        "\tNode rearrange(Node root){\n\t\tif(root == null) return null;\n\t\tNode left = rearrange(root.left);\n\t\tNode right = rearrange(root.right);\n\t\tif(left != null){\n\t\t\tNode leftRight = left.right;\n\t\t\tleft.right = root;\n\t\t\troot.left = leftRight;\n\t\t}\n\t\tif(right != null){\n\t\t\tNode rightLeft = right.left;\n\t\t\tright.left = root;\n\t\t\troot.right = rightLeft;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode rearrange(TreeNode root){\n\t\tif(root == null) return null;\n\t\tTreeNode left = rearrange(root.left);\n\t\tTreeNode right = rearrange(root.right);\n\t\tif(left != null && left.val > root.val){\n\t\t\tTreeNode temp = left;\n\t\t\tleft = right;\n\t\t\tright = temp;\n\t\t}\n\t\troot.left = right;\n\t\troot.right = left;\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode rearrange(TreeNode root){\n\t\tif(root == null) return null;\n\t\tTreeNode left = rearrange(root.left);\n\t\tTreeNode right = rearrange(root.right);\n\t\tif(left != null && left.val >= root.val){\n\t\t\tTreeNode tmp = left;\n\t\t\tleft = right;\n\t\t\tright = tmp;\n\t\t}\n\t\tif(right != null && right.val <= root.val){\n\t\t\tTreeNode tmp = right;\n\t\t\tright = left;\n\t\t\tleft = tmp;\n\t\t}\n\t\troot.left = right;\n\t\troot.right = left;\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode rearrange(TreeNode root){\n\t\tif(root == null) return null;\n\t\tTreeNode left = rearrange(root.left);\n\t\tTreeNode right = rearrange(root.right);\n\t\tif(left != null){\n\t\t\tTreeNode leftRight = left.right;\n\t\t\tleft.right = root;\n\t\t\troot.left = leftRight;\n\t\t}\n\t\tif(right != null){\n\t\t\tTreeNode rightLeft = right.left;\n\t\t\tright.left = root;\n\t\t\troot.right = rightLeft;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode rearrange(TreeNode root){\n\t\tif(root == null) return null;\n\t\tTreeNode left = rearrange(root.left);\n\t\tTreeNode right = rearrange(root.right);\n\t\tif(left != null && left.val > root.val){\n\t\t\tTreeNode tmp = left;\n\t\t\tleft = right;\n\t\t\tright = tmp;\n\t\t}\n\t\troot.left = right;\n\t\troot.right = left;\n\t\treturn root;\n\t}\n}\n",
        "\tvoid rearrange(TreeNode root){\n\t\tif(root == null) return;\n\t\tTreeNode cur = root;\n\t\tTreeNode prev = null;\n\t\tTreeNode next = null;\n\t\twhile(cur != null){\n\t\t\tif(cur.left == null){\n\t\t\t\tnext = cur.right;\n\t\t\t\tcur.right = prev;\n\t\t\t\tprev = cur;\n\t\t\t\tcur = next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnext = cur.left;\n\t\t\t\twhile(next.right != null && next.right != cur){\n\t\t\t\t\tnext = next.right;\n\t\t\t\t}\n\t\t\t\tif(next.right == null){\n\t\t\t\t\tnext.right = cur;\n\t\t\t\t\tcur = cur.left;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnext.right = null;\n\t\t\t\t\tnext = cur.right;\n\t\t\t\t\tcur.right = prev;\n\t\t\t\t\tprev = cur;\n\t\t\t\t\tcur = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\troot = prev;\n\t}\n}\n",
        "\tTreeNode rearrangeBinaryTree(TreeNode root){\n\t\tif(root == null) return null;\n\t\tTreeNode left = rearrangeBinaryTree(root.left);\n\t\tTreeNode right = rearrangeBinaryTree(root.right);\n\t\tif(left != null){\n\t\t\tTreeNode leftRight = left.right;\n\t\t\tleft.right = root;\n\t\t\troot.left = leftRight;\n\t\t}\n\t\tif(right != null){\n\t\t\tTreeNode rightLeft = right.left;\n\t\t\tright.left = root;\n\t\t\troot.right = rightLeft;\n\t\t}\n\t\treturn left != null ? left : root;\n\t}\n}\n",
        "\tstatic void rearrange(TreeNode root){\n\t\tif(root == null) return;\n\t\tTreeNode cur = root;\n\t\tTreeNode prev = null;\n\t\tTreeNode next = null;\n\t\twhile(cur != null){\n\t\t\tnext = cur.right;\n\t\t\tcur.right = prev;\n\t\t\tprev = cur;\n\t\t\tcur = next;\n\t\t}\n\t\troot = prev;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1968",
    "source": "leetcode",
    "language": "java",
    "query": "The population of some year x is the number of people alive during that year. The person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die.",
    "snippets": [
        "\tstatic int population(int birth, int death){\n\t\tint sum = 0;\n\t\tfor(int i = birth; i < death; i++){\n\t\t\tsum += i;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic int population(int birth, int death){\n\t\tint pop = 0;\n\t\tfor(int i = birth; i < death; i++){\n\t\t\tpop += i;\n\t\t}\n\t\treturn pop;\n\t}\n}\n",
        "\tint population(int birth, int death){\n\t\tint sum = 0;\n\t\tfor(int i = birth; i < death; i++){\n\t\t\tsum += i;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint population(int birth, int death, int year) {\n\t\tint pop = 0;\n\t\tfor(int i = birth; i < death; i++){\n\t\t\tif(i == year){\n\t\t\t\tpop++;\n\t\t\t}\n\t\t}\n\t\treturn pop;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1969",
    "source": "leetcode",
    "language": "java",
    "query": "A line chart is created from the array by plotting the points on an XY plane. The X-axis represents the day and the Y-axis representing the price and connecting adjacent points.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] prices = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] days = {1,2,3,4,5,6,7,8,9,10};\n\t\tLineChart chart = new LineChart(days, prices);\n\t\tchart.setTitle(\"Price of a stock\");\n\t\tchart.setXAxisLabel(\"Day\");\n\t\tchart.setYAxisLabel(\"Price\");\n\t\tchart.setXAxisMin(0);\n\t\tchart.setXAxisMax(10);\n\t\tchart.setYAxisMin(0);\n\t\tchart.setYAxisMax(10);\n\t\tchart.setXAxisTickMarkSpacing(1);\n\t\tchart.setYAxisTickMarkSpacing(1);\n\t\tchart.setXAxisTickMarkLength(5);\n\t\tchart.setYAxisTickMarkLength(5);\n\t\tchart.setXAxisTickMarkColor(Color.BLACK);\n\t\tchart.setYAxisTickMarkColor(Color.BLACK);\n\t\tchart.setXAxisTickMarkLabelColor(Color.BLACK);\n\t\tchart.setYAxisTickMarkLabelColor(Color.BLACK);\n\t\tchart.setXAxisTickMarkLabelFont(new Font(\"Arial\", Font.PLAIN, 12));\n\t\tchart.setYAxisTickMarkLabelFont(new Font(\"Arial\", Font.PLAIN, 12));\n\t\tchart.setXAxisTickMarkLabelFormat(\"%d\");\n\t\tchart.setYAxisTickMarkLabelFormat(\"%d\");\n\t\tchart.setXAxisTickMarkLabelRotation(0);\n\t\tchart.setYAxisTickMarkLabelRotation(0);\n\t\tchart.setXAxisTickMarkLabelSpacing(0);\n\t\tchart.setYAxisTickMarkLabelSpacing(0);\n\t\tchart.setXAxisTickMarkLabelAlignment(LineChart.AL\n",
        "\tstatic void main(String[] args){\n\t\tint[] prices = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] days = {1,2,3,4,5,6,7,8,9,10};\n\t\tLineChart chart = new LineChart(days, prices);\n\t\tchart.setTitle(\"Line Chart\");\n\t\tchart.pack();\n\t\tRefineryUtilities.centerFrameOnScreen(chart);\n\t\tchart.setVisible(true);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] prices = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] days = {1,2,3,4,5,6,7,8,9,10};\n\t\tStdDraw.setScale(0, 10);\n\t\tStdDraw.setPenRadius(0.01);\n\t\tStdDraw.setPenColor(StdDraw.BLACK);\n\t\tStdDraw.line(0, 0, 10, 0);\n\t\tStdDraw.setPenColor(StdDraw.RED);\n\t\tStdDraw.line(0, 0, 0, 10);\n\t\tStdDraw.setPenColor(StdDraw.BLUE);\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tStdDraw.point(days[i], prices[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] prices = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices2 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices3 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices4 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days4 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices5 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days5 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices6 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days6 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices7 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days7 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices8 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days8 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint[] prices9 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n",
        "\tvoid main(String[] args){\n\t\tint[] prices = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] days = {1,2,3,4,5,6,7,8,9,10};\n\t\tLineChart chart = new LineChart(days, prices);\n\t\tchart.setTitle(\"Price vs Day\");\n\t\tchart.pack();\n\t\tRefineryUtilities.centerFrameOnScreen(chart);\n\t\tchart.setVisible(true);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tdouble[] prices = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n\t\tdouble[] days = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};\n\t\tLineChart chart = new LineChart(\"Line Chart\", \"Day\", \"Price\", days, prices);\n\t\tchart.pack();\n\t\tRefineryUtilities.centerFrameOnScreen(chart);\n\t\tchart.setVisible(true);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tdouble[] prices = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tdouble[] days = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tLineChart chart = new LineChart(\"Price vs Day\", \"Day\", \"Price\", days, prices);\n\t\tchart.setVisible(true);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tdouble[] prices = {1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0};\n\t\tdouble[] days = {1, 2, 3, 4, 5, 6, 7, 8};\n\t\tLineChart chart = new LineChart(\"Price of Coffee\", \"Day\", \"Price\");\n\t\tchart.addSeries(\"Coffee\", days, prices);\n\t\tchart.show();\n\t}\n}\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic static void main(String[] args){\n\t\tint[] prices = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n\t\tint[] days = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tXYChart chart = new XYChart(500, 500);\n\t\tchart.setTitle(\"Price vs Day\");\n\t\tchart.setXAxisTitle(\"Day\");\n\t\tchart.setYAxisTitle(\"Price\");\n\t\tchart.addDataSet(days, prices);\n\t\tchart.setXAxisTicks(5);\n\t\tchart.setYAxisTicks(5);\n\t\tchart.setXAxisTickLabels(true);\n\t\tchart.setYAxisTickLabels(true);\n\t\tchart.setXAxisTickLabelsAngle(45);\n\t\tchart.setYAxisTickLabelsAngle(45);\n\t\tchart.setXAxisTickLabelsFont(new Font(\"Arial\", Font.PLAIN, 10));\n\t\tchart.setYAxisTickLabelsFont(new Font(\"Arial\", Font.PLAIN, 10));\n\t\tchart.setXAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setYAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setXAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setYAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setXAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setYAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setXAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setYAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setXAxisTickLabelsColor(Color.BLACK);\n\t\tchart.setYAxisTickLabelsColor(Color.BLACK);\n\t\tchart\n"
    ],
    "results": 10
},{
    "id": "1970",
    "source": "leetcode",
    "language": "java",
    "query": "The returned string must contain only lowercase English letters. Given an integer n, return a string with n characters such that each character in such string occurs an odd number of times.",
    "snippets": [
        "\tString generateTheString(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n%2==0){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tsb.append(\"a\");\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tsb.append(\"a\");\n\t\t\t}\n\t\t\tsb.append(\"b\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString generateTheString(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n%2==0){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tsb.append('a');\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tsb.append('a');\n\t\t\t}\n\t\t\tsb.append('b');\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString odd(int n){\n\t\tString s = \"\";\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts += (char)('a' + i);\n\t\t}\n\t\treturn s;\n\t}\n}\n",
        "\tString odd(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append((char)('a' + i));\n\t\t}\n\t\tString s = sb.toString();\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb2.append(s.charAt(i));\n\t\t}\n\t\treturn sb2.toString();\n\t}\n}\n",
        "\tString odd(int n){\n\t\tString s = \"\";\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ts += (char)(i + 97);\n\t\t}\n\t\treturn s;\n\t}\n}\n",
        "\tString oddOccurrences(String str) {\n\t\tint[] count = new int[26];\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tcount[str.charAt(i) - 'a']++;\n\t\t}\n\t\tfor (int i = 0; i < count.length; i++) {\n\t\t\tif (count[i] % 2 == 1) {\n\t\t\t\treturn String.valueOf((char) (i + 'a'));\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1971",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.",
    "snippets": [
        "\tList<TreeNode> allPossibleFBT(int n) {\n\t\tList<TreeNode> res = new ArrayList<TreeNode>();\n\t\tif(n == 1){\n\t\t\tres.add(new TreeNode(0));\n\t\t\treturn res;\n\t\t}\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\tList<TreeNode> left = allPossibleFBT(i);\n\t\t\tList<TreeNode> right = allPossibleFBT(n - i - 1);\n\t\t\tfor(TreeNode l : left){\n\t\t\t\tfor(TreeNode r : right){\n\t\t\t\t\tTreeNode root = new TreeNode(0);\n\t\t\t\t\troot.left = l;\n\t\t\t\t\troot.right = r;\n\t\t\t\t\tres.add(root);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<TreeNode> allPossibleFBT(int n) {\n\t\tList<TreeNode> res = new ArrayList<TreeNode>();\n\t\tif(n == 1){\n\t\t\tTreeNode root = new TreeNode(0);\n\t\t\tres.add(root);\n\t\t\treturn res;\n\t\t}\n\t\tfor(int i = 1; i < n; i += 2){\n\t\t\tList<TreeNode> left = allPossibleFBT(i);\n\t\t\tList<TreeNode> right = allPossibleFBT(n - i - 1);\n\t\t\tfor(TreeNode l : left){\n\t\t\t\tfor(TreeNode r : right){\n\t\t\t\t\tTreeNode root = new TreeNode(0);\n\t\t\t\t\troot.left = l;\n\t\t\t\t\troot.right = r;\n\t\t\t\t\tres.add(root);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1972",
    "source": "leetcode",
    "language": "java",
    "query": "Return all lonely numbers in nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array. You may return the answer in any order.",
    "snippets": [
        "\tList<Integer> findLonely(int[] nums){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i == 0){\n\t\t\t\tif(nums[i] != nums[i + 1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i == nums.length - 1){\n\t\t\t\tif(nums[i] != nums[i - 1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(nums[i] != nums[i - 1] && nums[i] != nums[i + 1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> findLonely(int[] nums){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tif(nums[i] == nums[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == 1){\n\t\t\t\tresult.add(nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> findLonely(int[] nums){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i == 0){\n\t\t\t\tif(nums[i] == nums[i+1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i == nums.length-1){\n\t\t\t\tif(nums[i] == nums[i-1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(nums[i] == nums[i+1] || nums[i] == nums[i-1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> findLonely(int[] nums){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i == 0){\n\t\t\t\tif(nums[i] == nums[i + 1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i == nums.length - 1){\n\t\t\t\tif(nums[i] == nums[i - 1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(nums[i] == nums[i - 1] || nums[i] == nums[i + 1]){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> findLonely(int[] nums){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == i + 1){\n\t\t\t\tresult.add(nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> findLonely(int[] nums){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tint[] count = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tcount[nums[i]]++;\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(count[i] == 1){\n\t\t\t\tresult.add(i);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> findLonely(int[] nums){\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tint[] count = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tcount[i] = 1;\n\t\t\tfor(int j = i - 1; j >= 0; j--){\n\t\t\t\tif(nums[i] == nums[j]){\n\t\t\t\t\tcount[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(nums[i] == nums[j]){\n\t\t\t\t\tcount[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count[i] == 1){\n\t\t\t\tres.add(nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1973",
    "source": "leetcode",
    "language": "java",
    "query": "In C++, there are two types of comments, line comments, and block comments. The first effective comment takes precedence over others. Given a C++ program, remove comments from it.",
    "snippets": [
        "\tvoid removeComments(String input){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint aa = 0;\n\t\tint bb = 0;\n\t\tint cc = 0;\n\t\tint dd = 0;\n\t\tint ee = 0;\n\t\tint ff = 0;\n\t\tint gg = 0;\n\t\tint hh = 0;\n\t\tint ii = 0;\n\t\tint jj = 0;\n\t\tint kk = 0;\n\t\tint ll = 0;\n\t\tint mm = 0;\n\t\tint nn = 0;\n\t\tint oo = 0;\n\t\tint pp = 0;\n\t\tint qq = 0;\n\t\tint rr = 0;\n\t\tint ss = 0;\n\t\tint tt = 0;\n\t\tint uu = 0;\n\t\tint vv = 0;\n\t\tint ww = 0;\n\t\tint xx = 0;\n\t\tint yy = 0;\n\t\tint zz = 0;\n\t\tint aaa = 0;\n\t\tint bbb = 0;\n\t\tint ccc = 0;\n\t\tint ddd = 0;\n\t\tint eee = 0;\n\t\tint fff = 0;\n\t\tint ggg = 0;\n\t\tint hhh = 0;\n\t\tint iii = 0;\n\t\tint jjj = 0;\n",
        "\tvoid removeComments(String[] source){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint aa = 0;\n\t\tint bb = 0;\n\t\tint cc = 0;\n\t\tint dd = 0;\n\t\tint ee = 0;\n\t\tint ff = 0;\n\t\tint gg = 0;\n\t\tint hh = 0;\n\t\tint ii = 0;\n\t\tint jj = 0;\n\t\tint kk = 0;\n\t\tint ll = 0;\n\t\tint mm = 0;\n\t\tint nn = 0;\n\t\tint oo = 0;\n\t\tint pp = 0;\n\t\tint qq = 0;\n\t\tint rr = 0;\n\t\tint ss = 0;\n\t\tint tt = 0;\n\t\tint uu = 0;\n\t\tint vv = 0;\n\t\tint ww = 0;\n\t\tint xx = 0;\n\t\tint yy = 0;\n\t\tint zz = 0;\n\t\tint aaa = 0;\n\t\tint bbb = 0;\n\t\tint ccc = 0;\n\t\tint ddd = 0;\n\t\tint eee = 0;\n\t\tint fff = 0;\n\t\tint ggg = 0;\n\t\tint hhh = 0;\n\t\tint iii = 0;\n\t\tint jjj = 0;\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"// This is a line comment\\n\" +\n\t\t\t\t\"/* This is a block comment */\\n\" +\n\t\t\t\t\"int main(){\\n\" +\n\t\t\t\t\"\t// This is a line comment\\n\" +\n\t\t\t\t\"\t/* This is a block comment */\\n\" +\n\t\t\t\t\"\treturn 0;\\n\" +\n\t\t\t\t\"}\\n\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removeComments(s));\n\t}\n\tpublic static String removeComments(String source) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile (i < source.length()) {\n\t\t\tif (source.charAt(i) == '/') {\n\t\t\t\tif (i + 1 < source.length() && source.charAt(i + 1) == '/') {\n\t\t\t\t\t// skip single line comment\n\t\t\t\t\ti = source.indexOf(\"\\n\", i + 2);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\ti = source.length();\n\t\t\t\t\t}\n\t\t\t\t} else if (i + 1 < source.length() && source.charAt(i + 1) == '*') {\n\t\t\t\t\t// skip block comment\n\t\t\t\t\ti = source.indexOf(\"*/\", i + 2);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\ti = source.length();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(source.charAt(i));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsb.append(source.charAt(i));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"// This is a comment\\n\" +\n\t\t\t\t\"/* This is a comment\\n\" +\n\t\t\t\t\" * This is a comment\\n\" +\n\t\t\t\t\" */\\n\" +\n\t\t\t\t\"int main(){\\n\" +\n\t\t\t\t\"\t// This is a comment\\n\" +\n\t\t\t\t\"\t/* This is a comment\\n\" +\n\t\t\t\t\"\t * This is a comment\\n\" +\n\t\t\t\t\"\t */\\n\" +\n\t\t\t\t\"\tint a; // This is a comment\\n\" +\n\t\t\t\t\"\t/* This is a comment\\n\" +\n\t\t\t\t\"\t * This is a comment\\n\" +\n\t\t\t\t\"\t */\\n\" +\n\t\t\t\t\"\ta = 5; /* This is a comment\\n\" +\n\t\t\t\t\"\t * This is a comment\\n\" +\n\t\t\t\t\"\t */\\n\" +\n\t\t\t\t\"\treturn 0;\\n\" +\n\t\t\t\t\"}\\n\";\n\t\tSystem.out.println(removeComments(s));\n\t}\n\tpublic static String removeComments(String s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '/' && i < s.length() - 1 && s.charAt(i + 1) == '/'){\n\t\t\t\ti = s.indexOf('\\n', i + 2);\n\t\t\t\tif(i == -1)\n\t\t\t\t\ti = s.length();\n\t\t\t}\n\t\t\telse if(s.charAt(i) == '/' && i < s.length() - 1 && s.charAt(i + 1) == '*'){\n\t\t\t\ti = s.indexOf(\"*/\", i + 2);\n\t\t\t\tif(i == -1)\n\t\t\t\t\ti =\n",
        "\tvoid removeComments(String inputString){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(i < inputString.length()){\n\t\t\tif(inputString.charAt(i) == '/' && i < inputString.length() - 1 && inputString.charAt(i + 1) == '/'){\n\t\t\t\ti = inputString.indexOf('\\n', i);\n\t\t\t}\n\t\t\telse if(inputString.charAt(i) == '/' && i < inputString.length() - 1 && inputString.charAt(i + 1) == '*'){\n\t\t\t\ti = inputString.indexOf('*', i) + 1;\n\t\t\t\ti = inputString.indexOf('/', i) + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(inputString.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n}\n",
        "\tvoid removeComments(String[] lines) {\n\t\tint i = 0;\n\t\twhile (i < lines.length) {\n\t\t\tString line = lines[i];\n\t\t\tif (line.contains(\"//\")) {\n\t\t\t\tlines[i] = line.substring(0, line.indexOf(\"//\"));\n\t\t\t} else if (line.contains(\"/*\")) {\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile (j < lines.length && !lines[j].contains(\"*/\")) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tlines[i] = line.substring(0, line.indexOf(\"/*\")) + line.substring(line.indexOf(\"*/\") + 2);\n\t\t\t\ti = j;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"// This is a comment\\n\" +\n\t\t\t\t\"/* This is a comment\\n\" +\n\t\t\t\t\"* inside a comment\\n\" +\n\t\t\t\t\"*/\\n\" +\n\t\t\t\t\"int main(){\\n\" +\n\t\t\t\t\"\t// This is a comment\\n\" +\n\t\t\t\t\"\t/* This is a comment\\n\" +\n\t\t\t\t\"\t* inside a comment\\n\" +\n\t\t\t\t\"\t*/\\n\" +\n\t\t\t\t\"\treturn 0;\\n\" +\n\t\t\t\t\"}\\n\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removeComments(s));\n\t}\n\tpublic static String removeComments(String source) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint i = 0;\n\t\twhile (i < source.length()) {\n\t\t\tif (source.charAt(i) == '/') {\n\t\t\t\tif (i + 1 < source.length() && source.charAt(i + 1) == '/') {\n\t\t\t\t\t// line comment, skip to end of line\n\t\t\t\t\ti = source.indexOf('\\n', i + 2);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\ti = source.length();\n\t\t\t\t\t}\n\t\t\t\t} else if (i + 1 < source.length() && source.charAt(i + 1) == '*') {\n\t\t\t\t\t// block comment, skip to end of block\n\t\t\t\t\ti = source.indexOf(\"*/\", i + 2);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\ti = source.length();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(source.charAt(i));\n\t\t\t\t}\n",
        "\tstatic void main(String[] args){\n\t\tString str = \"// This is a comment\\n\" +\n\t\t\t\t\"/* This is a comment too\\n\" +\n\t\t\t\t\"and this is another comment */\\n\" +\n\t\t\t\t\"int main(){\\n\" +\n\t\t\t\t\"\t// This is a comment\\n\" +\n\t\t\t\t\"\t/* This is a comment too\\n\" +\n\t\t\t\t\"\tand this is another comment */\\n\" +\n\t\t\t\t\"\treturn 0;\\n\" +\n\t\t\t\t\"}\";\n\t\tSystem.out.println(removeComments(str));\n\t}\n\tpublic static String removeComments(String source) {\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint i = 0;\n\t\twhile (i < source.length()) {\n\t\t\tif (source.charAt(i) == '/') {\n\t\t\t\tif (i + 1 < source.length() && source.charAt(i + 1) == '/') {\n\t\t\t\t\ti = source.indexOf(\"\\n\", i + 2);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\ti = source.length();\n\t\t\t\t\t}\n\t\t\t\t} else if (i + 1 < source.length() && source.charAt(i + 1) == '*') {\n\t\t\t\t\ti = source.indexOf(\"*/\", i + 2);\n\t\t\t\t\tif (i == -1) {\n\t\t\t\t\t\ti = source.length();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsb.append(source.charAt(i));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsb.append(source.charAt(i));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1974",
    "source": "leetcode",
    "language": "java",
    "query": "For every (contiguous) subarray sub = [arr[i], arr[i + 1], ..., arr[j] (with i <= j), we take the bitwise OR of all the elements in sub. Results that occur more than once are only counted once in the final answer.",
    "snippets": [
        "\tint countElements(int[] arr) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tfor (int j = i + 1; j < arr.length; j++) {\n\t\t\t\tif ((arr[i] | arr[j]) == (arr[j] | arr[i])) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countBitWiseORs(int[] A) {\n\t\tint n = A.length;\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i] = A[i];\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdp[i] |= dp[j];\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tres += Integer.bitCount(dp[i] & dp[j]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int bitwiseOr(int[] arr){\n\t\tint result = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tresult |= arr[i];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint bitwiseORs(int[] a) {\n\t\tint n = a.length;\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i] = a[i];\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdp[i] |= dp[j];\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres |= dp[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1975",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s which represents an expression, evaluate this expression and return its value. All intermediate results will be in the range of [-231, 231 - 1].",
    "snippets": [
        "\tint evalRPN(String[] tokens) {\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tfor (String token : tokens) {\n\t\t\tif (token.equals(\"+\")) {\n\t\t\t\tstack.push(stack.pop() + stack.pop());\n\t\t\t} else if (token.equals(\"-\")) {\n\t\t\t\tint num2 = stack.pop();\n\t\t\t\tint num1 = stack.pop();\n\t\t\t\tstack.push(num1 - num2);\n\t\t\t} else if (token.equals(\"*\")) {\n\t\t\t\tstack.push(stack.pop() * stack.pop());\n\t\t\t} else if (token.equals(\"/\")) {\n\t\t\t\tint num2 = stack.pop();\n\t\t\t\tint num1 = stack.pop();\n\t\t\t\tstack.push(num1 / num2);\n\t\t\t} else {\n\t\t\t\tstack.push(Integer.parseInt(token));\n\t\t\t}\n\t\t}\n\t\treturn stack.pop();\n\t}\n}\n",
        "\tint evalRPN(String[] tokens) {\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tfor (String token : tokens) {\n\t\t\tif (token.equals(\"+\")) {\n\t\t\t\tstack.push(stack.pop() + stack.pop());\n\t\t\t} else if (token.equals(\"-\")) {\n\t\t\t\tstack.push(-stack.pop() + stack.pop());\n\t\t\t} else if (token.equals(\"*\")) {\n\t\t\t\tstack.push(stack.pop() * stack.pop());\n\t\t\t} else if (token.equals(\"/\")) {\n\t\t\t\tint a = stack.pop();\n\t\t\t\tint b = stack.pop();\n\t\t\t\tstack.push(b / a);\n\t\t\t} else {\n\t\t\t\tstack.push(Integer.parseInt(token));\n\t\t\t}\n\t\t}\n\t\treturn stack.pop();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1976",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 & new2, but all the digits in num must be used.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint num = 1234;\n\t\tint new1 = num/100;\n\t\tint new2 = num%100;\n\t\tSystem.out.println(new1);\n\t\tSystem.out.println(new2);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint num = 1234;\n\t\tint new1 = num/100;\n\t\tint new2 = num%100;\n\t\tSystem.out.println(new1+\" \"+new2);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint num = 1234;\n\t\tint new1 = num/100;\n\t\tint new2 = num%10;\n\t\tSystem.out.println(new1+\" \"+new2);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1977",
    "source": "leetcode",
    "language": "java",
    "query": "Given the root of a binary tree, return the sum of values of its deepest leaves.",
    "snippets": [
        "\tint deepestLeavesSum(TreeNode root) {\n\t\tint sum = 0;\n\t\tint max = 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tif(node.left == null && node.right == null){\n\t\t\t\t\tsum += node.val;\n\t\t\t\t\tmax = Math.max(max, sum);\n\t\t\t\t}\n\t\t\t\tif(node.left != null)\n\t\t\t\t\tqueue.offer(node.left);\n\t\t\t\tif(node.right != null)\n\t\t\t\t\tqueue.offer(node.right);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint deepestLeavesSum(TreeNode root) {\n\t\tint sum = 0;\n\t\tint max = 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tif (node.left == null && node.right == null) {\n\t\t\t\t\tsum += node.val;\n\t\t\t\t\tmax = Math.max(max, sum);\n\t\t\t\t} else {\n\t\t\t\t\tif (node.left != null) {\n\t\t\t\t\t\tqueue.offer(node.left);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.right != null) {\n\t\t\t\t\t\tqueue.offer(node.right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint deepestLeavesSum(TreeNode root) {\n\t\tint sum = 0;\n\t\tint max = 0;\n\t\tint[] res = new int[1];\n\t\thelper(root, res, 0);\n\t\treturn res[0];\n\t}\n\tpublic void helper(TreeNode root, int[] res, int depth) {\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (root.left == null && root.right == null) {\n\t\t\tif (depth > max) {\n\t\t\t\tmax = depth;\n\t\t\t\tres[0] = root.val;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\thelper(root.left, res, depth + 1);\n\t\thelper(root.right, res, depth + 1);\n\t}\n}\n",
        "\tint deepestLeavesSum(TreeNode root){\n\t\tif(root==null) return 0;\n\t\tint[] res=new int[1];\n\t\tdeepestLeavesSum(root,res);\n\t\treturn res[0];\n\t}\n\tpublic void deepestLeavesSum(TreeNode root,int[] res){\n\t\tif(root==null) return;\n\t\tif(root.left==null&&root.right==null){\n\t\t\tres[0]+=root.val;\n\t\t\treturn;\n\t\t}\n\t\tdeepestLeavesSum(root.left,res);\n\t\tdeepestLeavesSum(root.right,res);\n\t}\n}\n",
        "\tint deepestLeavesSum(TreeNode root){\n\t\tint sum = 0;\n\t\tint max = 0;\n\t\tint[] res = new int[1];\n\t\tdeepestLeavesSum(root, res, 0);\n\t\treturn res[0];\n\t}\n\tpublic void deepestLeavesSum(TreeNode root, int[] res, int depth){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null){\n\t\t\tif(depth > max) max = depth;\n\t\t\tres[0] += root.val;\n\t\t}\n\t\tdeepestLeavesSum(root.left, res, depth + 1);\n\t\tdeepestLeavesSum(root.right, res, depth + 1);\n\t}\n}\n",
        "\tint deepestLeavesSum(TreeNode root) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\thelper(root, max, sum);\n\t\treturn sum;\n\t}\n\tpublic void helper(TreeNode root, int max, int sum){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null){\n\t\t\tmax = Math.max(max, root.val);\n\t\t\tsum += root.val;\n\t\t}\n\t\thelper(root.left, max, sum);\n\t\thelper(root.right, max, sum);\n\t}\n}\n",
        "\tint deepestLeavesSum(TreeNode root) {\n\t\tint sum = 0;\n\t\tint max = 0;\n\t\tint[] res = new int[1];\n\t\thelper(root, 0, res);\n\t\treturn res[0];\n\t}\n\tpublic void helper(TreeNode root, int level, int[] res){\n\t\tif(root == null) return;\n\t\tif(level > res[0]){\n\t\t\tres[0] = level;\n\t\t\tsum = 0;\n\t\t}\n\t\tsum += root.val;\n\t\thelper(root.left, level + 1, res);\n\t\thelper(root.right, level + 1, res);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1978",
    "source": "leetcode",
    "language": "java",
    "query": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e., 0 <= i < n). In one operation, you can select two indices x and y where 0 <= x, y < n. The goal is to make all the elements of the array equal.",
    "snippets": [
        "\tvoid equalizeArray(int[] arr){\n\t\tint n = arr.length;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\tint[] count = new int[max + 1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[arr[i]]++;\n\t\t}\n\t\tint i = 0;\n\t\twhile(i < max + 1 && count[i] == 0){\n\t\t\ti++;\n\t\t}\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(arr[j] != i){\n\t\t\t\tarr[j] = i;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid equalizeArray(int[] arr){\n\t\tint n = arr.length;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t}\n\t\tint[] count = new int[max + 1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[arr[i]]++;\n\t\t}\n\t\tfor(int i = 1; i < count.length; i++){\n\t\t\tcount[i] += count[i - 1];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[count[arr[i]] - 1] = i;\n\t\t\tcount[arr[i]]--;\n\t\t}\n\t}\n}\n",
        "\tvoid equalizeArray(int[] arr){\n\t\tint n = arr.length;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t}\n\t\tint[] count = new int[max + 1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[arr[i]]++;\n\t\t}\n\t\tint i = 0;\n\t\tfor(int j = 0; j < max + 1; j++){\n\t\t\twhile(count[j] > 0){\n\t\t\t\tarr[i++] = j;\n\t\t\t\tcount[j]--;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid equalizeArray(int[] arr){\n\t\tint n = arr.length;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t}\n\t\tint[] count = new int[max + 1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[arr[i]]++;\n\t\t}\n\t\tint[] newArr = new int[n];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < max + 1; i++){\n\t\t\twhile(count[i] > 0){\n\t\t\t\tnewArr[index++] = i;\n\t\t\t\tcount[i]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = newArr[i];\n\t\t}\n\t}\n}\n",
        "\tvoid equalizeArray(int[] arr){\n\t\tint n = arr.length;\n\t\tint max = 0;\n\t\tint min = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t\tif(arr[i] < min){\n\t\t\t\tmin = arr[i];\n\t\t\t}\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = arr[i] + diff;\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9,10};\n\t\tint n = arr.length;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint count = 0;\n\t\twhile(count < n){\n\t\t\tx = (int)(Math.random() * n);\n\t\t\ty = (int)(Math.random() * n);\n\t\t\tif(arr[x] != arr[y]){\n\t\t\t\tint temp = arr[x];\n\t\t\t\tarr[x] = arr[y];\n\t\t\t\tarr[y] = temp;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tvoid equalizeArray(int[] arr){\n\t\tint n = arr.length;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmin = Math.min(min, arr[i]);\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tif(diff == 0) return;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = arr[i] + diff;\n\t\t}\n\t}\n}\n",
        "\tvoid equalizeArray(int[] arr){\n\t\tint n = arr.length;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmin = Math.min(min, arr[i]);\n\t\t\tmax = Math.max(max, arr[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tif(diff == 0) return;\n\t\tint[] count = new int[diff + 1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[arr[i] - min]++;\n\t\t}\n\t\tint j = 0;\n\t\tfor(int i = 0; i < diff + 1; i++){\n\t\t\twhile(count[i] > 0){\n\t\t\t\tarr[j++] = i + min;\n\t\t\t\tcount[i]--;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] arr = {1,3,5,7,9,11,13,15};\n\t\tint n = arr.length;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint temp = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(arr[i] > temp){\n\t\t\t\ttemp = arr[i];\n\t\t\t\tx = i;\n\t\t\t}\n\t\t}\n\t\ttemp = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(arr[i] > temp){\n\t\t\t\ttemp = arr[i];\n\t\t\t\ty = i;\n\t\t\t}\n\t\t}\n\t\tif(x != y){\n\t\t\tarr[x] = arr[y];\n\t\t\tarr[y] = temp;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1979",
    "source": "leetcode",
    "language": "java",
    "query": "Each element is either an integer or a list whose elements may also be integers or other lists. Given a string s represents the serialization of a nested list, implement a parser to deserialize it.",
    "snippets": [
        "\tstatic class NestedInteger{\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic List<NestedInteger> getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedList extends NestedInteger{\n\t\tprivate List<NestedInteger> list;\n\t\tpublic NestedList(List<NestedInteger> list){\n\t\t\tthis.list = list;\n\t\t}\n\t\tpublic List<NestedInteger> getList(){\n\t\t\treturn list;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t}\n\tpublic static class NestedIntegerInt extends NestedInteger{\n\t\tprivate int value;\n\t\tpublic NestedIntegerInt(int value){\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn value;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn true;\n\t\t}\n\t}\n\tpublic static NestedInteger deserialize(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tif(s.charAt(0) == '['){\n\t\t\treturn deserializeList(s);\n\t\t}\n\t\treturn deserializeInt(s);\n\t}\n\tpublic static NestedInteger deserializeInt(String s){\n\t\tint start = 0;\n\t\tint end = s.length();\n\t\twhile(start < end && s.charAt(start) == '-'){\n\t\t\tstart++;\n\t\t}\n\t\twhile(start < end && s.charAt(end - 1) == '0'){\n\t\t\tend--;\n\t\t}\n\t\tif(start == end){\n\t\t\treturn new NestedIntegerInt(0);\n\t\t}\n\t\tint value = 0;\n",
        "\tstatic class NestedInteger{\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic List<NestedInteger> getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static NestedInteger deserialize(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tStack<NestedInteger> stack = new Stack<NestedInteger>();\n\t\tNestedInteger cur = new NestedInteger();\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '['){\n\t\t\t\tstack.push(cur);\n\t\t\t\tcur = new NestedInteger();\n\t\t\t}else if(s.charAt(i) == ']'){\n\t\t\t\tNestedInteger pre = stack.pop();\n\t\t\t\tpre.add(cur);\n\t\t\t\tcur = pre;\n\t\t\t}else if(s.charAt(i) == ','){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tint start = i;\n\t\t\t\twhile(i < s.length() && s.charAt(i) != ',' && s.charAt(i) != ']'){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tString num = s.substring(start, i);\n\t\t\t\tcur.add(new NestedInteger(Integer.parseInt(num)));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn cur;\n\t}\n\tpublic static void main(String[] args){\n\t\tString s = \"[1,[2,3],4]\";\n\t\tNestedInteger ni = deserialize(s);\n\t\tSystem.out.println(ni.getInteger());\n\t\tSystem.out.println(ni.isInteger());\n\t\tSystem.out.println(ni.getList().\n",
        "\tstatic class NestedInteger{\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic List<NestedInteger> getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedList extends NestedInteger{\n\t\tpublic List<NestedInteger> list;\n\t\tpublic NestedList(List<NestedInteger> list){\n\t\t\tthis.list = list;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic List<NestedInteger> getList(){\n\t\t\treturn list;\n\t\t}\n\t}\n\tpublic static class NestedIntegerInteger extends NestedInteger{\n\t\tpublic int value;\n\t\tpublic NestedIntegerInteger(int value){\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn value;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn true;\n\t\t}\n\t\tpublic List<NestedInteger> getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static NestedInteger deserialize(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tif(s.charAt(0) == '['){\n\t\t\treturn deserializeList(s);\n\t\t}\n\t\treturn deserializeInteger(s);\n\t}\n\tpublic static NestedInteger deserializeInteger(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tint i = 0;\n\t\twhile(i < s.length() && s.charAt(i) != '-'){\n\t\t\ti++;\n\t\t}\n\t\tif(i == s.length()){\n\t\t\treturn new NestedIntegerInteger(Integer\n",
        "\tstatic class NestedInteger{\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedList extends NestedInteger{\n\t\tprivate List<NestedInteger> list;\n\t\tpublic NestedList(){\n\t\t\tlist = new ArrayList<NestedInteger>();\n\t\t}\n\t\tpublic void add(NestedInteger ni){\n\t\t\tlist.add(ni);\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn this;\n\t\t}\n\t}\n\tpublic static class NestedIntegerInteger extends NestedInteger{\n\t\tprivate int value;\n\t\tpublic NestedIntegerInteger(int value){\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn value;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn true;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedIntegerList extends NestedInteger{\n\t\tprivate List<NestedInteger> list;\n\t\tpublic NestedIntegerList(){\n\t\t\tlist = new ArrayList<NestedInteger>();\n\t\t}\n\t\tpublic void add(NestedInteger ni){\n\t\t\tlist.add(ni);\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn this;\n\t\t}\n\t}\n\tpublic static NestedInteger deserialize(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn null;\n",
        "\tstatic class NestedInteger{\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedList extends NestedInteger{\n\t\tprivate List<NestedInteger> list;\n\t\tpublic NestedList(List<NestedInteger> list){\n\t\t\tthis.list = list;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedIntegerInteger extends NestedInteger{\n\t\tprivate int value;\n\t\tpublic NestedIntegerInteger(int value){\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn value;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn true;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedIntegerList extends NestedInteger{\n\t\tprivate List<NestedInteger> list;\n\t\tpublic NestedIntegerList(List<NestedInteger> list){\n\t\t\tthis.list = list;\n\t\t}\n\t\tpublic int getInteger(){\n\t\t\treturn 0;\n\t\t}\n\t\tpublic boolean isInteger(){\n\t\t\treturn false;\n\t\t}\n\t\tpublic NestedInteger getList(){\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static NestedInteger deserialize(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tif(s.charAt(0) == '['){\n\t\t\tList<NestedInteger> list = new ArrayList<NestedInteger>();\n\t\t\tint i =\n",
        "\tstatic class NestedInteger {\n\t\tpublic int getInteger() {\n\t\t\treturn 0;\n\t\t}\n\t\tpublic void add(NestedInteger ni) {\n\t\t}\n\t\tpublic void setInteger(int value) {\n\t\t}\n\t\tpublic boolean isInteger() {\n\t\t\treturn false;\n\t\t}\n\t};\n\tpublic static class NestedList {\n\t\tpublic List<NestedInteger> getList() {\n\t\t\treturn null;\n\t\t}\n\t};\n\tpublic static class NestedListParser {\n\t\tpublic NestedList parse(String s) {\n\t\t\treturn null;\n\t\t}\n\t};\n}\n",
        "\tstatic class NestedInteger {\n\t\tpublic int getInteger() {\n\t\t\treturn 0;\n\t\t}\n\t\tpublic void add(NestedInteger ni) {\n\t\t}\n\t\tpublic void setInteger(int value) {\n\t\t}\n\t\tpublic List<NestedInteger> getList() {\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedListInteger extends NestedInteger {\n\t\tList<NestedInteger> list;\n\t\tpublic NestedListInteger(List<NestedInteger> list) {\n\t\t\tthis.list = list;\n\t\t}\n\t\tpublic List<NestedInteger> getList() {\n\t\t\treturn list;\n\t\t}\n\t}\n\tpublic static class NestedIntegerInteger extends NestedInteger {\n\t\tint value;\n\t\tpublic NestedIntegerInteger(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic int getInteger() {\n\t\t\treturn value;\n\t\t}\n\t}\n\tpublic static NestedInteger deserialize(String s) {\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (s.charAt(0) == '[') {\n\t\t\treturn deserializeList(s);\n\t\t} else {\n\t\t\treturn deserializeInteger(s);\n\t\t}\n\t}\n\tpublic static NestedInteger deserializeInteger(String s) {\n\t\tint i = 0;\n\t\twhile (i < s.length() && s.charAt(i) != '-') {\n\t\t\ti++;\n\t\t}\n\t\tif (i == s.length()) {\n\t\t\treturn new NestedIntegerInteger(Integer.parseInt(s));\n\t\t} else {\n\t\t\treturn new NestedIntegerInteger(Integer.parseInt(s.substring(0, i)));\n\t\t}\n\t}\n\tpublic static NestedInteger deserializeList(String s) {\n\t\tint i = 1;\n\t\tList<NestedInteger>\n",
        "\tstatic class NestedInteger {\n\t\tpublic int getInteger() {\n\t\t\treturn 0;\n\t\t}\n\t\tpublic void add(NestedInteger ni) {\n\t\t}\n\t\tpublic void setInteger(int value) {\n\t\t}\n\t\tpublic List<NestedInteger> getList() {\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedListIterator {\n\t\tpublic NestedListIterator(List<NestedInteger> nestedList) {\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\treturn false;\n\t\t}\n\t\tpublic NestedInteger next() {\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static NestedListIterator deserialize(String s) {\n\t\treturn null;\n\t}\n}\n",
        "\tstatic class NestedInteger {\n\t\tpublic int getInteger() {\n\t\t\treturn 0;\n\t\t}\n\t\tpublic NestedInteger getList() {\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedIntegerImpl extends NestedInteger {\n\t\tprivate int value;\n\t\tpublic NestedIntegerImpl(int value) {\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic int getInteger() {\n\t\t\treturn value;\n\t\t}\n\t\tpublic NestedInteger getList() {\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedIntegerList extends NestedInteger {\n\t\tprivate List<NestedInteger> list;\n\t\tpublic NestedIntegerList(List<NestedInteger> list) {\n\t\t\tthis.list = list;\n\t\t}\n\t\tpublic int getInteger() {\n\t\t\treturn 0;\n\t\t}\n\t\tpublic NestedInteger getList() {\n\t\t\treturn this;\n\t\t}\n\t}\n\tpublic static NestedInteger deserialize(String s) {\n\t\tif (s == null || s.length() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tStack<NestedInteger> stack = new Stack<NestedInteger>();\n\t\tint i = 0;\n\t\twhile (i < s.length()) {\n\t\t\tif (s.charAt(i) == '[') {\n\t\t\t\tstack.push(new NestedIntegerList(new ArrayList<NestedInteger>()));\n\t\t\t} else if (s.charAt(i) == '-') {\n\t\t\t\ti++;\n\t\t\t\tint j = i;\n\t\t\t\twhile (j < s.length() && s.charAt(j) >= '0' && s.charAt(j) <= '9') {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tstack.push(new NestedIntegerImpl(Integer.parseInt(s.substring(i, j))));\n\t\t\t\ti = j\n",
        "\tstatic class NestedInteger {\n\t\tpublic int getInteger() {\n\t\t\treturn 0;\n\t\t}\n\t\tpublic NestedInteger getList() {\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static class NestedList {\n\t\tpublic List<NestedInteger> getList() {\n\t\t\treturn null;\n\t\t}\n\t}\n\tpublic static NestedList deserialize(String s) {\n\t\treturn null;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1980",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible. Return the maximum number of instances that can be formed.",
    "snippets": [
        "\tint maxNumberOfBalloons(String text) {\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < text.length(); i++){\n\t\t\tcount[text.charAt(i) - 'a']++;\n\t\t}\n\t\tint countBalloon = 0;\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] >= 2){\n\t\t\t\tcountBalloon += count[i] / 2;\n\t\t\t}\n\t\t}\n\t\treturn countBalloon;\n\t}\n}\n",
        "\tint maxNumberOfBalloons(String text) {\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < text.length(); i++){\n\t\t\tcount[text.charAt(i) - 'a']++;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] >= 3){\n\t\t\t\tres += count[i] / 3;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxNumberOfBalloons(String text) {\n\t\tint[] count = new int[26];\n\t\tfor(char c : text.toCharArray()){\n\t\t\tcount[c - 'a']++;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] >= 3){\n\t\t\t\tcount[i] -= 3;\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxNumberOfBalloons(String text) {\n\t\tint[] count = new int[26];\n\t\tfor(char c : text.toCharArray()){\n\t\t\tcount[c-'a']++;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] >= 2 && count[i] % 2 == 0){\n\t\t\t\tres += count[i] / 2;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxNumberOfBalloons(String text) {\n\t\tint[] count = new int[26];\n\t\tfor(char c : text.toCharArray()){\n\t\t\tcount[c - 'a']++;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] >= \"balloon\".length()){\n\t\t\t\tres++;\n\t\t\t\tcount[i] -= \"balloon\".length();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxNumberOfBalloons(String text) {\n\t\tint count = 0;\n\t\tint len = text.length();\n\t\tint[] map = new int[26];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tmap[text.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(map[i] >= 2){\n\t\t\t\tcount += map[i] / 2;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int maxNumberOfBalloons(String text) {\n\t\tint count = 0;\n\t\tint balloon = 0;\n\t\tint balloon1 = 0;\n\t\tint balloon2 = 0;\n\t\tint balloon3 = 0;\n\t\tint balloon4 = 0;\n\t\tint balloon5 = 0;\n\t\tint balloon6 = 0;\n\t\tint balloon7 = 0;\n\t\tint balloon8 = 0;\n\t\tint balloon9 = 0;\n\t\tint balloon10 = 0;\n\t\tint balloon11 = 0;\n\t\tint balloon12 = 0;\n\t\tint balloon13 = 0;\n\t\tint balloon14 = 0;\n\t\tint balloon15 = 0;\n\t\tint balloon16 = 0;\n\t\tint balloon17 = 0;\n\t\tint balloon18 = 0;\n\t\tint balloon19 = 0;\n\t\tint balloon20 = 0;\n\t\tint balloon21 = 0;\n\t\tint balloon22 = 0;\n\t\tint balloon23 = 0;\n\t\tint balloon24 = 0;\n\t\tint balloon25 = 0;\n\t\tint balloon26 = 0;\n\t\tint balloon27 = 0;\n\t\tint balloon28 = 0;\n\t\tint balloon29 = 0;\n\t\tint balloon30 = 0;\n\t\tint balloon31 = 0;\n\t\tint balloon32 = 0;\n\t\tint balloon33 = 0;\n\t\tint balloon34 = 0;\n\t\tint balloon35 = 0;\n\t\tint balloon36 = 0;\n\t\tint balloon37 = 0;\n\t\tint balloon38 = 0;\n\t\tint balloon39 = 0;\n\t\tint balloon40 = 0;\n\t\tint balloon41 = 0;\n\t\tint balloon42 = 0;\n\t\tint balloon43 = 0;\n\t\tint balloon44 = 0;\n\t\tint balloon45 = 0;\n\t\tint balloon46 = 0;\n\t\tint balloon47 = 0;\n\t\tint balloon48 = 0;\n\t\tint balloon49 = 0;\n\t\tint balloon50 = 0;\n\t\tint balloon51 = 0;\n\t\tint balloon52 = 0;\n"
    ],
    "results": 10
},{
    "id": "1981",
    "source": "leetcode",
    "language": "java",
    "query": "The answer is guaranteed to fit into a signed 32-bit integer. You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.",
    "snippets": [
        "\tint coinChange(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = amount + 1;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (coins[j] <= i) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount] > amount ? -1 : dp[amount];\n\t}\n}\n",
        "\tint coinChange(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (i >= coins[j]) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];\n\t}\n}\n",
        "\tint coinChange(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (i >= coins[j] && dp[i - coins[j]] != Integer.MAX_VALUE) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1982",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement. If there multiple valid answers, return any of them.",
    "snippets": [
        "\tList<Integer> constructArray(int n, int k) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 1;\n\t\tint j = n;\n\t\twhile(i<=j){\n\t\t\tif(k>0){\n\t\t\t\tlist.add(i);\n\t\t\t\ti++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> constructArray(int n, int k) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 1;\n\t\tint j = n;\n\t\twhile(i <= j){\n\t\t\tif(k > 0){\n\t\t\t\tlist.add(i);\n\t\t\t\ti++;\n\t\t\t\tk--;\n\t\t\t}else{\n\t\t\t\tlist.add(j);\n\t\t\t\tj--;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> constructArray(int n, int k) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tint i = 1;\n\t\tint j = n;\n\t\twhile(i <= j){\n\t\t\tif(k > 0){\n\t\t\t\tlist.add(i);\n\t\t\t\ti++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> constructArray(int n, int k) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tint i = 1;\n\t\tint j = n;\n\t\twhile(k > 0){\n\t\t\tif(k % 2 == 1){\n\t\t\t\tlist.add(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t\twhile(i <= j){\n\t\t\tlist.add(i);\n\t\t\ti++;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> constructArray(int n, int k) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 1;\n\t\tint j = n;\n\t\twhile(i<=j){\n\t\t\tif(k>1){\n\t\t\t\tlist.add(i);\n\t\t\t\ti++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> constructArray(int n, int k) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tint start = 1;\n\t\tint end = n;\n\t\tint count = n - k;\n\t\twhile(count > 0){\n\t\t\tlist.add(start);\n\t\t\tlist.add(end);\n\t\t\tstart++;\n\t\t\tend--;\n\t\t\tcount--;\n\t\t}\n\t\tif(count == 0){\n\t\t\tlist.add(start);\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> constructArray(int n, int k) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 0;\n\t\tint j = n;\n\t\twhile(i < j){\n\t\t\tif(k % 2 == 0){\n\t\t\t\tlist.add(i + 1);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(j);\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t\treturn list;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1983",
    "source": "leetcode",
    "language": "java",
    "query": "Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.",
    "snippets": [
        "\tint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n\t\tint area1 = (C - A) * (D - B);\n\t\tint area2 = (G - E) * (H - F);\n\t\tint x = Math.max(A, E);\n\t\tint y = Math.max(B, F);\n\t\tint w = Math.min(C, G);\n\t\tint h = Math.min(D, H);\n\t\tint area3 = (w - x) * (h - y);\n\t\treturn area1 + area2 - area3;\n\t}\n}\n",
        "\tint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n\t\tint area1 = (C - A) * (D - B);\n\t\tint area2 = (G - E) * (H - F);\n\t\tint x = Math.max(A, E);\n\t\tint y = Math.max(B, F);\n\t\tint w = Math.min(C, G);\n\t\tint h = Math.min(D, H);\n\t\tint overlap = 0;\n\t\tif (w > x && h > y) {\n\t\t\toverlap = (w - x) * (h - y);\n\t\t}\n\t\treturn area1 + area2 - overlap;\n\t}\n}\n",
        "\tint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n\t\tint area1 = (C - A) * (D - B);\n\t\tint area2 = (G - E) * (H - F);\n\t\tint x = Math.max(A, E);\n\t\tint y = Math.max(B, F);\n\t\tint w = Math.min(C, G);\n\t\tint h = Math.min(D, H);\n\t\tint overlap = 0;\n\t\tif (x < w && y < h) {\n\t\t\toverlap = (w - x) * (h - y);\n\t\t}\n\t\treturn area1 + area2 - overlap;\n\t}\n}\n",
        "\tint rectangleArea(int A, int B, int C, int D, int E, int F, int G, int H) {\n\t\tint area1 = (C - A) * (D - B);\n\t\tint area2 = (G - E) * (H - F);\n\t\tint area3 = (C - A) * (H - F);\n\t\tint area4 = (G - E) * (D - B);\n\t\treturn area1 + area2 - area3 - area4;\n\t}\n}\n",
        "\tint rectangleArea(int[] a, int[] b) {\n\t\tint x1 = a[0];\n\t\tint y1 = a[1];\n\t\tint x2 = b[0];\n\t\tint y2 = b[1];\n\t\treturn (x2-x1)*(y2-y1);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1984",
    "source": "leetcode",
    "language": "java",
    "query": "The average value of a set of k numbers is the sum of the numbers divided by k. You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint k = Integer.parseInt(args[2]);\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tb[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tint avg = sum/n;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(b[i] >= avg){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count/m);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint k = Integer.parseInt(args[2]);\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random() * 6) + 1;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tb[i] = (int)(Math.random() * 6) + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tint avg = sum / n;\n\t\tint sum2 = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tsum2 += b[i];\n\t\t}\n\t\tint avg2 = sum2 / m;\n\t\tint sum3 = 0;\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tsum3 += a[i];\n\t\t}\n\t\tint avg3 = sum3 / k;\n\t\tSystem.out.println(\"The average value of a set of k numbers is the sum of the numbers divided by k.\");\n\t\tSystem.out.println(\"You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6.\");\n\t\tSystem.out.println(\"n of the observations went missing, and you only have the observations of m rolls.\");\n\t\tSystem.out.println(\"n = \" + n);\n\t\tSystem.out.println(\"m = \" + m);\n\t\tSystem.out.println(\"k = \" + k);\n\t\tSystem.out.println(\"a = \" + Arrays.toString(a));\n\t\tSystem.out.println(\"b = \" + Arrays.toString(b));\n\t\tSystem.out\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint k = Integer.parseInt(args[2]);\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tb[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tint[] c = new int[k];\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tc[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tsum += b[i];\n\t\t}\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tsum += c[i];\n\t\t}\n\t\tSystem.out.println(sum/(n+m+k));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint k = Integer.parseInt(args[2]);\n\t\tint[] dice = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tdice[i] = (int)(Math.random() * 6) + 1;\n\t\t}\n\t\tint[] missing = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmissing[i] = (int)(Math.random() * m) + 1;\n\t\t}\n\t\tint[] missingDice = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmissingDice[i] = dice[missing[i] - 1];\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tsum += dice[i];\n\t\t}\n\t\tdouble average = (double)sum / m;\n\t\tdouble missingAverage = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmissingAverage += missingDice[i];\n\t\t}\n\t\tmissingAverage = (double)missingAverage / n;\n\t\tSystem.out.println(\"The average value of a set of k numbers is \" + average);\n\t\tSystem.out.println(\"The average value of the missing numbers is \" + missingAverage);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint k = Integer.parseInt(args[2]);\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tb[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tint avg = sum/n;\n\t\tint sum2 = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tsum2 += b[i];\n\t\t}\n\t\tint avg2 = sum2/m;\n\t\tSystem.out.println(\"The average value of a set of k numbers is the sum of the numbers divided by k.\");\n\t\tSystem.out.println(\"You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6.\");\n\t\tSystem.out.println(\"n of the observations went missing, and you only have the observations of m rolls.\");\n\t\tSystem.out.println(\"n = \" + n);\n\t\tSystem.out.println(\"m = \" + m);\n\t\tSystem.out.println(\"k = \" + k);\n\t\tSystem.out.println(\"a = \" + Arrays.toString(a));\n\t\tSystem.out.println(\"b = \" + Arrays.toString(b));\n\t\tSystem.out.println(\"The average value of a set of k numbers is the sum of the numbers divided by k.\");\n\t\tSystem.out.println(\"You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6.\"\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint k = Integer.parseInt(args[2]);\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tb[i] = (int)(Math.random()*6) + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tint avg = sum/n;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(b[i] == avg){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"The average value of a set of k numbers is \" + avg);\n\t\tSystem.out.println(\"The number of times the average value appears in the set of m numbers is \" + count);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint m = 6;\n\t\tint k = n + m;\n\t\tint[] a = new int[k];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random() * 6) + 1;\n\t\t}\n\t\tfor(int i = n; i < k; i++){\n\t\t\ta[i] = (int)(Math.random() * 6) + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tdouble average = (double)sum / k;\n\t\tSystem.out.println(\"The average value of a set of k numbers is \" + average);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 6;\n\t\tint m = 6;\n\t\tint k = n + m;\n\t\tint[] a = new int[n];\n\t\tint[] b = new int[m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random() * 6) + 1;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tb[i] = (int)(Math.random() * 6) + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tsum += b[i];\n\t\t}\n\t\tdouble average = (double)sum / k;\n\t\tSystem.out.println(\"The average value of a set of k numbers is \" + average);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1985",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary string s, return the number of substrings with all characters 1's. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "\tint countBinarySubstrings(String s) {\n\t\tint count = 0;\n\t\tint len = s.length();\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tint j = i + 1;\n\t\t\twhile(j < len && s.charAt(i) == s.charAt(j)){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tcount += j - i;\n\t\t\ti = j - 1;\n\t\t}\n\t\treturn count % 1000000007;\n\t}\n}\n",
        "\tint countBinarySubstrings(String s) {\n\t\tint count = 0;\n\t\tint len = s.length();\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tint j = i + 1;\n\t\t\twhile(j < len && s.charAt(i) == s.charAt(j)){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tcount += j - i - 1;\n\t\t\ti = j - 1;\n\t\t}\n\t\treturn count % 1000000007;\n\t}\n}\n",
        "\tint countSubstrings(String s) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount += check(s, i, i);\n\t\t\tcount += check(s, i, i+1);\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic int check(String s, int left, int right){\n\t\tint count = 0;\n\t\twhile(left >= 0 && right < s.length() && s.charAt(left) == '1' && s.charAt(right) == '1'){\n\t\t\tcount++;\n\t\t\tleft--;\n\t\t\tright++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSubstrings(String s) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount += countSubstrings(s, i, i);\n\t\t\tcount += countSubstrings(s, i, i + 1);\n\t\t}\n\t\treturn count;\n\t}\n\tprivate int countSubstrings(String s, int left, int right){\n\t\tint count = 0;\n\t\twhile(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){\n\t\t\tcount++;\n\t\t\tleft--;\n\t\t\tright++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSubstrings(String s) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount += countCenter(s, i);\n\t\t\tcount += countRight(s, i);\n\t\t}\n\t\treturn count % ((int)1e9 + 7);\n\t}\n\tpublic int countCenter(String s, int i){\n\t\tint count = 0;\n\t\tfor(int j = i; j < s.length(); j++){\n\t\t\tif(s.charAt(j) == '1'){\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic int countRight(String s, int i){\n\t\tint count = 0;\n\t\tfor(int j = i; j >= 0; j--){\n\t\t\tif(s.charAt(j) == '1'){\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1986",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "\tint splitString(String s){\n\t\tint len = s.length();\n\t\tint[] dp = new int[len+1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor(int i = 2; i <= len; i++){\n\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\tdp[i] += dp[j] * dp[i-j];\n\t\t\t\tdp[i] %= 1000000007;\n\t\t\t}\n\t\t}\n\t\treturn dp[len];\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint n = s.length();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tString s1 = s.substring(0, i);\n\t\t\tif (s1.length() > 1 && s1.charAt(0) == '0')\n\t\t\t\tcontinue;\n\t\t\tlong l1 = Long.parseLong(s1);\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tString s2 = s.substring(i, j);\n\t\t\t\tif (s2.length() > 1 && s2.charAt(0) == '0')\n\t\t\t\t\tcontinue;\n\t\t\t\tlong l2 = Long.parseLong(s2);\n\t\t\t\tString s3 = s.substring(j);\n\t\t\t\tif (s3.length() > 1 && s3.charAt(0) == '0')\n\t\t\t\t\tcontinue;\n\t\t\t\tlong l3 = Long.parseLong(s3);\n\t\t\t\tif (l1 + l2 == l3) {\n\t\t\t\t\tif (l1 > Integer.MAX_VALUE || l2 > Integer.MAX_VALUE || l3 > Integer.MAX_VALUE)\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\treturn (int) (l1 % 1000000007);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint n = s.length();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tString s1 = s.substring(0, i);\n\t\t\tif (s1.length() > 1 && s1.charAt(0) == '0')\n\t\t\t\tcontinue;\n\t\t\tlong num1 = Long.parseLong(s1);\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tString s2 = s.substring(i, j);\n\t\t\t\tif (s2.length() > 1 && s2.charAt(0) == '0')\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num2 = Long.parseLong(s2);\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tString s3 = s.substring(j, k);\n\t\t\t\t\tif (s3.length() > 1 && s3.charAt(0) == '0')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tlong num3 = Long.parseLong(s3);\n\t\t\t\t\tif (num1 + num2 == num3) {\n\t\t\t\t\t\tif (num1 < 0 || num2 < 0 || num3 < 0)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (num1 > Integer.MAX_VALUE || num2 > Integer.MAX_VALUE || num3 > Integer.MAX_VALUE)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\treturn (int) (num1 % 1000000007);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint n = s.length();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tString s1 = s.substring(0, i);\n\t\t\t\tString s2 = s.substring(i, j);\n\t\t\t\tString s3 = s.substring(j);\n\t\t\t\tif (s1.length() > 1 && s2.length() > 1 && s3.length() > 1 && isFibonacci(s1) && isFibonacci(s2) && isFibonacci(s3)) {\n\t\t\t\t\treturn s1.hashCode() + s2.hashCode() + s3.hashCode() % 1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic boolean isFibonacci(String s) {\n\t\tif (s.length() == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tint n = s.length();\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tif (dp[i] == Integer.parseInt(s.substring(0, i))) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint n = s.length();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tString s1 = s.substring(0, i);\n\t\t\t\tString s2 = s.substring(i, i + j);\n\t\t\t\tString s3 = s.substring(i + j);\n\t\t\t\tif (s1.length() > 1 && s2.length() > 1 && s3.length() > 1 && s1.charAt(0) == '0' || s2.charAt(0) == '0' || s3.charAt(0) == '0')\n\t\t\t\t\tcontinue;\n\t\t\t\tlong x1 = Long.parseLong(s1);\n\t\t\t\tlong x2 = Long.parseLong(s2);\n\t\t\t\tlong x3 = Long.parseLong(s3);\n\t\t\t\tif (x1 + x2 == x3 && x2 + x3 == x1)\n\t\t\t\t\treturn (int) (x1 % 1000000007);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint n = s.length();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tString s1 = s.substring(0, i);\n\t\t\tif (s1.length() > 1 && s1.charAt(0) == '0') return 0;\n\t\t\tlong num1 = Long.parseLong(s1);\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tString s2 = s.substring(i, j);\n\t\t\t\tif (s2.length() > 1 && s2.charAt(0) == '0') return 0;\n\t\t\t\tlong num2 = Long.parseLong(s2);\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tString s3 = s.substring(j, k);\n\t\t\t\t\tif (s3.length() > 1 && s3.charAt(0) == '0') return 0;\n\t\t\t\t\tlong num3 = Long.parseLong(s3);\n\t\t\t\t\tif (num1 + num2 == num3) {\n\t\t\t\t\t\tif (num3 >= Math.pow(2, 31)) return 0;\n\t\t\t\t\t\treturn (int) (num3 % 1000000007);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint n = s.length();\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tString s1 = s.substring(0, i);\n\t\t\t\tString s2 = s.substring(i, j);\n\t\t\t\tString s3 = s.substring(j);\n\t\t\t\tif (isFibonacci(s1) && isFibonacci(s2) && isFibonacci(s3)) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic boolean isFibonacci(String s) {\n\t\tint n = s.length();\n\t\tif (n <= 1) {\n\t\t\treturn true;\n\t\t}\n\t\tint i = 0;\n\t\tint j = 1;\n\t\tint k = 2;\n\t\twhile (k < n) {\n\t\t\tif (s.charAt(i) != s.charAt(j) || s.charAt(i) != s.charAt(k)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint len = s.length();\n\t\tfor (int i = 1; i < len - 1; i++) {\n\t\t\tfor (int j = i + 1; j < len; j++) {\n\t\t\t\tString s1 = s.substring(0, i);\n\t\t\t\tString s2 = s.substring(i, j);\n\t\t\t\tString s3 = s.substring(j);\n\t\t\t\tif (isFibonacci(s1) && isFibonacci(s2) && isFibonacci(s3)) {\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic boolean isFibonacci(String s) {\n\t\tif (s.length() == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (s.length() == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tint len = s.length();\n\t\tint i = 0;\n\t\tint j = 1;\n\t\tint k = 2;\n\t\twhile (k < len) {\n\t\t\tif (s.substring(i, j).equals(s.substring(j, k))) {\n\t\t\t\ti = j;\n\t\t\t\tj = k;\n\t\t\t\tk++;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint len = s.length();\n\t\tfor (int i = 1; i < len; i++) {\n\t\t\tfor (int j = 1; j < len; j++) {\n\t\t\t\tString s1 = s.substring(0, i);\n\t\t\t\tString s2 = s.substring(i, i + j);\n\t\t\t\tString s3 = s.substring(i + j);\n\t\t\t\tif (s1.length() > 1 && s2.length() > 1 && s3.length() > 1 && s1.charAt(0) == '0' || s2.charAt(0) == '0' || s3.charAt(0) == '0')\n\t\t\t\t\tcontinue;\n\t\t\t\tlong num1 = Long.parseLong(s1);\n\t\t\t\tlong num2 = Long.parseLong(s2);\n\t\t\t\tlong num3 = Long.parseLong(s3);\n\t\t\t\tif (num1 + num2 == num3 && num1 < Integer.MAX_VALUE && num2 < Integer.MAX_VALUE && num3 < Integer.MAX_VALUE)\n\t\t\t\t\treturn (int) (num1 % 1000000007);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint splitIntoFibonacci(String s) {\n\t\tint len = s.length();\n\t\tfor(int i = 1; i < len; i++){\n\t\t\tString s1 = s.substring(0, i);\n\t\t\tif(s1.length() > 1 && s1.charAt(0) == '0') return 0;\n\t\t\tlong num1 = Long.parseLong(s1);\n\t\t\tfor(int j = i + 1; j < len; j++){\n\t\t\t\tString s2 = s.substring(i, j);\n\t\t\t\tif(s2.length() > 1 && s2.charAt(0) == '0') return 0;\n\t\t\t\tlong num2 = Long.parseLong(s2);\n\t\t\t\tfor(int k = j + 1; k < len; k++){\n\t\t\t\t\tString s3 = s.substring(j, k);\n\t\t\t\t\tif(s3.length() > 1 && s3.charAt(0) == '0') return 0;\n\t\t\t\t\tlong num3 = Long.parseLong(s3);\n\t\t\t\t\tif(num1 + num2 == num3){\n\t\t\t\t\t\tif(num1 < Integer.MAX_VALUE && num2 < Integer.MAX_VALUE && num3 < Integer.MAX_VALUE) return 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1987",
    "source": "leetcode",
    "language": "java",
    "query": "Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store.",
    "snippets": [
        "\tint maxArea(int[] height) {\n\t\tint max = 0;\n\t\tint i = 0;\n\t\tint j = height.length - 1;\n\t\twhile (i < j) {\n\t\t\tmax = Math.max(max, Math.min(height[i], height[j]) * (j - i));\n\t\t\tif (height[i] < height[j]) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int[] height) {\n\t\tint max = 0;\n\t\tint left = 0;\n\t\tint right = height.length - 1;\n\t\twhile (left < right) {\n\t\t\tint area = Math.min(height[left], height[right]) * (right - left);\n\t\t\tmax = Math.max(max, area);\n\t\t\tif (height[left] < height[right]) {\n\t\t\t\tleft++;\n\t\t\t} else {\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int[] height) {\n\t\tint max = 0;\n\t\tint left = 0;\n\t\tint right = height.length - 1;\n\t\twhile (left < right) {\n\t\t\tint area = (right - left) * Math.min(height[left], height[right]);\n\t\t\tmax = Math.max(max, area);\n\t\t\tif (height[left] < height[right]) {\n\t\t\t\tleft++;\n\t\t\t} else {\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxArea(int[] height) {\n\t\tint max = 0;\n\t\tint left = 0;\n\t\tint right = height.length - 1;\n\t\twhile (left < right) {\n\t\t\tmax = Math.max(max, Math.min(height[left], height[right]) * (right - left));\n\t\t\tif (height[left] < height[right]) {\n\t\t\t\tleft++;\n\t\t\t} else {\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxArea(int[] height) {\n\t\tint max = 0;\n\t\tint i = 0;\n\t\tint j = height.length - 1;\n\t\twhile (i < j) {\n\t\t\tint area = Math.min(height[i], height[j]) * (j - i);\n\t\t\tmax = Math.max(max, area);\n\t\t\tif (height[i] < height[j]) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1988",
    "source": "leetcode",
    "language": "java",
    "query": "We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked.",
    "snippets": [
        "\tint guessNumber(int n){\n\t\tint start = 1;\n\t\tint end = n;\n\t\twhile(start <= end){\n\t\t\tint mid = (start + end) / 2;\n\t\t\tif(guess(mid) == 0){\n\t\t\t\treturn mid;\n\t\t\t}else if(guess(mid) == -1){\n\t\t\t\tend = mid - 1;\n\t\t\t}else{\n\t\t\t\tstart = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic\n\tint guess(int num){\n\t\treturn 0;\n\t}\n}\n",
        "\tint guessNumber(int n) {\n\t\tint left = 1;\n\t\tint right = n;\n\t\twhile(left <= right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(guess(mid) == 0){\n\t\t\t\treturn mid;\n\t\t\t}else if(guess(mid) == -1){\n\t\t\t\tright = mid - 1;\n\t\t\t}else{\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic int guess(int num){\n\t\treturn 0;\n\t}\n}\n",
        "\tint guessNumber(int n) {\n\t\tint low = 1;\n\t\tint high = n;\n\t\twhile(low <= high){\n\t\t\tint mid = low + (high - low) / 2;\n\t\t\tint res = guess(mid);\n\t\t\tif(res == 0) return mid;\n\t\t\telse if(res == -1) high = mid - 1;\n\t\t\telse low = mid + 1;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic int guess(int num){\n\t\treturn 0;\n\t}\n}\n",
        "\tint guessNumber(int n) {\n\t\tint low = 1;\n\t\tint high = n;\n\t\twhile(low <= high){\n\t\t\tint mid = (low + high) / 2;\n\t\t\tint res = guess(mid);\n\t\t\tif(res == 0) return mid;\n\t\t\telse if(res == -1) high = mid - 1;\n\t\t\telse low = mid + 1;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic int guess(int num){\n\t\treturn 0;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint rand = (int)(Math.random()*n+1);\n\t\tint guess = 0;\n\t\tint count = 0;\n\t\twhile(guess != rand){\n\t\t\tcount++;\n\t\t\tScanner in = new Scanner(System.in);\n\t\t\tSystem.out.println(\"Please input your guess:\");\n\t\t\tguess = in.nextInt();\n\t\t\tif(guess > rand){\n\t\t\t\tSystem.out.println(\"Your guess is too big.\");\n\t\t\t}\n\t\t\telse if(guess < rand){\n\t\t\t\tSystem.out.println(\"Your guess is too small.\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"Bingo!\");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"You have tried \"+count+\" times.\");\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1989",
    "source": "leetcode",
    "language": "java",
    "query": "The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases. Given a string s, reverse only all the vowels in the string and return it.",
    "snippets": [
        "\tString reverseVowels(String s) {\n\t\tchar[] ch = s.toCharArray();\n\t\tint i = 0, j = ch.length - 1;\n\t\twhile (i < j) {\n\t\t\tif (!isVowel(ch[i])) {\n\t\t\t\ti++;\n\t\t\t} else if (!isVowel(ch[j])) {\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tchar temp = ch[i];\n\t\t\t\tch[i] = ch[j];\n\t\t\t\tch[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(ch);\n\t}\n\tpublic boolean isVowel(char ch) {\n\t\treturn ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tif(s == null || s.length() == 0) return s;\n\t\tchar[] arr = s.toCharArray();\n\t\tint i = 0, j = arr.length - 1;\n\t\twhile(i < j){\n\t\t\twhile(i < j && !isVowel(arr[i])) i++;\n\t\t\twhile(i < j && !isVowel(arr[j])) j--;\n\t\t\tif(i < j){\n\t\t\t\tchar temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(arr);\n\t}\n\tpublic boolean isVowel(char c){\n\t\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tchar[] chars = s.toCharArray();\n\t\tint i = 0;\n\t\tint j = s.length() - 1;\n\t\twhile (i < j) {\n\t\t\tif (!isVowel(chars[i])) {\n\t\t\t\ti++;\n\t\t\t} else if (!isVowel(chars[j])) {\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tchar temp = chars[i];\n\t\t\t\tchars[i] = chars[j];\n\t\t\t\tchars[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(chars);\n\t}\n\tpublic boolean isVowel(char c) {\n\t\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tint i = 0, j = s.length() - 1;\n\t\tchar[] ch = s.toCharArray();\n\t\twhile (i < j) {\n\t\t\twhile (i < j && !isVowel(ch[i])) i++;\n\t\t\twhile (i < j && !isVowel(ch[j])) j--;\n\t\t\tif (i < j) {\n\t\t\t\tchar temp = ch[i];\n\t\t\t\tch[i] = ch[j];\n\t\t\t\tch[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(ch);\n\t}\n\tpublic boolean isVowel(char c) {\n\t\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tchar[] chars = s.toCharArray();\n\t\tint i = 0, j = s.length() - 1;\n\t\twhile (i < j) {\n\t\t\twhile (i < j && !isVowel(chars[i])) i++;\n\t\t\twhile (i < j && !isVowel(chars[j])) j--;\n\t\t\tif (i < j) {\n\t\t\t\tchar temp = chars[i];\n\t\t\t\tchars[i] = chars[j];\n\t\t\t\tchars[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(chars);\n\t}\n\tpublic boolean isVowel(char c) {\n\t\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tchar[] chars = s.toCharArray();\n\t\tint i = 0, j = chars.length - 1;\n\t\twhile (i < j) {\n\t\t\tif (!isVowel(chars[i])) {\n\t\t\t\ti++;\n\t\t\t} else if (!isVowel(chars[j])) {\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tchar temp = chars[i];\n\t\t\t\tchars[i] = chars[j];\n\t\t\t\tchars[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(chars);\n\t}\n\tpublic boolean isVowel(char c) {\n\t\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tchar[] chars = s.toCharArray();\n\t\tint left = 0;\n\t\tint right = s.length() - 1;\n\t\twhile(left < right){\n\t\t\twhile(left < right && !isVowel(chars[left])){\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\twhile(left < right && !isVowel(chars[right])){\n\t\t\t\tright--;\n\t\t\t}\n\t\t\tif(left < right){\n\t\t\t\tchar temp = chars[left];\n\t\t\t\tchars[left] = chars[right];\n\t\t\t\tchars[right] = temp;\n\t\t\t\tleft++;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\treturn new String(chars);\n\t}\n\tpublic boolean isVowel(char c){\n\t\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tchar[] arr = s.toCharArray();\n\t\tint i = 0, j = arr.length - 1;\n\t\twhile (i < j) {\n\t\t\twhile (i < j && !isVowel(arr[i])) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (i < j && !isVowel(arr[j])) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i < j) {\n\t\t\t\tchar temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(arr);\n\t}\n\n\tpublic boolean isVowel(char c) {\n\t\treturn c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n\t}\n}\n",
        "\tString reverseVowels(String s) {\n\t\tchar[] ch = s.toCharArray();\n\t\tint i = 0;\n\t\tint j = ch.length - 1;\n\t\twhile (i < j) {\n\t\t\twhile (i < j && !isVowel(ch[i])) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (i < j && !isVowel(ch[j])) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i < j) {\n\t\t\t\tchar temp = ch[i];\n\t\t\t\tch[i] = ch[j];\n\t\t\t\tch[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn new String(ch);\n\t}\n\tpublic boolean isVowel(char ch) {\n\t\treturn ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U';\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1990",
    "source": "leetcode",
    "language": "java",
    "query": "A grid is said to be valid if all the cells above the main diagonal are zeros. Given an n x n binary grid, in one step you can choose two adjacent rows of the grid and swap them. Return the minimum number of steps needed to make the grid valid.",
    "snippets": [
        "\tint movesToMakeZigZag(int[][] grid) {\n\t\tint n = grid.length;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tif (grid[i][j] == 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint movesToMakeZigZag(int[][] grid) {\n\t\tint n = grid.length;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i < j && grid[i][j] == 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minSwaps(int[][] grid) {\n\t\tint n = grid.length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tdp[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(dp[i] == 0){\n\t\t\t\tmin++;\n\t\t\t}\n\t\t}\n\t\treturn count - min;\n\t}\n}\n",
        "\tint validGrid(int[][] grid) {\n\t\tint n = grid.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 0){\n\t\t\t\t\tif(i > 0){\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif(j > 0){\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tres = Math.min(res, dp[n - 1][i]);\n\t\t}\n\t\treturn res == Integer.MAX_VALUE ? -1 : res;\n\t}\n}\n",
        "\tint minSwaps(int[][] grid) {\n\t\tint n = grid.length;\n\t\tint[] count = new int[n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\tcount[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (count[i] % 2 == 1) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\tans += count[j] / 2;\n\t\t\t\t\tcount[j] -= count[j] / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint makeGridValid(int[][] grid) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\tfor (int j = 0; j < grid[0].length; j++) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] row = new int[grid.length];\n\t\tint[] col = new int[grid[0].length];\n\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\tfor (int j = 0; j < grid[0].length; j++) {\n\t\t\t\tif (grid[i][j] == 1) {\n\t\t\t\t\trow[i]++;\n\t\t\t\t\tcol[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\tfor (int j = 0; j < grid[0].length; j++) {\n\t\t\t\tif (grid[i][j] == 0) {\n\t\t\t\t\tif (row[i] > 1) {\n\t\t\t\t\t\tmin = Math.min(min, row[i] - 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (col[j] > 1) {\n\t\t\t\t\t\tmin = Math.min(min, col[j] - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count + min;\n\t}\n}\n",
        "\tint makeGridValid(int[][] grid) {\n\t\tint n = grid.length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] row = new int[n];\n\t\tint[] col = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\trow[i]++;\n\t\t\t\t\tcol[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(row[i] > 1){\n\t\t\t\tmin = Math.min(min, row[i] - 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(col[i] > 1){\n\t\t\t\tmin = Math.min(min, col[i] - 1);\n\t\t\t}\n\t\t}\n\t\treturn count - min;\n\t}\n}\n",
        "\tint movesToMakeZigzag(int[][] grid) {\n\t\tint n = grid.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 || j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = grid[i][j] + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1][n-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1991",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[][] bombs = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tint[][] result = new int[3][3];\n\t\tfor(int i = 0; i < bombs.length; i++){\n\t\t\tfor(int j = 0; j < bombs[i].length; j++){\n\t\t\t\tint x = bombs[i][j];\n\t\t\t\tint y = bombs[i][j];\n\t\t\t\tint x1 = x - 1;\n\t\t\t\tint x2 = x + 1;\n\t\t\t\tint y1 = y - 1;\n\t\t\t\tint y2 = y + 1;\n\t\t\t\tfor(int k = x1; k <= x2; k++){\n\t\t\t\t\tfor(int l = y1; l <= y2; l++){\n\t\t\t\t\t\tif(k >= 0 && k < bombs.length && l >= 0 && l < bombs[k].length){\n\t\t\t\t\t\t\tresult[k][l]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tfor(int j = 0; j < result[i].length; j++){\n\t\t\t\tSystem.out.print(result[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] bombs = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tint[][] result = new int[3][3];\n\t\tfor(int i = 0; i < bombs.length; i++){\n\t\t\tfor(int j = 0; j < bombs[i].length; j++){\n\t\t\t\tresult[i][j] = bombs[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bombs.length; i++){\n\t\t\tfor(int j = 0; j < bombs[i].length; j++){\n\t\t\t\tif(bombs[i][j] != 0){\n\t\t\t\t\tfor(int k = i - 1; k <= i + 1; k++){\n\t\t\t\t\t\tfor(int l = j - 1; l <= j + 1; l++){\n\t\t\t\t\t\t\tif(k >= 0 && k < bombs.length && l >= 0 && l < bombs[i].length){\n\t\t\t\t\t\t\t\tresult[k][l] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tfor(int j = 0; j < result[i].length; j++){\n\t\t\t\tSystem.out.print(result[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] bombs = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] range = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] result = new int[bombs.length];\n\t\tfor(int i = 0; i < bombs.length; i++){\n\t\t\tresult[i] = range[i] * 2 + 1;\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] bombs = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tint[][] result = new int[3][3];\n\t\tfor(int i = 0; i < bombs.length; i++){\n\t\t\tfor(int j = 0; j < bombs[i].length; j++){\n\t\t\t\tresult[i][j] = bombs[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bombs.length; i++){\n\t\t\tfor(int j = 0; j < bombs[i].length; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i == 0){\n\t\t\t\t\tresult[i][j] = result[i][j] + result[i][j-1];\n\t\t\t\t}\n\t\t\t\tif(j == 0){\n\t\t\t\t\tresult[i][j] = result[i][j] + result[i-1][j];\n\t\t\t\t}\n\t\t\t\tif(i > 0 && j > 0){\n\t\t\t\t\tresult[i][j] = result[i][j] + result[i-1][j] + result[i][j-1] - result[i-1][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tfor(int j = 0; j < result[i].length; j++){\n\t\t\t\tSystem.out.print(result[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] bombs = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tint[][] result = new int[3][3];\n\t\tfor(int i=0;i<bombs.length;i++){\n\t\t\tfor(int j=0;j<bombs[i].length;j++){\n\t\t\t\tresult[i][j] = bombs[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<bombs.length;i++){\n\t\t\tfor(int j=0;j<bombs[i].length;j++){\n\t\t\t\tif(bombs[i][j]!=0){\n\t\t\t\t\tfor(int k=0;k<bombs.length;k++){\n\t\t\t\t\t\tfor(int l=0;l<bombs[k].length;l++){\n\t\t\t\t\t\t\tif(Math.abs(i-k)+Math.abs(j-l)<=bombs[i][j]){\n\t\t\t\t\t\t\t\tresult[k][l] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<result.length;i++){\n\t\t\tfor(int j=0;j<result[i].length;j++){\n\t\t\t\tSystem.out.print(result[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] bombs = {{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,10},{10,11},{11,12},{12,13},{13,14},{14,15},{15,16},{16,17},{17,18},{18,19},{19,20},{20,21},{21,22},{22,23},{23,24},{24,25},{25,26},{26,27},{27,28},{28,29},{29,30},{30,31},{31,32},{32,33},{33,34},{34,35},{35,36},{36,37},{37,38},{38,39},{39,40},{40,41},{41,42},{42,43},{43,44},{44,45},{45,46},{46,47},{47,48},{48,49},{49,50},{50,51},{51,52},{52,53},{53,54},{54,55},{55,56},{56,57},{57,58},{58,59},{59,60},{60,61},{61,62},{62,63},{63,64},{64,65},{65,66},{66,67},{67,68},{68,69},{69,70},{70,71},{71,72},{72,73},{73,74},{74,75},{75,76},{76,77},{77,78},{78,79},{79,80},{80,81},{81,82},{82,83},{83,84},{84,85},{85,86},{86,87},{87,88},{88,89},{89,90},{90,91},{91,92},{92,93},{93,94},{94,95},{95,96},{96,97},{\n",
        "\tstatic void main(String[] args){\n\t\tint[][] bombs = {{0,0},{1,1},{2,2},{3,3}};\n\t\tint[][] result = new int[4][2];\n\t\tfor(int i = 0; i < bombs.length; i++){\n\t\t\tint x = bombs[i][0];\n\t\t\tint y = bombs[i][1];\n\t\t\tresult[i][0] = x;\n\t\t\tresult[i][1] = y;\n\t\t\tfor(int j = -1; j <= 1; j++){\n\t\t\t\tfor(int k = -1; k <= 1; k++){\n\t\t\t\t\tif(j == 0 && k == 0) continue;\n\t\t\t\t\tint newX = x + j;\n\t\t\t\t\tint newY = y + k;\n\t\t\t\t\tif(newX < 0 || newX >= 4 || newY < 0 || newY >= 4) continue;\n\t\t\t\t\tresult[i][0] = newX;\n\t\t\t\t\tresult[i][1] = newY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i][0] + \" \" + result[i][1]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] bombs = {{0,0},{1,1},{2,2},{3,3}};\n\t\tint[][] result = new int[4][2];\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tresult[i][0] = bombs[i][0] - 1;\n\t\t\tresult[i][1] = bombs[i][1] - 1;\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tSystem.out.println(result[i][0] + \" \" + result[i][1]);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1992",
    "source": "leetcode",
    "language": "java",
    "query": "Head is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1.",
    "snippets": [
        "\tNode head;\n\tpublic Clazz(Node head){\n\t\tthis.head = head;\n\t}\n\tpublic void add(Node node){\n\t\tNode temp = head;\n\t\twhile(temp.next != null){\n\t\t\ttemp = temp.next;\n\t\t}\n\t\ttemp.next = node;\n\t}\n\tpublic void print(){\n\t\tNode temp = head;\n\t\twhile(temp != null){\n\t\t\tSystem.out.print(temp.val + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\tclass Node{\n\t\tint val;\n\t\tNode next;\n\t\tNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic Node head;\n\tpublic Clazz(){\n\t\thead = new Node(0);\n\t}\n\tpublic void add(int x){\n\t\tNode cur = head;\n\t\twhile(cur.next != null){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tcur.next = new Node(x);\n\t}\n\tpublic void print(){\n\t\tNode cur = head;\n\t\twhile(cur.next != null){\n\t\t\tSystem.out.print(cur.val + \"->\");\n\t\t\tcur = cur.next;\n\t\t}\n\t\tSystem.out.println(cur.val);\n\t}\n\tpublic void reverse(){\n\t\tNode cur = head;\n\t\tNode pre = null;\n\t\twhile(cur.next != null){\n\t\t\tNode next = cur.next;\n\t\t\tcur.next = pre;\n\t\t\tpre = cur;\n\t\t\tcur = next;\n\t\t}\n\t\tcur.next = pre;\n\t\thead = cur;\n\t}\n\tpublic void reverse2(){\n\t\tNode cur = head;\n\t\tNode pre = null;\n\t\twhile(cur.next != null){\n\t\t\tNode next = cur.next;\n\t\t\tcur.next = pre;\n\t\t\tpre = cur;\n\t\t\tcur = next;\n\t\t}\n\t\tcur.next = pre;\n\t\thead = cur;\n\t}\n\tpublic void reverse3(){\n\t\tNode cur = head;\n\t\tNode pre = null;\n\t\twhile(cur.next != null){\n\t\t\tNode next = cur.next;\n\t\t\tcur.next = pre;\n\t\t\tpre = cur;\n\t\t\tcur = next;\n\t\t}\n\t\tcur.next = pre;\n\t\thead = cur;\n\t}\n\tpublic void reverse4(){\n\t\tNode cur = head;\n\t\tNode pre = null;\n",
        "\tNode head;\n\tpublic Clazz(Node head){\n\t\tthis.head = head;\n\t}\n\tpublic void addNode(Node node){\n\t\tNode temp = head;\n\t\twhile(temp.next != null){\n\t\t\ttemp = temp.next;\n\t\t}\n\t\ttemp.next = node;\n\t}\n\tpublic void print(){\n\t\tNode temp = head;\n\t\twhile(temp != null){\n\t\t\tSystem.out.print(temp.val + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\tNode head;\n\tpublic Clazz(){\n\t\thead = null;\n\t}\n\tpublic void add(int data){\n\t\tNode newNode = new Node(data);\n\t\tnewNode.next = head;\n\t\thead = newNode;\n\t}\n\tpublic void print(){\n\t\tNode temp = head;\n\t\twhile(temp != null){\n\t\t\tSystem.out.print(temp.data + \" \");\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic void printReverse(){\n\t\tNode temp = head;\n\t\twhile(temp.next != null){\n\t\t\ttemp = temp.next;\n\t\t}\n\t\twhile(temp != null){\n\t\t\tSystem.out.print(temp.data + \" \");\n\t\t\ttemp = temp.prev;\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic void printReverse(Node temp){\n\t\tif(temp.next != null){\n\t\t\tprintReverse(temp.next);\n\t\t}\n\t\tSystem.out.print(temp.data + \" \");\n\t}\n\tpublic void printReverseRecursive(){\n\t\tprintReverse(head);\n\t}\n\tpublic void printReverseRecursive(Node temp){\n\t\tif(temp.next != null){\n\t\t\tprintReverseRecursive(temp.next);\n\t\t}\n\t\tSystem.out.print(temp.data + \" \");\n\t}\n\tpublic void printReverseRecursive(Node temp, int count){\n\t\tif(temp.next != null){\n\t\t\tprintReverseRecursive(temp.next, count + 1);\n\t\t}\n\t\tSystem.out.print(temp.data + \" \");\n\t}\n\tpublic void printReverseRecursive(int count){\n\t\tprintReverseRecursive(head, count);\n\t}\n\tpublic void printReverseRecursive(int count, Node temp){\n\t\tif(temp.next != null){\n",
        "\t\tNode head;\n\t\tpublic Clazz(Node head){\n\t\t\tthis.head = head;\n\t\t}\n\t\tpublic void print(){\n\t\t\tNode current = head;\n\t\t\twhile(current != null){\n\t\t\t\tSystem.out.print(current.val + \" \");\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tpublic void add(int val){\n\t\t\tNode current = head;\n\t\t\twhile(current.next != null){\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\tcurrent.next = new Node(val);\n\t\t}\n\t\tpublic void remove(int val){\n\t\t\tNode current = head;\n\t\t\twhile(current.next != null){\n\t\t\t\tif(current.next.val == val){\n\t\t\t\t\tcurrent.next = current.next.next;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t}\n\t\tpublic void removeAll(int val){\n\t\t\tNode current = head;\n\t\t\twhile(current.next != null){\n\t\t\t\tif(current.next.val == val){\n\t\t\t\t\tcurrent.next = current.next.next;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic void removeAll(){\n\t\t\tNode current = head;\n\t\t\twhile(current.next != null){\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\tcurrent.next = null;\n\t\t}\n\t\tpublic void removeAll(int val, int count){\n\t\t\tNode current = head;\n\t\t\twhile(current.next != null){\n\t\t\t\tif(current.next.val == val){\n\t\t\t\t\tcurrent.next = current.next.next;\n\t\t\t\t\tcount--\n",
        "\t\tNode head;\n\t\tpublic Clazz(Node head){\n\t\t\tthis.head = head;\n\t\t}\n\t\tpublic void print(){\n\t\t\tNode temp = head;\n\t\t\twhile(temp != null){\n\t\t\t\tSystem.out.print(temp.val + \" \");\n\t\t\t\ttemp = temp.next;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tpublic void printReverse(){\n\t\t\tNode temp = head;\n\t\t\tStack<Integer> stack = new Stack<Integer>();\n\t\t\twhile(temp != null){\n\t\t\t\tstack.push(temp.val);\n\t\t\t\ttemp = temp.next;\n\t\t\t}\n\t\t\twhile(!stack.isEmpty()){\n\t\t\t\tSystem.out.print(stack.pop() + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tpublic void printReverseRecursive(Node temp){\n\t\t\tif(temp == null)\n\t\t\t\treturn;\n\t\t\tprintReverseRecursive(temp.next);\n\t\t\tSystem.out.print(temp.val + \" \");\n\t\t}\n\t\tpublic void printReverseRecursive(){\n\t\t\tprintReverseRecursive(head);\n\t\t\tSystem.out.println();\n\t\t}\n\t\tpublic void printReverseRecursive(Node temp, int count){\n\t\t\tif(temp == null)\n\t\t\t\treturn;\n\t\t\tprintReverseRecursive(temp.next, count + 1);\n\t\t\tif(count % 2 == 0)\n\t\t\t\tSystem.out.print(temp.val + \" \");\n\t\t\telse\n\t\t\t\tSystem.out.print(temp.val + \" \");\n\t\t}\n\t\tpublic void printReverseRecursive(int count){\n\t\t\tprintReverseRecursive(head, count);\n\t\t\tSystem.out.println();\n\t\t}\n\t\tpublic void printReverse\n",
        "\tNode head;\n\tpublic Clazz(){\n\t\thead = new Node(0);\n\t}\n\tpublic void add(int i){\n\t\tNode n = new Node(i);\n\t\tn.next = head.next;\n\t\thead.next = n;\n\t}\n\tpublic void print(){\n\t\tNode n = head.next;\n\t\twhile(n != null){\n\t\t\tSystem.out.print(n.val + \" \");\n\t\t\tn = n.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic void remove(int i){\n\t\tNode n = head;\n\t\twhile(n.next != null){\n\t\t\tif(n.next.val == i){\n\t\t\t\tn.next = n.next.next;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tn = n.next;\n\t\t}\n\t}\n\tpublic void removeAll(int i){\n\t\tNode n = head;\n\t\twhile(n.next != null){\n\t\t\tif(n.next.val == i){\n\t\t\t\tn.next = n.next.next;\n\t\t\t}\n\t\t\tn = n.next;\n\t\t}\n\t}\n\tpublic void removeAll(){\n\t\thead.next = null;\n\t}\n\tpublic void removeAll(int i, int j){\n\t\tNode n = head;\n\t\twhile(n.next != null){\n\t\t\tif(n.next.val == i || n.next.val == j){\n\t\t\t\tn.next = n.next.next;\n\t\t\t}\n\t\t\tn = n.next;\n\t\t}\n\t}\n\tpublic void removeAll(int i, int j, int k){\n\t\tNode n = head;\n\t\twhile(n.next != null){\n\t\t\tif(n.next.val == i || n.next.val == j || n.next.val == k){\n\t\t\t\tn.next = n.next.next;\n\t\t\t}\n",
        "\tNode head;\n\tpublic Clazz(Node head){\n\t\tthis.head = head;\n\t}\n\tpublic void add(Node node){\n\t\tNode current = head;\n\t\twhile(current.next != null){\n\t\t\tcurrent = current.next;\n\t\t}\n\t\tcurrent.next = node;\n\t}\n\tpublic void print(){\n\t\tNode current = head;\n\t\twhile(current != null){\n\t\t\tSystem.out.print(current.val + \" \");\n\t\t\tcurrent = current.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\t\tNode head;\n\t\tpublic Clazz(Node head){\n\t\t\tthis.head = head;\n\t\t}\n\t\tpublic void addNode(Node node){\n\t\t\tNode temp = head;\n\t\t\twhile(temp.next != null){\n\t\t\t\ttemp = temp.next;\n\t\t\t}\n\t\t\ttemp.next = node;\n\t\t}\n\t\tpublic void print(){\n\t\t\tNode temp = head;\n\t\t\twhile(temp != null){\n\t\t\t\tSystem.out.print(temp.val + \" \");\n\t\t\t\ttemp = temp.next;\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tpublic void deleteNode(int index){\n\t\t\tNode temp = head;\n\t\t\tNode prev = null;\n\t\t\tint i = 0;\n\t\t\twhile(temp != null){\n\t\t\t\tif(i == index){\n\t\t\t\t\tprev.next = temp.next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = temp;\n\t\t\t\ttemp = temp.next;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tpublic void deleteNode(Node node){\n\t\t\tNode temp = head;\n\t\t\tNode prev = null;\n\t\t\twhile(temp != null){\n\t\t\t\tif(temp == node){\n\t\t\t\t\tprev.next = temp.next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = temp;\n\t\t\t\ttemp = temp.next;\n\t\t\t}\n\t\t}\n\t\tpublic void deleteNode(Node node, int index){\n\t\t\tNode temp = head;\n\t\t\tNode prev = null;\n\t\t\tint i = 0;\n\t\t\twhile(temp != null){\n\t\t\t\tif(i == index){\n\t\t\t\t\tprev.next = temp.next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = temp;\n",
        "\tNode head;\n\tpublic Clazz(){\n\t\thead = new Node(0);\n\t}\n\tpublic void add(int num){\n\t\tNode cur = head;\n\t\twhile(cur.next != null){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tcur.next = new Node(num);\n\t}\n\tpublic void print(){\n\t\tNode cur = head;\n\t\twhile(cur.next != null){\n\t\t\tSystem.out.print(cur.val + \"->\");\n\t\t\tcur = cur.next;\n\t\t}\n\t\tSystem.out.println(cur.val);\n\t}\n\tpublic void remove(int num){\n\t\tNode cur = head;\n\t\tNode prev = null;\n\t\twhile(cur.next != null){\n\t\t\tif(cur.val == num){\n\t\t\t\tprev.next = cur.next;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur.next;\n\t\t}\n\t}\n\tpublic void removeAll(int num){\n\t\tNode cur = head;\n\t\tNode prev = null;\n\t\twhile(cur.next != null){\n\t\t\tif(cur.val == num){\n\t\t\t\tprev.next = cur.next;\n\t\t\t}\n\t\t\tprev = cur;\n\t\t\tcur = cur.next;\n\t\t}\n\t}\n\tpublic void removeAll2(int num){\n\t\tNode cur = head;\n\t\tNode prev = null;\n\t\twhile(cur.next != null){\n\t\t\tif(cur.val == num){\n\t\t\t\tprev.next = cur.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tprev = cur;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif(cur.val == num){\n\t\t\tprev.next = null;\n\t\t}\n\t}\n\tpublic void removeAll3(int num){\n\t\tNode cur = head;\n\t\tNode prev = null;\n"
    ],
    "results": 10
},{
    "id": "1993",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, return true if the given array is monotonic, or false otherwise. An array ismonotonic if it is either monotone increasing or monot one decreasing.",
    "snippets": [
        "\tboolean isMonotonic(int[] nums) {\n\t\tif(nums.length<=1) return true;\n\t\tint i=0;\n\t\twhile(i<nums.length-1 && nums[i]==nums[i+1]) i++;\n\t\tif(i==nums.length-1) return true;\n\t\tif(nums[i]<nums[i+1]){\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]<nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]>nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotonic(int[] nums) {\n\t\tif(nums.length<=1) return true;\n\t\tint i=0;\n\t\twhile(i<nums.length-1&&nums[i]==nums[i+1]) i++;\n\t\tif(i==nums.length-1) return true;\n\t\tif(nums[i]<nums[i+1]){\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]<nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\tif(nums[i]>nums[i+1]){\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]>nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotonic(int[] nums) {\n\t\tif(nums.length<=1) return true;\n\t\tint i=0;\n\t\twhile(i<nums.length-1 && nums[i]==nums[i+1]) i++;\n\t\tif(i==nums.length-1) return true;\n\t\tif(nums[i]>nums[i+1]){\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]>nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]<nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotonic(int[] nums) {\n\t\tif(nums.length<2) return true;\n\t\tint i=0;\n\t\twhile(i<nums.length-1&&nums[i]==nums[i+1]) i++;\n\t\tif(i==nums.length-1) return true;\n\t\tif(nums[i]<nums[i+1]){\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]<nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=i+1;j<nums.length-1;j++){\n\t\t\t\tif(nums[j]>nums[j+1]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotonic(int[] nums) {\n\t\tif(nums.length<=1) return true;\n\t\tboolean isInc = true;\n\t\tboolean isDec = true;\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tif(nums[i]<nums[i-1]){\n\t\t\t\tisInc = false;\n\t\t\t}\n\t\t\tif(nums[i]>nums[i-1]){\n\t\t\t\tisDec = false;\n\t\t\t}\n\t\t}\n\t\treturn isInc||isDec;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1994",
    "source": "leetcode",
    "language": "java",
    "query": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges.",
    "snippets": [
        "\tint countComponents(int n, int[][] edges) {\n\t\tint[] visited = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tdfs(i, visited, edges);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(int i, int[] visited, int[][] edges){\n\t\tvisited[i] = 1;\n\t\tfor(int j = 0; j < edges.length; j++){\n\t\t\tif(edges[j][0] == i && visited[edges[j][1]] == 0){\n\t\t\t\tdfs(edges[j][1], visited, edges);\n\t\t\t}\n\t\t\tif(edges[j][1] == i && visited[edges[j][0]] == 0){\n\t\t\t\tdfs(edges[j][0], visited, edges);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[][] edges = {{1, 2}, {1, 3}, {1, 4}, {2, 3}, {3, 4}};\n\t\tSystem.out.println(isStarGraph(n, edges));\n\t}\n\tpublic static boolean isStarGraph(int n, int[][] edges){\n\t\tint[] degree = new int[n + 1];\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tdegree[edges[i][0]]++;\n\t\t\tdegree[edges[i][1]]++;\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(degree[i] != 2){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint findCenter(int[][] graph){\n\t\tint n = graph.length;\n\t\tint[] visited = new int[n];\n\t\tint[] parent = new int[n];\n\t\tint[] depth = new int[n];\n\t\tint[] size = new int[n];\n\t\tint[] center = new int[n];\n\t\tint[] centerSize = new int[n];\n\t\tint[] centerDepth = new int[n];\n\t\tint[] centerParent = new int[n];\n\t\tint[] centerVisited = new int[n];\n\t\tint[] centerParentVisited = new int[n];\n\t\tint[] centerParentDepth = new int[n];\n\t\tint[] centerParentSize = new int[n];\n\t\tint[] centerParentParent = new int[n];\n\t\tint[] centerParentParentVisited = new int[n];\n\t\tint[] centerParentParentDepth = new int[n];\n\t\tint[] centerParentParentSize = new int[n];\n\t\tint[] centerParentParentParent = new int[n];\n\t\tint[] centerParentParentParentVisited = new int[n];\n\t\tint[] centerParentParentParentDepth = new int[n];\n\t\tint[] centerParentParentParentSize = new int[n];\n\t\tint[] centerParentParentParentParent = new int[n];\n\t\tint[] centerParentParentParentParentVisited = new int[n];\n\t\tint[] centerParentParentParentParentDepth = new int[n];\n\t\tint[] centerParentParentParentParentSize = new int[n];\n\t\tint[] centerParentParentParentParentParent = new int[n];\n\t\tint[] centerParentParentParentParentParentVisited = new int[n];\n\t\tint[] centerParentParentParentParentParentDepth = new int[n];\n\t\tint[] centerParentParentParentParentParentSize = new int[n];\n\t\tint[] centerParentParentParentParentParentParent = new int[n];\n\t\tint[] centerParentParentParentParentParentParentVisited = new int[n];\n\t\tint[] centerParentParentParentParentParentParentDepth = new int[n];\n",
        "\tvoid findCenter(int n){\n\t\tint[] visited = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tdfs(i, visited);\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid dfs(int i, int[] visited){\n\t\tvisited[i] = 1;\n\t\tfor(int j = 0; j < visited.length; j++){\n\t\t\tif(visited[j] == 0 && graph[i][j] == 1){\n\t\t\t\tdfs(j, visited);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid findCenter(int[] graph){\n\t\tint n = graph.length;\n\t\tint[] visited = new int[n];\n\t\tint[] parent = new int[n];\n\t\tint[] depth = new int[n];\n\t\tint[] center = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tdfs(graph, i, visited, parent, depth, center);\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tint maxIndex = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(depth[i] > max){\n\t\t\t\tmax = depth[i];\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxIndex + 1);\n\t}\n\tpublic\n\tvoid dfs(int[] graph, int i, int[] visited, int[] parent, int[] depth, int[] center){\n\t\tvisited[i] = 1;\n\t\tfor(int j = 0; j < graph.length; j++){\n\t\t\tif(graph[i] == graph[j] && i != j){\n\t\t\t\tif(visited[j] == 0){\n\t\t\t\t\tparent[j] = i;\n\t\t\t\t\tdepth[j] = depth[i] + 1;\n\t\t\t\t\tdfs(graph, j, visited, parent, depth, center);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid printStarGraph(int n){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tSystem.out.print(\"*\");\n\t\t\t\telse\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tvoid findCenter(int n){\n\t\tint[] visited = new int[n];\n\t\tint[] parent = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tvisited[i] = 0;\n\t\t\tparent[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tdfs(i, visited, parent);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count > 1){\n\t\t\tSystem.out.println(\"No\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Yes\");\n\t\t}\n\t}\n\tpublic\n\tvoid dfs(int i, int[] visited, int[] parent){\n\t\tvisited[i] = 1;\n\t\tfor(int j = 0; j < visited.length; j++){\n\t\t\tif(visited[j] == 0 && graph[i][j] == 1){\n\t\t\t\tparent[j] = i;\n\t\t\t\tdfs(j, visited, parent);\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid print(int[] visited){\n\t\tfor(int i = 0; i < visited.length; i++){\n\t\t\tSystem.out.print(visited[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic\n\tvoid print(int[][] graph){\n\t\tfor(int i = 0; i < graph.length; i++){\n\t\t\tfor(int j = 0; j < graph[i].length; j++){\n\t\t\t\tSystem.out.print(graph[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.\n",
        "\tvoid findCenter(int n){\n\t\tint[] visited = new int[n];\n\t\tint[] distance = new int[n];\n\t\tint[] parent = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tvisited[i] = 0;\n\t\t\tdistance[i] = 0;\n\t\t\tparent[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tdfs(i, visited, distance, parent);\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(distance[i] > max){\n\t\t\t\tmax = distance[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(index);\n\t}\n\tpublic\n\tvoid dfs(int i, int[] visited, int[] distance, int[] parent){\n\t\tvisited[i] = 1;\n\t\tfor(int j = 0; j < visited.length; j++){\n\t\t\tif(visited[j] == 0){\n\t\t\t\tif(isConnected(i, j)){\n\t\t\t\t\tdistance[j] = distance[i] + 1;\n\t\t\t\t\tparent[j] = i;\n\t\t\t\t\tdfs(j, visited, distance, parent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tboolean isConnected(int i, int j){\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1995",
    "source": "leetcode",
    "language": "java",
    "query": "Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString email = \"\n",
        "\tstatic void main(String[] args){\n\t\tString email = \"\";\n\t\tSystem.out.println(isValidEmail(email));\n\t}\n\tpublic static boolean isValidEmail(String email){\n\t\tif(email == null || email.length() == 0){\n\t\t\treturn false;\n\t\t}\n\t\tString[] emailArray = email.split(\"@\");\n\t\tif(emailArray.length != 2){\n\t\t\treturn false;\n\t\t}\n\t\tString[] localNameArray = emailArray[0].split(\"\\\\.\");\n\t\tif(localNameArray.length == 0){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0; i < localNameArray.length; i++){\n\t\t\tif(localNameArray[i].length() == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor(int j = 0; j < localNameArray[i].length(); j++){\n\t\t\t\tif(!Character.isLowerCase(localNameArray[i].charAt(j))){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString[] domainNameArray = emailArray[1].split(\"\\\\+\");\n\t\tif(domainNameArray.length == 0){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0; i < domainNameArray.length; i++){\n\t\t\tif(domainNameArray[i].length() == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor(int j = 0; j < domainNameArray[i].length(); j++){\n\t\t\t\tif(!Character.isLowerCase(domainNameArray[i].charAt(j))){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] emails = {\"\n"
    ],
    "results": 10
},{
    "id": "1996",
    "source": "leetcode",
    "language": "java",
    "query": "When a friend arrives at the party, they sit on the unoccupied chair with the smallest number. For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] chairs = {0, 1, 2, 3, 4, 5};\n\t\tint[] friends = {1, 2, 3, 4, 5, 6};\n\t\tint[] result = new int[friends.length];\n\t\tfor(int i = 0; i < friends.length; i++){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int j = 0; j < chairs.length; j++){\n\t\t\t\tif(chairs[j] < min && chairs[j] != -1){\n\t\t\t\t\tmin = chairs[j];\n\t\t\t\t\tresult[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchairs[result[i]] = -1;\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] chairs = {0, 1, 2, 3, 4, 5};\n\t\tint[] friends = {1, 2, 3, 4, 5, 6};\n\t\tint[] result = new int[friends.length];\n\t\tfor(int i = 0; i < friends.length; i++){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int j = 0; j < chairs.length; j++){\n\t\t\t\tif(chairs[j] < min && chairs[j] != -1){\n\t\t\t\t\tmin = chairs[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult[i] = min;\n\t\t\tchairs[min] = -1;\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] chairs = {0, 1, 2, 3, 4, 5};\n\t\tint[] friends = {1, 2, 3, 4, 5, 6};\n\t\tint[] result = new int[friends.length];\n\t\tfor(int i = 0; i < friends.length; i++){\n\t\t\tresult[i] = findChair(chairs, friends[i]);\n\t\t}\n\t\tSystem.out.println(Arrays.toString(result));\n\t}\n\tpublic static int findChair(int[] chairs, int friend){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] < min && chairs[i] != -1){\n\t\t\t\tmin = chairs[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tchairs[index] = -1;\n\t\treturn index;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] chairs = {0, 1, 2, 3, 4, 5};\n\t\tint[] friends = {1, 2, 3, 4, 5, 6};\n\t\tint[] result = new int[friends.length];\n\t\tfor(int i = 0; i < friends.length; i++){\n\t\t\tresult[i] = findChair(chairs, friends[i]);\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic static int findChair(int[] chairs, int friend){\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0 && i < min){\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] chairs = {0, 1, 2, 3, 4, 5};\n\t\tint[] friends = {1, 2, 3, 4, 5, 6};\n\t\tint[] result = new int[friends.length];\n\t\tfor(int i = 0; i < friends.length; i++){\n\t\t\tresult[i] = findChair(chairs, friends[i]);\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic static int findChair(int[] chairs, int friend){\n\t\tint min = chairs[0];\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] < min && chairs[i] != -1){\n\t\t\t\tmin = chairs[i];\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tvoid main(String[] args){\n\t\tint[] chairs = {0, 1, 2, 3, 4, 5};\n\t\tint[] friends = {1, 2, 3, 4, 5, 6};\n\t\tint[] result = new int[friends.length];\n\t\tfor(int i = 0; i < friends.length; i++){\n\t\t\tresult[i] = findChair(chairs, friends[i]);\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic int findChair(int[] chairs, int friend){\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tmin = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0 && i < min){\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tvoid main(String[] args){\n\t\tint[] chairs = {0, 1, 2, 3, 4, 5};\n\t\tint[] friends = {1, 2, 3, 4, 5, 6};\n\t\tint[] result = new int[friends.length];\n\t\tfor(int i = 0; i < friends.length; i++){\n\t\t\tresult[i] = findChair(chairs, friends[i]);\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic int findChair(int[] chairs, int friend){\n\t\tint min = chairs[0];\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] < min && chairs[i] != -1){\n\t\t\t\tmin = chairs[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == min){\n\t\t\t\tchairs[i] = -1;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tvoid main(String[] args){\n\t\tint[] chairs = new int[6];\n\t\tint friend = 0;\n\t\tint friend_chair = 0;\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tchairs[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tfriend_chair = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tfriend_chair = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tfriend_chair = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tfriend_chair = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tfriend_chair = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tfriend_chair = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.length; i++){\n\t\t\tif(chairs[i] == 0){\n\t\t\t\tfriend_chair = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < chairs.\n"
    ],
    "results": 10
},{
    "id": "1997",
    "source": "leetcode",
    "language": "java",
    "query": "We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a \"V\" shaped pattern between two boards or if a board redirects the ball into either wall.",
    "snippets": [
        "\tvoid method(){\n\t\tint[][] board = {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}};\n\t\tint[][] balls = {{1,1,1,1},{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n\t\tint[][] result = new int[4][4];\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tresult[i][j] = balls[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tif(board[i][j] == 1){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tresult[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult[i][j] = result[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tif(board[i][j] == 1){\n\t\t\t\t\tif(i == 3){\n\t\t\t\t\t\tresult[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult[i][j] = result[i+1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tif(board[i][j] ==\n"
    ],
    "results": 1
},{
    "id": "1998",
    "source": "leetcode",
    "language": "java",
    "query": "You may assume the input array always has a valid answer. Given an integer array nums, reorder it such that nums [0] < nums[1] > nums,[2] <nums[3]....",
    "snippets": [
        "\tvoid reorder(int[] nums){\n\t\tint len = nums.length;\n\t\tint i = 0;\n\t\tint j = len - 1;\n\t\twhile(i < j){\n\t\t\twhile(i < j && nums[i] <= nums[i + 1]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile(i < j && nums[j] >= nums[j - 1]){\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif(i < j){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j] = temp;\n\t\t\t}\n\t\t}\n\t\tint start = 0;\n\t\tint end = len - 1;\n\t\twhile(start < end){\n\t\t\tint temp = nums[start];\n\t\t\tnums[start] = nums[end];\n\t\t\tnums[end] = temp;\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n}\n",
        "\tvoid reorder(int[] nums){\n\t\tint len = nums.length;\n\t\tint i = 0;\n\t\tint j = len - 1;\n\t\twhile(i < j){\n\t\t\twhile(i < j && nums[i] <= nums[i + 1]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile(i < j && nums[j] >= nums[j - 1]){\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif(i < j){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j] = temp;\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tint l = len - 1;\n\t\twhile(k < l){\n\t\t\twhile(k < l && nums[k] <= nums[k + 1]){\n\t\t\t\tk++;\n\t\t\t}\n\t\t\twhile(k < l && nums[l] >= nums[l - 1]){\n\t\t\t\tl--;\n\t\t\t}\n\t\t\tif(k < l){\n\t\t\t\tint temp = nums[k];\n\t\t\t\tnums[k] = nums[l];\n\t\t\t\tnums[l] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid reorder(int[] nums){\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\twhile(i < j){\n\t\t\twhile(i < j && nums[i] <= nums[i + 1]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile(i < j && nums[j] >= nums[j - 1]){\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif(i < j){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid reorder(int[] nums){\n\t\tint n = nums.length;\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile(i < j){\n\t\t\twhile(i < j && nums[i] <= nums[i + 1]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile(i < j && nums[j] >= nums[j - 1]){\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif(i < j){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j] = temp;\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tint l = n - 1;\n\t\twhile(k < l){\n\t\t\tif(nums[k] > nums[l]){\n\t\t\t\tint temp = nums[k];\n\t\t\t\tnums[k] = nums[l];\n\t\t\t\tnums[l] = temp;\n\t\t\t}\n\t\t\tk++;\n\t\t\tl--;\n\t\t}\n\t}\n}\n",
        "\tvoid reorder(int[] nums){\n\t\tint len = nums.length;\n\t\tif(len<=1) return;\n\t\tint i = 0;\n\t\tint j = len-1;\n\t\twhile(i<j){\n\t\t\twhile(i<j && nums[i]<=nums[i+1]) i++;\n\t\t\twhile(i<j && nums[j]>nums[j-1]) j--;\n\t\t\tif(i<j){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j] = temp;\n\t\t\t}\n\t\t}\n\t\tint mid = i;\n\t\ti = 0;\n\t\tj = mid;\n\t\twhile(i<j){\n\t\t\tint temp = nums[i];\n\t\t\tnums[i] = nums[j];\n\t\t\tnums[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n}\n",
        "\tvoid reorder(int[] nums){\n\t\tint len = nums.length;\n\t\tif(len<=1) return;\n\t\tint i = 0;\n\t\tint j = len-1;\n\t\twhile(i<j){\n\t\t\twhile(i<j && nums[i]<=nums[i+1]) i++;\n\t\t\twhile(i<j && nums[j]>=nums[j-1]) j--;\n\t\t\tif(i<j){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j] = temp;\n\t\t\t}\n\t\t}\n\t\tint k = i;\n\t\tfor(int m = 0; m<k; m++){\n\t\t\tint temp = nums[m];\n\t\t\tnums[m] = nums[k];\n\t\t\tnums[k] = temp;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "1999",
    "source": "leetcode",
    "language": "java",
    "query": "Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums [j] such that 0 <= i < j < n. If no such i and j exists, return -1.",
    "snippets": [
        "\tint maxDiff(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = 0;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t\tres = Math.max(res, max - min);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxDiff(int[] nums) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tint diff = Math.abs(nums[i] - nums[j]);\n\t\t\t\tif(diff > max){\n\t\t\t\t\tmax = diff;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maximumGap(int[] nums) {\n\t\tif(nums == null || nums.length < 2) return 0;\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t}\n\t\tint gap = (max - min) / (nums.length - 1);\n\t\tint[] mins = new int[nums.length - 1];\n\t\tint[] maxs = new int[nums.length - 1];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == min || nums[i] == max) continue;\n\t\t\tint index = (nums[i] - min) / gap;\n\t\t\tif(mins[index] == 0){\n\t\t\t\tmins[index] = nums[i];\n\t\t\t}else{\n\t\t\t\tmins[index] = Math.min(mins[index], nums[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == min || nums[i] == max) continue;\n\t\t\tint index = (nums[i] - min) / gap;\n\t\t\tif(maxs[index] == 0){\n\t\t\t\tmaxs[index] = nums[i];\n\t\t\t}else{\n\t\t\t\tmaxs[index] = Math.max(maxs[index], nums[i]);\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tint last = min;\n\t\tfor(int i = 0; i < mins.length; i++){\n\t\t\tif(mins[i] == 0) continue;\n\t\t\tres = Math.max(res, mins[i] - last\n",
        "\tint maximumGap(int[] nums) {\n\t\tint n = nums.length;\n\t\tif(n < 2) return 0;\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t}\n\t\tint gap = (int)Math.ceil((double)(max - min) / (n - 1));\n\t\tint[] mins = new int[n];\n\t\tint[] maxs = new int[n];\n\t\tArrays.fill(mins, Integer.MAX_VALUE);\n\t\tArrays.fill(maxs, Integer.MIN_VALUE);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint idx = (nums[i] - min) / gap;\n\t\t\tmins[idx] = Math.min(mins[idx], nums[i]);\n\t\t\tmaxs[idx] = Math.max(maxs[idx], nums[i]);\n\t\t}\n\t\tint res = 0;\n\t\tint lastMax = maxs[0];\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tif(mins[i] == Integer.MAX_VALUE) continue;\n\t\t\tres = Math.max(res, mins[i] - lastMax);\n\t\t\tlastMax = maxs[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2000",
    "source": "leetcode",
    "language": "java",
    "query": "The test cases are generated so that there is at least one valid solution. No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tSystem.out.println(solve(a));\n\t}\n\tpublic static int solve(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(b[i] == 0){\n\t\t\t\tans++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = i+1;\n\t\t\twhile(j < n && b[j] != 0){\n\t\t\t\tb[j] = b[j] - b[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tans++;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = Integer.parseInt(args[i+n+1]);\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = Integer.parseInt(args[i+2*n+1]);\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = Integer.parseInt(args[i+3*n+1]);\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = Integer.parseInt(args[i+4*n+1]);\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = Integer.parseInt(args[i+5*n+1]);\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = Integer.parseInt(args[i+6*n+1]);\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = Integer.parseInt(args[i+7*n+1]);\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i + 1]);\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = Integer.parseInt(args[i + n + 1]);\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = Integer.parseInt(args[i + 2 * n + 1]);\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = Integer.parseInt(args[i + 3 * n + 1]);\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = Integer.parseInt(args[i + 4 * n + 1]);\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = Integer.parseInt(args[i + 5 * n + 1]);\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = Integer.parseInt(args[i + 6 * n + 1]);\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = Integer.parseInt(args[i + 7 * n + 1]);\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int j = 0; j < n\n",
        "\tstatic int getNoZeroInteger(int n){\n\t\tint i = 1;\n\t\twhile(i < n){\n\t\t\tif(i % 10 != 0 && i / 10 != 0){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n}\n",
        "\tint getNoZeroIntegers(int n) {\n\t\tint i = 1;\n\t\twhile (true) {\n\t\t\tif (i > n)\n\t\t\t\treturn i;\n\t\t\tif (i % 10 != 0 && i / 10 != 0)\n\t\t\t\treturn i;\n\t\t\ti++;\n\t\t}\n\t}\n}\n",
        "\tint getNoZeroIntegers(int n) {\n\t\tint i = 1;\n\t\twhile (i <= n) {\n\t\t\tif (isNoZeroInteger(i) && isNoZeroInteger(n - i)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic boolean isNoZeroInteger(int n) {\n\t\tString s = String.valueOf(n);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tSystem.out.println(noZeroIntegers(n));\n\t}\n\tpublic static String noZeroIntegers(int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i % 10 != 0){\n\t\t\t\tsb.append(i);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2001",
    "source": "leetcode",
    "language": "java",
    "query": "A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed)",
    "snippets": [
        "\tint countSpecial(int[][] mat){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < mat.length; i++){\n\t\t\tfor(int j = 0; j < mat[0].length; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tfor(int k = 0; k < mat.length; k++){\n\t\t\t\t\t\tif(mat[k][j] == 1 && k != i){\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < mat[0].length; k++){\n\t\t\t\t\t\tif(mat[i][k] == 1 && k != j){\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSpecial(int[][] mat){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < mat.length; i++){\n\t\t\tfor(int j = 0; j < mat[0].length; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tfor(int k = 0; k < mat.length; k++){\n\t\t\t\t\t\tif(mat[k][j] == 1)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < mat[0].length; k++){\n\t\t\t\t\t\tif(mat[i][k] == 1)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSpecial(int[][] mat){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < mat.length; i++){\n\t\t\tfor(int j = 0; j < mat[0].length; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tfor(int k = 0; k < mat.length; k++){\n\t\t\t\t\t\tif(mat[k][j] == 1 && k != i)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < mat[0].length; k++){\n\t\t\t\t\t\tif(mat[i][k] == 1 && k != j)\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic boolean isSpecial(int[][] mat){\n\t\tint n = mat.length;\n\t\tint m = mat[0].length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(mat[k][j] == 1 && k != i){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tif(mat[i][k] == 1 && k != j){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isSpecial(int[][] mat){\n\t\tint m = mat.length;\n\t\tint n = mat[0].length;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tif(mat[k][j] == 1 && k != i){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(mat[i][k] == 1 && k != j){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countSpecial(int[][] mat) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < mat.length; i++){\n\t\t\tfor(int j = 0; j < mat[0].length; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tfor(int k = 0; k < mat.length; k++){\n\t\t\t\t\t\tif(mat[k][j] == 1){\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < mat[0].length; k++){\n\t\t\t\t\t\tif(mat[i][k] == 1){\n\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic boolean isSpecial(int[][] mat){\n\t\tint m = mat.length;\n\t\tint n = mat[0].length;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tfor(int k = 0; k < m; k++){\n\t\t\t\t\t\tif(mat[k][j] == 1 && k != i){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(mat[i][k] == 1 && k != j){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countSpecialPositions(int[][] mat){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < mat.length; i++){\n\t\t\tfor(int j = 0; j < mat[0].length; j++){\n\t\t\t\tif(mat[i][j] == 1){\n\t\t\t\t\tif(isSpecial(mat, i, j)){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tboolean isSpecial(int[][] mat, int i, int j){\n\t\tif(mat[i][j] == 0){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int k = 0; k < mat.length; k++){\n\t\t\tif(mat[k][j] == 1 && k != i){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < mat[0].length; k++){\n\t\t\tif(mat[i][k] == 1 && k != j){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2002",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules. The values at even indices 0 and 2 are sorted in non-decreasing order.",
    "snippets": [
        "\tvoid rearrange(int[] nums){\n\t\tint n = nums.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] % 2 == 0){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[i + 1];\n\t\t\t\tnums[i + 1] = temp;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] % 2 == 1){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[i + 1];\n\t\t\t\tnums[i + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid rearrange(int[] nums){\n\t\tint n = nums.length;\n\t\tint[] temp = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttemp[i] = nums[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(i % 2 == 0){\n\t\t\t\tnums[i] = temp[i/2];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnums[i] = temp[n-1-i/2];\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid rearrange(int[] nums){\n\t\tint n = nums.length;\n\t\tint[] temp = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] % 2 == 0){\n\t\t\t\ttemp[count] = nums[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] % 2 != 0){\n\t\t\t\ttemp[count] = nums[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnums[i] = temp[i];\n\t\t}\n\t}\n}\n",
        "\tvoid rerange(int[] nums){\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\twhile(i < j){\n\t\t\twhile(i < j && nums[i] < 0) i++;\n\t\t\twhile(i < j && nums[j] > 0) j--;\n\t\t\tif(i < j){\n\t\t\t\tint temp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tint k = 0;\n\t\tint l = nums.length - 1;\n\t\twhile(k < l){\n\t\t\twhile(k < l && nums[k] < 0) k++;\n\t\t\twhile(k < l && nums[l] > 0) l--;\n\t\t\tif(k < l){\n\t\t\t\tint temp = nums[k];\n\t\t\t\tnums[k] = nums[l];\n\t\t\t\tnums[l] = temp;\n\t\t\t\tk++;\n\t\t\t\tl--;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid rearrange(int[] nums){\n\t\tint n = nums.length;\n\t\tint[] temp = new int[n];\n\t\tint[] temp2 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttemp[i] = nums[i];\n\t\t\ttemp2[i] = nums[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(i % 2 == 0){\n\t\t\t\tnums[i] = temp[i/2];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnums[i] = temp2[n-1-i/2];\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid rerange(int[] nums){\n\t\tint len = nums.length;\n\t\tint[] temp = new int[len];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < len){\n\t\t\tif(nums[i] % 2 == 0){\n\t\t\t\ttemp[j] = nums[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp[len - 1 - k] = nums[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor(int m = 0; m < len; m++){\n\t\t\tnums[m] = temp[m];\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2003",
    "source": "leetcode",
    "language": "java",
    "query": "24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23. The earliest 24-hour time is 00:00, and the latest is 23:59.",
    "snippets": [
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 12){\n\t\t\thour = 0;\n\t\t}\n\t\tif(time.contains(\"PM\")){\n\t\t\thour += 12;\n\t\t}\n\t\treturn String.format(\"%02d:%02d\", hour, minute);\n\t}\n}\n",
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 12 && minute == 0){\n\t\t\treturn \"00:00\";\n\t\t}\n\t\tif(hour < 12){\n\t\t\treturn time;\n\t\t}\n\t\tif(hour == 12){\n\t\t\treturn String.format(\"%02d:%02d\", hour, minute);\n\t\t}\n\t\treturn String.format(\"%02d:%02d\", hour-12, minute);\n\t}\n}\n",
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn \"00:00\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn \"12:\" + minute;\n\t\t\t}\n\t\t}\n\t\telse if(hour < 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn hour + \":00\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn hour + \":\" + minute;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(minute == 0){\n\t\t\t\treturn (hour - 12) + \":00\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn (hour - 12) + \":\" + minute;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString time = \"23:59\";\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 23 && minute == 59){\n\t\t\tSystem.out.println(\"true\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"false\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString time = \"23:59\";\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 23 && minute == 59){\n\t\t\tSystem.out.println(\"YES\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"NO\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString time = \"00:00\";\n\t\tSystem.out.println(isValidTime(time));\n\t}\n\tpublic static boolean isValidTime(String time){\n\t\tif(time.length() != 5) return false;\n\t\tint hour = Integer.parseInt(time.substring(0,2));\n\t\tint minute = Integer.parseInt(time.substring(3));\n\t\tif(hour < 0 || hour > 23) return false;\n\t\tif(minute < 0 || minute > 59) return false;\n\t\treturn true;\n\t}\n}\n",
        "\tstatic String timeConversion(String s) {\n\t\tString[] time = s.split(\":\");\n\t\tString[] time2 = time[2].split(\"\");\n\t\tString[] time3 = time2[2].split(\"\");\n\t\tString[] time4 = time3[2].split(\"\");\n\t\tString[] time5 = time4[2].split(\"\");\n\t\tString[] time6 = time5[2].split(\"\");\n\t\tString[] time7 = time6[2].split(\"\");\n\t\tString[] time8 = time7[2].split(\"\");\n\t\tString[] time9 = time8[2].split(\"\");\n\t\tString[] time10 = time9[2].split(\"\");\n\t\tString[] time11 = time10[2].split(\"\");\n\t\tString[] time12 = time11[2].split(\"\");\n\t\tString[] time13 = time12[2].split(\"\");\n\t\tString[] time14 = time13[2].split(\"\");\n\t\tString[] time15 = time14[2].split(\"\");\n\t\tString[] time16 = time15[2].split(\"\");\n\t\tString[] time17 = time16[2].split(\"\");\n\t\tString[] time18 = time17[2].split(\"\");\n\t\tString[] time19 = time18[2].split(\"\");\n\t\tString[] time20 = time19[2].split(\"\");\n\t\tString[] time21 = time20[2].split(\"\");\n\t\tString[] time22 = time21[2].split(\"\");\n\t\tString[] time23 = time22[2].split(\"\");\n\t\tString[] time24 = time23[2].split(\"\");\n\t\tString[] time25 = time24[2].split(\"\");\n\t\tString[] time26 = time25[2].split(\"\");\n\t\tString[] time27 = time26[2].split(\"\");\n\t\tString[] time28 = time27[2].split(\"\");\n\t\tString[] time29 = time28[2].split(\"\");\n\t\tString[] time30 = time29[2].split(\"\");\n\t\tString[] time31 = time30[2\n",
        "\tstatic void main(String[] args){\n\t\tString time = \"00:00\";\n\t\tSystem.out.println(time.matches(\"^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$\"));\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2004",
    "source": "leetcode",
    "language": "java",
    "query": "Alice starts with 0 points and draws numbers while she has less than k points. Each draw is independent and the outcomes have equal probabilities.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*k);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tif(sum < k){\n\t\t\tSystem.out.println(\"Alice\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Bob\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*10);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tif(sum < k){\n\t\t\tSystem.out.println(\"Alice\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Bob\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random() * k);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tif(sum < k){\n\t\t\tSystem.out.println(\"Alice\");\n\t\t}\n\t\telse if(sum > k){\n\t\t\tSystem.out.println(\"Bob\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Draw\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*10);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tif(sum >= k){\n\t\t\tSystem.out.println(\"Alice wins\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Bob wins\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = (int)(Math.random()*10);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += arr[i];\n\t\t}\n\t\tif(sum >= k){\n\t\t\tSystem.out.println(\"Alice\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Bob\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint k = Integer.parseInt(args[0]);\n\t\tint n = Integer.parseInt(args[1]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = (int)(Math.random()*k);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += a[i];\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n}\n",
        "\tint k;\n\tpublic\n\tint n;\n\tpublic\n\tint[] a;\n\tpublic\n\tint[] b;\n\tpublic\n\tint[] c;\n\tpublic\n\tint[] d;\n\tpublic\n\tint[] e;\n\tpublic\n\tint[] f;\n\tpublic\n\tint[] g;\n\tpublic\n\tint[] h;\n\tpublic\n\tint[] i;\n\tpublic\n\tint[] j;\n\tpublic\n\tint[] kk;\n\tpublic\n\tint[] l;\n\tpublic\n\tint[] m;\n\tpublic\n\tint[] nn;\n\tpublic\n\tint[] o;\n\tpublic\n\tint[] p;\n\tpublic\n\tint[] q;\n\tpublic\n\tint[] r;\n\tpublic\n\tint[] s;\n\tpublic\n\tint[] t;\n\tpublic\n\tint[] u;\n\tpublic\n\tint[] v;\n\tpublic\n\tint[] w;\n\tpublic\n\tint[] x;\n\tpublic\n\tint[] y;\n\tpublic\n\tint[] z;\n\tpublic\n\tint[] aa;\n\tpublic\n\tint[] bb;\n\tpublic\n\tint[] cc;\n\tpublic\n\tint[] dd;\n\tpublic\n\tint[] ee;\n\tpublic\n\tint[] ff;\n\tpublic\n\tint[] gg;\n\tpublic\n\tint[] hh;\n\tpublic\n\tint[] ii;\n\tpublic\n\tint[] jj;\n\tpublic\n\tint[] kk;\n\tpublic\n\tint[] ll;\n\tpublic\n\tint[] mm;\n\tpublic\n\tint[] nn;\n\tpublic\n\tint[] oo;\n\tpublic\n\tint[] pp;\n\tpublic\n\tint[] qq;\n\tpublic\n\tint[] rr;\n\tpublic\n\tint[] ss;\n\tpublic\n\tint[] tt;\n\tpublic\n\tint[] uu;\n\tpublic\n\tint[] vv;\n\tpublic\n\tint[] ww;\n\tpublic\n\tint[] xx;\n\tpublic\n\tint[] yy;\n\tpublic\n\tint[] zz;\n",
        "\tint k;\n\tpublic\n\tint[] draw(int k){\n\t\tint[] res = new int[k];\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tres[i] = (int)(Math.random() * 10);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tint points(int[] numbers){\n\t\tint res = 0;\n\t\tfor(int i = 0; i < numbers.length; i++){\n\t\t\tres += numbers[i];\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tint alice(int k){\n\t\tint res = 0;\n\t\tint[] numbers = draw(k);\n\t\tint points = points(numbers);\n\t\twhile(points < k){\n\t\t\tres++;\n\t\t\tnumbers = draw(k);\n\t\t\tpoints = points(numbers);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint k;\n\tpublic\n\tint getProbability(int n, int k){\n\t\tint res = 0;\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tres += getProbability(i, k);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tint getProbability(int n, int k){\n\t\tif(n == 0) return 1;\n\t\tif(n < 0) return 0;\n\t\tif(k == 0) return 0;\n\t\treturn getProbability(n - 1, k - 1) + getProbability(n - 1, k);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2005",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return a list of all simplified fractions between 0 and 1 (exclusive) such that the denominator is less-than-or-equal-to n.",
    "snippets": [
        "\tList<String> simplifiedFractions(int n) {\n\t\tList<String> res = new ArrayList<>();\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\t\tif(gcd(i, j) == 1){\n\t\t\t\t\tres.add(i + \"/\" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic int gcd(int a, int b){\n\t\tif(b == 0) return a;\n\t\treturn gcd(b, a % b);\n\t}\n}\n",
        "\tList<String> simplifiedFractions(int n) {\n\t\tList<String> res = new ArrayList<>();\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\t\tif(gcd(i, j) == 1){\n\t\t\t\t\tres.add(i + \"/\" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic int gcd(int a, int b){\n\t\tif(b == 0){\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n}\n",
        "\tList<String> simplifiedFractions(int n) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\t\tif(gcd(i, j) == 1){\n\t\t\t\t\tres.add(i + \"/\" + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic int gcd(int a, int b){\n\t\tif(b == 0){\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2006",
    "source": "leetcode",
    "language": "java",
    "query": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr1 are also in arr2. Elements that do not appear inarr2 should be placed at the end of arr1 in ascending order.",
    "snippets": [
        "\tvoid sortArray(int[] arr1, int[] arr2){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr1.length && j < arr2.length){\n\t\t\tif(arr1[i] == arr2[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(arr1[i] < arr2[j]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr1[k] = arr2[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\twhile(j < arr2.length){\n\t\t\tarr1[k] = arr2[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n}\n",
        "\tvoid sortArray(int[] arr1, int[] arr2){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr1.length && j < arr2.length){\n\t\t\tif(arr1[i] == arr2[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(arr1[i] > arr2[j]){\n\t\t\t\tarr1[k] = arr2[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr1[k] = arr1[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\twhile(i < arr1.length){\n\t\t\tarr1[k] = arr1[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\twhile(j < arr2.length){\n\t\t\tarr1[k] = arr2[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n}\n",
        "\tvoid sortArray(int[] arr1, int[] arr2){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr1.length && j < arr2.length){\n\t\t\tif(arr1[i] == arr2[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(arr1[i] < arr2[j]){\n\t\t\t\tarr1[k] = arr1[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr1[k] = arr2[j];\n\t\t\t\tj++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\twhile(i < arr1.length){\n\t\t\tarr1[k] = arr1[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\twhile(j < arr2.length){\n\t\t\tarr1[k] = arr2[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n}\n",
        "\tvoid sortArray(int[] arr1, int[] arr2){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < arr1.length && j < arr2.length){\n\t\t\tif(arr1[i] == arr2[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(arr1[i] < arr2[j]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint temp = arr1[i];\n\t\t\t\tarr1[i] = arr2[j];\n\t\t\t\tarr1[j] = temp;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid\n\trearrange(int[] arr1, int[] arr2){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr1.length && j < arr2.length){\n\t\t\tif(arr1[i] == arr2[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr1[k] = arr1[i];\n\t\t\t\ti++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\twhile(i < arr1.length){\n\t\t\tarr1[k] = arr1[i];\n\t\t\ti++;\n\t\t\tk++;\n\t\t}\n\t\twhile(j < arr2.length){\n\t\t\tarr1[k] = arr2[j];\n\t\t\tj++;\n\t\t\tk++;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2007",
    "source": "leetcode",
    "language": "java",
    "query": "Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples).",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tNode root = new Node(1);\n\t\troot.left = new Node(2);\n\t\troot.right = new Node(3);\n\t\troot.left.left = new Node(4);\n\t\troot.left.right = new Node(5);\n\t\troot.right.left = new Node(6);\n\t\troot.right.right = new Node(7);\n\t\troot.left.left.left = new Node(8);\n\t\troot.left.left.right = new Node(9);\n\t\troot.left.right.left = new Node(10);\n\t\troot.left.right.right = new Node(11);\n\t\troot.right.left.left = new Node(12);\n\t\troot.right.left.right = new Node(13);\n\t\troot.right.right.left = new Node(14);\n\t\troot.right.right.right = new Node(15);\n\t\troot.left.left.left.left = new Node(16);\n\t\troot.left.left.left.right = new Node(17);\n\t\troot.left.left.right.left = new Node(18);\n\t\troot.left.left.right.right = new Node(19);\n\t\troot.left.right.left.left = new Node(20);\n\t\troot.left.right.left.right = new Node(21);\n\t\troot.left.right.right.left = new Node(22);\n\t\troot.left.right.right.right = new Node(23);\n\t\troot.right.left.left.left = new Node(24);\n\t\troot.right.left.left.right = new Node(25);\n\t\troot.right.left.right.left = new Node(26);\n\t\troot.right.left.right.right = new Node(27);\n\t\troot.right.right.left.left = new Node(28);\n\t\troot.right.right.left.right = new Node(29);\n\t\troot.right.right.right.left = new Node(30);\n",
        "\tstatic void main(String[] args){\n\t\tNaryTree tree = new NaryTree();\n\t\ttree.add(1);\n\t\ttree.add(2);\n\t\ttree.add(3);\n\t\ttree.add(4);\n\t\ttree.add(5);\n\t\ttree.add(6);\n\t\ttree.add(7);\n\t\ttree.add(8);\n\t\ttree.add(9);\n\t\ttree.add(10);\n\t\ttree.add(11);\n\t\ttree.add(12);\n\t\ttree.add(13);\n\t\ttree.add(14);\n\t\ttree.add(15);\n\t\ttree.add(16);\n\t\ttree.add(17);\n\t\ttree.add(18);\n\t\ttree.add(19);\n\t\ttree.add(20);\n\t\ttree.add(21);\n\t\ttree.add(22);\n\t\ttree.add(23);\n\t\ttree.add(24);\n\t\ttree.add(25);\n\t\ttree.add(26);\n\t\ttree.add(27);\n\t\ttree.add(28);\n\t\ttree.add(29);\n\t\ttree.add(30);\n\t\ttree.add(31);\n\t\ttree.add(32);\n\t\ttree.add(33);\n\t\ttree.add(34);\n\t\ttree.add(35);\n\t\ttree.add(36);\n\t\ttree.add(37);\n\t\ttree.add(38);\n\t\ttree.add(39);\n\t\ttree.add(40);\n\t\ttree.add(41);\n\t\ttree.add(42);\n\t\ttree.add(43);\n\t\ttree.add(44);\n\t\ttree.add(45);\n\t\ttree.add(46);\n\t\ttree.add(47);\n\t\ttree.add(48);\n\t\ttree.add(49);\n\t\ttree.add(50);\n\t\ttree.add(51);\n\t\ttree.add(52);\n\t\ttree.add(53);\n",
        "\tstatic Node deserialize(String data){\n\t\tif(data == null || data.length() == 0) return null;\n\t\tString[] nodes = data.split(\",\");\n\t\tNode root = new Node(Integer.parseInt(nodes[0]));\n\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\tqueue.offer(root);\n\t\tint i = 1;\n\t\twhile(!queue.isEmpty()){\n\t\t\tNode node = queue.poll();\n\t\t\tif(nodes[i] != \"null\"){\n\t\t\t\tNode left = new Node(Integer.parseInt(nodes[i]));\n\t\t\t\tnode.left = left;\n\t\t\t\tqueue.offer(left);\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(nodes[i] != \"null\"){\n\t\t\t\tNode right = new Node(Integer.parseInt(nodes[i]));\n\t\t\t\tnode.right = right;\n\t\t\t\tqueue.offer(right);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tstatic class Node{\n\t\tint data;\n\t\tNode left;\n\t\tNode right;\n\t\tNode(int data){\n\t\t\tthis.data=data;\n\t\t}\n\t}\n\tpublic static Node construct(int[] arr){\n\t\tif(arr==null||arr.length==0)\n\t\t\treturn null;\n\t\tNode root=new Node(arr[0]);\n\t\tQueue<Node> q=new LinkedList<Node>();\n\t\tq.add(root);\n\t\tint i=1;\n\t\twhile(!q.isEmpty()){\n\t\t\tNode temp=q.remove();\n\t\t\tif(arr[i]!=0){\n\t\t\t\ttemp.left=new Node(arr[i]);\n\t\t\t\tq.add(temp.left);\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(arr[i]!=0){\n\t\t\t\ttemp.right=new Node(arr[i]);\n\t\t\t\tq.add(temp.right);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn root;\n\t}\n\tpublic static void print(Node root){\n\t\tif(root==null)\n\t\t\treturn;\n\t\tSystem.out.print(root.data+\" \");\n\t\tprint(root.left);\n\t\tprint(root.right);\n\t}\n\tpublic static void main(String[] args){\n\t\tint[] arr={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,0};\n\t\tNode root=construct(arr);\n\t\tprint(root);\n\t}\n}\n",
        "\tstatic Node deserialize(String data){\n\t\tif(data == null || data.length() == 0) return null;\n\t\tString[] nodes = data.split(\",\");\n\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\tNode root = new Node(Integer.parseInt(nodes[0]));\n\t\tqueue.offer(root);\n\t\tint i = 1;\n\t\twhile(!queue.isEmpty()){\n\t\t\tNode node = queue.poll();\n\t\t\tif(nodes[i] != null && !nodes[i].equals(\"null\")){\n\t\t\t\tNode left = new Node(Integer.parseInt(nodes[i]));\n\t\t\t\tnode.left = left;\n\t\t\t\tqueue.offer(left);\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(nodes[i] != null && !nodes[i].equals(\"null\")){\n\t\t\t\tNode right = new Node(Integer.parseInt(nodes[i]));\n\t\t\t\tnode.right = right;\n\t\t\t\tqueue.offer(right);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tstatic TreeNode deserialize(String data){\n\t\tif(data == null || data.length() == 0){\n\t\t\treturn null;\n\t\t}\n\t\tString[] nodes = data.split(\",\");\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tTreeNode root = new TreeNode(Integer.parseInt(nodes[0]));\n\t\tqueue.offer(root);\n\t\tint index = 1;\n\t\twhile(!queue.isEmpty()){\n\t\t\tTreeNode node = queue.poll();\n\t\t\tif(nodes[index].equals(\"#\")){\n\t\t\t\tnode.left = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode.left = new TreeNode(Integer.parseInt(nodes[index]));\n\t\t\t\tqueue.offer(node.left);\n\t\t\t}\n\t\t\tindex++;\n\t\t\tif(nodes[index].equals(\"#\")){\n\t\t\t\tnode.right = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnode.right = new TreeNode(Integer.parseInt(nodes[index]));\n\t\t\t\tqueue.offer(node.right);\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\treturn root;\n\t}\n\tpublic\n\tstatic String serialize(TreeNode root){\n\t\tif(root == null){\n\t\t\treturn \"\";\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\twhile(!queue.isEmpty()){\n\t\t\tTreeNode node = queue.poll();\n\t\t\tif(node.left != null){\n\t\t\t\tqueue.offer(node.left);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(\"#,\");\n\t\t\t}\n\t\t\tif(node.right != null){\n\t\t\t\tqueue.offer(node.right);\n"
    ],
    "results": 10
},{
    "id": "2008",
    "source": "leetcode",
    "language": "java",
    "query": "A magical string s consists of only '1' and '2' and obeys the following rules. The string s is magical because concatenating the number of contiguous occurrences of characters '1', '2', generates the string s itself.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString s = \"1221121221221121121\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0, s.length()/2));\n\t\tSystem.out.println(s.substring(s.length()/2));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"1221121221221121121\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0, s.length()/2));\n\t\tSystem.out.println(s.substring(s.length()/2));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t}\n}\n",
        "\tString magicalString(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(n > 0){\n\t\t\tif(i == 0 || i == 1 || i == 2){\n\t\t\t\tsb.append(\"1\");\n\t\t\t}else{\n\t\t\t\tsb.append(\"2\");\n\t\t\t}\n\t\t\ti = (i + 1) % 3;\n\t\t\tn--;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString magicalString(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(n > 0){\n\t\t\tif(i == 0 || i == 1 || i == 2){\n\t\t\t\tsb.append(\"1\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(\"2\");\n\t\t\t}\n\t\t\tn--;\n\t\t\ti = (i + 1) % 3;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic String solve(String s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(count);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tsb.append(count);\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"12212221122121\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0,1));\n\t\tSystem.out.println(s.substring(1,2));\n\t\tSystem.out.println(s.substring(2,3));\n\t\tSystem.out.println(s.substring(3,4));\n\t\tSystem.out.println(s.substring(4,5));\n\t\tSystem.out.println(s.substring(5,6));\n\t\tSystem.out.println(s.substring(6,7));\n\t\tSystem.out.println(s.substring(7,8));\n\t\tSystem.out.println(s.substring(8,9));\n\t\tSystem.out.println(s.substring(9,10));\n\t\tSystem.out.println(s.substring(10,11));\n\t\tSystem.out.println(s.substring(11,12));\n\t\tSystem.out.println(s.substring(12,13));\n\t\tSystem.out.println(s.substring(13,14));\n\t\tSystem.out.println(s.substring(14,15));\n\t\tSystem.out.println(s.substring(15,16));\n\t\tSystem.out.println(s.substring(16,17));\n\t\tSystem.out.println(s.substring(17,18));\n\t\tSystem.out.println(s.substring(18,19));\n\t\tSystem.out.println(s.substring(19,20));\n\t\tSystem.out.println(s.substring(20,21));\n\t\tSystem.out.println(s.substring(21,22));\n\t\tSystem.out.println(s.substring(22,23));\n\t\tSystem.out.println(s.substring(23,24));\n\t\tSystem.out.println(s.substring(24,25));\n",
        "\tString getString(String s){\n\t\tStringBuffer sb = new StringBuffer();\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(count);\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tsb.append(count);\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"1221222112122221121122\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0,1));\n\t\tSystem.out.println(s.substring(1,2));\n\t\tSystem.out.println(s.substring(2,3));\n\t\tSystem.out.println(s.substring(3,4));\n\t\tSystem.out.println(s.substring(4,5));\n\t\tSystem.out.println(s.substring(5,6));\n\t\tSystem.out.println(s.substring(6,7));\n\t\tSystem.out.println(s.substring(7,8));\n\t\tSystem.out.println(s.substring(8,9));\n\t\tSystem.out.println(s.substring(9,10));\n\t\tSystem.out.println(s.substring(10,11));\n\t\tSystem.out.println(s.substring(11,12));\n\t\tSystem.out.println(s.substring(12,13));\n\t\tSystem.out.println(s.substring(13,14));\n\t\tSystem.out.println(s.substring(14,15));\n\t\tSystem.out.println(s.substring(15,16));\n\t\tSystem.out.println(s.substring(16,17));\n\t\tSystem.out.println(s.substring(17,18));\n\t\tSystem.out.println(s.substring(18,19));\n\t\tSystem.out.println(s.substring(19,20));\n\t\tSystem.out.println(s.substring(20,21));\n\t\tSystem.out.println(s.substring(21,22));\n\t\tSystem.out.println(s.substring(22,23));\n\t\tSystem.out.println(s.substring(23,24));\n\t\tSystem.out.println(s.substring(24,\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"1221222112122221121122\";\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0, s.length()/2));\n\t\tSystem.out.println(s.substring(s.length()/2));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(0, s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2, s.length())));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2, s.length())));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(0, s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2, s.length())));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(0, s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2, s.length())));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(0, s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"1221222112122221121122\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(s.length());\n\t\tSystem.out.println(s.substring(0, s.length()/2));\n\t\tSystem.out.println(s.substring(s.length()/2));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(0, s.length()/2).equals(s.substring(s.length()/2)));\n\t\tSystem.out.println(s.substring(\n"
    ],
    "results": 10
},{
    "id": "2009",
    "source": "leetcode",
    "language": "java",
    "query": "Given two strings a and b, return the minimum number of times you should repeat string a so that string b is a substring of it. If it is impossible for b​​​​​​ to be a subring of a after repeating it, return -1.Notice: string \"abc\" repeated 0 times is \"\", repeated 1 time is \"ABC\" and repeated 2 times is 'abc'",
    "snippets": [
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint lenB = B.length();\n\t\tint times = lenA / lenB;\n\t\tint remainder = lenA % lenB;\n\t\tif (remainder == 0) {\n\t\t\tfor (int i = 0; i < lenB; i++) {\n\t\t\t\tif (B.charAt(i) == A.charAt(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < remainder; i++) {\n\t\t\t\tif (B.charAt(i) == A.charAt(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = remainder; i < lenB; i++) {\n\t\t\t\tif (B.charAt(i) == A.charAt(i - remainder)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count * times;\n\t}\n}\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint lenB = B.length();\n\t\tint lenA1 = lenA;\n\t\tint lenA2 = lenA;\n\t\tint lenA3 = lenA;\n\t\tint lenA4 = lenA;\n\t\tint lenA5 = lenA;\n\t\tint lenA6 = lenA;\n\t\tint lenA7 = lenA;\n\t\tint lenA8 = lenA;\n\t\tint lenA9 = lenA;\n\t\tint lenA10 = lenA;\n\t\tint lenA11 = lenA;\n\t\tint lenA12 = lenA;\n\t\tint lenA13 = lenA;\n\t\tint lenA14 = lenA;\n\t\tint lenA15 = lenA;\n\t\tint lenA16 = lenA;\n\t\tint lenA17 = lenA;\n\t\tint lenA18 = lenA;\n\t\tint lenA19 = lenA;\n\t\tint lenA20 = lenA;\n\t\tint lenA21 = lenA;\n\t\tint lenA22 = lenA;\n\t\tint lenA23 = lenA;\n\t\tint lenA24 = lenA;\n\t\tint lenA25 = lenA;\n\t\tint lenA26 = lenA;\n\t\tint lenA27 = lenA;\n\t\tint lenA28 = lenA;\n\t\tint lenA29 = lenA;\n\t\tint lenA30 = lenA;\n\t\tint lenA31 = lenA;\n\t\tint lenA32 = lenA;\n\t\tint lenA33 = lenA;\n\t\tint lenA34 = lenA;\n\t\tint lenA35 = lenA;\n\t\tint lenA36 = lenA;\n\t\tint lenA37 = lenA;\n\t\tint lenA38 = lenA;\n\t\tint lenA39 = lenA;\n\t\tint lenA40 = lenA;\n\t\tint lenA41\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint lenB = B.length();\n\t\tint times = lenA / lenB;\n\t\tint remainder = lenA % lenB;\n\t\tif (remainder == 0) {\n\t\t\tfor (int i = 0; i < lenB; i++) {\n\t\t\t\tif (B.charAt(i) == A.charAt(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < remainder; i++) {\n\t\t\t\tif (B.charAt(i) == A.charAt(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = remainder; i < lenB; i++) {\n\t\t\t\tif (B.charAt(i) == A.charAt(i - remainder)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint lenB = B.length();\n\t\tint times = lenA / lenB;\n\t\tint remainder = lenA % lenB;\n\t\tif (remainder == 0) {\n\t\t\tfor (int i = 0; i < lenB; i++) {\n\t\t\t\tif (A.charAt(i) == B.charAt(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < remainder; i++) {\n\t\t\t\tif (A.charAt(i) == B.charAt(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < times; i++) {\n\t\t\t\tfor (int j = 0; j < lenB; j++) {\n\t\t\t\t\tif (A.charAt(j + remainder) == B.charAt(j)) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint times = len / lenA;\n\t\tint remainder = len % lenA;\n\t\tfor (int i = 0; i < lenA; i++) {\n\t\t\tif (B.charAt(i) == A.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count == len) {\n\t\t\treturn times;\n\t\t} else if (count > 0 && count < len) {\n\t\t\treturn times + 1;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}\n}\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint times = len / lenA;\n\t\tint remainder = len % lenA;\n\t\tfor (int i = 0; i < lenA; i++) {\n\t\t\tif (A.charAt(i) == B.charAt(i)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (remainder != 0) {\n\t\t\tString temp = A.substring(0, remainder);\n\t\t\tfor (int i = 0; i < remainder; i++) {\n\t\t\t\tif (temp.charAt(i) == B.charAt(i)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count * times;\n\t}\n}\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint countA = 0;\n\t\tint countB = 0;\n\t\tfor (int i = 0; i < lenA; i++) {\n\t\t\tif (A.charAt(i) == 'a') {\n\t\t\t\tcountA++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (B.charAt(i) == 'a') {\n\t\t\t\tcountB++;\n\t\t\t}\n\t\t}\n\t\tcount = len / lenA;\n\t\tif (len % lenA != 0) {\n\t\t\tcount++;\n\t\t}\n\t\tif (countA < countB) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint len = B.length();\n\t\tint lenA = A.length();\n\t\tint countA = 0;\n\t\tfor (int i = 0; i < lenA; i++) {\n\t\t\tif (A.charAt(i) == 'a') {\n\t\t\t\tcountA++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tif (B.charAt(i) == 'a') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint times = len / lenA;\n\t\tint times2 = len % lenA;\n\t\tif (times2 == 0) {\n\t\t\treturn count * times;\n\t\t} else {\n\t\t\tint count2 = 0;\n\t\t\tfor (int i = 0; i < times2; i++) {\n\t\t\t\tif (A.charAt(i) == 'a') {\n\t\t\t\t\tcount2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (count * times) + count2;\n\t\t}\n\t}\n}\n",
        "\tint repeatedString(String A, String B) {\n\t\tint count = 0;\n\t\tint lenA = A.length();\n\t\tint lenB = B.length();\n\t\tint len = lenA;\n\t\tint i = 0;\n\t\twhile(len < lenB){\n\t\t\tlen += lenA;\n\t\t}\n\t\twhile(i < len){\n\t\t\tif(A.substring(i, i+lenB).equals(B)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2010",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false.",
    "snippets": [
        "\tboolean threeConsecutiveOddNumbers(int[] arr) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] % 2 == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tif(count == 3){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean threeConsecutiveOdds(int[] arr) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] % 2 == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tif(count == 3){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean threeConsecutiveOddNumbers(int[] arr){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] % 2 == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tif(count == 3){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2011",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array arr, and an integer target, return the number of tuples i, j, k such that i < j < k. Return it modulo 109 + 7.",
    "snippets": [
        "\tint threeSumMulti(int[] arr, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = arr.length;\n\t\tint[][] dp = new int[n][target + 1];\n\t\tdp[0][arr[0]] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j <= target; j++) {\n\t\t\t\tif (j - arr[i] >= 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - arr[i]];\n\t\t\t\t}\n\t\t\t\tif (j + arr[i] <= target) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j + arr[i]];\n\t\t\t\t}\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (arr[i] == target) {\n\t\t\t\tres += dp[n - 1][arr[i]];\n\t\t\t\tres %= mod;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint threeSumMulti(int[] arr, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = arr.length;\n\t\tint[][] dp = new int[n][target + 1];\n\t\tdp[0][arr[0]] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j <= target; j++) {\n\t\t\t\tif (j - arr[i] >= 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - arr[i]];\n\t\t\t\t}\n\t\t\t\tif (j + arr[i] <= target) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j + arr[i]];\n\t\t\t\t}\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int j = 0; j <= target; j++) {\n\t\t\tres += dp[n - 1][j];\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint threeSumMulti(int[] arr, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = arr.length;\n\t\tint[][] dp = new int[n][target + 1];\n\t\tdp[0][arr[0]] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j <= target; j++) {\n\t\t\t\tif (j - arr[i] >= 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - arr[i]];\n\t\t\t\t}\n\t\t\t\tif (j + arr[i] <= target) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j + arr[i]];\n\t\t\t\t}\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int j = 0; j <= target; j++) {\n\t\t\tans += dp[n - 1][j];\n\t\t\tans %= mod;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint threeSumMulti(int[] arr, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = arr.length;\n\t\tint[][] dp = new int[n][target + 1];\n\t\tdp[0][arr[0]] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j <= target; j++) {\n\t\t\t\tif (j - arr[i] >= 0) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - arr[i]];\n\t\t\t\t}\n\t\t\t\tif (j + arr[i] <= target) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j + arr[i]];\n\t\t\t\t}\n\t\t\t\tdp[i][j] %= mod;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < target; i++) {\n\t\t\tres += dp[n - 1][i] * dp[n - 1][target - i];\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint threeSumMulti(int[] arr, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[target + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint k = target - arr[i] - arr[j];\n\t\t\t\tif (k < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tcnt[arr[i] + arr[j] + k]++;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint k = target - arr[i] - arr[j];\n\t\t\t\tif (k < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tans = (ans + cnt[k]) % mod;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint threeSumMulti(int[] arr, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = arr.length;\n\t\tint[] count = new int[2001];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcount[arr[i] + 1000]++;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint k = target - arr[i] - arr[j];\n\t\t\t\tif (k < arr[j]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans = (ans + count[k + 1000]) % mod;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint threeSumSmaller(int[] arr, int target) {\n\t\tint n = arr.length;\n\t\tint res = 0;\n\t\tArrays.sort(arr);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint j = i + 1, k = n - 1;\n\t\t\twhile(j < k){\n\t\t\t\tif(arr[i] + arr[j] + arr[k] < target){\n\t\t\t\t\tres += k - j;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse k--;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint threeSumMulti(int[] arr, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = arr.length;\n\t\tArrays.sort(arr);\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint left = i + 1;\n\t\t\tint right = n - 1;\n\t\t\twhile (left < right) {\n\t\t\t\tint sum = arr[i] + arr[left] + arr[right];\n\t\t\t\tif (sum == target) {\n\t\t\t\t\tcount += (right - left + 1) * (right - left) / 2;\n\t\t\t\t\tcount %= mod;\n\t\t\t\t\tleft++;\n\t\t\t\t\tright--;\n\t\t\t\t} else if (sum < target) {\n\t\t\t\t\tleft++;\n\t\t\t\t} else {\n\t\t\t\t\tright--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint threeSumSmaller(int[] arr, int target) {\n\t\tint ans = 0;\n\t\tArrays.sort(arr);\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tint left = i + 1, right = arr.length - 1;\n\t\t\twhile (left < right) {\n\t\t\t\tif (arr[i] + arr[left] + arr[right] < target) {\n\t\t\t\t\tans += right - left;\n\t\t\t\t\tleft++;\n\t\t\t\t} else {\n\t\t\t\t\tright--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2012",
    "source": "leetcode",
    "language": "java",
    "query": "Given the circular array code and an integer key k, return the decrypted code to defuse the bomb. All the numbers are replaced simultaneously.",
    "snippets": [
        "\tString decrypt(String code, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < code.length(); i++){\n\t\t\tchar c = code.charAt(i);\n\t\t\tif(Character.isDigit(c)){\n\t\t\t\tint num = c - '0';\n\t\t\t\tnum = num - k;\n\t\t\t\tif(num < 0) num = num + 10;\n\t\t\t\tsb.append(num);\n\t\t\t}else{\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString decrypt(String code, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < code.length(); i++){\n\t\t\tchar c = code.charAt(i);\n\t\t\tif(c >= '0' && c <= '9'){\n\t\t\t\tint num = c - '0';\n\t\t\t\tnum = (num + k) % 10;\n\t\t\t\tsb.append(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString decrypt(String code, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < code.length(); i++){\n\t\t\tchar c = code.charAt(i);\n\t\t\tif(c >= '0' && c <= '9'){\n\t\t\t\tint num = c - '0';\n\t\t\t\tnum = (num + k) % 10;\n\t\t\t\tc = (char)(num + '0');\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic String decrypt(String code, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < code.length(); i++){\n\t\t\tchar c = code.charAt(i);\n\t\t\tif(c >= '0' && c <= '9'){\n\t\t\t\tint num = c - '0';\n\t\t\t\tnum = (num + k) % 10;\n\t\t\t\tsb.append(num);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString decrypt(String code, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < code.length(); i++){\n\t\t\tint num = code.charAt(i) - '0';\n\t\t\tnum = (num + k) % 10;\n\t\t\tsb.append(num);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2013",
    "source": "leetcode",
    "language": "java",
    "query": "For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k- Repeating value is the highest value k.",
    "snippets": [
        "\tstatic int maxKRepeating(String sequence, String word){\n\t\tint max = 0;\n\t\tint index = 0;\n\t\twhile(index < sequence.length()){\n\t\t\tint count = 0;\n\t\t\twhile(index < sequence.length() && sequence.substring(index, index + word.length()).equals(word)){\n\t\t\t\tcount++;\n\t\t\t\tindex += word.length();\n\t\t\t}\n\t\t\tif(count > max){\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxKRepeating(String sequence, String word){\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < sequence.length()){\n\t\t\tif(sequence.substring(i, i + word.length()).equals(word)){\n\t\t\t\tcount++;\n\t\t\t\ti += word.length();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxKRepeating(String sequence, String word){\n\t\tint max = 0;\n\t\tint len = word.length();\n\t\tint count = 0;\n\t\tfor(int i = 0; i < sequence.length(); i++){\n\t\t\tif(sequence.substring(i, i+len).equals(word)){\n\t\t\t\tcount++;\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int kRepeating(String sequence, String word){\n\t\tint max = 0;\n\t\tint index = 0;\n\t\twhile(index < sequence.length()){\n\t\t\tint count = 0;\n\t\t\twhile(index < sequence.length() && sequence.substring(index, index+word.length()).equals(word)){\n\t\t\t\tcount++;\n\t\t\t\tindex += word.length();\n\t\t\t}\n\t\t\tif(count > max){\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxKRepeating(String sequence, String word){\n\t\tint max = 0;\n\t\tint len = word.length();\n\t\tint count = 0;\n\t\tfor(int i = 0; i < sequence.length(); i++){\n\t\t\tif(sequence.substring(i, i + len).equals(word)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(count > max){\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2014",
    "source": "leetcode",
    "language": "java",
    "query": "You must write an algorithm with O(log n) runtime complexity. There is an integer array nums sorted in ascending order (with distinct values).",
    "snippets": [
        "\tint findPeakElement(int[] nums) {\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif (nums[mid] < nums[mid + 1]) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint findPeakElement(int[] nums) {\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif (nums[mid] > nums[mid + 1]) {\n\t\t\t\tright = mid;\n\t\t\t} else {\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint findMin(int[] nums) {\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif (nums[mid] > nums[right]) {\n\t\t\t\tleft = mid + 1;\n\t\t\t} else {\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn nums[left];\n\t}\n}\n",
        "\tint findPeakElement(int[] nums) {\n\t\tint left = 0, right = nums.length - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif (nums[mid] < nums[mid + 1])\n\t\t\t\tleft = mid + 1;\n\t\t\telse\n\t\t\t\tright = mid;\n\t\t}\n\t\treturn left;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2015",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0- indexed string s that you must perform k replacement operations on. The replacement operations are given as three 0-indexed parallel arrays, indices, sources, and targets, all of length k.",
    "snippets": [
        "\tstatic String replace(String s, int[] indices, int[] sources, int[] targets){\n\t\tStringBuilder sb = new StringBuilder(s);\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tsb.replace(indices[i], indices[i] + sources[i].length(), targets[i]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString str;\n\tpublic\n\tClazz(String str){\n\t\tthis.str = str;\n\t}\n\tpublic\n\tString replace(int[] indices, String[] sources, String[] targets){\n\t\tStringBuilder sb = new StringBuilder(str);\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tsb.replace(indices[i], indices[i] + sources[i].length(), targets[i]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString replace(String s, int[] indices, int[] sources, int[] targets) {\n\t\tStringBuilder sb = new StringBuilder(s);\n\t\tfor (int i = 0; i < indices.length; i++) {\n\t\t\tsb.replace(indices[i], indices[i] + sources[i].length(), targets[i]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString str;\n\tint[] indices;\n\tint[] sources;\n\tint[] targets;\n\tpublic Clazz(String str, int[] indices, int[] sources, int[] targets){\n\t\tthis.str = str;\n\t\tthis.indices = indices;\n\t\tthis.sources = sources;\n\t\tthis.targets = targets;\n\t}\n\tpublic String toString(){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(str);\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tsb.replace(indices[i], sources[i], targets[i]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString str;\n\tint[] indices;\n\tchar[] sources;\n\tchar[] targets;\n\tpublic Clazz(String str, int[] indices, char[] sources, char[] targets){\n\t\tthis.str = str;\n\t\tthis.indices = indices;\n\t\tthis.sources = sources;\n\t\tthis.targets = targets;\n\t}\n\tpublic String replace(){\n\t\tStringBuilder sb = new StringBuilder(str);\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tsb.setCharAt(indices[i], targets[i]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString replace(String s, int[] indices, String[] sources, String[] targets) {\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\ts = s.substring(0, indices[i]) + targets[i] + s.substring(indices[i] + sources[i].length());\n\t\t}\n\t\treturn s;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2016",
    "source": "leetcode",
    "language": "java",
    "query": "A ramp in an integer array nums is a pair (i, j) for which i < j. The width of such a ramp is j - i. If there is no ramp in nums, return 0.",
    "snippets": [
        "\tint widthOfBinaryRamp(int[] nums){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(nums[i] > nums[j]){\n\t\t\t\t\tmax = Math.max(max, j - i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint widthOfBinaryRamp(int[] nums){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(nums[i] < nums[j]){\n\t\t\t\t\tmax = Math.max(max, j - i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxWidthRamp(int[] nums) {\n\t\tint max = 0;\n\t\tint[] dp = new int[nums.length];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tdp[i] = 1;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (nums[j] < nums[i]) {\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxWidthRamp(int[] nums) {\n\t\tint max = 0;\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i] = i;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (nums[j] > nums[dp[i]]) {\n\t\t\t\t\tdp[i] = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i] - i);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint widthOfBinaryRamp(int[] nums){\n\t\tint max = 0;\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\twhile(i < j){\n\t\t\tint width = j - i;\n\t\t\tif(width > max){\n\t\t\t\tmax = width;\n\t\t\t}\n\t\t\tif(nums[i] < nums[j]){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint widthOfBinaryRamp(int[] nums){\n\t\tint max = 0;\n\t\tint min = 0;\n\t\tint width = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 1){\n\t\t\t\tmax = i;\n\t\t\t\tmin = i;\n\t\t\t}\n\t\t\tif(nums[i] == 0){\n\t\t\t\tif(max != 0){\n\t\t\t\t\twidth = max - min;\n\t\t\t\t\tmax = 0;\n\t\t\t\t\tmin = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(max != 0){\n\t\t\twidth = max - min;\n\t\t}\n\t\treturn width;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2017",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a string s consisting of digits and an integer k. Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters in the second group, and so on. A round can be completed if the length of s is greater than k.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tString[] result = split(s, k);\n\t\tfor(String str : result){\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\tpublic static String[] split(String s, int k){\n\t\tint len = s.length();\n\t\tint count = len/k;\n\t\tif(len%k != 0){\n\t\t\tcount++;\n\t\t}\n\t\tString[] result = new String[count];\n\t\tfor(int i = 0; i < count; i++){\n\t\t\tresult[i] = s.substring(i*k, Math.min((i+1)*k, len));\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tString[] result = split(s, k);\n\t\tfor(String str : result){\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\tpublic static String[] split(String s, int k){\n\t\tint len = s.length();\n\t\tint count = len/k;\n\t\tif(len%k != 0){\n\t\t\tcount++;\n\t\t}\n\t\tString[] result = new String[count];\n\t\tfor(int i = 0; i < count; i++){\n\t\t\tif(i == count - 1){\n\t\t\t\tresult[i] = s.substring(i*k);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresult[i] = s.substring(i*k, (i+1)*k);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tString[] result = split(s, k);\n\t\tfor(String str : result){\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\tpublic static String[] split(String s, int k){\n\t\tint len = s.length();\n\t\tint count = len/k;\n\t\tif(len%k != 0){\n\t\t\tcount++;\n\t\t}\n\t\tString[] result = new String[count];\n\t\tfor(int i = 0; i < count; i++){\n\t\t\tresult[i] = s.substring(i*k, (i+1)*k);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tString[] result = split(s, k);\n\t\tfor(String str : result){\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\tpublic static String[] split(String s, int k){\n\t\tString[] result = new String[(s.length() - 1) / k + 1];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < s.length(); i += k){\n\t\t\tresult[index++] = s.substring(i, i + k);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tString[] result = split(s, k);\n\t\tfor(String str: result){\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\tpublic static String[] split(String s, int k){\n\t\tString[] result = new String[s.length()/k];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i+=k){\n\t\t\tresult[count++] = s.substring(i, i+k);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tSystem.out.println(s.length()%k==0?s.length()/k:s.length()/k+1);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tString[] result = divide(s, k);\n\t\tfor(String str : result){\n\t\t\tSystem.out.println(str);\n\t\t}\n\t}\n\tpublic static String[] divide(String s, int k){\n\t\tint len = s.length();\n\t\tint count = len / k;\n\t\tint remain = len % k;\n\t\tString[] result = new String[count + (remain == 0 ? 0 : 1)];\n\t\tfor(int i = 0; i < count; i++){\n\t\t\tresult[i] = s.substring(i * k, (i + 1) * k);\n\t\t}\n\t\tif(remain != 0){\n\t\t\tresult[count] = s.substring(count * k, len);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tSystem.out.println(s.length()%k);\n\t\tint count = s.length()/k;\n\t\tfor(int i = 0; i < count; i++){\n\t\t\tSystem.out.println(s.substring(i*k, (i+1)*k));\n\t\t}\n\t\tSystem.out.println(s.substring(count*k, s.length()));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"123456789\";\n\t\tint k = 3;\n\t\tSystem.out.println(s.length()/k);\n\t\tSystem.out.println(s.length()%k);\n\t\tSystem.out.println(s.length()/k+1);\n\t\tSystem.out.println(s.length()%k==0);\n\t\tSystem.out.println(s.length()%k==1);\n\t\tSystem.out.println(s.length()%k==2);\n\t\tSystem.out.println(s.length()%k==3);\n\t\tSystem.out.println(s.length()%k==4);\n\t\tSystem.out.println(s.length()%k==5);\n\t\tSystem.out.println(s.length()%k==6);\n\t\tSystem.out.println(s.length()%k==7);\n\t\tSystem.out.println(s.length()%k==8);\n\t\tSystem.out.println(s.length()%k==9);\n\t\tSystem.out.println(s.length()%k==10);\n\t\tSystem.out.println(s.length()%k==11);\n\t\tSystem.out.println(s.length()%k==12);\n\t\tSystem.out.println(s.length()%k==13);\n\t\tSystem.out.println(s.length()%k==14);\n\t\tSystem.out.println(s.length()%k==15);\n\t\tSystem.out.println(s.length()%k==16);\n\t\tSystem.out.println(s.length()%k==17);\n\t\tSystem.out.println(s.length()%k==18);\n\t\tSystem.out.println(s.length()%k==19);\n\t\tSystem.out.println(s.length()%k==20);\n\t\tSystem.out.println(s.length()%k==21);\n\t\tSystem.out.println(s.length()%k==22);\n\t\tSystem.out\n"
    ],
    "results": 10
},{
    "id": "2018",
    "source": "leetcode",
    "language": "java",
    "query": "Return true if the circle and rectangle are overlapped otherwise return false. Check if there is any point (xi, yi) that belongs to the circles and rectangle at the same time.",
    "snippets": [
        "\tboolean isOverlapped(int x1, int y1, int r1, int x2, int y2, int w2, int h2){\n\t\tint x3 = x2 + w2;\n\t\tint y3 = y2 + h2;\n\t\tint x4 = x2 - w2;\n\t\tint y4 = y2 - h2;\n\t\tint x5 = x1 + r1;\n\t\tint y5 = y1 + r1;\n\t\tint x6 = x1 - r1;\n\t\tint y6 = y1 - r1;\n\t\tif(x3 > x6 && x3 < x5 && y3 > y6 && y3 < y5) return true;\n\t\tif(x4 > x6 && x4 < x5 && y4 > y6 && y4 < y5) return true;\n\t\tif(x5 > x6 && x5 < x3 && y5 > y6 && y5 < y3) return true;\n\t\tif(x6 > x6 && x6 < x4 && y6 > y6 && y6 < y4) return true;\n\t\treturn false;\n\t}\n}\n",
        "\tboolean isOverlapped(int x1, int y1, int r1, int x2, int y2, int r2){\n\t\tint x = x2 - x1;\n\t\tint y = y2 - y1;\n\t\tint d = (x * x) + (y * y);\n\t\tint r = r1 + r2;\n\t\tif(d <= r * r)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isOverlapped(int x1, int y1, int r1, int x2, int y2, int r2){\n\t\tint x = x2 - x1;\n\t\tint y = y2 - y1;\n\t\tint d = (int)Math.sqrt(x*x + y*y);\n\t\tif(d <= r1 + r2){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isOverlapped(int x1, int y1, int r1, int x2, int y2, int r2){\n\t\tint x = x2 - x1;\n\t\tint y = y2 - y1;\n\t\tint d = (x*x) + (y*y);\n\t\tint r = r1 + r2;\n\t\treturn d <= r*r;\n\t}\n}\n",
        "\tboolean isOverlapped(int x1, int y1, int r1, int x2, int y2, int r2){\n\t\tint x = x2 - x1;\n\t\tint y = y2 - y1;\n\t\tint d = x*x + y*y;\n\t\tint r = r1 + r2;\n\t\treturn d <= r*r;\n\t}\n}\n",
        "\tstatic boolean isOverlapped(int x1, int y1, int r1, int x2, int y2, int w2, int h2){\n\t\tint x2_max = x2 + w2;\n\t\tint y2_max = y2 + h2;\n\t\tint x1_max = x1 + r1;\n\t\tint y1_max = y1 + r1;\n\t\tif(x1_max > x2 && x1 < x2_max && y1_max > y2 && y1 < y2_max)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n",
        "\tboolean isOverlapped(int x1, int y1, int r1, int x2, int y2, int r2){\n\t\tdouble d = Math.sqrt(Math.pow(x1-x2, 2) + Math.pow(y1-y2, 2));\n\t\tif(d <= r1+r2) return true;\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isOverlapped(Circle circle, Rectangle rectangle){\n\t\tint x = circle.getX();\n\t\tint y = circle.getY();\n\t\tint r = circle.getR();\n\t\tint x1 = rectangle.getX();\n\t\tint y1 = rectangle.getY();\n\t\tint x2 = rectangle.getX() + rectangle.getWidth();\n\t\tint y2 = rectangle.getY() + rectangle.getHeight();\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r)\n\t\t\treturn true;\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2\n",
        "\tstatic boolean isOverlapped(Circle circle, Rectangle rectangle){\n\t\tdouble x = circle.getX();\n\t\tdouble y = circle.getY();\n\t\tdouble r = circle.getR();\n\t\tdouble x1 = rectangle.getX();\n\t\tdouble y1 = rectangle.getY();\n\t\tdouble x2 = rectangle.getX() + rectangle.getWidth();\n\t\tdouble y2 = rectangle.getY() + rectangle.getHeight();\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn true;\n\t\t}\n\t\tif(x1 - r <= x && x <= x2 + r && y1 - r <= y && y <= y2 + r){\n\t\t\treturn\n"
    ],
    "results": 10
},{
    "id": "2019",
    "source": "leetcode",
    "language": "java",
    "query": "The frequency of a letter x is the number of times it occurs in the string. Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' betweenword1 andword2 is at most 3.",
    "snippets": [
        "\tstatic boolean isAlmostEquivalent(String word1, String word2){\n\t\tint[] count1 = new int[26];\n\t\tint[] count2 = new int[26];\n\t\tfor(int i = 0; i < word1.length(); i++){\n\t\t\tcount1[word1.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < word2.length(); i++){\n\t\t\tcount2[word2.charAt(i) - 'a']++;\n\t\t}\n\t\tint diff = 0;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tdiff += Math.abs(count1[i] - count2[i]);\n\t\t}\n\t\treturn diff <= 3;\n\t}\n}\n",
        "\tstatic boolean isAlmostEquivalent(String word1, String word2){\n\t\tint[] freq1 = new int[26];\n\t\tint[] freq2 = new int[26];\n\t\tfor(int i = 0; i < word1.length(); i++){\n\t\t\tfreq1[word1.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < word2.length(); i++){\n\t\t\tfreq2[word2.charAt(i) - 'a']++;\n\t\t}\n\t\tint diff = 0;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tdiff += Math.abs(freq1[i] - freq2[i]);\n\t\t}\n\t\treturn diff <= 3;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2020",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.",
    "snippets": [
        "\tint addDigits(int num) {\n\t\tif(num<10) return num;\n\t\tint sum=0;\n\t\twhile(num>0){\n\t\t\tsum+=num%10;\n\t\t\tnum/=10;\n\t\t}\n\t\treturn addDigits(sum);\n\t}\n}\n",
        "\tint addDigits(int num) {\n\t\tif(num<=9) return num;\n\t\tint sum=0;\n\t\twhile(num>0){\n\t\t\tsum+=num%10;\n\t\t\tnum/=10;\n\t\t}\n\t\treturn addDigits(sum);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2021",
    "source": "leetcode",
    "language": "java",
    "query": "A subarray is a contiguous non-empty sequence of elements within an array. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.",
    "snippets": [
        "\tint maxSubArray(int[] nums) {\n\t\tint max = nums[0];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum > max){\n\t\t\t\tmax = sum;\n\t\t\t}\n\t\t\tif(sum < 0){\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxSubArray(int[] nums) {\n\t\tint max = nums[0];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum > max)\n\t\t\t\tmax = sum;\n\t\t\tif(sum < 0)\n\t\t\t\tsum = 0;\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxSubArray(int[] nums) {\n\t\tint max = nums[0];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum > max){\n\t\t\t\tmax = sum;\n\t\t\t}\n\t\t\tif(sum < 0){\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maximumGap(int[] nums) {\n\t\tif(nums.length<2) return 0;\n\t\tint max=nums[0];\n\t\tint min=nums[0];\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tif(nums[i]>max) max=nums[i];\n\t\t\tif(nums[i]<min) min=nums[i];\n\t\t}\n\t\tint gap=(max-min)/(nums.length-1);\n\t\tint[] buckets=new int[nums.length-1];\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tint index=(nums[i]-min)/gap;\n\t\t\tbuckets[index]++;\n\t\t}\n\t\tint maxGap=0;\n\t\tint last=0;\n\t\tfor(int i=0;i<buckets.length;i++){\n\t\t\tif(buckets[i]==0) continue;\n\t\t\tif(i-last>maxGap) maxGap=i-last;\n\t\t\tlast=i;\n\t\t}\n\t\tif(nums.length-1-last>maxGap) maxGap=nums.length-1-last;\n\t\treturn maxGap;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2022",
    "source": "leetcode",
    "language": "java",
    "query": "For two strings s and t, we say \"t divides s\" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times) Given two strings str1 and str2, return the largest string x such that x divides both str1 & str2.",
    "snippets": [
        "\tString gcdOfStrings(String str1, String str2) {\n\t\tif(str1.length() == 0 || str2.length() == 0) return \"\";\n\t\tif(str1.length() < str2.length()) return gcdOfStrings(str2, str1);\n\t\tif(str2.length() == 0) return str1;\n\t\tif(str1.endsWith(str2)) return str2;\n\t\treturn gcdOfStrings(str1.substring(0, str1.length() - str2.length()), str2);\n\t}\n}\n",
        "\tString gcdOfStrings(String str1, String str2) {\n\t\tif(str1.length() == 0 || str2.length() == 0) return \"\";\n\t\tif(str1.length() < str2.length()) return gcdOfStrings(str2, str1);\n\t\tif(str2.length() == 0) return str1;\n\t\tif(str1.charAt(0) != str2.charAt(0)) return \"\";\n\t\treturn gcdOfStrings(str1.substring(1), str2.substring(1));\n\t}\n}\n",
        "\tString gcdOfStrings(String str1, String str2) {\n\t\tif(str1.length() < str2.length()) return gcdOfStrings(str2, str1);\n\t\tif(str2.length() == 0) return str1;\n\t\tif(str1.length() % str2.length() != 0) return \"\";\n\t\tif(str1.substring(0, str2.length()).equals(str2)) return str2;\n\t\treturn gcdOfStrings(str1.substring(str2.length()), str2);\n\t}\n}\n",
        "\tString gcdOfStrings(String str1, String str2) {\n\t\tif(str1+str2!=str2+str1) return \"\";\n\t\tint len1=str1.length(),len2=str2.length();\n\t\tif(len1==len2) return str1;\n\t\tif(len1>len2) return gcdOfStrings(str1.substring(len2),str2);\n\t\treturn gcdOfStrings(str1,str2.substring(len1));\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2023",
    "source": "leetcode",
    "language": "java",
    "query": "You must implement a solution with a linear runtime complexity and use only constant extra space. Given a non-empty array of integers nums, every element appears twice except for one.",
    "snippets": [
        "\tint singleNumber(int[] nums) {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tresult ^= nums[i];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint singleNumber(int[] nums) {\n\t\tint res = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tres ^= nums[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int singleNumber(int[] nums) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tresult ^= nums[i];\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2024",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString[] items = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"};\n\t\tString ruleKey = \"type\";\n\t\tString ruleValue = \"B\";\n\t\tSystem.out.println(new Clazz().findItems(items, ruleKey, ruleValue));\n\t}\n\tpublic int findItems(String[] items, String ruleKey, String ruleValue){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < items.length; i++){\n\t\t\tif(items[i].split(\",\")[0].equals(ruleValue)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] items = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"};\n\t\tString ruleKey = \"type\";\n\t\tString ruleValue = \"C\";\n\t\tSystem.out.println(new Clazz().findItems(items, ruleKey, ruleValue));\n\t}\n\tpublic int findItems(String[] items, String ruleKey, String ruleValue){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < items.length; i++){\n\t\t\tif(items[i].substring(0, 1).equals(ruleValue)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] items = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"};\n\t\tString ruleKey = \"type\";\n\t\tString ruleValue = \"A\";\n\t\tSystem.out.println(new Clazz().findItems(items, ruleKey, ruleValue));\n\t}\n\tpublic int findItems(String[] items, String ruleKey, String ruleValue){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < items.length; i++){\n\t\t\tif(items[i].equals(ruleValue)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] items = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"};\n\t\tString ruleKey = \"type\";\n\t\tString ruleValue = \"name\";\n\t\tString[] result = solution(items, ruleKey, ruleValue);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic static String[] solution(String[] items, String ruleKey, String ruleValue){\n\t\tString[] result = new String[items.length];\n\t\tfor(int i = 0; i < items.length; i++){\n\t\t\tString[] item = items[i].split(\",\");\n\t\t\tif(item[0].equals(ruleKey) && item[1].equals(ruleValue)){\n\t\t\t\tresult[i] = item[2];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] items = {\"A\", \"B\", \"C\", \"D\", \"E\"};\n\t\tString ruleKey = \"color\";\n\t\tString ruleValue = \"B\";\n\t\tSystem.out.println(classify(items, ruleKey, ruleValue));\n\t}\n\tpublic static int classify(String[] items, String ruleKey, String ruleValue){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < items.length; i++){\n\t\t\tif(items[i].contains(ruleKey) && items[i].contains(ruleValue)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] items = {\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"};\n\t\tString ruleKey = \"color\";\n\t\tString ruleValue = \"blue\";\n\t\tString[] result = new String[items.length];\n\t\tfor(int i = 0; i < items.length; i++){\n\t\t\tif(items[i].equals(ruleKey)){\n\t\t\t\tif(items[i+1].equals(ruleValue)){\n\t\t\t\t\tresult[i] = items[i+2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n}\n"
    ],
    "results": 6
},{
    "id": "2025",
    "source": "leetcode",
    "language": "java",
    "query": "A k-diff pair is an integer pair (nums[i], nums[j), where the following are true: 0 <= i, j < nums.length. Given an array of integers nums and an integer k, return the number of unique k-Diff pairs in the array.",
    "snippets": [
        "\tint uniquePairs(int[] nums, int k) {\n\t\tint count = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(Math.abs(nums[i] - nums[j]) == k){\n\t\t\t\t\tset.add(nums[i] + nums[j]);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint uniquePairs(int[] nums, int k) {\n\t\tint count = 0;\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(Math.abs(nums[i] - nums[j]) == k){\n\t\t\t\t\tset.add(nums[i] + nums[j]);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint findPairs(int[] nums, int k) {\n\t\tif(k < 0) return 0;\n\t\tif(k == 0) {\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\t\tif(set.contains(nums[i])) return 1;\n\t\t\t\tset.add(nums[i]);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tint count = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++) {\n\t\t\tif(set.contains(nums[i] - k)) count++;\n\t\t\tif(set.contains(nums[i] + k)) count++;\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\treturn count / 2;\n\t}\n}\n",
        "\tint findPairs(int[] nums, int k) {\n\t\tif(k < 0) return 0;\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(set.contains(nums[i])){\n\t\t\t\tset.add(nums[i] + k);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tset.add(nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn set.size();\n\t}\n}\n",
        "\tint findPairs(int[] nums, int k) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tint count = 0;\n\t\tSet<Integer> set = new HashSet<>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(set.contains(nums[i])) count++;\n\t\t\tset.add(nums[i] + k);\n\t\t\tset.add(nums[i] - k);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint uniquePairs(int[] nums, int k) {\n\t\tint n = nums.length;\n\t\tint[] cnt = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (Math.abs(nums[i] - nums[j]) == k) {\n\t\t\t\t\tcnt[i]++;\n\t\t\t\t\tcnt[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres += cnt[i] * (cnt[i] - 1) / 2;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint uniquePairs(int[] nums, int k) {\n\t\tint n = nums.length;\n\t\tint[] cnt = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt[i] = 1;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (nums[i] - nums[j] == k) {\n\t\t\t\t\tcnt[i] += cnt[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres += cnt[i] * (cnt[i] - 1) / 2;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint findPairs(int[] nums, int k) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tint count = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmap.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(nums[i] + k)) count++;\n\t\t\tif(map.containsKey(nums[i] - k)) count++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint findPairs(int[] nums, int k) {\n\t\tif(k<0) return 0;\n\t\tif(nums==null||nums.length==0) return 0;\n\t\tint count=0;\n\t\tSet<Integer> set=new HashSet<Integer>();\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tif(set.contains(nums[i]+k)) count++;\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint findPairs(int[] nums, int k) {\n\t\tif(nums==null||nums.length==0||k<0)\n\t\t\treturn 0;\n\t\tint count=0;\n\t\tSet<Integer> set=new HashSet<>();\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tif(set.contains(nums[i]+k))\n\t\t\t\tcount++;\n\t\t\tif(set.contains(nums[i]-k))\n\t\t\t\tcount++;\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\treturn count/2;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2026",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.",
    "snippets": [
        "\tint numTilings(int n) {\n\t\tint mod = 1000000007;\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tdp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tstatic int numTilings(int n) {\n\t\tint mod = 1000000007;\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tdp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint numTilings(int n) {\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return 2;\n\t\tif(n == 2) return 4;\n\t\tint[] dp = new int[n+1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 2;\n\t\tdp[2] = 4;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint numTilings(int n) {\n\t\tint MOD = 1000000007;\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tdp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % MOD;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tstatic int numTilings(int n) {\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return 2;\n\t\tif(n == 2) return 5;\n\t\tint[] dp = new int[n+1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 2;\n\t\tdp[2] = 5;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2027",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.",
    "snippets": [
        "\tint pass;\n\tint total;\n\tpublic Clazz(int pass, int total){\n\t\tthis.pass = pass;\n\t\tthis.total = total;\n\t}\n}\n",
        "\tint pass;\n\tint total;\n\tpublic Clazz(int pass, int total){\n\t\tthis.pass = pass;\n\t\tthis.total = total;\n\t}\n\tpublic double getAverage(){\n\t\treturn (double)pass/total;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2028",
    "source": "leetcode",
    "language": "java",
    "query": "Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element. If the array is already strictly increasing, returntrue.",
    "snippets": [
        "\tboolean checkPossibility(int[] nums) {\n\t\tint count = 0;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tif(nums[i] < nums[i-1]){\n\t\t\t\tcount++;\n\t\t\t\tif(i == 1 || nums[i-2] <= nums[i]){\n\t\t\t\t\tnums[i-1] = nums[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnums[i] = nums[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] nums) {\n\t\tint count = 0;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tif(nums[i] < nums[i-1]){\n\t\t\t\tcount++;\n\t\t\t\tif(i > 1 && nums[i] < nums[i-2]){\n\t\t\t\t\tnums[i] = nums[i-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] nums) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length - 1; i++){\n\t\t\tif(nums[i] > nums[i + 1]){\n\t\t\t\tcount++;\n\t\t\t\tif(i == 0 || nums[i - 1] <= nums[i + 1]){\n\t\t\t\t\tnums[i] = nums[i + 1];\n\t\t\t\t}else{\n\t\t\t\t\tnums[i + 1] = nums[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2029",
    "source": "leetcode",
    "language": "java",
    "query": "Given a characters array tasks, representing the tasks a CPU needs to do, where each letter represents a different task. Tasks could be done in any order. Each task is done in one unit of time. There is a non-negative integer n that represents the cooldown period between two same tasks.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tchar[] tasks = {'A','A','A','B','B','B'};\n\t\tint n = 2;\n\t\tSystem.out.println(leetcode.task_scheduler.TaskScheduler.leastInterval(tasks, n));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tchar[] tasks = {'A','A','A','B','B','B'};\n\t\tint n = 2;\n\t\tSystem.out.println(leetcode.task_scheduler(tasks, n));\n\t}\n}\n",
        "\tint leastInterval(char[] tasks, int n) {\n\t\tint[] count = new int[26];\n\t\tfor (char c : tasks) {\n\t\t\tcount[c - 'A']++;\n\t\t}\n\t\tArrays.sort(count);\n\t\tint i = 25;\n\t\twhile (i >= 0 && count[i] == count[25]) {\n\t\t\ti--;\n\t\t}\n\t\treturn Math.max(tasks.length, (count[25] - 1) * (n + 1) + 25 - i);\n\t}\n}\n",
        "\tint leastInterval(char[] tasks, int n) {\n\t\tint[] count = new int[26];\n\t\tfor (char c : tasks)\n\t\t\tcount[c - 'A']++;\n\t\tArrays.sort(count);\n\t\tint i = 25;\n\t\twhile (i >= 0 && count[i] == count[25])\n\t\t\ti--;\n\t\treturn Math.max(tasks.length, (count[25] - 1) * (n + 1) + 25 - i);\n\t}\n}\n",
        "\tstatic int[] leastInterval(char[] tasks, int n) {\n\t\tint[] count = new int[26];\n\t\tfor (char c : tasks) {\n\t\t\tcount[c - 'A']++;\n\t\t}\n\t\tArrays.sort(count);\n\t\tint max = count[25] - 1;\n\t\tint idle = max * n;\n\t\tfor (int i = 24; i >= 0 && count[i] > 0; i--) {\n\t\t\tidle -= Math.min(max, count[i]);\n\t\t}\n\t\tif (idle < 0) {\n\t\t\tidle = 0;\n\t\t}\n\t\tint len = tasks.length + idle;\n\t\tint[] ans = new int[len];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tans[i] = '.';\n\t\t}\n\t\tfor (int i = 0; i < tasks.length; i++) {\n\t\t\tint pos = i + count[25] - 1;\n\t\t\tif (pos >= len) {\n\t\t\t\tpos %= len;\n\t\t\t}\n\t\t\tans[pos] = tasks[i];\n\t\t}\n\t\treturn ans;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2030",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s, return the power of s. The power of the string is the maximum length of a non-empty substring.",
    "snippets": [
        "\tint power(String s){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i; j < s.length(); j++){\n\t\t\t\tString sub = s.substring(i, j+1);\n\t\t\t\tif(isPalindrome(sub)){\n\t\t\t\t\tmax = Math.max(max, sub.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tboolean isPalindrome(String s){\n\t\tint i = 0;\n\t\tint j = s.length()-1;\n\t\twhile(i < j){\n\t\t\tif(s.charAt(i) != s.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint power(String s){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i; j < s.length(); j++){\n\t\t\t\tString sub = s.substring(i, j+1);\n\t\t\t\tif(isPower(sub)){\n\t\t\t\t\tmax = Math.max(max, sub.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic boolean isPower(String s){\n\t\tif(s.length() == 1){\n\t\t\treturn true;\n\t\t}\n\t\tif(s.length() == 2){\n\t\t\treturn s.charAt(0) == s.charAt(1);\n\t\t}\n\t\tif(s.length() == 3){\n\t\t\treturn s.charAt(0) == s.charAt(2) && s.charAt(1) == s.charAt(2);\n\t\t}\n\t\tif(s.length() == 4){\n\t\t\treturn s.charAt(0) == s.charAt(3) && s.charAt(1) == s.charAt(3) && s.charAt(2) == s.charAt(3);\n\t\t}\n\t\tif(s.length() == 5){\n\t\t\treturn s.charAt(0) == s.charAt(4) && s.charAt(1) == s.charAt(4) && s.charAt(2) == s.charAt(4) && s.charAt(3) == s.charAt(4);\n\t\t}\n\t\tif(s.length() == 6){\n\t\t\treturn s.charAt(0) == s.charAt(5) && s.charAt(1) == s.charAt(5) && s.charAt(2) == s.charAt(5) && s.charAt(3) == s.charAt(5) && s.charAt(4) == s.charAt(5);\n",
        "\tint power(String s){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i; j < s.length(); j++){\n\t\t\t\tString temp = s.substring(i, j+1);\n\t\t\t\tif(isPalindrome(temp)){\n\t\t\t\t\tmax = Math.max(max, temp.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic boolean isPalindrome(String s){\n\t\tint i = 0;\n\t\tint j = s.length()-1;\n\t\twhile(i < j){\n\t\t\tif(s.charAt(i) != s.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint power(String s){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i + 1; j < s.length(); j++){\n\t\t\t\tString sub = s.substring(i, j);\n\t\t\t\tif(isPower(sub)){\n\t\t\t\t\tmax = Math.max(max, sub.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tboolean isPower(String s){\n\t\tint len = s.length();\n\t\tif(len == 1) return true;\n\t\tif(len == 2) return s.charAt(0) == s.charAt(1);\n\t\tif(s.charAt(0) == s.charAt(1)) return isPower(s.substring(2));\n\t\treturn false;\n\t}\n}\n",
        "\tint power(String s){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i+1; j < s.length(); j++){\n\t\t\t\tString sub = s.substring(i,j);\n\t\t\t\tif(isPower(sub)){\n\t\t\t\t\tmax = Math.max(max, sub.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tboolean isPower(String s){\n\t\tif(s.length() == 1){\n\t\t\treturn true;\n\t\t}\n\t\tif(s.length() == 2){\n\t\t\treturn s.charAt(0) == s.charAt(1);\n\t\t}\n\t\tif(s.length() == 3){\n\t\t\treturn s.charAt(0) == s.charAt(2) || s.charAt(0) == s.charAt(1);\n\t\t}\n\t\tif(s.length() == 4){\n\t\t\treturn s.charAt(0) == s.charAt(3) || s.charAt(0) == s.charAt(1) || s.charAt(0) == s.charAt(2);\n\t\t}\n\t\tif(s.length() == 5){\n\t\t\treturn s.charAt(0) == s.charAt(4) || s.charAt(0) == s.charAt(1) || s.charAt(0) == s.charAt(2) || s.charAt(0) == s.charAt(3);\n\t\t}\n\t\tif(s.length() == 6){\n\t\t\treturn s.charAt(0) == s.charAt(5) || s.charAt(0) == s.charAt(1) || s.charAt(0) == s.charAt(2) || s.charAt(0) == s.charAt(3) || s.charAt(0) == s.charAt(4\n",
        "\tint power(String s){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i + 1; j < s.length(); j++){\n\t\t\t\tString sub = s.substring(i, j);\n\t\t\t\tif(isPalindrome(sub)){\n\t\t\t\t\tmax = Math.max(max, sub.length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tboolean isPalindrome(String s){\n\t\tint i = 0;\n\t\tint j = s.length() - 1;\n\t\twhile(i < j){\n\t\t\tif(s.charAt(i) != s.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2031",
    "source": "leetcode",
    "language": "java",
    "query": "A server center is represented as a m * n integer matrix grid. 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on same column.",
    "snippets": [
        "\tint countServers(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tif(i > 0 && grid[i - 1][j] == 1) count++;\n\t\t\t\t\tif(j > 0 && grid[i][j - 1] == 1) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,1,0,0},{1,1,0,0},{0,0,1,0},{0,0,0,1}};\n\t\tSystem.out.println(countServers(grid));\n\t}\n\tpublic static int countServers(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tif(i > 0 && grid[i-1][j] == 1) count++;\n\t\t\t\t\tif(j > 0 && grid[i][j-1] == 1) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,1,0,0},{1,1,0,0},{0,0,1,0},{0,0,0,1}};\n\t\tSystem.out.println(countServers(grid));\n\t}\n\tpublic static int countServers(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tif(i == 0){\n\t\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\t\tif(grid[i+1][j] == 1 || grid[i][j+1] == 1){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(j == n-1){\n\t\t\t\t\t\t\tif(grid[i+1][j] == 1 || grid[i][j-1] == 1){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(grid[i+1][j] == 1 || grid[i][j+1] == 1 || grid[i][j-1] == 1){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(i == m-1){\n\t\t\t\t\t\tif(j == 0){\n\t\t\t\t\t\t\tif(grid[i-1][j] == 1 || grid[i][j+1] == 1){\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,1,0},{0,1,0},{0,1,0}};\n\t\tSystem.out.println(countServers(grid));\n\t}\n\tpublic static int countServers(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tif(i > 0 && grid[i-1][j] == 1) count++;\n\t\t\t\t\tif(j > 0 && grid[i][j-1] == 1) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid2 = {{1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid3 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid4 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid5 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid6 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid7 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid8 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid9 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid10 = {{1,1,0,0},{0,1,1,0},{0,0,1,0},{0,0,1,0}};\n\t\tint[][] grid11 = {{1,1,0,0},{0\n"
    ],
    "results": 10
},{
    "id": "2032",
    "source": "leetcode",
    "language": "java",
    "query": "Alice has n balloons arranged on a rope. She asks Bob for help to make the rope colorful. Bob can remove some balloons from the rope to make it colorful.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans += a[i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = in.nextInt();\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = in.nextInt();\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = in.nextInt();\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = in.nextInt();\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = in.nextInt();\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = in.nextInt();\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ti[i] = in.nextInt();\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tj[i] = in.next\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\tsum += a[j];\n\t\t\t\tans = Math.max(ans, sum);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = i; j < n; j++){\n\t\t\t\tsum += a[j];\n\t\t\t\tans = Math.max(ans, sum);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = a[i];\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = a[i];\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = a[i];\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = a[i];\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = a[i];\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = a[i];\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ti[i] = a[i];\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tj[i] = a[i];\n\t\t}\n\t\tint[] k = new\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5};\n\t\tint[] c = {1,2,3,4,5};\n\t\tint[] d = {1,2,3,4,5};\n\t\tint[] e = {1,2,3,4,5};\n\t\tint[] f = {1,2,3,4,5};\n\t\tint[] g = {1,2,3,4,5};\n\t\tint[] h = {1,2,3,4,5};\n\t\tint[] i = {1,2,3,4,5};\n\t\tint[] j = {1,2,3,4,5};\n\t\tint[] k = {1,2,3,4,5};\n\t\tint[] l = {1,2,3,4,5};\n\t\tint[] m = {1,2,3,4,5};\n\t\tint[] n1 = {1,2,3,4,5};\n\t\tint[] o = {1,2,3,4,5};\n\t\tint[] p = {1,2,3,4,5};\n\t\tint[] q = {1,2,3,4,5};\n\t\tint[] r = {1,2,3,4,5};\n\t\tint[] s = {1,2,3,4,5};\n\t\tint[] t = {1,2,3,4,5};\n\t\tint[] u = {1,2,3,4,5};\n\t\tint[] v = {1,2,3,4,5};\n\t\tint[] w = {1,2,3,4,5};\n\t\tint[] x = {1,2,3,4,5};\n\t\tint[] y = {1,2,3,4,5};\n\t\tint[] z = {1,2,3,4,5};\n\t\tint[] a1 = {1,2,\n",
        "\tint makeRope(int n){\n\t\tif(n==1) return 1;\n\t\tif(n==2) return 2;\n\t\treturn makeRope(n-1)+makeRope(n-2);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2033",
    "source": "leetcode",
    "language": "java",
    "query": "utf-8 can be from 1 to 4 bytes long, subjected to the following rules. For a 1-byte character, the first bit is a 0, followed by its Unicode code. For an n-bytes character the first n bits are all one's, the n + 1 bit is 0.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tchar c = '\\u0041';\n\t\tSystem.out.println(c);\n\t\tSystem.out.println((int)c);\n\t\tSystem.out.println((int)'\\u0041');\n\t\tSystem.out.println((int)'\\u0042');\n\t\tSystem.out.println((int)'\\u0043');\n\t\tSystem.out.println((int)'\\u0044');\n\t\tSystem.out.println((int)'\\u0045');\n\t\tSystem.out.println((int)'\\u0046');\n\t\tSystem.out.println((int)'\\u0047');\n\t\tSystem.out.println((int)'\\u0048');\n\t\tSystem.out.println((int)'\\u0049');\n\t\tSystem.out.println((int)'\\u004A');\n\t\tSystem.out.println((int)'\\u004B');\n\t\tSystem.out.println((int)'\\u004C');\n\t\tSystem.out.println((int)'\\u004D');\n\t\tSystem.out.println((int)'\\u004E');\n\t\tSystem.out.println((int)'\\u004F');\n\t\tSystem.out.println((int)'\\u0050');\n\t\tSystem.out.println((int)'\\u0051');\n\t\tSystem.out.println((int)'\\u0052');\n\t\tSystem.out.println((int)'\\u0053');\n\t\tSystem.out.println((int)'\\u0054');\n\t\tSystem.out.println((int)'\\u0055');\n\t\tSystem.out.println((int)'\\u0056');\n\t\tSystem.out.println((int)'\\u0057');\n\t\tSystem.out.println((int)'\\u0058');\n\t\tSystem.out.println((int)'\\u0059');\n\t\tSystem.out.println((int)'\\u005A');\n\t\tSystem.out.println((int)'\\u0061');\n\t\tSystem.out.println((int)'\\u0062');\n\t\tSystem.\n",
        "\tstatic void main(String[] args){\n\t\tchar c = '\\u0041';\n\t\tSystem.out.println(c);\n\t\tSystem.out.println((int)c);\n\t\tSystem.out.println((int)'\\u0041');\n\t\tSystem.out.println((int)'\\u0042');\n\t\tSystem.out.println((int)'\\u0043');\n\t\tSystem.out.println((int)'\\u0044');\n\t\tSystem.out.println((int)'\\u0045');\n\t\tSystem.out.println((int)'\\u0046');\n\t\tSystem.out.println((int)'\\u0047');\n\t\tSystem.out.println((int)'\\u0048');\n\t\tSystem.out.println((int)'\\u0049');\n\t\tSystem.out.println((int)'\\u004a');\n\t\tSystem.out.println((int)'\\u004b');\n\t\tSystem.out.println((int)'\\u004c');\n\t\tSystem.out.println((int)'\\u004d');\n\t\tSystem.out.println((int)'\\u004e');\n\t\tSystem.out.println((int)'\\u004f');\n\t\tSystem.out.println((int)'\\u0050');\n\t\tSystem.out.println((int)'\\u0051');\n\t\tSystem.out.println((int)'\\u0052');\n\t\tSystem.out.println((int)'\\u0053');\n\t\tSystem.out.println((int)'\\u0054');\n\t\tSystem.out.println((int)'\\u0055');\n\t\tSystem.out.println((int)'\\u0056');\n\t\tSystem.out.println((int)'\\u0057');\n\t\tSystem.out.println((int)'\\u0058');\n\t\tSystem.out.println((int)'\\u0059');\n\t\tSystem.out.println((int)'\\u005a');\n\t\tSystem.out.println((int\n",
        "\tstatic void main(String[] args){\n\t\tchar c = '\\u0041';\n\t\tSystem.out.println(c);\n\t\tSystem.out.println((int)c);\n\t\tSystem.out.println((int)'\\u0041');\n\t\tSystem.out.println((int)'\\u0042');\n\t\tSystem.out.println((int)'\\u0043');\n\t\tSystem.out.println((int)'\\u0044');\n\t\tSystem.out.println((int)'\\u0045');\n\t\tSystem.out.println((int)'\\u0046');\n\t\tSystem.out.println((int)'\\u0047');\n\t\tSystem.out.println((int)'\\u0048');\n\t\tSystem.out.println((int)'\\u0049');\n\t\tSystem.out.println((int)'\\u004A');\n\t\tSystem.out.println((int)'\\u004B');\n\t\tSystem.out.println((int)'\\u004C');\n\t\tSystem.out.println((int)'\\u004D');\n\t\tSystem.out.println((int)'\\u004E');\n\t\tSystem.out.println((int)'\\u004F');\n\t\tSystem.out.println((int)'\\u0050');\n\t\tSystem.out.println((int)'\\u0051');\n\t\tSystem.out.println((int)'\\u0052');\n\t\tSystem.out.println((int)'\\u0053');\n\t\tSystem.out.println((int)'\\u0054');\n\t\tSystem.out.println((int)'\\u0055');\n\t\tSystem.out.println((int)'\\u0056');\n\t\tSystem.out.println((int)'\\u0057');\n\t\tSystem.out.println((int)'\\u0058');\n\t\tSystem.out.println((int)'\\u0059');\n\t\tSystem.out.println((int)'\\u005A');\n\t\tSystem.out.println((int\n",
        "\tstatic void main(String[] args){\n\t\tchar c = '\\u0041';\n\t\tSystem.out.println(c);\n\t\tSystem.out.println((int)c);\n\t\tSystem.out.println((int)'\\u0041');\n\t\tSystem.out.println((int)'\\u0042');\n\t\tSystem.out.println((int)'\\u0043');\n\t\tSystem.out.println((int)'\\u0044');\n\t\tSystem.out.println((int)'\\u0045');\n\t\tSystem.out.println((int)'\\u0046');\n\t\tSystem.out.println((int)'\\u0047');\n\t\tSystem.out.println((int)'\\u0048');\n\t\tSystem.out.println((int)'\\u0049');\n\t\tSystem.out.println((int)'\\u004A');\n\t\tSystem.out.println((int)'\\u004B');\n\t\tSystem.out.println((int)'\\u004C');\n\t\tSystem.out.println((int)'\\u004D');\n\t\tSystem.out.println((int)'\\u004E');\n\t\tSystem.out.println((int)'\\u004F');\n\t\tSystem.out.println((int)'\\u0050');\n\t\tSystem.out.println((int)'\\u0051');\n\t\tSystem.out.println((int)'\\u0052');\n\t\tSystem.out.println((int)'\\u0053');\n\t\tSystem.out.println((int)'\\u0054');\n\t\tSystem.out.println((int)'\\u0055');\n\t\tSystem.out.println((int)'\\u0056');\n\t\tSystem.out.println((int)'\\u0057');\n\t\tSystem.out.println((int)'\\u0058');\n\t\tSystem.out.println((int)'\\u0059');\n\t\tSystem.out.println((int)'\\u005A');\n\t\tSystem.out.println((int)'\\u005B');\n\t\tSystem.out.println((int)'\\u005C');\n\t\tSystem.\n",
        "\tstatic void main(String[] args){\n\t\tchar c = '\\u0041';\n\t\tSystem.out.println(c);\n\t\tSystem.out.println(c + 1);\n\t\tSystem.out.println(c + 2);\n\t\tSystem.out.println(c + 3);\n\t\tSystem.out.println(c + 4);\n\t\tSystem.out.println(c + 5);\n\t\tSystem.out.println(c + 6);\n\t\tSystem.out.println(c + 7);\n\t\tSystem.out.println(c + 8);\n\t\tSystem.out.println(c + 9);\n\t\tSystem.out.println(c + 10);\n\t\tSystem.out.println(c + 11);\n\t\tSystem.out.println(c + 12);\n\t\tSystem.out.println(c + 13);\n\t\tSystem.out.println(c + 14);\n\t\tSystem.out.println(c + 15);\n\t\tSystem.out.println(c + 16);\n\t\tSystem.out.println(c + 17);\n\t\tSystem.out.println(c + 18);\n\t\tSystem.out.println(c + 19);\n\t\tSystem.out.println(c + 20);\n\t\tSystem.out.println(c + 21);\n\t\tSystem.out.println(c + 22);\n\t\tSystem.out.println(c + 23);\n\t\tSystem.out.println(c + 24);\n\t\tSystem.out.println(c + 25);\n\t\tSystem.out.println(c + 26);\n\t\tSystem.out.println(c + 27);\n\t\tSystem.out.println(c + 28);\n\t\tSystem.out.println(c + 29);\n\t\tSystem.out.println(c + 30);\n\t\tSystem.out.println(c + 31);\n\t\tSystem.out.println(c + 32);\n\t\tSystem.out.println(c + 33);\n\t\tSystem.out.println(c + 34);\n\t\tSystem.out.println(c + 35);\n\t\tSystem.out.println(c + 36\n",
        "\tvoid method(){\n\t\tchar c = '\\u0041';\n\t\tSystem.out.println(c);\n\t\tchar c2 = '\\u0041';\n\t\tSystem.out.println(c2);\n\t\tchar c3 = '\\u0041';\n\t\tSystem.out.println(c3);\n\t\tchar c4 = '\\u0041';\n\t\tSystem.out.println(c4);\n\t\tchar c5 = '\\u0041';\n\t\tSystem.out.println(c5);\n\t\tchar c6 = '\\u0041';\n\t\tSystem.out.println(c6);\n\t\tchar c7 = '\\u0041';\n\t\tSystem.out.println(c7);\n\t\tchar c8 = '\\u0041';\n\t\tSystem.out.println(c8);\n\t\tchar c9 = '\\u0041';\n\t\tSystem.out.println(c9);\n\t\tchar c10 = '\\u0041';\n\t\tSystem.out.println(c10);\n\t\tchar c11 = '\\u0041';\n\t\tSystem.out.println(c11);\n\t\tchar c12 = '\\u0041';\n\t\tSystem.out.println(c12);\n\t\tchar c13 = '\\u0041';\n\t\tSystem.out.println(c13);\n\t\tchar c14 = '\\u0041';\n\t\tSystem.out.println(c14);\n\t\tchar c15 = '\\u0041';\n\t\tSystem.out.println(c15);\n\t\tchar c16 = '\\u0041';\n\t\tSystem.out.println(c16);\n\t\tchar c17 = '\\u0041';\n\t\tSystem.out.println(c17);\n\t\tchar c18 = '\\u0041';\n\t\tSystem.out.println(c18);\n\t\tchar c19 = '\\u0041';\n\t\tSystem.out.println(c19);\n\t\tchar c20 = '\\u0041';\n\t\tSystem.out.println(\n"
    ],
    "results": 10
},{
    "id": "2034",
    "source": "leetcode",
    "language": "java",
    "query": "A string is represented by an array if the array elements concatenated in order forms the string. Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.",
    "snippets": [
        "\tboolean arrayStringsAreEqual(String[] word1, String[] word2) {\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tfor(int i = 0; i < word1.length; i++){\n\t\t\ts1 += word1[i];\n\t\t}\n\t\tfor(int i = 0; i < word2.length; i++){\n\t\t\ts2 += word2[i];\n\t\t}\n\t\tif(s1.equals(s2)){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean arrayStringsAreEqual(String[] word1, String[] word2) {\n\t\tString s1 = \"\";\n\t\tString s2 = \"\";\n\t\tfor(int i = 0; i < word1.length; i++){\n\t\t\ts1 += word1[i];\n\t\t}\n\t\tfor(int i = 0; i < word2.length; i++){\n\t\t\ts2 += word2[i];\n\t\t}\n\t\treturn s1.equals(s2);\n\t}\n}\n",
        "\tstatic boolean arrayStringsAreEqual(String[] word1, String[] word2) {\n\t\tString word1Str = \"\";\n\t\tString word2Str = \"\";\n\t\tfor(int i = 0; i < word1.length; i++){\n\t\t\tword1Str += word1[i];\n\t\t}\n\t\tfor(int i = 0; i < word2.length; i++){\n\t\t\tword2Str += word2[i];\n\t\t}\n\t\tif(word1Str.equals(word2Str)){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2035",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of strings, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.",
    "snippets": [
        "\tString findMissing(String[] nums, int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tString num = nums[i];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(num.charAt(j) == '1'){\n\t\t\t\t\tsb.setCharAt(j, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString findMissing(String[] nums, int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\tString ans = sb.toString();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tans = xor(ans, nums[i]);\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic String xor(String a, String b){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < a.length(); i++){\n\t\t\tif(a.charAt(i) == b.charAt(i)){\n\t\t\t\tsb.append(\"0\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(\"1\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString findMissing(String[] nums, int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\tfor(String s : nums){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\t\tsb.setCharAt(i, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString findMissing(String[] nums, int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tString s = nums[i];\n\t\t\tfor(int j = 0; j < s.length(); j++){\n\t\t\t\tint index = s.charAt(j) - '0';\n\t\t\t\tsb.setCharAt(index, '1');\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString findMissing(String[] nums, int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tString s = nums[i];\n\t\t\tfor(int j = 0; j < s.length(); j++){\n\t\t\t\tif(s.charAt(j) == '1'){\n\t\t\t\t\tsb.setCharAt(j, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString missing(String[] nums, int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append('0');\n\t\t}\n\t\tfor(String s : nums){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\t\tsb.setCharAt(i, '1');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString findMissing(String[] nums, int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\tString s = sb.toString();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\ts = s.replaceFirst(nums[i], \"\");\n\t\t}\n\t\treturn s;\n\t}\n}\n",
        "\tString findMissing(String[] nums, int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\tString result = sb.toString();\n\t\tfor(String s : nums){\n\t\t\tresult = xor(result, s);\n\t\t}\n\t\treturn result;\n\t}\n\tpublic String xor(String s1, String s2){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s1.length(); i++){\n\t\t\tif(s1.charAt(i) == s2.charAt(i)){\n\t\t\t\tsb.append(\"0\");\n\t\t\t}else{\n\t\t\t\tsb.append(\"1\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString missing(String[] nums, int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append('0');\n\t\t}\n\t\tfor(String s : nums){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\t\tsb.setCharAt(i, '0');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString missing(String[] nums, int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append('0');\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tString num = nums[i];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(num.charAt(j) == '1'){\n\t\t\t\t\tsb.setCharAt(j, '1');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2036",
    "source": "leetcode",
    "language": "java",
    "query": "The game will work as follows: I pick a number between 1 and n. You guess a number. If you guess the right number, you win the game. Every time you guess a wrong number x, you will pay x dollars.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint guess = 0;\n\t\tint money = 0;\n\t\tint count = 0;\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = i+1;\n\t\t}\n\t\twhile(true){\n\t\t\tcount++;\n\t\t\tSystem.out.println(\"Guess a number between 1 and \" + n);\n\t\t\tguess = Clazz.getInt();\n\t\t\tif(guess == n){\n\t\t\t\tSystem.out.println(\"You win!\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(guess > n || guess < 1){\n\t\t\t\tSystem.out.println(\"Invalid guess\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(arr[guess-1] == 0){\n\t\t\t\tSystem.out.println(\"You have already guessed this number\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tarr[guess-1] = 0;\n\t\t\tmoney += x;\n\t\t\tSystem.out.println(\"You have $\" + money);\n\t\t\tif(count == n){\n\t\t\t\tSystem.out.println(\"You lose!\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int getInt(){\n\t\tScanner in = new Scanner(System.in);\n\t\tint num = in.nextInt();\n\t\treturn num;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner input = new Scanner(System.in);\n\t\tSystem.out.println(\"Enter the number of dollars you have: \");\n\t\tint dollars = input.nextInt();\n\t\tSystem.out.println(\"Enter the number of guesses you have: \");\n\t\tint guesses = input.nextInt();\n\t\tSystem.out.println(\"Enter the number of dollars you want to bet: \");\n\t\tint bet = input.nextInt();\n\t\tint guess = 0;\n\t\tint guesss = 0;\n\t\tint guesss2 = 0;\n\t\tint guesss3 = 0;\n\t\tint guesss4 = 0;\n\t\tint guesss5 = 0;\n\t\tint guesss6 = 0;\n\t\tint guesss7 = 0;\n\t\tint guesss8 = 0;\n\t\tint guesss9 = 0;\n\t\tint guesss10 = 0;\n\t\tint guesss11 = 0;\n\t\tint guesss12 = 0;\n\t\tint guesss13 = 0;\n\t\tint guesss14 = 0;\n\t\tint guesss15 = 0;\n\t\tint guesss16 = 0;\n\t\tint guesss17 = 0;\n\t\tint guesss18 = 0;\n\t\tint guesss19 = 0;\n\t\tint guesss20 = 0;\n\t\tint guesss21 = 0;\n\t\tint guesss22 = 0;\n\t\tint guesss23 = 0;\n\t\tint guesss24 = 0;\n\t\tint guesss25 = 0;\n\t\tint guesss26 = 0;\n\t\tint guesss27 = 0;\n\t\tint guesss28 = 0;\n\t\tint guesss29 = 0;\n\t\tint guesss30 = 0;\n\t\tint guesss31 = 0;\n\t\tint guesss32 = 0;\n\t\tint guesss33 = 0;\n\t\tint guesss34 = 0;\n\t\tint guesss35 = 0;\n\t\tint guesss36 = 0;\n\t\tint guesss37 = 0;\n\t\tint guesss\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint c = 0;\n\t\tint d = 0;\n\t\tint e = 0;\n\t\tint f = 0;\n\t\tint g = 0;\n\t\tint h = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n1 = 0;\n\t\tint n2 = 0;\n\t\tint n3 = 0;\n\t\tint n4 = 0;\n\t\tint n5 = 0;\n\t\tint n6 = 0;\n\t\tint n7 = 0;\n\t\tint n8 = 0;\n\t\tint n9 = 0;\n\t\tint n10 = 0;\n\t\tint n11 = 0;\n\t\tint n12 = 0;\n\t\tint n13 = 0;\n\t\tint n14 = 0;\n\t\tint n15 = 0;\n\t\tint n16 = 0;\n\t\tint n17 = 0;\n\t\tint n18 = 0;\n\t\tint n19 = 0;\n\t\tint n20 = 0;\n\t\tint n21 = 0;\n\t\tint n22 = 0;\n\t\tint n23 = 0;\n\t\tint n24 = 0;\n\t\tint n25 = 0;\n\t\tint n26 = 0;\n\t\tint n27 = 0;\n\t\tint n28 = 0;\n\t\tint n29 = 0;\n\t\tint n30 = 0;\n\t\tint n31 = 0;\n\t\tint n32 = 0;\n\t\tint n33 = 0;\n\t\tint n34 = 0;\n\t\tint n35 = 0;\n\t\tint n36 = 0;\n\t\tint n37 = 0;\n\t\tint n38 = 0;\n\t\tint n39 = 0;\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint y = 1;\n\t\tint z = 1;\n\t\tint w = 1;\n\t\tint a = 1;\n\t\tint b = 1;\n\t\tint c = 1;\n\t\tint d = 1;\n\t\tint e = 1;\n\t\tint f = 1;\n\t\tint g = 1;\n\t\tint h = 1;\n\t\tint i = 1;\n\t\tint j = 1;\n\t\tint k = 1;\n\t\tint l = 1;\n\t\tint m = 1;\n\t\tint p = 1;\n\t\tint q = 1;\n\t\tint r = 1;\n\t\tint s = 1;\n\t\tint t = 1;\n\t\tint u = 1;\n\t\tint v = 1;\n\t\tint w = 1;\n\t\tint x = 1;\n\t\tint y = 1;\n\t\tint z = 1;\n\t\tint a = 1;\n\t\tint b = 1;\n\t\tint c = 1;\n\t\tint d = 1;\n\t\tint e = 1;\n\t\tint f = 1;\n\t\tint g = 1;\n\t\tint h = 1;\n\t\tint i = 1;\n\t\tint j = 1;\n\t\tint k = 1;\n\t\tint l = 1;\n\t\tint m = 1;\n\t\tint p = 1;\n\t\tint q = 1;\n\t\tint r = 1;\n\t\tint s = 1;\n\t\tint t = 1;\n\t\tint u = 1;\n\t\tint v = 1;\n\t\tint w = 1;\n\t\tint x = 1;\n\t\tint y = 1;\n\t\tint z = 1;\n\t\tint a = 1;\n\t\tint b = 1;\n\t\tint c = 1;\n\t\tint d = 1;\n\t\tint e = 1;\n\t\tint f = 1;\n\t\tint g = 1;\n\t\tint h = 1;\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint y = 1;\n\t\tint z = 1;\n\t\tint w = 1;\n\t\tint u = 1;\n\t\tint v = 1;\n\t\tint t = 1;\n\t\tint s = 1;\n\t\tint r = 1;\n\t\tint q = 1;\n\t\tint p = 1;\n\t\tint o = 1;\n\t\tint m = 1;\n\t\tint l = 1;\n\t\tint k = 1;\n\t\tint j = 1;\n\t\tint i = 1;\n\t\tint h = 1;\n\t\tint g = 1;\n\t\tint f = 1;\n\t\tint e = 1;\n\t\tint d = 1;\n\t\tint c = 1;\n\t\tint b = 1;\n\t\tint a = 1;\n\t\tint zz = 1;\n\t\tint yy = 1;\n\t\tint xx = 1;\n\t\tint ww = 1;\n\t\tint uu = 1;\n\t\tint vv = 1;\n\t\tint tt = 1;\n\t\tint ss = 1;\n\t\tint rr = 1;\n\t\tint qq = 1;\n\t\tint pp = 1;\n\t\tint oo = 1;\n\t\tint mm = 1;\n\t\tint ll = 1;\n\t\tint kk = 1;\n\t\tint jj = 1;\n\t\tint ii = 1;\n\t\tint hh = 1;\n\t\tint gg = 1;\n\t\tint ff = 1;\n\t\tint ee = 1;\n\t\tint dd = 1;\n\t\tint cc = 1;\n\t\tint bb = 1;\n\t\tint aa = 1;\n\t\tint zzz = 1;\n\t\tint yyy = 1;\n\t\tint xxx = 1;\n\t\tint www = 1;\n\t\tint uuu = 1;\n\t\tint vvv = 1;\n\t\tint ttt = 1;\n\t\tint\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint y = 1;\n\t\tint z = 1;\n\t\tint w = 1;\n\t\tint q = 1;\n\t\tint r = 1;\n\t\tint t = 1;\n\t\tint u = 1;\n\t\tint v = 1;\n\t\tint a = 1;\n\t\tint b = 1;\n\t\tint c = 1;\n\t\tint d = 1;\n\t\tint e = 1;\n\t\tint f = 1;\n\t\tint g = 1;\n\t\tint h = 1;\n\t\tint i = 1;\n\t\tint j = 1;\n\t\tint k = 1;\n\t\tint l = 1;\n\t\tint m = 1;\n\t\tint o = 1;\n\t\tint p = 1;\n\t\tint qq = 1;\n\t\tint rr = 1;\n\t\tint tt = 1;\n\t\tint uu = 1;\n\t\tint vv = 1;\n\t\tint aa = 1;\n\t\tint bb = 1;\n\t\tint cc = 1;\n\t\tint dd = 1;\n\t\tint ee = 1;\n\t\tint ff = 1;\n\t\tint gg = 1;\n\t\tint hh = 1;\n\t\tint ii = 1;\n\t\tint jj = 1;\n\t\tint kk = 1;\n\t\tint ll = 1;\n\t\tint mm = 1;\n\t\tint oo = 1;\n\t\tint pp = 1;\n\t\tint qqq = 1;\n\t\tint rrr = 1;\n\t\tint ttt = 1;\n\t\tint uuu = 1;\n\t\tint vvv = 1;\n\t\tint aaa = 1;\n\t\tint bbb = 1;\n\t\tint ccc = 1;\n\t\tint ddd = 1;\n\t\tint eee = 1;\n\t\tint fff = 1;\n\t\tint ggg = 1;\n\t\tint hhh = 1;\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint y = 1;\n\t\tint z = 1;\n\t\tint a = 1;\n\t\tint b = 1;\n\t\tint c = 1;\n\t\tint d = 1;\n\t\tint e = 1;\n\t\tint f = 1;\n\t\tint g = 1;\n\t\tint h = 1;\n\t\tint i = 1;\n\t\tint j = 1;\n\t\tint k = 1;\n\t\tint l = 1;\n\t\tint m = 1;\n\t\tint p = 1;\n\t\tint q = 1;\n\t\tint r = 1;\n\t\tint s = 1;\n\t\tint t = 1;\n\t\tint u = 1;\n\t\tint v = 1;\n\t\tint w = 1;\n\t\tint x1 = 1;\n\t\tint y1 = 1;\n\t\tint z1 = 1;\n\t\tint a1 = 1;\n\t\tint b1 = 1;\n\t\tint c1 = 1;\n\t\tint d1 = 1;\n\t\tint e1 = 1;\n\t\tint f1 = 1;\n\t\tint g1 = 1;\n\t\tint h1 = 1;\n\t\tint i1 = 1;\n\t\tint j1 = 1;\n\t\tint k1 = 1;\n\t\tint l1 = 1;\n\t\tint m1 = 1;\n\t\tint p1 = 1;\n\t\tint q1 = 1;\n\t\tint r1 = 1;\n\t\tint s1 = 1;\n\t\tint t1 = 1;\n\t\tint u1 = 1;\n\t\tint v1 = 1;\n\t\tint w1 = 1;\n\t\tint x2 = 1;\n\t\tint y2 = 1;\n\t\tint z2 = 1;\n\t\tint a2 = 1;\n\t\tint b2 = 1;\n\t\tint c2 = 1;\n\t\tint d2 = 1;\n\t\tint e2 = 1;\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint guess = 0;\n\t\tint money = 0;\n\t\tint win = 0;\n\t\tint lose = 0;\n\t\tint tie = 0;\n\t\tint count = 0;\n\t\tint count2 = 0;\n\t\tint count3 = 0;\n\t\tint count4 = 0;\n\t\tint count5 = 0;\n\t\tint count6 = 0;\n\t\tint count7 = 0;\n\t\tint count8 = 0;\n\t\tint count9 = 0;\n\t\tint count10 = 0;\n\t\tint count11 = 0;\n\t\tint count12 = 0;\n\t\tint count13 = 0;\n\t\tint count14 = 0;\n\t\tint count15 = 0;\n\t\tint count16 = 0;\n\t\tint count17 = 0;\n\t\tint count18 = 0;\n\t\tint count19 = 0;\n\t\tint count20 = 0;\n\t\tint count21 = 0;\n\t\tint count22 = 0;\n\t\tint count23 = 0;\n\t\tint count24 = 0;\n\t\tint count25 = 0;\n\t\tint count26 = 0;\n\t\tint count27 = 0;\n\t\tint count28 = 0;\n\t\tint count29 = 0;\n\t\tint count30 = 0;\n\t\tint count31 = 0;\n\t\tint count32 = 0;\n\t\tint count33 = 0;\n\t\tint count34 = 0;\n\t\tint count35 = 0;\n\t\tint count36 = 0;\n\t\tint count37 = 0;\n\t\tint count38 = 0;\n\t\tint count39 = 0;\n\t\tint count40 = 0;\n\t\tint count41 = 0;\n\t\tint count42 = 0;\n\t\tint count43 = 0;\n\t\tint count44 = 0;\n\t\tint count45 = 0;\n\t\tint count46 = 0;\n\t\tint count47 = 0;\n\t\tint count48 = 0;\n",
        "\tstatic void main(String[] args){\n\t\tint n = 10;\n\t\tint x = 1;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint guess = 0;\n\t\tint money = 0;\n\t\tint money2 = 0;\n\t\tint money3 = 0;\n\t\tint money4 = 0;\n\t\tint money5 = 0;\n\t\tint money6 = 0;\n\t\tint money7 = 0;\n\t\tint money8 = 0;\n\t\tint money9 = 0;\n\t\tint money10 = 0;\n\t\tint money11 = 0;\n\t\tint money12 = 0;\n\t\tint money13 = 0;\n\t\tint money14 = 0;\n\t\tint money15 = 0;\n\t\tint money16 = 0;\n\t\tint money17 = 0;\n\t\tint money18 = 0;\n\t\tint money19 = 0;\n\t\tint money20 = 0;\n\t\tint money21 = 0;\n\t\tint money22 = 0;\n\t\tint money23 = 0;\n\t\tint money24 = 0;\n\t\tint money25 = 0;\n\t\tint money26 = 0;\n\t\tint money27 = 0;\n\t\tint money28 = 0;\n\t\tint money29 = 0;\n\t\tint money30 = 0;\n\t\tint money31 = 0;\n\t\tint money32 = 0;\n\t\tint money33 = 0;\n\t\tint money34 = 0;\n\t\tint money35 = 0;\n\t\tint money36 = 0;\n\t\tint money37 = 0;\n\t\tint money38 = 0;\n\t\tint money39 = 0;\n\t\tint money40 = 0;\n\t\tint money41 = 0;\n\t\tint money42 = 0;\n\t\tint money43 = 0;\n\t\tint money44 = 0;\n\t\tint money45 = 0;\n\t\tint money46 = 0;\n\t\tint money47 = 0;\n\t\tint money48 = 0;\n\t\tint money49 = 0;\n\t\tint money50 = 0;\n"
    ],
    "results": 10
},{
    "id": "2037",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "snippets": [
        "\tList<List<Integer>> levelOrder(TreeNode root) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(root == null) return result;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tList<Integer> level = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tlevel.add(node.val);\n\t\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\t}\n\t\t\tresult.add(level);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> levelOrder(TreeNode root) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(root == null) return result;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tlist.add(node.val);\n\t\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\t}\n\t\t\tresult.add(list);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> levelOrder(TreeNode root) {\n\t\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\t\tif(root == null) return res;\n\t\tQueue<TreeNode> q = new LinkedList<TreeNode>();\n\t\tq.offer(root);\n\t\twhile(!q.isEmpty()){\n\t\t\tint size = q.size();\n\t\t\tList<Integer> level = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode cur = q.poll();\n\t\t\t\tlevel.add(cur.val);\n\t\t\t\tif(cur.left != null) q.offer(cur.left);\n\t\t\t\tif(cur.right != null) q.offer(cur.right);\n\t\t\t}\n\t\t\tres.add(level);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2038",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position.",
    "snippets": [
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j <= i + nums[i] && j < n; j++) {\n\t\t\t\tdp[j] = Math.min(dp[j], dp[i] + 1);\n\t\t\t}\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (nums[j] >= i - j) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (j + nums[j] >= i) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tif(n == 1) return 0;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 0;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint max = 0;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(j + nums[j] >= i){\n\t\t\t\t\tmax = Math.max(max, dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = max;\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint max = 0;\n\t\tint end = 0;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (i > max) {\n\t\t\t\treturn count;\n\t\t\t}\n\t\t\tmax = Math.max(max, i + nums[i]);\n\t\t\tif (i == end) {\n\t\t\t\tcount++;\n\t\t\t\tend = max;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint max = 0;\n\t\tint end = 0;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (i > max) {\n\t\t\t\tcount++;\n\t\t\t\tmax = end;\n\t\t\t}\n\t\t\tend = Math.max(end, i + nums[i]);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint max = 0;\n\t\tint step = 0;\n\t\tint i = 0;\n\t\twhile (i < nums.length - 1) {\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t\tif (i == max) {\n\t\t\t\tstep++;\n\t\t\t\tmax = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn step;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2039",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed 1-dimensional integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] original = {1,2,3,4,5,6,7,8,9,10};\n\t\tint m = 3;\n\t\tint n = 4;\n\t\tint[][] result = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tresult[i][j] = original[i * n + j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tSystem.out.print(result[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n",
        "\tint[][] create2DArray(int[] original, int m, int n){\n\t\tint[][] newArray = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tnewArray[i][j] = original[i*n + j];\n\t\t\t}\n\t\t}\n\t\treturn newArray;\n\t}\n}\n",
        "\tstatic int[][] create2DArray(int[] original, int m, int n){\n\t\tint[][] newArray = new int[m][n];\n\t\tint counter = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tnewArray[i][j] = original[counter];\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t\treturn newArray;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2040",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an n x n grid where you have placed some 1 x 1x 1 cubes. Each value v = grid[i] represents a tower of v cubes placed on top of cell (i, j)",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tSystem.out.println(solution(grid));\n\t}\n\tpublic static int solution(int[][] grid){\n\t\tint n = grid.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1][n-1];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tSystem.out.println(find(grid));\n\t}\n\tpublic static int find(int[][] grid){\n\t\tint n = grid.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1][n-1];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tSystem.out.println(new Clazz().solve(grid));\n\t}\n\tpublic int solve(int[][] grid){\n\t\tint n = grid.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1][n-1];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tSystem.out.println(solve(grid));\n\t}\n\tpublic static int solve(int[][] grid){\n\t\tint n = grid.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1][n-1];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,2,3},{4,5,6},{7,8,9}};\n\t\tint[][] grid2 = {{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};\n\t\tint[][] grid3 = {{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15},{16,17,18,19,20},{21,22,23,24,25}};\n\t\tint[][] grid4 = {{1,2,3,4,5,6},{7,8,9,10,11,12},{13,14,15,16,17,18},{19,20,21,22,23,24},{25,26,27,28,29,30},{31,32,33,34,35,36}};\n\t\tint[][] grid5 = {{1,2,3,4,5,6,7},{8,9,10,11,12,13,14},{15,16,17,18,19,20,21},{22,23,24,25,26,27,28},{29,30,31,32,33,34,35},{36,37,38,39,40,41,42},{43,44,45,46,47,48,49}};\n\t\tint[][] grid6 = {{1,2,3,4,5,6,7,8},{9,10,11,12,13,14,15,16},{17,18,19,20,21,22,23,24},{25,26,27,28,29,30,31,32},{33,34,35,36,37,38,39,40},{41,42,43,44,45,46,47,48},{49,50,51,52,53,54,55,56},{57,58,59,60,61,62\n",
        "\tvoid solve(int[][] grid){\n\t\tint n = grid.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n-1][n-1]);\n\t}\n}\n",
        "\tint[][] tower(int[][] grid){\n\t\tint[][] result = new int[grid.length][grid.length];\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid.length; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tresult[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tresult[i][j] = result[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tresult[i][j] = result[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresult[i][j] = Math.min(result[i-1][j], result[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[][] grid;\n\tpublic static void main(String[] args){\n\t\tgrid = new int[][]{\n\t\t\t{1,2,3},\n\t\t\t{4,5,6},\n\t\t\t{7,8,9}\n\t\t};\n\t\tSystem.out.println(clazz(grid));\n\t}\n\tpublic static int clazz(int[][] grid){\n\t\tint[][] clazz = new int[grid.length][grid.length];\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid.length; j++){\n\t\t\t\tclazz[i][j] = grid[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid.length; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i == 0){\n\t\t\t\t\tclazz[i][j] = clazz[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\tif(j == 0){\n\t\t\t\t\tclazz[i][j] = clazz[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\tif(i > 0 && j > 0){\n\t\t\t\t\tclazz[i][j] = Math.min(clazz[i-1][j], clazz[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn clazz[grid.length-1][grid.length-1];\n\t}\n}\n",
        "\tint[][] towerBuilder(int n) {\n\t\tint[][] tower = new int[n][n];\n\t\tint count = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\ttower[i][j] = count;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn tower;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2041",
    "source": "leetcode",
    "language": "java",
    "query": "Find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.",
    "snippets": [
        "\tTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\tif(root == null) return null;\n\t\tif(root == p || root == q) return root;\n\t\tTreeNode left = lowestCommonAncestor(root.left, p, q);\n\t\tTreeNode right = lowestCommonAncestor(root.right, p, q);\n\t\tif(left != null && right != null) return root;\n\t\treturn left == null ? right : left;\n\t}\n}\n",
        "\tTreeNode find(TreeNode root){\n\t\tif(root == null) return null;\n\t\tTreeNode left = find(root.left);\n\t\tTreeNode right = find(root.right);\n\t\tif(left != null && right != null){\n\t\t\tif(Math.abs(left.val - right.val) == root.val) return root;\n\t\t}\n\t\tif(left != null) return left;\n\t\tif(right != null) return right;\n\t\treturn null;\n\t}\n}\n",
        "\tTreeNode findTarget(TreeNode root, int k) {\n\t\tif(root == null) return null;\n\t\tTreeNode p = root;\n\t\tTreeNode q = root;\n\t\twhile(p != null && q != null){\n\t\t\tint diff = p.val - q.val;\n\t\t\tif(diff == k) return p;\n\t\t\telse if(diff < k) p = p.right;\n\t\t\telse q = q.left;\n\t\t}\n\t\treturn null;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2042",
    "source": "leetcode",
    "language": "java",
    "query": "In a deck of cards, each card has an integer written on it. Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups.",
    "snippets": [
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tif(deck.length<2) return false;\n\t\tint[] count = new int[10000];\n\t\tfor(int i=0;i<deck.length;i++){\n\t\t\tcount[deck[i]]++;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]>0 && count[i]<2) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tif(deck.length<2) return false;\n\t\tint[] count = new int[10000];\n\t\tfor(int i=0;i<deck.length;i++){\n\t\t\tcount[deck[i]]++;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]>=2){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tif(deck.length<2) return false;\n\t\tint[] count = new int[10000];\n\t\tfor(int i:deck) count[i]++;\n\t\tfor(int i:count) if(i>=2) return true;\n\t\treturn false;\n\t}\n}\n",
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tif(deck.length<=1) return false;\n\t\tint[] count = new int[10000];\n\t\tfor(int i=0;i<deck.length;i++){\n\t\t\tcount[deck[i]]++;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]>=2) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tif(deck.length<2) return false;\n\t\tint[] count = new int[10000];\n\t\tfor(int i=0;i<deck.length;i++){\n\t\t\tcount[deck[i]]++;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]>=2) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tif(deck.length<2) return false;\n\t\tint[] count = new int[10000];\n\t\tfor(int i:deck){\n\t\t\tcount[i]++;\n\t\t}\n\t\tfor(int i:count){\n\t\t\tif(i>=2){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tint[] count = new int[10000];\n\t\tfor(int i = 0; i < deck.length; i++){\n\t\t\tcount[deck[i]]++;\n\t\t}\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] > 0 && count[i] < 2){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean hasGroupsSizeX(int[] deck) {\n\t\tif(deck.length<2) return false;\n\t\tint[] count = new int[10000];\n\t\tfor(int i:deck){\n\t\t\tcount[i]++;\n\t\t}\n\t\tfor(int i:count){\n\t\t\tif(i>=2) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2043",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer n, the number of teams in a tournament that has strange rules. If the current number is even, each team gets paired with another team. A total of (n - 1) / 2 matches are played, and n / 2 teams advance to the next round.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tif(n % 2 == 0){\n\t\t\tSystem.out.println(n / 2);\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println((n - 1) / 2);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] teams = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tteams[i] = i + 1;\n\t\t}\n\t\tint count = 0;\n\t\twhile(teams.length > 1){\n\t\t\tif(count % 2 == 0){\n\t\t\t\tteams = even(teams);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tteams = odd(teams);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tSystem.out.println(teams[0]);\n\t}\n\tpublic static int[] even(int[] teams){\n\t\tint[] newTeams = new int[teams.length / 2];\n\t\tfor(int i = 0; i < teams.length; i += 2){\n\t\t\tnewTeams[i / 2] = teams[i] + teams[i + 1];\n\t\t}\n\t\treturn newTeams;\n\t}\n\tpublic static int[] odd(int[] teams){\n\t\tint[] newTeams = new int[teams.length / 2];\n\t\tfor(int i = 0; i < teams.length; i += 2){\n\t\t\tnewTeams[i / 2] = teams[i] + teams[i + 1];\n\t\t}\n\t\treturn newTeams;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = in.nextInt();\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = in.nextInt();\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = in.nextInt();\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = in.nextInt();\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = in.nextInt();\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = in.nextInt();\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ti[i] = in.nextInt();\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tj[i] = in.next\n"
    ],
    "results": 10
},{
    "id": "2044",
    "source": "leetcode",
    "language": "java",
    "query": "A substring is a contiguous sequence of characters within a string. Given a string s, return the length of the longest substring between two equal characters. If there is no such substring return -1.",
    "snippets": [
        "\tint longestSubstring(String s){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tfor(int j = i + 1; j < s.length(); j++){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int k = i; k < j; k++){\n\t\t\t\t\tif(s.charAt(k) == s.charAt(j)){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestSubstring(String s){\n\t\tint n = s.length();\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j <= n; j++){\n\t\t\t\tif(isPalindrome(s, i, j)) ans = Math.max(ans, j - i);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic\n\tboolean isPalindrome(String s, int i, int j){\n\t\twhile(i < j){\n\t\t\tif(s.charAt(i++) != s.charAt(j--)) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint longestSubstring(String s) {\n\t\tint n = s.length();\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\tSet<Character> set = new HashSet<>();\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tset.add(s.charAt(k));\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, j - i - set.size());\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint longestSubstring(String s){\n\t\tint n = s.length();\n\t\tint[] count = new int[128];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[s.charAt(i)]++;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(count[s.charAt(i)] > 1){\n\t\t\t\tmax = Math.max(max, longestSubstring(s, i));\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tint longestSubstring(String s, int i){\n\t\tint n = s.length();\n\t\tint[] count = new int[128];\n\t\tcount[s.charAt(i)]++;\n\t\tint max = 1;\n\t\tfor(int j = i + 1; j < n; j++){\n\t\t\tcount[s.charAt(j)]++;\n\t\t\twhile(count[s.charAt(j)] > 1){\n\t\t\t\tcount[s.charAt(i)]--;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tmax = Math.max(max, j - i + 1);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestSubstring(String s){\n\t\tint n = s.length();\n\t\tint[] count = new int[128];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[s.charAt(i)]++;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(count[s.charAt(i)] > 1){\n\t\t\t\tans = Math.max(ans, longestSubstring(s, i));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic\n\tint longestSubstring(String s, int i){\n\t\tint n = s.length();\n\t\tint[] count = new int[128];\n\t\tcount[s.charAt(i)]++;\n\t\tint j = i + 1;\n\t\twhile(j < n && count[s.charAt(j)] < 2){\n\t\t\tcount[s.charAt(j)]++;\n\t\t\tj++;\n\t\t}\n\t\treturn j - i;\n\t}\n}\n",
        "\tint longestSubstring(String s){\n\t\tint n = s.length();\n\t\tint[] count = new int[128];\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[s.charAt(i)]++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(count[s.charAt(i)] == 1){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < n && count[s.charAt(j)] == 1){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, j - i);\n\t\t\t\ti = j - 1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint longestSubstring(String s){\n\t\tint n = s.length();\n\t\tint[] count = new int[128];\n\t\tint ans = 0;\n\t\tfor(int i = 0, j = 0; i < n; i++){\n\t\t\tcount[s.charAt(i)]++;\n\t\t\twhile(j < n && count[s.charAt(j)] == 1){\n\t\t\t\tcount[s.charAt(j)]--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tans = Math.max(ans, j-i);\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic int longestSubstring(String s){\n\t\tint max = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tint[] count = new int[128];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tchar c = s.charAt(i);\n\t\t\tcount[c]++;\n\t\t\twhile(count[c] > 1){\n\t\t\t\tchar d = s.charAt(start);\n\t\t\t\tcount[d]--;\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tmax = Math.max(max, i - start + 1);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2045",
    "source": "leetcode",
    "language": "java",
    "query": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num.",
    "snippets": [
        "\tString removeKdigits(String num, int k) {\n\t\tif(num.length()==k) return \"0\";\n\t\tint i=0;\n\t\twhile(i<num.length()&&num.charAt(i)=='0') i++;\n\t\tif(i==num.length()) return \"0\";\n\t\tStringBuilder sb=new StringBuilder();\n\t\tint count=0;\n\t\tfor(int j=i;j<num.length();j++){\n\t\t\tif(num.charAt(j)<num.charAt(i)){\n\t\t\t\ti=j;\n\t\t\t\tcount=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t\tif(count==k){\n\t\t\t\t\ti=j+1;\n\t\t\t\t\tcount=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=i;j<num.length();j++) sb.append(num.charAt(j));\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeKdigits(String num, int k) {\n\t\tif(num.length() == k) return \"0\";\n\t\tint i = 0;\n\t\twhile(i < num.length() && num.charAt(i) == '0') i++;\n\t\tif(i == num.length()) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint j = 0;\n\t\twhile(j < num.length() && j < i + k) {\n\t\t\tif(num.charAt(j) <= num.charAt(i)) {\n\t\t\t\tsb.append(num.charAt(j));\n\t\t\t\ti = j;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\twhile(j < num.length()) {\n\t\t\tif(num.charAt(j) < sb.charAt(sb.length() - 1)) {\n\t\t\t\tsb.deleteCharAt(sb.length() - 1);\n\t\t\t\tsb.append(num.charAt(j));\n\t\t\t\ti = j;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif(sb.length() == 0) return \"0\";\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeKdigits(String num, int k) {\n\t\tif(num.length()==k) return \"0\";\n\t\tint i=0;\n\t\twhile(i<num.length()&&k>0){\n\t\t\tif(num.charAt(i)=='0'){\n\t\t\t\tnum=num.substring(i+1);\n\t\t\t\ti=0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t\tif(num.length()==0) return \"0\";\n\t\twhile(num.length()>1&&num.charAt(0)=='0'){\n\t\t\tnum=num.substring(1);\n\t\t}\n\t\treturn num;\n\t}\n}\n",
        "\tString removeKdigits(String num, int k) {\n\t\tif(num.length() == k) return \"0\";\n\t\tint i = 0;\n\t\twhile(i < num.length() && num.charAt(i) == '0') i++;\n\t\tif(i == num.length()) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint j = i;\n\t\twhile(j < num.length() && k > 0) {\n\t\t\tif(num.charAt(j) < num.charAt(i)) {\n\t\t\t\tsb.append(num.charAt(j));\n\t\t\t\tj++;\n\t\t\t\tk--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\twhile(j < num.length()) {\n\t\t\tsb.append(num.charAt(j));\n\t\t\tj++;\n\t\t}\n\t\twhile(sb.length() > 1 && sb.charAt(0) == '0') sb.deleteCharAt(0);\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeKdigits(String num, int k) {\n\t\tif(num.length() == k) return \"0\";\n\t\tint i = 0;\n\t\twhile(i < num.length() && num.charAt(i) == '0') i++;\n\t\tif(i == num.length()) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int j = 0; j < num.length(); j++){\n\t\t\tif(j == i) continue;\n\t\t\tif(sb.length() == k) break;\n\t\t\tsb.append(num.charAt(j));\n\t\t}\n\t\tif(sb.length() == k) return sb.toString();\n\t\tif(sb.length() > k) return sb.substring(0, k);\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString smallestInteger(String num, int k){\n\t\tint len = num.length();\n\t\tint i = 0;\n\t\twhile(i < k){\n\t\t\tint j = 0;\n\t\t\twhile(j < len - 1 && num.charAt(j) == '0'){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(j == len - 1){\n\t\t\t\tnum = num.substring(0, len - 1);\n\t\t\t\tlen--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum = num.substring(0, j) + num.substring(j + 1);\n\t\t\t\tlen--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn num;\n\t}\n}\n",
        "\tString removeKdigits(String num, int k) {\n\t\tint n = num.length();\n\t\tif (n == 0) return \"0\";\n\t\tif (k == n) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile (i < n && k > 0) {\n\t\t\twhile (i < n - 1 && num.charAt(i) <= num.charAt(i + 1)) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tk--;\n\t\t\ti++;\n\t\t}\n\t\twhile (i < n) {\n\t\t\tsb.append(num.charAt(i++));\n\t\t}\n\t\twhile (sb.length() > 1 && sb.charAt(0) == '0') {\n\t\t\tsb.deleteCharAt(0);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeKdigits(String num, int k){\n\t\tif(num.length() == k) return \"0\";\n\t\tint i = 0;\n\t\twhile(i < num.length() && num.charAt(i) == '0') i++;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int j = i; j < num.length(); j++){\n\t\t\tif(k == 0) break;\n\t\t\tif(num.charAt(j) < num.charAt(i)){\n\t\t\t\ti = j + 1;\n\t\t\t\tk--;\n\t\t\t}\n\t\t}\n\t\tfor(int j = i; j < num.length(); j++){\n\t\t\tif(num.charAt(j) != '0') sb.append(num.charAt(j));\n\t\t}\n\t\tif(sb.length() == 0) return \"0\";\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString smallestInteger(String num, int k){\n\t\tint len = num.length();\n\t\tif(k >= len) return \"0\";\n\t\tint[] count = new int[10];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tcount[num.charAt(i) - '0']++;\n\t\t}\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tcount[i]--;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\twhile(count[i] > 0){\n\t\t\t\tsb.append(i);\n\t\t\t\tcount[i]--;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString smallestInteger(String num, int k){\n\t\tint len = num.length();\n\t\tif(k>=len) return \"0\";\n\t\tint[] arr = new int[len];\n\t\tfor(int i=0;i<len;i++){\n\t\t\tarr[i] = num.charAt(i)-'0';\n\t\t}\n\t\tfor(int i=0;i<k;i++){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint minIndex = -1;\n\t\t\tfor(int j=0;j<len;j++){\n\t\t\t\tif(arr[j]<min){\n\t\t\t\t\tmin = arr[j];\n\t\t\t\t\tminIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tarr[minIndex] = Integer.MAX_VALUE;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(arr[i]!=Integer.MAX_VALUE){\n\t\t\t\tsb.append(arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2046",
    "source": "leetcode",
    "language": "java",
    "query": "You have a convex n-sided polygon where each vertex has an integer value. You will triangulate the polygon into n - 2 triangles. For each triangle, the value of that triangle is the product of the values of its vertices.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n - 2; i++){\n\t\t\tfor(int j = i + 1; j < n - 1; j++){\n\t\t\t\tfor(int k = j + 1; k < n; k++){\n\t\t\t\t\tans = Math.max(ans, a[i] * a[j] * a[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n",
        "\tstatic int triangulate(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n - 2; i++){\n\t\t\tint max = 0;\n\t\t\tfor(int j = 0; j < n - 1; j++){\n\t\t\t\tif(b[j] > max){\n\t\t\t\t\tmax = b[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += max;\n\t\t\tb[b.indexOf(max)] = 0;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic int triangulate(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint c = 0;\n\t\tfor(int i = 0; i < n - 2; i++){\n\t\t\tc += b[i] * b[i + 1] * b[i + 2];\n\t\t\tb[i] = b[i + 1];\n\t\t\tb[i + 1] = b[i + 2];\n\t\t}\n\t\treturn c;\n\t}\n}\n",
        "\tstatic int triangulate(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint c = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tb[c] = b[i] * b[j];\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint d = 0;\n\t\tfor(int i = 0; i < n - 2; i++){\n\t\t\td += b[i];\n\t\t}\n\t\treturn d;\n\t}\n}\n",
        "\tstatic int product(int[] a){\n\t\tint result = 1;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tresult *= a[i];\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic int[] triangulate(int[] a){\n\t\tint[] result = new int[a.length - 2];\n\t\tfor(int i = 0; i < a.length - 2; i++){\n\t\t\tresult[i] = product(new int[]{a[i], a[i + 1], a[i + 2]});\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int product(int[] a){\n\t\tint p = 1;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tp *= a[i];\n\t\t}\n\t\treturn p;\n\t}\n\tpublic\n\tstatic int[] triangulate(int[] a){\n\t\tint[] t = new int[a.length - 2];\n\t\tfor(int i = 0; i < t.length; i++){\n\t\t\tt[i] = product(a[i], a[i + 1], a[i + 2]);\n\t\t}\n\t\treturn t;\n\t}\n}\n",
        "\tstatic int triangulate(int[] polygon){\n\t\tint n = polygon.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = polygon[0];\n\t\tdp[1] = polygon[1];\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tdp[i] = dp[i-1] * polygon[i];\n\t\t}\n\t\tint res = dp[n-1];\n\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\tres = res * dp[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2047",
    "source": "leetcode",
    "language": "java",
    "query": "An island is a maximal 4-directionally connected group of 0s. A closed island is an island totally (all left, top, right, bottom) surrounded by 1s.",
    "snippets": [
        "\tstatic int[][] island(int[][] grid){\n\t\tint[][] result = new int[grid.length][grid[0].length];\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tresult[i][j] = 1;\n\t\t\t\t\tif(i > 0 && grid[i-1][j] == 0){\n\t\t\t\t\t\tresult[i-1][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j > 0 && grid[i][j-1] == 0){\n\t\t\t\t\t\tresult[i][j-1] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(i < grid.length-1 && grid[i+1][j] == 0){\n\t\t\t\t\t\tresult[i+1][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j < grid[0].length-1 && grid[i][j+1] == 0){\n\t\t\t\t\t\tresult[i][j+1] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[][] island(int[][] grid){\n\t\tint[][] result = new int[grid.length][grid[0].length];\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tresult[i][j] = 1;\n\t\t\t\t\tdfs(grid, i, j, result);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic void dfs(int[][] grid, int i, int j, int[][] result){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0 || result[i][j] == 1) return;\n\t\tresult[i][j] = 1;\n\t\tdfs(grid, i + 1, j, result);\n\t\tdfs(grid, i - 1, j, result);\n\t\tdfs(grid, i, j + 1, result);\n\t\tdfs(grid, i, j - 1, result);\n\t}\n}\n",
        "\tstatic int[][] island(int[][] grid){\n\t\tint[][] res = new int[grid.length][grid[0].length];\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tres[i][j] = 1;\n\t\t\t\t\tdfs(grid, i, j, res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void dfs(int[][] grid, int i, int j, int[][] res){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0 || res[i][j] == 1)\n\t\t\treturn;\n\t\tres[i][j] = 1;\n\t\tdfs(grid, i + 1, j, res);\n\t\tdfs(grid, i - 1, j, res);\n\t\tdfs(grid, i, j + 1, res);\n\t\tdfs(grid, i, j - 1, res);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{1,1,0,0,0},\n\t\t\t\t\t\t{1,1,0,0,0},\n\t\t\t\t\t\t{0,0,0,1,1},\n\t\t\t\t\t\t{0,0,0,1,1}};\n\t\tSystem.out.println(closedIsland(grid));\n\t}\n\tpublic static int closedIsland(int[][] grid){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == 0){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic static void dfs(int[][] grid, int i, int j){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1) return;\n\t\tgrid[i][j] = 1;\n\t\tdfs(grid, i + 1, j);\n\t\tdfs(grid, i - 1, j);\n\t\tdfs(grid, i, j + 1);\n\t\tdfs(grid, i, j - 1);\n\t}\n}\n",
        "\tint closedIsland(int[][] grid){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tvoid dfs(int[][] grid, int i, int j){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0)\n\t\t\treturn;\n\t\tgrid[i][j] = 0;\n\t\tdfs(grid, i + 1, j);\n\t\tdfs(grid, i - 1, j);\n\t\tdfs(grid, i, j + 1);\n\t\tdfs(grid, i, j - 1);\n\t}\n}\n",
        "\tint closedIsland(int[][] grid) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == 0){\n\t\t\t\t\tcount += dfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic int dfs(int[][] grid, int i, int j){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1)\n\t\t\treturn 0;\n\t\tgrid[i][j] = 1;\n\t\tint count = 1;\n\t\tcount += dfs(grid, i + 1, j);\n\t\tcount += dfs(grid, i - 1, j);\n\t\tcount += dfs(grid, i, j + 1);\n\t\tcount += dfs(grid, i, j - 1);\n\t\treturn count;\n\t}\n}\n",
        "\tint closedIsland(int[][] grid) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\tfor (int j = 0; j < grid[0].length; j++) {\n\t\t\t\tif (grid[i][j] == 0) {\n\t\t\t\t\tcount += dfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic int dfs(int[][] grid, int i, int j) {\n\t\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tgrid[i][j] = 1;\n\t\tint count = 1;\n\t\tcount += dfs(grid, i + 1, j);\n\t\tcount += dfs(grid, i - 1, j);\n\t\tcount += dfs(grid, i, j + 1);\n\t\tcount += dfs(grid, i, j - 1);\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] grid = {{0,0,0,0,0},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{0,1,0,1,0},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{0,0,0,0,0}};\n\t\tSystem.out.println(closedIsland(grid));\n\t}\n\tpublic static int closedIsland(int[][] grid){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == 0){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic static void dfs(int[][] grid, int i, int j){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1) return;\n\t\tgrid[i][j] = 1;\n\t\tdfs(grid, i + 1, j);\n\t\tdfs(grid, i - 1, j);\n\t\tdfs(grid, i, j + 1);\n\t\tdfs(grid, i, j - 1);\n\t}\n}\n",
        "\tstatic boolean isIsland(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tboolean[][] visited = new boolean[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == 1 && !visited[i][j]){\n\t\t\t\t\tif(!dfs(grid, i, j, visited)){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic\n\tstatic boolean dfs(int[][] grid, int i, int j, boolean[][] visited){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tif(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0 || visited[i][j]){\n\t\t\treturn false;\n\t\t}\n\t\tvisited[i][j] = true;\n\t\tif(i > 0 && grid[i - 1][j] == 1 && !visited[i - 1][j]){\n\t\t\tif(!dfs(grid, i - 1, j, visited)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif(i < m - 1 && grid[i + 1][j] == 1 && !visited[i + 1][j]){\n\t\t\tif(!dfs(grid, i + 1, j, visited)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif(j > 0 && grid[i][j - 1] == 1 && !visited[i][j - 1]){\n\t\t\tif(!dfs(grid, i, j - 1, visited)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif(\n"
    ],
    "results": 10
},{
    "id": "2048",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array nums and an integer target, return the maximum number of non-empty non-overlapping subarrays such that the sum of values in each subarray is equal to target.",
    "snippets": [
        "\tint maxSubArrayLen(int[] nums, int k) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tmap.put(0, -1);\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\tif (map.containsKey(sum - k)) {\n\t\t\t\tmax = Math.max(max, i - map.get(sum - k));\n\t\t\t}\n\t\t\tif (!map.containsKey(sum)) {\n\t\t\t\tmap.put(sum, i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxSubArrayLen(int[] nums, int k) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tdp[i] = dp[i - 1] + nums[i];\n\t\t}\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tfor (int j = i; j < nums.length; j++) {\n\t\t\t\tif (dp[j] - dp[i] == k) {\n\t\t\t\t\tmax = Math.max(max, j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxNonOverlapping(int[] nums, int target) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\twhile (sum > target) {\n\t\t\t\tsum -= nums[start];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tmax = Math.max(max, i - start + 1);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxNonOverlapping(int[] nums, int target) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\twhile (sum > target) {\n\t\t\t\tsum -= nums[start++];\n\t\t\t}\n\t\t\tmax = Math.max(max, i - start + 1);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxNonOverlapping(int[] nums, int target) {\n\t\tint n = nums.length;\n\t\tint[] sum = new int[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tsum[i] = sum[i - 1] + nums[i - 1];\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\tif (sum[j] - sum[i] == target) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxNonOverlapping(int[] nums, int target) {\n\t\tint n = nums.length;\n\t\tint[] sum = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum[i + 1] = sum[i] + nums[i];\n\t\t}\n\t\tint res = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < n + 1; i++) {\n\t\t\tint diff = target - sum[i];\n\t\t\tif (map.containsKey(diff)) {\n\t\t\t\tres = Math.max(res, i - map.get(diff));\n\t\t\t}\n\t\t\tmap.put(sum[i], i);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2049",
    "source": "leetcode",
    "language": "java",
    "query": "A node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit. Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root.",
    "snippets": [
        "\tNode deleteInsufficient(Node root, int limit){\n\t\tif(root == null) return null;\n\t\troot.left = deleteInsufficient(root.left, limit);\n\t\troot.right = deleteInsufficient(root.right, limit);\n\t\tif(root.val < limit && (root.left == null && root.right == null)){\n\t\t\treturn null;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tNode deleteInsufficient(Node root, int limit){\n\t\tif(root == null) return null;\n\t\tif(root.left == null && root.right == null){\n\t\t\tif(root.val < limit) return null;\n\t\t\telse return root;\n\t\t}\n\t\troot.left = deleteInsufficient(root.left, limit);\n\t\troot.right = deleteInsufficient(root.right, limit);\n\t\tif(root.left == null && root.right == null){\n\t\t\tif(root.val < limit) return null;\n\t\t\telse return root;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode deleteInsufficient(TreeNode root, int limit){\n\t\tif(root == null) return null;\n\t\troot.left = deleteInsufficient(root.left, limit);\n\t\troot.right = deleteInsufficient(root.right, limit);\n\t\tif(root.val < limit && (root.left == null || root.right == null)){\n\t\t\tif(root.left != null) return root.right;\n\t\t\telse return root.left;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode deleteInsufficient(TreeNode root, int limit){\n\t\tif(root==null) return null;\n\t\troot.left=deleteInsufficient(root.left,limit);\n\t\troot.right=deleteInsufficient(root.right,limit);\n\t\tif(root.val<limit&&root.left==null&&root.right==null) return null;\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode deleteInsufficientNodes(TreeNode root, int limit){\n\t\tif(root==null) return null;\n\t\troot.left=deleteInsufficientNodes(root.left,limit);\n\t\troot.right=deleteInsufficientNodes(root.right,limit);\n\t\tif(root.left==null&&root.right==null&&root.val<limit) return null;\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode deleteInsufficientNodes(TreeNode root, int limit){\n\t\tif(root == null) return null;\n\t\troot.left = deleteInsufficientNodes(root.left, limit);\n\t\troot.right = deleteInsufficientNodes(root.right, limit);\n\t\tif(root.val < limit && (root.left == null || root.left.val >= limit) && (root.right == null || root.right.val >= limit)){\n\t\t\treturn root.left == null ? root.right : root.left;\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode deleteInsufficientNodes(TreeNode root, int limit){\n\t\tif(root==null) return null;\n\t\tTreeNode left=deleteInsufficientNodes(root.left,limit);\n\t\tTreeNode right=deleteInsufficientNodes(root.right,limit);\n\t\tif(root.val<limit){\n\t\t\tif(left==null) return right;\n\t\t\telse return left;\n\t\t}\n\t\telse{\n\t\t\troot.left=left;\n\t\t\troot.right=right;\n\t\t\treturn root;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2050",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return a binary string representing its representation in base -2.Note that the returned string should not have leading zeros unless the string is \"0\".",
    "snippets": [
        "\tString baseNeg2(int n) {\n\t\tif(n == 0) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n != 0){\n\t\t\tsb.append(n % -2);\n\t\t\tn /= -2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString baseNeg2(int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n == 0) return \"0\";\n\t\twhile(n != 0){\n\t\t\tsb.append(n % -2);\n\t\t\tn /= -2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString baseNeg2(int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n == 0){\n\t\t\tsb.append(\"0\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\twhile(n != 0){\n\t\t\tsb.append(n % -2);\n\t\t\tn /= -2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString baseNeg2(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n == 0) return \"0\";\n\t\twhile(n != 0){\n\t\t\tsb.append(n & 1);\n\t\t\tn = n >> 1;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString baseNeg2(int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n == 0) return \"0\";\n\t\twhile(n != 0){\n\t\t\tsb.append(n%2);\n\t\t\tn = n/2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString baseNeg2(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n == 0){\n\t\t\tsb.append(\"0\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\twhile(n != 0){\n\t\t\tsb.append(n % -2);\n\t\t\tn = n / -2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString baseNeg2(int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n == 0){\n\t\t\tsb.append(\"0\");\n\t\t}\n\t\twhile(n != 0){\n\t\t\tsb.append(n % -2);\n\t\t\tn = n / -2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString baseNeg2(int n){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(n==0){\n\t\t\tsb.append(\"0\");\n\t\t\treturn sb.toString();\n\t\t}\n\t\twhile(n!=0){\n\t\t\tsb.append(n&1);\n\t\t\tn = n>>1;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2051",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element.",
    "snippets": [
        "\tint countSmaller(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tif (nums[j] < nums[i]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[i] = count;\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\tsum += res[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint countSmaller(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor(int i = nums.length - 1; i >= 0; i--){\n\t\t\tint count = 0;\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(nums[j] < nums[i]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[i] = count;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += res[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint countSmaller(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor(int i = nums.length - 1; i >= 0; i--){\n\t\t\tint count = 0;\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(nums[i] > nums[j]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[i] = count;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < res.length; i++){\n\t\t\tsum += res[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint countSmaller(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tif (nums[i] > nums[j]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[i] = count;\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\tsum += res[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint countSmaller(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor(int i = nums.length - 1; i >= 0; i--){\n\t\t\tint count = 0;\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(nums[j] < nums[i]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[i] = count;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < res.length; i++){\n\t\t\tsum += res[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint countSmaller(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tint count = 0;\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tif (nums[i] > nums[j]) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[i] = count;\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += res[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint countSmaller(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor(int i = nums.length - 1; i >= 0; i--){\n\t\t\tint count = 0;\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(nums[i] > nums[j]) count++;\n\t\t\t}\n\t\t\tres[i] = count;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < res.length; i++){\n\t\t\tsum += res[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2052",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray. Return the largest sum of the given array after partitioning.",
    "snippets": [
        "\tint maxSumAfterPartitioning(int[] arr, int k) {\n\t\tint n = arr.length;\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint max = 0;\n\t\t\tfor (int j = 0; j < k && i - j >= 0; j++) {\n\t\t\t\tmax = Math.max(max, arr[i - j]);\n\t\t\t\tdp[i] = Math.max(dp[i], max * (j + 1));\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = Math.max(res, dp[i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxSubarraySum(int[] arr, int k) {\n\t\tint n = arr.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i] = Math.max(dp[i - 1] + arr[i], arr[i]);\n\t\t}\n\t\tint res = dp[k - 1];\n\t\tfor (int i = k; i < n; i++) {\n\t\t\tres = Math.max(res, dp[i] - dp[i - k]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxSubarraySum(int[] arr, int k) {\n\t\tint n = arr.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i] = Math.max(dp[i - 1] + arr[i], arr[i]);\n\t\t}\n\t\tint res = dp[0];\n\t\tfor (int i = 1; i < n - k + 1; i++) {\n\t\t\tres = Math.max(res, dp[i + k - 1] - dp[i - 1]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxSumAfterPartitioning(int[] arr, int k) {\n\t\tint[] dp = new int[arr.length];\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tint max = 0;\n\t\t\tfor (int j = 0; j < k && i - j >= 0; j++) {\n\t\t\t\tmax = Math.max(max, arr[i - j]);\n\t\t\t\tdp[i] = Math.max(dp[i], max * (j + 1));\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tres = Math.max(res, dp[i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2053",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integers num and k, consider a set of positive integers with the following properties: The units digit of each integer is k. The sum of the integers is num.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint num = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] arr = new int[num];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr[i] = i + 1;\n\t\t\tsum += i + 1;\n\t\t}\n\t\tint[] arr2 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr2[i] = arr[i] * k;\n\t\t}\n\t\tint[] arr3 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr3[i] = arr2[i] * k;\n\t\t}\n\t\tint[] arr4 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr4[i] = arr3[i] * k;\n\t\t}\n\t\tint[] arr5 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr5[i] = arr4[i] * k;\n\t\t}\n\t\tint[] arr6 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr6[i] = arr5[i] * k;\n\t\t}\n\t\tint[] arr7 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr7[i] = arr6[i] * k;\n\t\t}\n\t\tint[] arr8 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr8[i] = arr7[i] * k;\n\t\t}\n\t\tint[] arr9 = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n",
        "\tstatic void main(String[] args){\n\t\tint num = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] arr = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr[i] = i + 1;\n\t\t}\n\t\tint[] result = new int[num];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tif(arr[i] % k == 0){\n\t\t\t\tresult[count] = arr[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < count; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tstatic int count(int num, int k){\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tfor(int i = 1; i <= num; i++){\n\t\t\tsum += i;\n\t\t}\n\t\tif(sum == num){\n\t\t\tcount++;\n\t\t}\n\t\tfor(int i = 1; i <= num; i++){\n\t\t\tint temp = i;\n\t\t\twhile(temp > 0){\n\t\t\t\tif(temp % 10 == k){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint count(int num, int k){\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tfor(int i = 1; i <= num; i++){\n\t\t\tsum += i;\n\t\t}\n\t\tif(sum == num){\n\t\t\tcount++;\n\t\t}\n\t\tfor(int i = 1; i <= num; i++){\n\t\t\tint temp = i;\n\t\t\twhile(temp > 0){\n\t\t\t\tint digit = temp % 10;\n\t\t\t\tif(digit == k){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ttemp = temp / 10;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint find(int num, int k){\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tfor(int i = 1; i <= num; i++){\n\t\t\tint temp = i;\n\t\t\twhile(temp != 0){\n\t\t\t\tif(temp % 10 == k){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ttemp /= 10;\n\t\t\t}\n\t\t\tsum += count;\n\t\t\tcount = 0;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint[] digits(int num, int k){\n\t\tint[] result = new int[num];\n\t\tint i = 0;\n\t\twhile(num > 0){\n\t\t\tresult[i] = num % k;\n\t\t\tnum /= k;\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint num = 12;\n\t\tint k = 3;\n\t\tint sum = 0;\n\t\tint temp = 0;\n\t\tint count = 0;\n\t\tint[] arr = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tarr[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < num; i++){\n\t\t\ttemp = arr[i];\n\t\t\twhile(temp > 0){\n\t\t\t\tif(temp % 10 == k){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ttemp = temp / 10;\n\t\t\t}\n\t\t\tsum += count;\n\t\t\tcount = 0;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n}\n",
        "\tstatic int[] findIntegers(int num) {\n\t\tint[] res = new int[2];\n\t\tres[0] = res[1] = -1;\n\t\tif(num <= 0) return res;\n\t\tint i = 1;\n\t\twhile(i <= num){\n\t\t\tif(num == i){\n\t\t\t\tres[0] = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(num == i + 1){\n\t\t\t\tres[0] = i;\n\t\t\t\tres[1] = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = i * 10;\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2054",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, return true if any value appears at least twice in the array. Return false if every element is distinct.",
    "snippets": [
        "\tboolean containsDuplicate(int[] nums) {\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(set.contains(nums[i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2055",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array bloomDay, an integer m and an integer k. To make a bouquet, you need to use k adjacent flowers from the garden. If it is impossible to make m bouquets return -1.",
    "snippets": [
        "\tint bouquet(int[] bloomDay, int m, int k){\n\t\tint n = bloomDay.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tdp[i] = dp[i-1];\n\t\t\tfor(int j = i-k; j >= 0; j--){\n\t\t\t\tif(bloomDay[i] > bloomDay[j]){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1] >= m ? 1 : -1;\n\t}\n}\n",
        "\tstatic int bouquet(int[] bloomDay, int m, int k){\n\t\tint n = bloomDay.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tdp[i] = dp[i-1];\n\t\t\tfor(int j = i-k; j >= 0; j--){\n\t\t\t\tif(bloomDay[i] > bloomDay[j]){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1] >= m ? 1 : -1;\n\t}\n}\n",
        "\tint[] bouquet(int[] bloomDay, int m, int k){\n\t\tint[] res = new int[m];\n\t\tint n = bloomDay.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint count = 0;\n\t\twhile(count < m){\n\t\t\tint max = 0;\n\t\t\tint maxIndex = 0;\n\t\t\tfor(int l = i; l < i + k; l++){\n\t\t\t\tif(bloomDay[l] > max){\n\t\t\t\t\tmax = bloomDay[l];\n\t\t\t\t\tmaxIndex = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[count] = max;\n\t\t\ti = maxIndex + 1;\n\t\t\tcount++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] makeBouquet(int[] bloomDay, int m, int k){\n\t\tint n = bloomDay.length;\n\t\tint[] res = new int[m];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint count = 0;\n\t\twhile(count < m){\n\t\t\tint max = 0;\n\t\t\tint maxIndex = 0;\n\t\t\tfor(int l = i; l < i + k; l++){\n\t\t\t\tif(bloomDay[l] > max){\n\t\t\t\t\tmax = bloomDay[l];\n\t\t\t\t\tmaxIndex = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[count] = maxIndex;\n\t\t\ti = maxIndex + 1;\n\t\t\tcount++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] bouquets(int[] bloomDay, int m, int k) {\n\t\tint n = bloomDay.length;\n\t\tint[] res = new int[m];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint count = 0;\n\t\twhile(i < n){\n\t\t\tif(count == k){\n\t\t\t\tres[j] = i - k + 1;\n\t\t\t\tj++;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tif(j == m){\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\ti++;\n\t\t\tcount++;\n\t\t}\n\t\treturn new int[0];\n\t}\n}\n",
        "\tint[] bouquet(int[] bloomDay, int m, int k){\n\t\tint n = bloomDay.length;\n\t\tint[] res = new int[m];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n){\n\t\t\tint count = 0;\n\t\t\twhile(count < k && i < n){\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(count < k) return new int[0];\n\t\t\tres[j] = i - k;\n\t\t\tj++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] bouquet(int[] bloomDay, int m, int k){\n\t\tint n = bloomDay.length;\n\t\tint[] res = new int[m];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n && j < m){\n\t\t\tint max = 0;\n\t\t\tint maxIndex = 0;\n\t\t\tfor(int l = i; l < i + k; l++){\n\t\t\t\tif(bloomDay[l] > max){\n\t\t\t\t\tmax = bloomDay[l];\n\t\t\t\t\tmaxIndex = l;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres[j] = maxIndex;\n\t\t\ti = maxIndex + 1;\n\t\t\tj++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] gardenNoAdj(int N, int[][] paths) {\n\t\tint[] garden = new int[N];\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tgarden[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < paths.length; i++){\n\t\t\tint flower1 = paths[i][0];\n\t\t\tint flower2 = paths[i][1];\n\t\t\tif(garden[flower1 - 1] == -1){\n\t\t\t\tgarden[flower1 - 1] = flower1;\n\t\t\t}\n\t\t\tif(garden[flower2 - 1] == -1){\n\t\t\t\tgarden[flower2 - 1] = flower2;\n\t\t\t}\n\t\t\tif(garden[flower1 - 1] != flower1 || garden[flower2 - 1] != flower2){\n\t\t\t\treturn new int[]{-1};\n\t\t\t}\n\t\t}\n\t\treturn garden;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2056",
    "source": "leetcode",
    "language": "java",
    "query": "You are trying to write s across several lines, where each line is no longer than 100 pixels. You are given a string s and an array widths denoting how many pixels wide each lowercase English letter is.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString s = \"abcdefghijklmnopqrstuvwxyz\";\n\t\tint[] widths = {3, 1, 4, 4, 5, 5, 1, 3, 1, 3, 4, 3, 1, 1, 3, 10};\n\t\tint expected = 43;\n\t\tint actual = new Clazz().longestWord(s, widths);\n\t\tSystem.out.println(actual == expected);\n\t}\n\tpublic int longestWord(String s, int[] widths) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) >= 'a' && s.charAt(i) <= 'z'){\n\t\t\t\tsum += widths[s.charAt(i) - 'a'];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(sum > max) max = sum;\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif(sum > max) max = sum;\n\t\treturn max;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"abcdefghijklmnopqrstuvwxyz\";\n\t\tint[] widths = {3, 1, 4, 4, 5, 2, 6, 3, 7, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"abcdefghijklmnopqrstuvwxyz\";\n\t\tint[] widths = {4,1,1,2,2,8,2,1,2,1,1,1,3,3,1,1,1,1,1,3,10,1,1,1,1,1,1,1,1,1,1,1};\n\t\tint[] res = new int[s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tres[i] = widths[s.charAt(i) - 'a'];\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < res.length; i++){\n\t\t\tsum += res[i];\n\t\t}\n\t\tint line = 0;\n\t\tint cur = 0;\n\t\tfor(int i = 0; i < res.length; i++){\n\t\t\tif(cur + res[i] > 100){\n\t\t\t\tline++;\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t\tcur += res[i];\n\t\t}\n\t\tSystem.out.println(line + 1);\n\t}\n}\n",
        "\tvoid method(String s, int[] widths) {\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tsum += widths[s.charAt(i) - 'a'];\n\t\t\tif(sum > 100){\n\t\t\t\tcount++;\n\t\t\t\tsum = widths[s.charAt(i) - 'a'];\n\t\t\t}\n\t\t}\n\t\tcount++;\n\t\tSystem.out.println(count);\n\t}\n}\n",
        "\tvoid method(String s, int[] widths) {\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == ' '){\n\t\t\t\tsum += widths[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum += widths[s.charAt(i) - 'a'];\n\t\t\t}\n\t\t\tif(sum > 100){\n\t\t\t\tSystem.out.println();\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.print(s.charAt(i));\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\tvoid method(String s, int[] widths) {\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tsum += widths[s.charAt(i) - 'a'];\n\t\t\tif(sum > 100){\n\t\t\t\tSystem.out.println();\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\tSystem.out.print(s.charAt(i));\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\tstatic void print(String s, int[] widths) {\n\t\tint len = s.length();\n\t\tint[] width = new int[len];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\twidth[i] = widths[s.charAt(i) - 'a'];\n\t\t}\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tsum += width[i];\n\t\t\tif(sum > 100){\n\t\t\t\tSystem.out.println(s.substring(count, i));\n\t\t\t\tcount = i;\n\t\t\t\tsum = width[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(s.substring(count));\n\t}\n}\n",
        "\tstatic String[] split(String s, int[] widths) {\n\t\tint n = s.length();\n\t\tint[] width = widths;\n\t\tint[] count = new int[n];\n\t\tint[] index = new int[n];\n\t\tint[] result = new int[n];\n\t\tint i = 0, j = 0, k = 0;\n\t\twhile (i < n) {\n\t\t\tif (s.charAt(i) == ' ') {\n\t\t\t\tindex[j] = i;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tindex[j] = n;\n\t\tj++;\n\t\tfor (i = 0; i < j; i++) {\n\t\t\tint sum = 0;\n\t\t\tfor (k = index[i]; k < index[i + 1]; k++) {\n\t\t\t\tsum += width[s.charAt(k) - 'a'];\n\t\t\t}\n\t\t\tcount[i] = sum;\n\t\t}\n\t\ti = 0;\n\t\twhile (i < j) {\n\t\t\tif (count[i] > 100) {\n\t\t\t\tresult[k] = index[i];\n\t\t\t\tk++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tresult[k] = index[j];\n\t\tk++;\n\t\tString[] resultStr = new String[k];\n\t\tfor (i = 0; i < k; i++) {\n\t\t\tresultStr[i] = s.substring(result[i], result[i + 1]);\n\t\t}\n\t\treturn resultStr;\n\t}\n}\n"
    ],
    "results": 8
},{
    "id": "2057",
    "source": "leetcode",
    "language": "java",
    "query": "Find the number that occurs twice and theNumber that is missing and return them in the form of an array.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] array = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};\n\t\tint[] result = findMissingAndTwice(array);\n\t\tSystem.out.println(\"Missing: \" + result[0] + \" Twice: \" + result[1]);\n\t}\n\tpublic static int[] findMissingAndTwice(int[] array){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tsum += array[i];\n\t\t}\n\t\tint expectedSum = (array.length * (array.length + 1)) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tint missing = difference / 2;\n\t\tint twice = difference - missing;\n\t\tresult[0] = missing;\n\t\tresult[1] = twice;\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] find(int[] array){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tsum += array[i];\n\t\t}\n\t\tint expectedSum = array.length * (array.length + 1) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == difference){\n\t\t\t\tresult[0] = difference;\n\t\t\t\tresult[1] = array[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] find(int[] array){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tsum += array[i];\n\t\t}\n\t\tint expectedSum = array.length * (array.length + 1) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == difference){\n\t\t\t\tresult[0] = array[i];\n\t\t\t\tresult[1] = array[i-1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] find(int[] array){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tsum += array[i];\n\t\t}\n\t\tint expectedSum = array.length * (array.length + 1) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == difference){\n\t\t\t\tresult[0] = array[i];\n\t\t\t\tresult[1] = array[i-1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] find(int[] array){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tsum += array[i];\n\t\t}\n\t\tint expectedSum = array.length * (array.length + 1) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == difference){\n\t\t\t\tresult[0] = array[i];\n\t\t\t\tresult[1] = array[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};\n\t\tint[] result = findMissingAndTwice(arr);\n\t\tSystem.out.println(\"Missing: \" + result[0]);\n\t\tSystem.out.println(\"Twice: \" + result[1]);\n\t}\n\tpublic static int[] findMissingAndTwice(int[] arr){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tsum += arr[i];\n\t\t}\n\t\tint expectedSum = (arr.length * (arr.length + 1)) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tint missing = difference / 2;\n\t\tint twice = difference - missing;\n\t\tresult[0] = missing;\n\t\tresult[1] = twice;\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] findTwice(int[] array){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tsum += array[i];\n\t\t}\n\t\tint expectedSum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum += i;\n\t\t}\n\t\tint expectedSum2 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum2 += array[i];\n\t\t}\n\t\tint expectedSum3 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum3 += array[i];\n\t\t}\n\t\tint expectedSum4 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum4 += array[i];\n\t\t}\n\t\tint expectedSum5 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum5 += array[i];\n\t\t}\n\t\tint expectedSum6 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum6 += array[i];\n\t\t}\n\t\tint expectedSum7 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum7 += array[i];\n\t\t}\n\t\tint expectedSum8 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum8 += array[i];\n\t\t}\n\t\tint expectedSum9 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\texpectedSum9 += array[i];\n\t\t}\n\t\tint expectedSum10 = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n",
        "\tstatic int[] findTwice(int[] array){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tsum += array[i];\n\t\t}\n\t\tint expectedSum = array.length * (array.length + 1) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == difference){\n\t\t\t\tresult[0] = array[i];\n\t\t\t\tresult[1] = array[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] findTwice(int[] arr){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tsum += arr[i];\n\t\t}\n\t\tint expectedSum = arr.length * (arr.length + 1) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] == difference){\n\t\t\t\tresult[0] = arr[i];\n\t\t\t\tresult[1] = arr[i+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] find(int[] numbers){\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < numbers.length; i++){\n\t\t\tsum += numbers[i];\n\t\t}\n\t\tint expectedSum = numbers.length * (numbers.length + 1) / 2;\n\t\tint difference = expectedSum - sum;\n\t\tfor(int i = 0; i < numbers.length; i++){\n\t\t\tif(numbers[i] == difference){\n\t\t\t\tresult[0] = difference;\n\t\t\t\tresult[1] = numbers[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2058",
    "source": "leetcode",
    "language": "java",
    "query": "Return an array [L, W] where L and W are the length and width of the web page you designed.",
    "snippets": [
        "\tint[] createWeb(int[] requests){\n\t\tint[] result = new int[2];\n\t\tint L = 0;\n\t\tint W = 0;\n\t\tfor(int i = 0; i < requests.length; i++){\n\t\t\tL += requests[i];\n\t\t\tW += requests[i];\n\t\t}\n\t\tresult[0] = L;\n\t\tresult[1] = W;\n\t\treturn result;\n\t}\n}\n",
        "\tint[] solution(int[] A, int[] B){\n\t\tint[] result = new int[2];\n\t\tint L = 0;\n\t\tint W = 0;\n\t\tfor(int i = 0; i < A.length; i++){\n\t\t\tL += A[i];\n\t\t\tW += B[i];\n\t\t}\n\t\tresult[0] = L;\n\t\tresult[1] = W;\n\t\treturn result;\n\t}\n}\n",
        "\tint[] createWeb(int[] requests) {\n\t\tint[] result = new int[2];\n\t\tint L = 0;\n\t\tint W = 0;\n\t\tfor(int i = 0; i < requests.length; i++){\n\t\t\tif(requests[i] == 1){\n\t\t\t\tL += 1;\n\t\t\t}else{\n\t\t\t\tW += 1;\n\t\t\t}\n\t\t}\n\t\tresult[0] = L;\n\t\tresult[1] = W;\n\t\treturn result;\n\t}\n}\n",
        "\tint[] designWebPage(int[] requests){\n\t\tint[] result = new int[2];\n\t\tint L = 0;\n\t\tint W = 0;\n\t\tfor(int i = 0; i < requests.length; i++){\n\t\t\tif(requests[i] > L){\n\t\t\t\tL = requests[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < requests.length; i++){\n\t\t\tif(requests[i] > W){\n\t\t\t\tW = requests[i];\n\t\t\t}\n\t\t}\n\t\tresult[0] = L;\n\t\tresult[1] = W;\n\t\treturn result;\n\t}\n}\n",
        "\tint[] getWebpageLengthWidth(String[] pages){\n\t\tint[] result = new int[2];\n\t\tint length = 0;\n\t\tint width = 0;\n\t\tfor(int i = 0; i < pages.length; i++){\n\t\t\tif(pages[i].length() > length){\n\t\t\t\tlength = pages[i].length();\n\t\t\t}\n\t\t\tif(pages[i].length() > width){\n\t\t\t\twidth = pages[i].length();\n\t\t\t}\n\t\t}\n\t\tresult[0] = length;\n\t\tresult[1] = width;\n\t\treturn result;\n\t}\n}\n",
        "\tint[] createWebpage(int[] widths, String S) {\n\t\tint[] result = new int[2];\n\t\tint length = 0;\n\t\tint width = 0;\n\t\tfor(int i = 0; i < S.length(); i++){\n\t\t\tint index = S.charAt(i) - 'a';\n\t\t\tlength += widths[index];\n\t\t\twidth += widths[index];\n\t\t}\n\t\tresult[0] = length;\n\t\tresult[1] = width;\n\t\treturn result;\n\t}\n}\n",
        "\tint[] designWebPage(int[] requests, int capacity) {\n\t\tint[] result = new int[2];\n\t\tint L = 0;\n\t\tint W = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint aa = 0;\n\t\tint bb = 0;\n\t\tint cc = 0;\n\t\tint dd = 0;\n\t\tint ee = 0;\n\t\tint ff = 0;\n\t\tint gg = 0;\n\t\tint hh = 0;\n\t\tint ii = 0;\n\t\tint jj = 0;\n\t\tint kk = 0;\n\t\tint ll = 0;\n\t\tint mm = 0;\n\t\tint nn = 0;\n\t\tint oo = 0;\n\t\tint pp = 0;\n\t\tint qq = 0;\n\t\tint rr = 0;\n\t\tint ss = 0;\n\t\tint tt = 0;\n\t\tint uu = 0;\n\t\tint vv = 0;\n\t\tint ww = 0;\n\t\tint xx = 0;\n\t\tint yy = 0;\n\t\tint zz = 0;\n\t\tint aaa = 0;\n\t\tint bbb = 0;\n\t\tint ccc = 0;\n\t\tint ddd = 0;\n\t\tint eee = 0;\n\t\tint fff = 0;\n\t\tint ggg = 0;\n\t\tint hhh = 0;\n\t\tint iii = 0;\n\t\tint jjj =\n",
        "\tint[] createWeb(int[] arr) {\n\t\tint[] result = new int[2];\n\t\tresult[0] = arr[0] + arr[1];\n\t\tresult[1] = arr[2] + arr[3];\n\t\treturn result;\n\t}\n}\n",
        "\tint[] createWebpage(int[] input1, int[] input2) {\n\t\tint[] result = new int[2];\n\t\tresult[0] = input1[0] + input2[0];\n\t\tresult[1] = input1[1] + input2[1];\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2059",
    "source": "leetcode",
    "language": "java",
    "query": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei. If there is no such route, return -1.",
    "snippets": [
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] prices = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tprices[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tprices[src] = 0;\n\t\tQueue<int[]> queue = new LinkedList<int[]>();\n\t\tqueue.offer(new int[] { src, 0 });\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint city = cur[0];\n\t\t\tint price = cur[1];\n\t\t\tif (city == dst) {\n\t\t\t\treturn price;\n\t\t\t}\n\t\t\tfor (int[] flight : flights) {\n\t\t\t\tif (flight[0] == city) {\n\t\t\t\t\tint next = flight[1];\n\t\t\t\t\tint nextPrice = price + flight[2];\n\t\t\t\t\tif (nextPrice < prices[next]) {\n\t\t\t\t\t\tprices[next] = nextPrice;\n\t\t\t\t\t\tqueue.offer(new int[] { next, nextPrice });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, Integer.MAX_VALUE);\n\t\tdp[src] = 0;\n\t\tfor (int i = 0; i <= K; i++) {\n\t\t\tint[] next = new int[n];\n\t\t\tfor (int[] f : flights) {\n\t\t\t\tnext[f[1]] = Math.min(next[f[1]], dp[f[0]] + f[2]);\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t\treturn dp[dst] == Integer.MAX_VALUE ? -1 : dp[dst];\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++) prices[i] = Integer.MAX_VALUE;\n\t\tprices[src] = 0;\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.offer(src);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tint cur = queue.poll();\n\t\t\t\tfor(int[] flight: flights){\n\t\t\t\t\tif(flight[0] == cur){\n\t\t\t\t\t\tint next = flight[1];\n\t\t\t\t\t\tint price = flight[2];\n\t\t\t\t\t\tif(prices[cur] + price < prices[next]){\n\t\t\t\t\t\t\tprices[next] = prices[cur] + price;\n\t\t\t\t\t\t\tif(next == dst) return prices[next];\n\t\t\t\t\t\t\tif(K > 0) queue.offer(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tK--;\n\t\t\tif(K < 0) break;\n\t\t}\n\t\treturn prices[dst] == Integer.MAX_VALUE? -1: prices[dst];\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] prices = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tprices[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tprices[src] = 0;\n\t\tQueue<int[]> queue = new LinkedList<int[]>();\n\t\tqueue.offer(new int[] { src, 0 });\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint[] cur = queue.poll();\n\t\t\tint city = cur[0];\n\t\t\tint price = cur[1];\n\t\t\tif (city == dst) {\n\t\t\t\treturn price;\n\t\t\t}\n\t\t\tif (K > 0) {\n\t\t\t\tfor (int[] flight : flights) {\n\t\t\t\t\tif (flight[0] == city) {\n\t\t\t\t\t\tint next = flight[1];\n\t\t\t\t\t\tint nextPrice = price + flight[2];\n\t\t\t\t\t\tif (nextPrice < prices[next]) {\n\t\t\t\t\t\t\tprices[next] = nextPrice;\n\t\t\t\t\t\t\tqueue.offer(new int[] { next, nextPrice });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[src] = 0;\n\t\tfor (int i = 0; i <= K; i++) {\n\t\t\tint[] next = new int[n];\n\t\t\tfor (int[] f : flights) {\n\t\t\t\tnext[f[1]] = Math.min(next[f[1]], dp[f[0]] + f[2]);\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t\treturn dp[dst] == Integer.MAX_VALUE ? -1 : dp[dst];\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[src] = 0;\n\t\tfor (int i = 0; i < K + 1; i++) {\n\t\t\tint[] next = new int[n];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int[] f : flights) {\n\t\t\t\t\tint from = f[0];\n\t\t\t\t\tint to = f[1];\n\t\t\t\t\tint cost = f[2];\n\t\t\t\t\tif (dp[from] != Integer.MAX_VALUE) {\n\t\t\t\t\t\tnext[to] = Math.min(next[to], dp[from] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = next;\n\t\t}\n\t\treturn dp[dst] == Integer.MAX_VALUE ? -1 : dp[dst];\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] prices = new int[n];\n\t\tfor(int i = 0; i < n; i++) prices[i] = Integer.MAX_VALUE;\n\t\tprices[src] = 0;\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.offer(src);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tint cur = queue.poll();\n\t\t\t\tfor(int[] flight : flights){\n\t\t\t\t\tif(cur == flight[0]){\n\t\t\t\t\t\tint next = flight[1];\n\t\t\t\t\t\tint price = flight[2];\n\t\t\t\t\t\tif(prices[next] > prices[cur] + price){\n\t\t\t\t\t\t\tprices[next] = prices[cur] + price;\n\t\t\t\t\t\t\tqueue.offer(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\n\t\tint[] prices = new int[n];\n\t\tArrays.fill(prices, Integer.MAX_VALUE);\n\t\tprices[src] = 0;\n\t\tfor (int i = 0; i < K + 1; i++) {\n\t\t\tint[] newPrices = new int[n];\n\t\t\tfor (int[] flight : flights) {\n\t\t\t\tint from = flight[0], to = flight[1], price = flight[2];\n\t\t\t\tif (prices[from] != Integer.MAX_VALUE) {\n\t\t\t\t\tnewPrices[to] = Math.min(newPrices[to], prices[from] + price);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprices = newPrices;\n\t\t}\n\t\treturn prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\n\t}\n}\n",
        "\tint findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n\t\tint[] dp = new int[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[src] = 0;\n\t\tfor(int i = 0; i < k + 1; i++) {\n\t\t\tint[] temp = dp.clone();\n\t\t\tfor(int[] f : flights) {\n\t\t\t\tint from = f[0];\n\t\t\t\tint to = f[1];\n\t\t\t\tint price = f[2];\n\t\t\t\tif(dp[from] != Integer.MAX_VALUE) {\n\t\t\t\t\ttemp[to] = Math.min(temp[to], dp[from] + price);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = temp;\n\t\t}\n\t\treturn dp[dst] == Integer.MAX_VALUE ? -1 : dp[dst];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2060",
    "source": "leetcode",
    "language": "java",
    "query": "An Anagram is a word or phrase formed by rearranging the letters of a different word. Given an array of strings strs, group the anagrams together.",
    "snippets": [
        "\tList<List<String>> groupAnagrams(String[] strs) {\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif(strs == null || strs.length == 0) return result;\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor(String str : strs){\n\t\t\tchar[] chars = str.toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = new String(chars);\n\t\t\tif(map.containsKey(key)){\n\t\t\t\tmap.get(key).add(str);\n\t\t\t}else{\n\t\t\t\tList<String> list = new ArrayList<String>();\n\t\t\t\tlist.add(str);\n\t\t\t\tmap.put(key, list);\n\t\t\t}\n\t\t}\n\t\tfor(List<String> list : map.values()){\n\t\t\tresult.add(list);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<String>> groupAnagrams(String[] strs) {\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif(strs == null || strs.length == 0) return result;\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor(String str : strs){\n\t\t\tchar[] chars = str.toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = new String(chars);\n\t\t\tif(!map.containsKey(key)){\n\t\t\t\tmap.put(key, new ArrayList<String>());\n\t\t\t}\n\t\t\tmap.get(key).add(str);\n\t\t}\n\t\tfor(List<String> list : map.values()){\n\t\t\tresult.add(list);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<String>> groupAnagrams(String[] strs) {\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif (strs == null || strs.length == 0) {\n\t\t\treturn result;\n\t\t}\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor (String str : strs) {\n\t\t\tchar[] chars = str.toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = new String(chars);\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<String>());\n\t\t\t}\n\t\t\tmap.get(key).add(str);\n\t\t}\n\t\tfor (String key : map.keySet()) {\n\t\t\tresult.add(map.get(key));\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<String>> groupAnagrams(String[] strs) {\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif (strs == null || strs.length == 0) {\n\t\t\treturn result;\n\t\t}\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor (String str : strs) {\n\t\t\tchar[] chars = str.toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = String.valueOf(chars);\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<String>());\n\t\t\t}\n\t\t\tmap.get(key).add(str);\n\t\t}\n\t\tfor (String key : map.keySet()) {\n\t\t\tresult.add(map.get(key));\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic List<List<String>> groupAnagrams(String[] strs) {\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif (strs == null || strs.length == 0) {\n\t\t\treturn result;\n\t\t}\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor (String str : strs) {\n\t\t\tchar[] chars = str.toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = new String(chars);\n\t\t\tif (!map.containsKey(key)) {\n\t\t\t\tmap.put(key, new ArrayList<String>());\n\t\t\t}\n\t\t\tmap.get(key).add(str);\n\t\t}\n\t\tfor (String key : map.keySet()) {\n\t\t\tresult.add(map.get(key));\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] strs = {\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"};\n\t\tSystem.out.println(groupAnagrams(strs));\n\t}\n\tpublic static List<List<String>> groupAnagrams(String[] strs){\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif(strs == null || strs.length == 0)\n\t\t\treturn result;\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor(int i = 0; i < strs.length; i++){\n\t\t\tchar[] chars = strs[i].toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = new String(chars);\n\t\t\tif(map.containsKey(key))\n\t\t\t\tmap.get(key).add(strs[i]);\n\t\t\telse{\n\t\t\t\tList<String> list = new ArrayList<String>();\n\t\t\t\tlist.add(strs[i]);\n\t\t\t\tmap.put(key, list);\n\t\t\t}\n\t\t}\n\t\tfor(String key : map.keySet()){\n\t\t\tresult.add(map.get(key));\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] strs = {\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"};\n\t\tList<List<String>> result = groupAnagrams(strs);\n\t\tfor(List<String> list: result){\n\t\t\tfor(String str: list){\n\t\t\t\tSystem.out.print(str + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static List<List<String>> groupAnagrams(String[] strs){\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif(strs == null || strs.length == 0){\n\t\t\treturn result;\n\t\t}\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor(String str: strs){\n\t\t\tchar[] chars = str.toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = new String(chars);\n\t\t\tif(map.containsKey(key)){\n\t\t\t\tmap.get(key).add(str);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<String> list = new ArrayList<String>();\n\t\t\t\tlist.add(str);\n\t\t\t\tmap.put(key, list);\n\t\t\t}\n\t\t}\n\t\tfor(List<String> list: map.values()){\n\t\t\tresult.add(list);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] strs = {\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"};\n\t\tList<List<String>> result = groupAnagrams(strs);\n\t\tfor(List<String> list: result){\n\t\t\tfor(String str: list){\n\t\t\t\tSystem.out.print(str + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static List<List<String>> groupAnagrams(String[] strs){\n\t\tList<List<String>> result = new ArrayList<List<String>>();\n\t\tif(strs == null || strs.length == 0) return result;\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tfor(String str: strs){\n\t\t\tchar[] chars = str.toCharArray();\n\t\t\tArrays.sort(chars);\n\t\t\tString key = new String(chars);\n\t\t\tif(map.containsKey(key)){\n\t\t\t\tmap.get(key).add(str);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tList<String> list = new ArrayList<String>();\n\t\t\t\tlist.add(str);\n\t\t\t\tmap.put(key, list);\n\t\t\t}\n\t\t}\n\t\tfor(List<String> list: map.values()){\n\t\t\tresult.add(list);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] strs = {\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"};\n\t\tSystem.out.println(new Solution().groupAnagrams(strs));\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2061",
    "source": "leetcode",
    "language": "java",
    "query": "Your solution must run in O(log n) time and O(1) space. Return the single element that appears only once.",
    "snippets": [
        "\tint singleNumber(int[] nums) {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tresult ^= nums[i];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int singleNumber(int[] nums) {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tresult ^= nums[i];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint singleNumber(int[] nums) {\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 32; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tsum += (nums[j] >> i) & 1;\n\t\t\t}\n\t\t\tres |= (sum % 3) << i;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint singleNumber(int[] nums) {\n\t\tint xor = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\txor ^= nums[i];\n\t\t}\n\t\treturn xor;\n\t}\n}\n",
        "\tstatic int singleNumber(int[] nums) {\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 32; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tsum += (nums[j] >> i) & 1;\n\t\t\t}\n\t\t\tres |= (sum % 3) << i;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int singleNumber(int[] nums) {\n\t\tint xor = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\txor ^= nums[i];\n\t\t}\n\t\treturn xor;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2062",
    "source": "leetcode",
    "language": "java",
    "query": "circular track consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector round[i].",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] rounds = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\trounds[i] = in.nextInt();\n\t\t}\n\t\tint[] result = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tresult[i] = (rounds[i] + n - 1) % n + 1;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] rounds = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\trounds[i] = sc.nextInt();\n\t\t}\n\t\tint[] res = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tres[i] = getDistance(rounds[i], rounds[(i + 1) % m], n);\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.print(res[i] + \" \");\n\t\t}\n\t}\n\tpublic static int getDistance(int start, int end, int n){\n\t\tint res = 0;\n\t\tif(start > end){\n\t\t\tres = (n - start + 1) + end;\n\t\t}else{\n\t\t\tres = end - start;\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 2
},{
    "id": "2063",
    "source": "leetcode",
    "language": "java",
    "query": "You must solve the problem without using any built-in library for handling large integers. You must also not convert the inputs to integers directly. Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 & num2 as a string.",
    "snippets": [
        "\tString addStrings(String num1, String num2) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tint i = num1.length() - 1;\n\t\tint j = num2.length() - 1;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint a = i >= 0 ? num1.charAt(i--) - '0' : 0;\n\t\t\tint b = j >= 0 ? num2.charAt(j--) - '0' : 0;\n\t\t\tint sum = a + b + carry;\n\t\t\tsb.append(sum % 10);\n\t\t\tcarry = sum / 10;\n\t\t}\n\t\tif (carry > 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addStrings(String num1, String num2) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tint i = num1.length() - 1;\n\t\tint j = num2.length() - 1;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint a = i >= 0 ? num1.charAt(i) - '0' : 0;\n\t\t\tint b = j >= 0 ? num2.charAt(j) - '0' : 0;\n\t\t\tint sum = a + b + carry;\n\t\t\tsb.append(sum % 10);\n\t\t\tcarry = sum / 10;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\tif (carry > 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addStrings(String num1, String num2) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tint i = num1.length() - 1;\n\t\tint j = num2.length() - 1;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint sum = carry;\n\t\t\tif (i >= 0) {\n\t\t\t\tsum += num1.charAt(i) - '0';\n\t\t\t}\n\t\t\tif (j >= 0) {\n\t\t\t\tsum += num2.charAt(j) - '0';\n\t\t\t}\n\t\t\tsb.append(sum % 10);\n\t\t\tcarry = sum / 10;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\tif (carry > 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addStrings(String num1, String num2) {\n\t\tint len1 = num1.length();\n\t\tint len2 = num2.length();\n\t\tint len = Math.max(len1, len2);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tint a = i < len1 ? num1.charAt(len1 - 1 - i) - '0' : 0;\n\t\t\tint b = i < len2 ? num2.charAt(len2 - 1 - i) - '0' : 0;\n\t\t\tint sum = a + b + carry;\n\t\t\tcarry = sum / 10;\n\t\t\tsb.append(sum % 10);\n\t\t}\n\t\tif (carry > 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addStrings(String num1, String num2) {\n\t\tint len1 = num1.length();\n\t\tint len2 = num2.length();\n\t\tint len = Math.max(len1, len2);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tint a = i < len1 ? num1.charAt(len1 - 1 - i) - '0' : 0;\n\t\t\tint b = i < len2 ? num2.charAt(len2 - 1 - i) - '0' : 0;\n\t\t\tint sum = a + b + carry;\n\t\t\tsb.append(sum % 10);\n\t\t\tcarry = sum / 10;\n\t\t}\n\t\tif (carry > 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addStrings(String num1, String num2) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint a = i >= 0 ? num1.charAt(i--) - '0' : 0;\n\t\t\tint b = j >= 0 ? num2.charAt(j--) - '0' : 0;\n\t\t\tint sum = a + b + carry;\n\t\t\tsb.append(sum % 10);\n\t\t\tcarry = sum / 10;\n\t\t}\n\t\tif (carry > 0) sb.append(carry);\n\t\treturn sb.reverse().toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2064",
    "source": "leetcode",
    "language": "java",
    "query": "A Bitset is a data structure that compactly stores bits. The class Bitset Initializes the Bitset with size bits that are 0.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tBitset bs = new Bitset(10);\n\t\tbs.set(0);\n\t\tbs.set(1);\n\t\tbs.set(2);\n\t\tbs.set(3);\n\t\tbs.set(4);\n\t\tbs.set(5);\n\t\tbs.set(6);\n\t\tbs.set(7);\n\t\tbs.set(8);\n\t\tbs.set(9);\n\t\tSystem.out.println(bs.toString());\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tBitset b = new Bitset(10);\n\t\tb.set(0);\n\t\tb.set(1);\n\t\tb.set(2);\n\t\tb.set(3);\n\t\tb.set(4);\n\t\tb.set(5);\n\t\tb.set(6);\n\t\tb.set(7);\n\t\tb.set(8);\n\t\tb.set(9);\n\t\tSystem.out.println(b.toString());\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tBitset b = new Bitset(10);\n\t\tb.set(1);\n\t\tb.set(3);\n\t\tb.set(5);\n\t\tb.set(7);\n\t\tb.set(9);\n\t\tSystem.out.println(b.toString());\n\t}\n}\n",
        "\tClazz(){\n\t\tBitset bs = new Bitset(10);\n\t\tbs.set(0);\n\t\tbs.set(1);\n\t\tbs.set(2);\n\t\tbs.set(3);\n\t\tbs.set(4);\n\t\tbs.set(5);\n\t\tbs.set(6);\n\t\tbs.set(7);\n\t\tbs.set(8);\n\t\tbs.set(9);\n\t\tSystem.out.println(bs.toString());\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tBitset b = new Bitset(10);\n\t\tb.set(2);\n\t\tb.set(4);\n\t\tb.set(6);\n\t\tb.set(8);\n\t\tSystem.out.println(b);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2065",
    "source": "leetcode",
    "language": "java",
    "query": "Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo 109 + 7.",
    "snippets": [
        "\tint findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < maxMove; i++) {\n\t\t\tint[][] temp = new int[m][n];\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\ttemp[j][k] = (dp[j][k] + dp[j][k + 1]) % 1000000007;\n\t\t\t\t\t} else if (j == m - 1) {\n\t\t\t\t\t\ttemp[j][k] = (dp[j][k] + dp[j][k - 1]) % 1000000007;\n\t\t\t\t\t} else if (k == 0) {\n\t\t\t\t\t\ttemp[j][k] = (dp[j][k] + dp[j + 1][k] + dp[j - 1][k]) % 1000000007;\n\t\t\t\t\t} else if (k == n - 1) {\n\t\t\t\t\t\ttemp[j][k] = (dp[j][k] + dp[j + 1][k] + dp[j - 1][k]) % 1000000007;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttemp[j][k] = (dp[j][k] + dp[j + 1][k] + dp[j - 1][k] + dp[j\n",
        "\tint findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < maxMove; i++) {\n\t\t\tint[][] dp2 = new int[m][n];\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else if (j == m - 1) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else if (k == 0) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else if (k == n - 1) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp2[j][k] = dp[j - 1][k] + dp[j + 1][k] + dp[j][k - 1] + dp[j][k + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp2;\n\t\t}\n\t\treturn dp[startRow][startColumn] % 1000000007;\n\t}\n}\n",
        "\tstatic int countPaths(int m, int n, int maxMove, int startRow, int startColumn){\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\treturn countPaths(m, n, maxMove, startRow, startColumn, dp);\n\t}\n\tpublic static int countPaths(int m, int n, int maxMove, int startRow, int startColumn, int[][] dp){\n\t\tif(startRow < 0 || startRow >= m || startColumn < 0 || startColumn >= n){\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[startRow][startColumn] != -1){\n\t\t\treturn dp[startRow][startColumn];\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i <= maxMove; i++){\n\t\t\tcount += countPaths(m, n, maxMove, startRow + i, startColumn, dp) + countPaths(m, n, maxMove, startRow, startColumn + i, dp);\n\t\t}\n\t\tdp[startRow][startColumn] = count % 1000000007;\n\t\treturn dp[startRow][startColumn];\n\t}\n}\n",
        "\tint findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i == 0){\n\t\t\t\t\tdp[i][j] = (dp[i][j] + dp[i][j - 1]) % 1000000007;\n\t\t\t\t}\n\t\t\t\tif(j == 0){\n\t\t\t\t\tdp[i][j] = (dp[i][j] + dp[i - 1][j]) % 1000000007;\n\t\t\t\t}\n\t\t\t\tif(i > 0 && j > 0){\n\t\t\t\t\tdp[i][j] = (dp[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]) % 1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == startRow && j == startColumn){\n\t\t\t\t\tans = (ans + dp[i][j]) % 1000000007;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(i == 0){\n\t\t\t\t\tdp[i][j] += dp[i][j - 1];\n\t\t\t\t}\n\t\t\t\tif(j == 0){\n\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t}\n\t\t\t\tif(i > 0 && j > 0){\n\t\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1];\n\t\t\t\t}\n\t\t\t\tdp[i][j] %= 1000000007;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == startRow && j == startColumn){\n\t\t\t\t\tres += dp[i][j];\n\t\t\t\t}\n\t\t\t\tif(i > startRow && j > startColumn){\n\t\t\t\t\tres += dp[i][j];\n\t\t\t\t}\n\t\t\t\tres %= 1000000007;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int countPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\treturn helper(m, n, maxMove, startRow, startColumn, dp);\n\t}\n\tpublic static int helper(int m, int n, int maxMove, int row, int column, int[][] dp){\n\t\tif(row < 0 || row >= m || column < 0 || column >= n){\n\t\t\treturn 0;\n\t\t}\n\t\tif(dp[row][column] != -1){\n\t\t\treturn dp[row][column];\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i <= maxMove; i++){\n\t\t\tcount += helper(m, n, maxMove, row - i, column - i, dp);\n\t\t\tcount += helper(m, n, maxMove, row - i, column + i, dp);\n\t\t\tcount += helper(m, n, maxMove, row + i, column - i, dp);\n\t\t\tcount += helper(m, n, maxMove, row + i, column + i, dp);\n\t\t}\n\t\tdp[row][column] = count % 1000000007;\n\t\treturn dp[row][column];\n\t}\n}\n",
        "\tstatic int countPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t} else if (i == 0) {\n\t\t\t\t\tdp[i][j] = dp[i][j - 1];\n\t\t\t\t} else if (j == 0) {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i + j <= maxMove) {\n\t\t\t\t\tans += dp[m - 1][n - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans % 1000000007;\n\t}\n}\n",
        "\tstatic int move(int m, int n, int maxMove, int startRow, int startColumn){\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1] % 1000000007;\n\t}\n}\n",
        "\tstatic int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < maxMove; i++) {\n\t\t\tint[][] dp2 = new int[m][n];\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else if (j == m - 1) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else if (k == 0) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else if (k == n - 1) {\n\t\t\t\t\t\tdp2[j][k] = dp[j][k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp2[j][k] = (dp[j - 1][k] + dp[j + 1][k] + dp[j][k - 1] + dp[j][k + 1]) % 1000000007;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp2;\n\t\t}\n\t\treturn dp[startRow][startColumn];\n\t}\n}\n",
        "\tint findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n\t\tint[][] dp = new int[m][n];\n\t\tdp[startRow][startColumn] = 1;\n\t\tfor (int i = 0; i < maxMove; i++) {\n\t\t\tint[][] dp2 = new int[m][n];\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (j - 1 >= 0) {\n\t\t\t\t\t\tdp2[j][k] += dp[j - 1][k];\n\t\t\t\t\t}\n\t\t\t\t\tif (j + 1 < m) {\n\t\t\t\t\t\tdp2[j][k] += dp[j + 1][k];\n\t\t\t\t\t}\n\t\t\t\t\tif (k - 1 >= 0) {\n\t\t\t\t\t\tdp2[j][k] += dp[j][k - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (k + 1 < n) {\n\t\t\t\t\t\tdp2[j][k] += dp[j][k + 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp = dp2;\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tans = (ans + dp[i][j]) % 1000000007;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2066",
    "source": "leetcode",
    "language": "java",
    "query": "Check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M). Check if there are two indices i and j such that : i != j- 0 <= i, j < arr.length- arr[i] == 2 * arr[j]",
    "snippets": [
        "\tstatic boolean checkIfExists(int[] arr){\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = 0; j < arr.length; j++){\n\t\t\t\tif(i != j && arr[i] == 2 * arr[j]){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean check(int[] arr){\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = 0; j < arr.length; j++){\n\t\t\t\tif(i != j && arr[i] == 2 * arr[j]){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean check(int[] arr){\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = 0; j < arr.length; j++){\n\t\t\t\tif(i != j && arr[i] == 2 * arr[j]){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean checkIfExistsDouble(int[] arr){\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = 0; j < arr.length; j++){\n\t\t\t\tif(i != j && arr[i] == 2 * arr[j]){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2067",
    "source": "leetcode",
    "language": "java",
    "query": "You want to change s to t. Changing the ith character of s to ithcharacter of t costs |s[i] - t[i].",
    "snippets": [
        "\tvoid change(String s, String t){\n\t\tint[] cost = new int[s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcost[i] = Math.abs(s.charAt(i) - t.charAt(i));\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < s.length(); j++){\n\t\t\t\tsum += cost[(i+j)%s.length()];\n\t\t\t}\n\t\t\tmin = Math.min(min, sum);\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n}\n",
        "\tvoid change(String s, String t){\n\t\tint[] cost = new int[s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcost[i] = Math.abs(s.charAt(i) - t.charAt(i));\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < cost.length; i++){\n\t\t\tmin = Math.min(min, cost[i]);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < cost.length; i++){\n\t\t\tsum += cost[i] - min;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n}\n",
        "\tvoid change(String s, String t){\n\t\tint[] cost = new int[s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcost[i] = Math.abs(s.charAt(i) - t.charAt(i));\n\t\t}\n\t\tint minCost = 0;\n\t\tfor(int i = 0; i < cost.length; i++){\n\t\t\tminCost += cost[i];\n\t\t}\n\t\tint[] dp = new int[minCost + 1];\n\t\tdp[0] = 0;\n\t\tfor(int i = 1; i < dp.length; i++){\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor(int j = 0; j < cost.length; j++){\n\t\t\t\tif(i - cost[j] >= 0){\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - cost[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[minCost]);\n\t}\n}\n",
        "\tint minCost(String s, String t) {\n\t\tint n = s.length();\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tdp[i][i+1] = Math.abs(s.charAt(i) - t.charAt(i+1));\n\t\t}\n\t\tfor(int len = 2; len < n; len++){\n\t\t\tfor(int i = 0; i < n-len; i++){\n\t\t\t\tdp[i][i+len] = Math.min(dp[i][i+len-1] + Math.abs(s.charAt(i+len) - t.charAt(i+len)), dp[i+1][i+len] + Math.abs(s.charAt(i+len) - t.charAt(i+len)));\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n-1];\n\t}\n}\n",
        "\tint minCost(String s, String t) {\n\t\tint n = s.length();\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tdp[i][i+1] = Math.abs(s.charAt(i) - t.charAt(i+1));\n\t\t}\n\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\tfor(int j = i+2; j < n; j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i+1][j] + Math.abs(s.charAt(i) - t.charAt(j)));\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j-1] + Math.abs(s.charAt(j) - t.charAt(i)));\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n-1];\n\t}\n}\n",
        "\tint minCost(String s, String t) {\n\t\tint n = s.length();\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tdp[i][i + 1] = Math.abs(s.charAt(i) - t.charAt(i + 1));\n\t\t}\n\t\tfor(int len = 2; len < n; len++){\n\t\t\tfor(int i = 0; i < n - len; i++){\n\t\t\t\tdp[i][i + len] = Math.min(dp[i][i + len - 1] + Math.abs(s.charAt(i + len) - t.charAt(i + len)), dp[i + 1][i + len] + Math.abs(s.charAt(i + len) - t.charAt(i + len - 1)));\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint minDistance(String s, String t) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\tint[][] dp = new int[m + 1][n + 1];\n\t\tfor (int i = 0; i <= m; i++) {\n\t\t\tdp[i][0] = i;\n\t\t}\n\t\tfor (int j = 0; j <= n; j++) {\n\t\t\tdp[0][j] = j;\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (s.charAt(i - 1) == t.charAt(j - 1)) {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j - 1];\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m][n];\n\t}\n}\n",
        "\tint minCost(String s, String t) {\n\t\tint n = s.length();\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tdp[i][i + 1] = Math.abs(s.charAt(i) - t.charAt(i + 1));\n\t\t}\n\t\tfor (int len = 2; len < n; len++) {\n\t\t\tfor (int i = 0; i < n - len; i++) {\n\t\t\t\tint j = i + len;\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\tfor (int k = i; k < j; k++) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] += Math.abs(s.charAt(i) - t.charAt(j));\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint minCost(String s, String t) {\n\t\tint len = s.length();\n\t\tint[][] dp = new int[len][len];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tfor(int j = i + 1; j < len; j++){\n\t\t\t\tdp[i][j] = Math.abs(s.charAt(i) - t.charAt(j));\n\t\t\t\tfor(int k = i; k < j; k++){\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][len - 1];\n\t}\n}\n",
        "\tint minDistance(String s, String t) {\n\t\tint[][] dp = new int[s.length() + 1][t.length() + 1];\n\t\tfor (int i = 0; i <= s.length(); i++) {\n\t\t\tfor (int j = 0; j <= t.length(); j++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tdp[i][j] = j;\n\t\t\t\t} else if (j == 0) {\n\t\t\t\t\tdp[i][j] = i;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j - 1] + (s.charAt(i - 1) == t.charAt(j - 1) ? 0 : 1),\n\t\t\t\t\t\t\tMath.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[s.length()][t.length()];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2068",
    "source": "leetcode",
    "language": "java",
    "query": "A path from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk] such that z0 = start and zk = end. Distance of a path is the sum of the weights on the edges of the path.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tGraph g = new Graph();\n\t\tg.addEdge(0, 1, 10);\n\t\tg.addEdge(0, 2, 20);\n\t\tg.addEdge(1, 2, 30);\n\t\tg.addEdge(1, 3, 40);\n\t\tg.addEdge(2, 3, 50);\n\t\tg.addEdge(2, 4, 60);\n\t\tg.addEdge(3, 4, 70);\n\t\tg.addEdge(3, 5, 80);\n\t\tg.addEdge(4, 5, 90);\n\t\tg.addEdge(4, 6, 100);\n\t\tg.addEdge(5, 6, 110);\n\t\tg.addEdge(5, 7, 120);\n\t\tg.addEdge(6, 7, 130);\n\t\tg.addEdge(6, 8, 140);\n\t\tg.addEdge(7, 8, 150);\n\t\tg.addEdge(7, 9, 160);\n\t\tg.addEdge(8, 9, 170);\n\t\tg.addEdge(8, 10, 180);\n\t\tg.addEdge(9, 10, 190);\n\t\tg.addEdge(9, 11, 200);\n\t\tg.addEdge(10, 11, 210);\n\t\tg.addEdge(10, 12, 220);\n\t\tg.addEdge(11, 12, 230);\n\t\tg.addEdge(11, 13, 240);\n\t\tg.addEdge(12, 13, 250);\n\t\tg.addEdge(12, 14, 260);\n\t\tg.addEdge(13, 14, 270);\n\t\tg.addEdge(13, 15, 280);\n\t\tg.addEdge(14, 15, 290);\n\t\tg.addEdge(14, 16, 300);\n\t\tg.addEdge(15, 16, 310);\n\t\tg.addEdge(15, 17, 320);\n\t\tg.addEdge(16, 17, 330);\n\t\tg.addEdge(16, 18, 340);\n\t\tg.\n",
        "\tstatic void main(String[] args){\n\t\tGraph g = new Graph();\n\t\tg.addEdge(0, 1, 10);\n\t\tg.addEdge(0, 2, 20);\n\t\tg.addEdge(1, 2, 30);\n\t\tg.addEdge(2, 3, 40);\n\t\tg.addEdge(3, 4, 50);\n\t\tg.addEdge(4, 5, 60);\n\t\tg.addEdge(5, 6, 70);\n\t\tg.addEdge(6, 7, 80);\n\t\tg.addEdge(7, 8, 90);\n\t\tg.addEdge(8, 9, 100);\n\t\tg.addEdge(9, 10, 110);\n\t\tg.addEdge(10, 11, 120);\n\t\tg.addEdge(11, 12, 130);\n\t\tg.addEdge(12, 13, 140);\n\t\tg.addEdge(13, 14, 150);\n\t\tg.addEdge(14, 15, 160);\n\t\tg.addEdge(15, 16, 170);\n\t\tg.addEdge(16, 17, 180);\n\t\tg.addEdge(17, 18, 190);\n\t\tg.addEdge(18, 19, 200);\n\t\tg.addEdge(19, 20, 210);\n\t\tg.addEdge(20, 21, 220);\n\t\tg.addEdge(21, 22, 230);\n\t\tg.addEdge(22, 23, 240);\n\t\tg.addEdge(23, 24, 250);\n\t\tg.addEdge(24, 25, 260);\n\t\tg.addEdge(25, 26, 270);\n\t\tg.addEdge(26, 27, 280);\n\t\tg.addEdge(27, 28, 290);\n\t\tg.addEdge(28, 29, 300);\n\t\tg.addEdge(29, 30, 310);\n\t\tg.addEdge(30, 31, 320);\n\t\tg.addEdge(31, 32, 330);\n\t\tg.addEdge(32, 33, 340);\n\t\tg.\n",
        "\tstatic void main(String[] args){\n\t\tGraph g = new Graph();\n\t\tg.addEdge(0, 1, 10);\n\t\tg.addEdge(0, 2, 6);\n\t\tg.addEdge(0, 3, 5);\n\t\tg.addEdge(1, 3, 15);\n\t\tg.addEdge(2, 3, 4);\n\t\tg.addEdge(2, 4, 12);\n\t\tg.addEdge(3, 4, 9);\n\t\tg.addEdge(3, 5, 4);\n\t\tg.addEdge(4, 5, 7);\n\t\tg.addEdge(4, 6, 3);\n\t\tg.addEdge(5, 6, 8);\n\t\tg.addEdge(5, 7, 11);\n\t\tg.addEdge(6, 7, 2);\n\t\tg.addEdge(6, 8, 6);\n\t\tg.addEdge(7, 8, 7);\n\t\tg.addEdge(7, 9, 1);\n\t\tg.addEdge(8, 9, 10);\n\t\tg.addEdge(8, 10, 5);\n\t\tg.addEdge(9, 10, 4);\n\t\tg.addEdge(9, 11, 15);\n\t\tg.addEdge(10, 11, 3);\n\t\tg.addEdge(10, 12, 6);\n\t\tg.addEdge(11, 12, 9);\n\t\tg.addEdge(11, 13, 2);\n\t\tg.addEdge(12, 13, 6);\n\t\tg.addEdge(12, 14, 2);\n\t\tg.addEdge(13, 14, 1);\n\t\tg.addEdge(13, 15, 10);\n\t\tg.addEdge(14, 15, 5);\n\t\tg.addEdge(14, 16, 1);\n\t\tg.addEdge(15, 16, 15);\n\t\tg.addEdge(15, 17, 10);\n\t\tg.addEdge(16, 17, 5);\n\t\tg.addEdge(16, 18, 1);\n\t\tg.\n",
        "\tstatic void main(String[] args){\n\t\tGraph g = new Graph();\n\t\tg.addEdge(0, 1, 10);\n\t\tg.addEdge(0, 2, 10);\n\t\tg.addEdge(1, 2, 10);\n\t\tg.addEdge(1, 3, 10);\n\t\tg.addEdge(2, 3, 10);\n\t\tg.addEdge(2, 4, 10);\n\t\tg.addEdge(3, 4, 10);\n\t\tg.addEdge(3, 5, 10);\n\t\tg.addEdge(4, 5, 10);\n\t\tg.addEdge(4, 6, 10);\n\t\tg.addEdge(5, 6, 10);\n\t\tg.addEdge(5, 7, 10);\n\t\tg.addEdge(6, 7, 10);\n\t\tg.addEdge(6, 8, 10);\n\t\tg.addEdge(7, 8, 10);\n\t\tg.addEdge(7, 9, 10);\n\t\tg.addEdge(8, 9, 10);\n\t\tg.addEdge(8, 10, 10);\n\t\tg.addEdge(9, 10, 10);\n\t\tg.addEdge(9, 11, 10);\n\t\tg.addEdge(10, 11, 10);\n\t\tg.addEdge(10, 12, 10);\n\t\tg.addEdge(11, 12, 10);\n\t\tg.addEdge(11, 13, 10);\n\t\tg.addEdge(12, 13, 10);\n\t\tg.addEdge(12, 14, 10);\n\t\tg.addEdge(13, 14, 10);\n\t\tg.addEdge(13, 15, 10);\n\t\tg.addEdge(14, 15, 10);\n\t\tg.addEdge(14, 16, 10);\n\t\tg.addEdge(15, 16, 10);\n\t\tg.addEdge(15, 17, 10);\n\t\tg.addEdge(16, 17, 10);\n\t\tg.addEdge(16, 18, 10);\n\t\tg.\n"
    ],
    "results": 10
},{
    "id": "2069",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. Test cases are generated so that the answer will be less than or equal to 2 * 109.",
    "snippets": [
        "\tint uniquePaths(int m, int n) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tdp[i][0] = 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[0][i] = 1;\n\t\t}\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n",
        "\tint uniquePaths(int m, int n) {\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 || j == 0){\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2070",
    "source": "leetcode",
    "language": "java",
    "query": "Given a collection of candidate numbers and a target number, find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.",
    "snippets": [
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(candidates == null || candidates.length == 0) return result;\n\t\tArrays.sort(candidates);\n\t\tList<Integer> path = new ArrayList<Integer>();\n\t\tdfs(candidates, target, 0, path, result);\n\t\treturn result;\n\t}\n\tpublic void dfs(int[] candidates, int target, int index, List<Integer> path, List<List<Integer>> result){\n\t\tif(target == 0){\n\t\t\tresult.add(new ArrayList<Integer>(path));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = index; i < candidates.length; i++){\n\t\t\tif(i > index && candidates[i] == candidates[i-1]) continue;\n\t\t\tif(candidates[i] > target) break;\n\t\t\tpath.add(candidates[i]);\n\t\t\tdfs(candidates, target - candidates[i], i + 1, path, result);\n\t\t\tpath.remove(path.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(candidates == null || candidates.length == 0)\n\t\t\treturn result;\n\t\tArrays.sort(candidates);\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tdfs(candidates, target, 0, list, result);\n\t\treturn result;\n\t}\n\tpublic void dfs(int[] candidates, int target, int index, List<Integer> list, List<List<Integer>> result){\n\t\tif(target == 0){\n\t\t\tresult.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = index; i < candidates.length; i++){\n\t\t\tif(i > index && candidates[i] == candidates[i-1])\n\t\t\t\tcontinue;\n\t\t\tif(candidates[i] > target)\n\t\t\t\tbreak;\n\t\t\tlist.add(candidates[i]);\n\t\t\tdfs(candidates, target - candidates[i], i + 1, list, result);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(candidates == null || candidates.length == 0) return result;\n\t\tArrays.sort(candidates);\n\t\thelper(candidates, target, 0, new ArrayList<Integer>(), result);\n\t\treturn result;\n\t}\n\tpublic void helper(int[] candidates, int target, int start, List<Integer> list, List<List<Integer>> result){\n\t\tif(target == 0){\n\t\t\tresult.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < candidates.length; i++){\n\t\t\tif(i > start && candidates[i] == candidates[i-1]) continue;\n\t\t\tif(candidates[i] > target) break;\n\t\t\tlist.add(candidates[i]);\n\t\t\thelper(candidates, target - candidates[i], i + 1, list, result);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(candidates == null || candidates.length == 0) return res;\n\t\tArrays.sort(candidates);\n\t\thelper(res, new ArrayList<>(), candidates, target, 0);\n\t\treturn res;\n\t}\n\tpublic void helper(List<List<Integer>> res, List<Integer> list, int[] candidates, int target, int start){\n\t\tif(target == 0){\n\t\t\tres.add(new ArrayList<>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < candidates.length; i++){\n\t\t\tif(i > start && candidates[i] == candidates[i-1]) continue;\n\t\t\tif(candidates[i] > target) break;\n\t\t\tlist.add(candidates[i]);\n\t\t\thelper(res, list, candidates, target - candidates[i], i + 1);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\t\tif(candidates == null || candidates.length == 0) return res;\n\t\tArrays.sort(candidates);\n\t\tdfs(candidates, target, 0, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tprivate void dfs(int[] candidates, int target, int start, List<Integer> list, List<List<Integer>> res){\n\t\tif(target == 0){\n\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < candidates.length; i++){\n\t\t\tif(i > start && candidates[i] == candidates[i-1]) continue;\n\t\t\tif(candidates[i] > target) break;\n\t\t\tlist.add(candidates[i]);\n\t\t\tdfs(candidates, target - candidates[i], i + 1, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\t\tif(candidates == null || candidates.length == 0) return res;\n\t\tArrays.sort(candidates);\n\t\thelper(candidates, target, 0, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] candidates, int target, int start, List<Integer> list, List<List<Integer>> res){\n\t\tif(target == 0){\n\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < candidates.length; i++){\n\t\t\tif(i > start && candidates[i] == candidates[i-1]) continue;\n\t\t\tif(candidates[i] > target) break;\n\t\t\tlist.add(candidates[i]);\n\t\t\thelper(candidates, target - candidates[i], i + 1, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(candidates == null || candidates.length == 0) return res;\n\t\tArrays.sort(candidates);\n\t\thelper(candidates, target, 0, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] candidates, int target, int start, List<Integer> list, List<List<Integer>> res){\n\t\tif(target == 0){\n\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < candidates.length; i++){\n\t\t\tif(i > start && candidates[i] == candidates[i-1]) continue;\n\t\t\tif(candidates[i] > target) break;\n\t\t\tlist.add(candidates[i]);\n\t\t\thelper(candidates, target - candidates[i], i + 1, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> combinationSum2(int[] candidates, int target) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(candidates == null || candidates.length == 0) return res;\n\t\tArrays.sort(candidates);\n\t\tbacktrack(candidates, target, 0, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tpublic void backtrack(int[] candidates, int target, int start, List<Integer> list, List<List<Integer>> res){\n\t\tif(target == 0){\n\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < candidates.length; i++){\n\t\t\tif(i > start && candidates[i] == candidates[i-1]) continue;\n\t\t\tif(candidates[i] > target) break;\n\t\t\tlist.add(candidates[i]);\n\t\t\tbacktrack(candidates, target - candidates[i], i+1, list, res);\n\t\t\tlist.remove(list.size()-1);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2071",
    "source": "leetcode",
    "language": "java",
    "query": "A target index is an index i such that nums[i] == target. Return a list of the target indices of nums after sorting nums in non-decreasing order.",
    "snippets": [
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile(left <= right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tres.add(mid);\n\t\t\t\tleft = mid + 1;\n\t\t\t}else if(nums[mid] < target){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\tint leftIndex = res.get(0);\n\t\tint rightIndex = res.get(res.size() - 1);\n\t\tint leftIndex2 = leftIndex;\n\t\tint rightIndex2 = rightIndex;\n\t\twhile(leftIndex2 >= 0 && nums[leftIndex2] == target){\n\t\t\tleftIndex2--;\n\t\t}\n\t\twhile(rightIndex2 < nums.length && nums[rightIndex2] == target){\n\t\t\trightIndex2++;\n\t\t}\n\t\tres.clear();\n\t\tres.add(leftIndex2 + 1);\n\t\tres.add(rightIndex2 - 1);\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tright = mid;\n\t\t\t}else if(nums[mid] < target){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\tif(nums[left] != target) return res;\n\t\tres.add(left);\n\t\tleft = 0;\n\t\tright = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else if(nums[mid] < target){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\tres.add(left - 1);\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint mid = 0;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tbreak;\n\t\t\t}else if(nums[mid] > target){\n\t\t\t\tright = mid - 1;\n\t\t\t}else{\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif(nums[mid] != target){\n\t\t\treturn list;\n\t\t}\n\t\tint leftIndex = mid;\n\t\twhile(leftIndex >= 0 && nums[leftIndex] == target){\n\t\t\tleftIndex--;\n\t\t}\n\t\tint rightIndex = mid;\n\t\twhile(rightIndex < nums.length && nums[rightIndex] == target){\n\t\t\trightIndex++;\n\t\t}\n\t\tlist.add(leftIndex + 1);\n\t\tlist.add(rightIndex - 1);\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\tint mid = 0;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tbreak;\n\t\t\t}else if(nums[mid] > target){\n\t\t\t\tright = mid - 1;\n\t\t\t}else{\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif(left > right){\n\t\t\treturn list;\n\t\t}\n\t\tint leftIndex = mid;\n\t\twhile(leftIndex >= 0 && nums[leftIndex] == target){\n\t\t\tleftIndex--;\n\t\t}\n\t\tleftIndex++;\n\t\tint rightIndex = mid;\n\t\twhile(rightIndex < nums.length && nums[rightIndex] == target){\n\t\t\trightIndex++;\n\t\t}\n\t\trightIndex--;\n\t\tlist.add(leftIndex);\n\t\tlist.add(rightIndex);\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tint left = 0, right = nums.length - 1;\n\t\twhile(left <= right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tres.add(mid);\n\t\t\t\tleft = mid + 1;\n\t\t\t}else if(nums[mid] < target){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tint left = 0, right = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] < target) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tif(nums[left] != target) return res;\n\t\tres.add(left);\n\t\tright = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = (left + right) / 2 + 1;\n\t\t\tif(nums[mid] > target) right = mid - 1;\n\t\t\telse left = mid;\n\t\t}\n\t\tres.add(right);\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tint left = 0, right = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(nums[mid] < target) left = mid + 1;\n\t\t\telse right = mid;\n\t\t}\n\t\tif(nums[left] != target) return res;\n\t\tres.add(left);\n\t\tright = nums.length - 1;\n\t\twhile(left < right){\n\t\t\tint mid = left + (right - left) / 2 + 1;\n\t\t\tif(nums[mid] > target) right = mid - 1;\n\t\t\telse left = mid;\n\t\t}\n\t\tres.add(right);\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0)\n\t\t\treturn list;\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile(left <= right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tlist.add(mid);\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse if(nums[mid] < target){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> searchRange(int[] nums, int target) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile(left <= right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] == target){\n\t\t\t\tres.add(mid);\n\t\t\t\tleft = mid + 1;\n\t\t\t}else if(nums[mid] < target){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2072",
    "source": "leetcode",
    "language": "java",
    "query": "Given two binary strings a and b, return their sum as a binary string.",
    "snippets": [
        "\tString addBinary(String a, String b) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tint i = a.length() - 1;\n\t\tint j = b.length() - 1;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint sum = carry;\n\t\t\tif (i >= 0) {\n\t\t\t\tsum += a.charAt(i) - '0';\n\t\t\t}\n\t\t\tif (j >= 0) {\n\t\t\t\tsum += b.charAt(j) - '0';\n\t\t\t}\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\tif (carry != 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tint i = a.length() - 1;\n\t\tint j = b.length() - 1;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint sum = carry;\n\t\t\tif (i >= 0) {\n\t\t\t\tsum += a.charAt(i--) - '0';\n\t\t\t}\n\t\t\tif (j >= 0) {\n\t\t\t\tsum += b.charAt(j--) - '0';\n\t\t\t}\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t}\n\t\tif (carry != 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tint i = a.length() - 1;\n\t\tint j = b.length() - 1;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint ai = i >= 0 ? a.charAt(i) - '0' : 0;\n\t\t\tint bj = j >= 0 ? b.charAt(j) - '0' : 0;\n\t\t\tint sum = ai + bj + carry;\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\tif (carry > 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tint i = a.length() - 1;\n\t\tint j = b.length() - 1;\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint ai = i >= 0 ? a.charAt(i) - '0' : 0;\n\t\t\tint bi = j >= 0 ? b.charAt(j) - '0' : 0;\n\t\t\tint sum = ai + bi + carry;\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\tif (carry == 1) {\n\t\t\tsb.append(1);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tint aLen = a.length();\n\t\tint bLen = b.length();\n\t\tint maxLen = Math.max(aLen, bLen);\n\t\tint minLen = Math.min(aLen, bLen);\n\t\tint carry = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < maxLen; i++){\n\t\t\tint ai = i < aLen ? a.charAt(aLen - 1 - i) - '0' : 0;\n\t\t\tint bi = i < bLen ? b.charAt(bLen - 1 - i) - '0' : 0;\n\t\t\tint sum = ai + bi + carry;\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t}\n\t\tif(carry > 0){\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tint aLen = a.length();\n\t\tint bLen = b.length();\n\t\tint maxLen = Math.max(aLen, bLen);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < maxLen; i++){\n\t\t\tint ai = i < aLen ? a.charAt(aLen - 1 - i) - '0' : 0;\n\t\t\tint bi = i < bLen ? b.charAt(bLen - 1 - i) - '0' : 0;\n\t\t\tint sum = ai + bi + carry;\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t}\n\t\tif(carry > 0) sb.append(carry);\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tint i = a.length() - 1, j = b.length() - 1, carry = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint sum = carry;\n\t\t\tif (i >= 0) sum += a.charAt(i--) - '0';\n\t\t\tif (j >= 0) sum += b.charAt(j--) - '0';\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t}\n\t\tif (carry != 0) sb.append(carry);\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tint lenA = a.length();\n\t\tint lenB = b.length();\n\t\tint len = Math.max(lenA, lenB);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint carry = 0;\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tint ai = i < lenA ? a.charAt(lenA - 1 - i) - '0' : 0;\n\t\t\tint bi = i < lenB ? b.charAt(lenB - 1 - i) - '0' : 0;\n\t\t\tint sum = ai + bi + carry;\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t}\n\t\tif(carry > 0) sb.append(carry);\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString addBinary(String a, String b) {\n\t\tint i = a.length() - 1;\n\t\tint j = b.length() - 1;\n\t\tint carry = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (i >= 0 || j >= 0) {\n\t\t\tint sum = carry;\n\t\t\tif (i >= 0) {\n\t\t\t\tsum += a.charAt(i) - '0';\n\t\t\t}\n\t\t\tif (j >= 0) {\n\t\t\t\tsum += b.charAt(j) - '0';\n\t\t\t}\n\t\t\tsb.append(sum % 2);\n\t\t\tcarry = sum / 2;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\tif (carry != 0) {\n\t\t\tsb.append(carry);\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2073",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
    "snippets": [
        "\tList<List<Integer>> permute(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, 0, res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int start, List<List<Integer>> res){\n\t\tif(start == nums.length){\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t}\n\t\t\tres.add(list);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tswap(nums, start, i);\n\t\t\thelper(nums, start + 1, res);\n\t\t\tswap(nums, start, i);\n\t\t}\n\t}\n\tpublic void swap(int[] nums, int i, int j){\n\t\tint temp = nums[i];\n\t\tnums[i] = nums[j];\n\t\tnums[j] = temp;\n\t}\n}\n",
        "\tList<List<Integer>> permute(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, List<Integer> list, List<List<Integer>> res){\n\t\tif(list.size() == nums.length){\n\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(list.contains(nums[i])) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> permute(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, res, new ArrayList<>());\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, List<List<Integer>> res, List<Integer> list){\n\t\tif(list.size() == nums.length){\n\t\t\tres.add(new ArrayList<>(list));\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(list.contains(nums[i])) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, res, list);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> permute(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(res, new ArrayList<>(), nums);\n\t\treturn res;\n\t}\n\tpublic void helper(List<List<Integer>> res, List<Integer> cur, int[] nums){\n\t\tif(cur.size() == nums.length){\n\t\t\tres.add(new ArrayList<>(cur));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(cur.contains(nums[i])) continue;\n\t\t\tcur.add(nums[i]);\n\t\t\thelper(res, cur, nums);\n\t\t\tcur.remove(cur.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> permute(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return result;\n\t\thelper(result, new ArrayList<>(), nums);\n\t\treturn result;\n\t}\n\tpublic void helper(List<List<Integer>> result, List<Integer> list, int[] nums){\n\t\tif(list.size() == nums.length){\n\t\t\tresult.add(new ArrayList<>(list));\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(list.contains(nums[i])) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(result, list, nums);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> permute(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0) return result;\n\t\thelper(nums, 0, result);\n\t\treturn result;\n\t}\n\tpublic void helper(int[] nums, int index, List<List<Integer>> result){\n\t\tif(index == nums.length){\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t}\n\t\t\tresult.add(list);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tswap(nums, index, i);\n\t\t\thelper(nums, index + 1, result);\n\t\t\tswap(nums, index, i);\n\t\t}\n\t}\n\tpublic void swap(int[] nums, int i, int j){\n\t\tint temp = nums[i];\n\t\tnums[i] = nums[j];\n\t\tnums[j] = temp;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2074",
    "source": "leetcode",
    "language": "java",
    "query": "A binary tree is named Even-Odd if it meets the following conditions. For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right)",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tTreeNode root = new TreeNode(1);\n\t\troot.left = new TreeNode(2);\n\t\troot.right = new TreeNode(3);\n\t\troot.left.left = new TreeNode(4);\n\t\troot.left.right = new TreeNode(5);\n\t\troot.right.left = new TreeNode(6);\n\t\troot.right.right = new TreeNode(7);\n\t\troot.left.left.left = new TreeNode(8);\n\t\troot.left.left.right = new TreeNode(9);\n\t\troot.left.right.left = new TreeNode(10);\n\t\troot.left.right.right = new TreeNode(11);\n\t\troot.right.left.left = new TreeNode(12);\n\t\troot.right.left.right = new TreeNode(13);\n\t\troot.right.right.left = new TreeNode(14);\n\t\troot.right.right.right = new TreeNode(15);\n\t\troot.left.left.left.left = new TreeNode(16);\n\t\troot.left.left.left.right = new TreeNode(17);\n\t\troot.left.left.right.left = new TreeNode(18);\n\t\troot.left.left.right.right = new TreeNode(19);\n\t\troot.left.right.left.left = new TreeNode(20);\n\t\troot.left.right.left.right = new TreeNode(21);\n\t\troot.left.right.right.left = new TreeNode(22);\n\t\troot.left.right.right.right = new TreeNode(23);\n\t\troot.right.left.left.left = new TreeNode(24);\n\t\troot.right.left.left.right = new TreeNode(25);\n\t\troot.right.left.right.left = new TreeNode(26);\n\t\troot.right.left.right.right = new TreeNode(27);\n\t\troot.right.right.left.left = new TreeNode(28);\n\t\troot.right.right\n",
        "\tstatic boolean isEvenOdd(TreeNode root){\n\t\tif(root==null) return true;\n\t\tif(root.left==null && root.right==null) return true;\n\t\tif(root.left==null){\n\t\t\tif(root.right.val%2==0) return false;\n\t\t\treturn isEvenOdd(root.right);\n\t\t}\n\t\tif(root.right==null){\n\t\t\tif(root.left.val%2==0) return false;\n\t\t\treturn isEvenOdd(root.left);\n\t\t}\n\t\tif(root.left.val%2==0){\n\t\t\tif(root.right.val%2==0) return false;\n\t\t\treturn isEvenOdd(root.right);\n\t\t}\n\t\tif(root.right.val%2==0){\n\t\t\tif(root.left.val%2==0) return false;\n\t\t\treturn isEvenOdd(root.left);\n\t\t}\n\t\tif(root.left.val>root.right.val) return false;\n\t\treturn isEvenOdd(root.left) && isEvenOdd(root.right);\n\t}\n}\n",
        "\tstatic boolean isEvenOdd(TreeNode root){\n\t\tif(root==null) return true;\n\t\tif(root.left==null && root.right==null) return true;\n\t\tif(root.left==null) return isEvenOdd(root.right) && root.val%2==1;\n\t\tif(root.right==null) return isEvenOdd(root.left) && root.val%2==0;\n\t\treturn isEvenOdd(root.left) && isEvenOdd(root.right) && root.val%2==0;\n\t}\n}\n",
        "\tboolean isEvenOdd(TreeNode root){\n\t\tif(root==null) return true;\n\t\tif(root.left==null && root.right==null) return true;\n\t\tif(root.left==null) return isEvenOdd(root.right) && root.val%2==1;\n\t\tif(root.right==null) return isEvenOdd(root.left) && root.val%2==0;\n\t\treturn isEvenOdd(root.left) && isEvenOdd(root.right) && root.val%2==0;\n\t}\n}\n",
        "\tstatic boolean isEvenOdd(TreeNode root){\n\t\tif(root == null) return true;\n\t\tif(root.left == null && root.right == null) return true;\n\t\tif(root.left == null) return root.val % 2 == 1 && isEvenOdd(root.right);\n\t\tif(root.right == null) return root.val % 2 == 0 && isEvenOdd(root.left);\n\t\treturn root.val % 2 == 1 && isEvenOdd(root.left) && isEvenOdd(root.right);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2075",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integers startValue and target, return the minimum number of operations needed to display target on the calculator.",
    "snippets": [
        "\tint minOperations(int startValue, int target) {\n\t\tint count = 0;\n\t\twhile(startValue != target){\n\t\t\tif(startValue < target){\n\t\t\t\tstartValue = startValue * 2;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartValue = startValue / 2;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int startValue, int target) {\n\t\tint count = 0;\n\t\twhile(startValue != target){\n\t\t\tif(startValue < target){\n\t\t\t\tstartValue += startValue;\n\t\t\t}else{\n\t\t\t\tstartValue -= startValue;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int startValue, int target) {\n\t\tint count = 0;\n\t\twhile(startValue != target){\n\t\t\tif(startValue < target){\n\t\t\t\tstartValue += startValue;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartValue -= startValue;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int startValue, int target) {\n\t\tint count = 0;\n\t\twhile(startValue != target){\n\t\t\tif(startValue < target){\n\t\t\t\tstartValue += 5;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartValue -= 1;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int startValue, int target) {\n\t\tint count = 0;\n\t\twhile(startValue != target){\n\t\t\tif(startValue < target){\n\t\t\t\tstartValue += startValue;\n\t\t\t}else{\n\t\t\t\tstartValue /= 2;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int startValue, int target) {\n\t\tint count = 0;\n\t\twhile(startValue != target){\n\t\t\tif(startValue > target){\n\t\t\t\tstartValue -= 9;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstartValue += 6;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int startValue, int target) {\n\t\tint count = 0;\n\t\twhile(startValue < target){\n\t\t\tstartValue *= 2;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2076",
    "source": "leetcode",
    "language": "java",
    "query": "A distinct string is a string that is present only once in an array. Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string \"\".",
    "snippets": [
        "\tString kthDistinct(String[] arr, int k) {\n\t\tSet<String> set = new HashSet<String>();\n\t\tfor(String s: arr){\n\t\t\tset.add(s);\n\t\t}\n\t\tint i = 0;\n\t\tfor(String s: set){\n\t\t\tif(i == k){\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString kthDistinct(String[] arr, int k){\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(String s : arr){\n\t\t\tif(map.containsKey(s)){\n\t\t\t\tmap.put(s, map.get(s)+1);\n\t\t\t}else{\n\t\t\t\tmap.put(s, 1);\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(String s : map.keySet()){\n\t\t\tif(map.get(s) == 1){\n\t\t\t\tcount++;\n\t\t\t\tif(count == k){\n\t\t\t\t\treturn s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString kthDistinct(String[] arr, int k) {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tfor(String s: arr){\n\t\t\tset.add(s);\n\t\t}\n\t\tint i = 0;\n\t\tfor(String s: set){\n\t\t\tif(i == k){\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString kthDistinct(String[] arr, int k) {\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tfor(String s: arr){\n\t\t\tset.add(s);\n\t\t}\n\t\tString[] arr2 = new String[set.size()];\n\t\tint i = 0;\n\t\tfor(String s: set){\n\t\t\tarr2[i] = s;\n\t\t\ti++;\n\t\t}\n\t\treturn arr2[k-1];\n\t}\n}\n",
        "\tString kthDistinct(String[] arr, int k) {\n\t\tif(arr.length<k) return \"\";\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tfor(String s:arr){\n\t\t\tset.add(s);\n\t\t}\n\t\tint i=0;\n\t\tfor(String s:set){\n\t\t\tif(i==k-1) return s;\n\t\t\ti++;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tstatic String kthDistinct(String[] arr, int k){\n\t\tHashSet<String> set = new HashSet<String>();\n\t\tfor(String s: arr){\n\t\t\tset.add(s);\n\t\t}\n\t\tString[] arr2 = new String[set.size()];\n\t\tint i = 0;\n\t\tfor(String s: set){\n\t\t\tarr2[i] = s;\n\t\t\ti++;\n\t\t}\n\t\treturn arr2[k-1];\n\t}\n}\n",
        "\tString kthDistinct(String[] arr, int k){\n\t\tif(arr.length<k) return \"\";\n\t\tSet<String> set = new HashSet<String>();\n\t\tfor(String s:arr){\n\t\t\tset.add(s);\n\t\t}\n\t\tint i=0;\n\t\tfor(String s:set){\n\t\t\tif(i==k-1) return s;\n\t\t\ti++;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString kthDistinct(String[] arr, int k){\n\t\tif(arr.length==0||k>arr.length) return \"\";\n\t\tHashSet<String> set=new HashSet<String>();\n\t\tfor(String s:arr){\n\t\t\tset.add(s);\n\t\t}\n\t\tint i=0;\n\t\tfor(String s:set){\n\t\t\tif(i==k-1) return s;\n\t\t\ti++;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2077",
    "source": "leetcode",
    "language": "java",
    "query": "There is a bi-directional graph with n vertices. The edges in the graph are represented as a 2D integer array edges. You want to determine if there is a valid path from source to destination.",
    "snippets": [
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tint[] visited = new int[edges.length];\n\t\treturn isValidPath(edges, source, destination, visited);\n\t}\n\t\n\tpublic static boolean isValidPath(int[][] edges, int source, int destination, int[] visited) {\n\t\tif(source == destination) {\n\t\t\treturn true;\n\t\t}\n\t\tvisited[source] = 1;\n\t\tfor(int[] edge : edges) {\n\t\t\tif(edge[0] == source && visited[edge[1]] == 0) {\n\t\t\t\tif(isValidPath(edges, edge[1], destination, visited)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tint n = edges.length;\n\t\tboolean[] visited = new boolean[n];\n\t\tQueue<Integer> queue = new LinkedList<>();\n\t\tqueue.add(source);\n\t\tvisited[source] = true;\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint curr = queue.poll();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (edges[curr][i] == 1 && !visited[i]) {\n\t\t\t\t\tqueue.add(i);\n\t\t\t\t\tvisited[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn visited[destination];\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination){\n\t\tif(edges == null || edges.length == 0){\n\t\t\treturn false;\n\t\t}\n\t\tint n = edges.length;\n\t\tboolean[] visited = new boolean[n];\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.offer(source);\n\t\tvisited[source] = true;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint curr = queue.poll();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(edges[curr][i] == 1 && !visited[i]){\n\t\t\t\t\tqueue.offer(i);\n\t\t\t\t\tvisited[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn visited[destination];\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tif(source == destination)\n\t\t\treturn true;\n\t\tint[] visited = new int[edges.length];\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.add(source);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint curr = queue.poll();\n\t\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\t\tif(edges[curr][i] == 1 && visited[i] == 0){\n\t\t\t\t\tvisited[i] = 1;\n\t\t\t\t\tif(i == destination)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tqueue.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tif(edges == null || edges.length == 0) return false;\n\t\tint n = edges.length;\n\t\tboolean[] visited = new boolean[n];\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.offer(source);\n\t\tvisited[source] = true;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\t\tif(edges[cur][i] == 1 && !visited[i]){\n\t\t\t\t\tqueue.offer(i);\n\t\t\t\t\tvisited[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn visited[destination];\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tif(source == destination)\n\t\t\treturn true;\n\t\tint[] visited = new int[edges.length];\n\t\treturn isValidPath(edges, source, destination, visited);\n\t}\n\tprivate static boolean isValidPath(int[][] edges, int source, int destination, int[] visited) {\n\t\tvisited[source] = 1;\n\t\tfor(int[] edge : edges) {\n\t\t\tif(edge[0] == source) {\n\t\t\t\tif(edge[1] == destination)\n\t\t\t\t\treturn true;\n\t\t\t\tif(visited[edge[1]] == 0 && isValidPath(edges, edge[1], destination, visited))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\t// Write your code here.\n\t\tint n = edges.length;\n\t\tint[] visited = new int[n];\n\t\treturn isValidPath(edges, source, destination, visited);\n\t}\n\tpublic static boolean isValidPath(int[][] edges, int source, int destination, int[] visited) {\n\t\tif (source == destination) {\n\t\t\treturn true;\n\t\t}\n\t\tvisited[source] = 1;\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tif (visited[i] == 0 && isValidPath(edges, i, destination, visited)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tint n = edges.length;\n\t\tint[] visited = new int[n];\n\t\treturn isValidPath(edges, source, destination, visited);\n\t}\n\tpublic static boolean isValidPath(int[][] edges, int source, int destination, int[] visited) {\n\t\tif (source == destination) {\n\t\t\treturn true;\n\t\t}\n\t\tvisited[source] = 1;\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tif (edges[source][i] == 1 && visited[i] == 0) {\n\t\t\t\tif (isValidPath(edges, i, destination, visited)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tif(edges == null || edges.length == 0) return false;\n\t\tint n = edges.length;\n\t\tboolean[] visited = new boolean[n];\n\t\tQueue<Integer> queue = new LinkedList<Integer>();\n\t\tqueue.add(source);\n\t\tvisited[source] = true;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint cur = queue.poll();\n\t\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\t\tif(edges[cur][i] == 1 && !visited[i]){\n\t\t\t\t\tqueue.add(i);\n\t\t\t\t\tvisited[i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn visited[destination];\n\t}\n}\n",
        "\tstatic boolean isValidPath(int[][] edges, int source, int destination) {\n\t\tif (source == destination) {\n\t\t\treturn true;\n\t\t}\n\t\tint[] visited = new int[edges.length];\n\t\treturn isValidPath(edges, source, destination, visited);\n\t}\n\tpublic static boolean isValidPath(int[][] edges, int source, int destination, int[] visited) {\n\t\tif (source == destination) {\n\t\t\treturn true;\n\t\t}\n\t\tvisited[source] = 1;\n\t\tfor (int[] edge : edges) {\n\t\t\tif (edge[0] == source && visited[edge[1]] == 0) {\n\t\t\t\tif (isValidPath(edges, edge[1], destination, visited)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2078",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.",
    "snippets": [
        "\tint titleToNumber(String columnTitle) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < columnTitle.length(); i++) {\n\t\t\tresult = result * 26 + (columnTitle.charAt(i) - 'A' + 1);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint titleToNumber(String columnTitle) {\n\t\tint result = 0;\n\t\tfor(int i = 0; i < columnTitle.length(); i++){\n\t\t\tresult = result * 26 + columnTitle.charAt(i) - 'A' + 1;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int titleToNumber(String columnTitle) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < columnTitle.length(); i++) {\n\t\t\tresult = result * 26 + (columnTitle.charAt(i) - 'A' + 1);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint titleToNumber(String s) {\n\t\tint result = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tresult = result * 26 + (s.charAt(i) - 'A' + 1);\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2079",
    "source": "leetcode",
    "language": "java",
    "query": "Given a root and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target.",
    "snippets": [
        "\tboolean findTarget(TreeNode root, int k) {\n\t\tif(root == null) return false;\n\t\treturn findTarget(root, k, new HashSet<Integer>());\n\t}\n\tpublic\n\tboolean findTarget(TreeNode root, int k, Set<Integer> set) {\n\t\tif(root == null) return false;\n\t\tif(set.contains(k - root.val)) return true;\n\t\tset.add(root.val);\n\t\treturn findTarget(root.left, k, set) || findTarget(root.right, k, set);\n\t}\n}\n",
        "\tboolean findTarget(TreeNode root, int k) {\n\t\tif(root == null) return false;\n\t\treturn findTarget(root, k, new HashSet<Integer>());\n\t}\n\tpublic\n\tboolean findTarget(TreeNode root, int k, HashSet<Integer> set) {\n\t\tif(root == null) return false;\n\t\tif(set.contains(k - root.val)) return true;\n\t\tset.add(root.val);\n\t\treturn findTarget(root.left, k, set) || findTarget(root.right, k, set);\n\t}\n}\n",
        "\tboolean findTarget(TreeNode root, int k) {\n\t\tif(root == null) return false;\n\t\tif(root.left == null && root.right == null) return k == root.val;\n\t\treturn findTarget(root.left, k - root.val) || findTarget(root.right, k - root.val);\n\t}\n}\n",
        "\tboolean findTarget(TreeNode root, int k) {\n\t\tif(root == null) return false;\n\t\tif(root.left == null && root.right == null) return k == root.val;\n\t\tif(root.left == null) return findTarget(root.right, k - root.val);\n\t\tif(root.right == null) return findTarget(root.left, k - root.val);\n\t\treturn findTarget(root.left, k - root.val) || findTarget(root.right, k - root.val);\n\t}\n}\n",
        "\tboolean findTarget(TreeNode root, int k) {\n\t\tif(root == null) return false;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\twhile(!queue.isEmpty()){\n\t\t\tTreeNode node = queue.poll();\n\t\t\tif(set.contains(k - node.val)) return true;\n\t\t\tset.add(node.val);\n\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean findTarget(TreeNode root, int k) {\n\t\tif(root == null) return false;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\twhile(!queue.isEmpty()){\n\t\t\tTreeNode node = queue.poll();\n\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\tif(node.val == k - node.val) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean findTarget(TreeNode root, int k) {\n\t\tif(root == null) return false;\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tstack.push(root);\n\t\twhile(!stack.isEmpty()){\n\t\t\tTreeNode node = stack.pop();\n\t\t\tif(set.contains(k-node.val)) return true;\n\t\t\tset.add(node.val);\n\t\t\tif(node.left != null) stack.push(node.left);\n\t\t\tif(node.right != null) stack.push(node.right);\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2080",
    "source": "leetcode",
    "language": "java",
    "query": "You are given four integers row, cols, rCenter, and cCenter. Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance.",
    "snippets": [
        "\tList<List<Integer>> matrix(int row, int cols, int rCenter, int cCenter){\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < row; i++){\n\t\t\tList<Integer> temp = new ArrayList<Integer>();\n\t\t\tfor(int j = 0; j < cols; j++){\n\t\t\t\ttemp.add(Math.abs(i - rCenter) + Math.abs(j - cCenter));\n\t\t\t}\n\t\t\tresult.add(temp);\n\t\t}\n\t\tCollections.sort(result, new Comparator<List<Integer>>(){\n\t\t\tpublic int compare(List<Integer> a, List<Integer> b){\n\t\t\t\treturn a.get(0) - b.get(0);\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> matrix(int row, int cols, int rCenter, int cCenter){\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < row; i++){\n\t\t\tList<Integer> rowList = new ArrayList<Integer>();\n\t\t\tfor(int j = 0; j < cols; j++){\n\t\t\t\trowList.add(i*cols+j);\n\t\t\t}\n\t\t\tresult.add(rowList);\n\t\t}\n\t\tCollections.sort(result, new Comparator<List<Integer>>(){\n\t\t\tpublic int compare(List<Integer> a, List<Integer> b){\n\t\t\t\tint aDist = Math.abs(a.get(0)-rCenter) + Math.abs(a.get(1)-cCenter);\n\t\t\t\tint bDist = Math.abs(b.get(0)-rCenter) + Math.abs(b.get(1)-cCenter);\n\t\t\t\treturn aDist - bDist;\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> matrix(int row, int cols, int rCenter, int cCenter){\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < row; i++){\n\t\t\tList<Integer> rowList = new ArrayList<Integer>();\n\t\t\tfor(int j = 0; j < cols; j++){\n\t\t\t\tint distance = Math.abs(i - rCenter) + Math.abs(j - cCenter);\n\t\t\t\trowList.add(distance);\n\t\t\t}\n\t\t\tresult.add(rowList);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> matrix(int row, int cols, int rCenter, int cCenter){\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < row; i++){\n\t\t\tList<Integer> temp = new ArrayList<Integer>();\n\t\t\tfor(int j = 0; j < cols; j++){\n\t\t\t\tint distance = (int)Math.sqrt((i - rCenter) * (i - rCenter) + (j - cCenter) * (j - cCenter));\n\t\t\t\ttemp.add(distance);\n\t\t\t}\n\t\t\tresult.add(temp);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> matrix(int row, int cols, int rCenter, int cCenter){\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tfor(int i = 0; i < row; i++){\n\t\t\tList<Integer> temp = new ArrayList<Integer>();\n\t\t\tfor(int j = 0; j < cols; j++){\n\t\t\t\ttemp.add(Math.abs(i - rCenter) + Math.abs(j - cCenter));\n\t\t\t}\n\t\t\tresult.add(temp);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> allCellsDistOrder(int r, int c, int r0, int c0) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tres.add(Arrays.asList(i, j));\n\t\t\t}\n\t\t}\n\t\tCollections.sort(res, new Comparator<List<Integer>>(){\n\t\t\tpublic int compare(List<Integer> a, List<Integer> b){\n\t\t\t\tint aDist = Math.abs(a.get(0) - r0) + Math.abs(a.get(1) - c0);\n\t\t\t\tint bDist = Math.abs(b.get(0) - r0) + Math.abs(b.get(1) - c0);\n\t\t\t\treturn aDist - bDist;\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t}\n}\n",
        "\tList<List<Integer>> allCellsDistOrder(int rows, int cols, int r0, int c0) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tfor(int i = 0; i < rows; i++){\n\t\t\tfor(int j = 0; j < cols; j++){\n\t\t\t\tres.add(Arrays.asList(i, j));\n\t\t\t}\n\t\t}\n\t\tCollections.sort(res, (a, b) -> {\n\t\t\tint aDist = Math.abs(a.get(0) - r0) + Math.abs(a.get(1) - c0);\n\t\t\tint bDist = Math.abs(b.get(0) - r0) + Math.abs(b.get(1) - c0);\n\t\t\treturn aDist - bDist;\n\t\t});\n\t\treturn res;\n\t}\n}\n",
        "\tstatic List<String> getCells(int row, int cols, int rCenter, int cCenter){\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(int i = 0; i < row; i++){\n\t\t\tfor(int j = 0; j < cols; j++){\n\t\t\t\tlist.add(i + \",\" + j);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(list, new Comparator<String>(){\n\t\t\tpublic int compare(String s1, String s2){\n\t\t\t\tString[] s1s = s1.split(\",\");\n\t\t\t\tString[] s2s = s2.split(\",\");\n\t\t\t\tint s1r = Integer.parseInt(s1s[0]);\n\t\t\t\tint s1c = Integer.parseInt(s1s[1]);\n\t\t\t\tint s2r = Integer.parseInt(s2s[0]);\n\t\t\t\tint s2c = Integer.parseInt(s2s[1]);\n\t\t\t\tint s1d = Math.abs(s1r - rCenter) + Math.abs(s1c - cCenter);\n\t\t\t\tint s2d = Math.abs(s2r - rCenter) + Math.abs(s2c - cCenter);\n\t\t\t\tif(s1d < s2d){\n\t\t\t\t\treturn -1;\n\t\t\t\t}else if(s1d > s2d){\n\t\t\t\t\treturn 1;\n\t\t\t\t}else{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn list;\n\t}\n}\n",
        "\tList<List<Integer>> allCellsDistOrder(int Rows, int Cols, int r0, int c0) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tint[][] dist = new int[Rows][Cols];\n\t\tfor(int i = 0; i < Rows; i++){\n\t\t\tfor(int j = 0; j < Cols; j++){\n\t\t\t\tdist[i][j] = Math.abs(i - r0) + Math.abs(j - c0);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < Rows; i++){\n\t\t\tfor(int j = 0; j < Cols; j++){\n\t\t\t\tList<Integer> temp = new ArrayList<>();\n\t\t\t\ttemp.add(i);\n\t\t\t\ttemp.add(j);\n\t\t\t\tres.add(temp);\n\t\t\t}\n\t\t}\n\t\tCollections.sort(res, new Comparator<List<Integer>>(){\n\t\t\tpublic int compare(List<Integer> a, List<Integer> b){\n\t\t\t\treturn dist[a.get(0)][a.get(1)] - dist[b.get(0)][b.get(1)];\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2081",
    "source": "leetcode",
    "language": "java",
    "query": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only. For each query you need to find the number of plates between candles that are in the substring.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString s = in.next();\n\t\tint[] ans = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tans[i] = 0;\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans[i] = count;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n; i < m; i++){\n\t\t\tans[i] = count;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.println(ans[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tString s = in.next();\n\t\tint[] ans = new int[m];\n\t\tint[] count = new int[m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount[i]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(s.charAt(i) == '|'){\n\t\t\t\tans[i] = count[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tans[i] += count[i-1];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tSystem.out.println(ans[i]);\n\t\t}\n\t}\n}\n",
        "\tint[] candles(int n, String s) {\n\t\tint[] res = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres[i] = count;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int[] candles(String s){\n\t\tint[] res = new int[s.length()];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres[i] = count;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int count(String s, int k){\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tj = i;\n\t\t\t\twhile(j < s.length() && s.charAt(j) == '*'){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j - i >= k){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\ti = j;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tString s = in.next();\n\t\tint q = in.nextInt();\n\t\tfor(int a0 = 0; a0 < q; a0++){\n\t\t\tint l = in.nextInt();\n\t\t\tint r = in.nextInt();\n\t\t\tint result = count(s, l, r);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\tpublic static int count(String s, int l, int r){\n\t\tint count = 0;\n\t\tfor(int i = l; i <= r; i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int[] solve(String s, int[] queries){\n\t\tint[] result = new int[queries.length];\n\t\tint[] count = new int[s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount[i]++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < s.length(); i++){\n\t\t\tcount[i] += count[i-1];\n\t\t}\n\t\tfor(int i = 0; i < queries.length; i++){\n\t\t\tresult[i] = count[queries[i]];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] candles(int n, String s) {\n\t\tint[] res = new int[n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres[i] = count;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int[] count(String s, int[] queries){\n\t\tint[] result = new int[queries.length];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '*'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int j = 0; j < queries.length; j++){\n\t\t\t\t\tif(queries[j] >= count){\n\t\t\t\t\t\tresult[j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2082",
    "source": "leetcode",
    "language": "java",
    "query": "You are given the head of a singly linked-list. You may not modify the values in the list's nodes. Only nodes themselves may be changed. The list can be represented as: L0, L1, L2, Ln - 1, ….",
    "snippets": [
        "\tclass ListNode{\n\t\tint val;\n\t\tListNode next;\n\t\tListNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic ListNode reverseList(ListNode head){\n\t\tif(head == null || head.next == null){\n\t\t\treturn head;\n\t\t}\n\t\tListNode prev = null;\n\t\tListNode cur = head;\n\t\twhile(cur != null){\n\t\t\tListNode next = cur.next;\n\t\t\tcur.next = prev;\n\t\t\tprev = cur;\n\t\t\tcur = next;\n\t\t}\n\t\treturn prev;\n\t}\n}\n",
        "\tNode head;\n\tpublic Clazz(Node head){\n\t\tthis.head = head;\n\t}\n\tpublic void printList(){\n\t\tNode current = head;\n\t\twhile(current != null){\n\t\t\tSystem.out.print(current.value + \" \");\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\tpublic void reverseList(){\n\t\tNode current = head;\n\t\tNode previous = null;\n\t\tNode next = null;\n\t\twhile(current != null){\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = previous;\n\t\t\tprevious = current;\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = previous;\n\t}\n\tpublic void reverseListRecursive(){\n\t\thead = reverseListRecursive(head);\n\t}\n\tpublic Node reverseListRecursive(Node current){\n\t\tif(current == null || current.next == null){\n\t\t\treturn current;\n\t\t}\n\t\tNode next = current.next;\n\t\tNode newHead = reverseListRecursive(next);\n\t\tnext.next = current;\n\t\tcurrent.next = null;\n\t\treturn newHead;\n\t}\n\tpublic void reverseListRecursive2(){\n\t\tNode current = head;\n\t\tNode previous = null;\n\t\tNode next = null;\n\t\twhile(current != null){\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = previous;\n\t\t\tprevious = current;\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = previous;\n\t}\n\tpublic void reverseListRecursive3(){\n\t\tNode current = head;\n\t\tNode previous = null;\n\t\tNode next = null;\n\t\twhile(current != null){\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = previous;\n\t\t\tprevious = current;\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = previous;\n\t}\n\tpublic void reverseListRecursive4(){\n\t\tNode current = head;\n\t\tNode previous\n",
        "\tNode head;\n\tpublic Clazz(Node head){\n\t\tthis.head = head;\n\t}\n\tpublic void printList(){\n\t\tNode current = head;\n\t\twhile(current != null){\n\t\t\tSystem.out.print(current.data + \" \");\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\tpublic void reverseList(){\n\t\tNode current = head;\n\t\tNode prev = null;\n\t\tNode next = null;\n\t\twhile(current != null){\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = prev;\n\t\t\tprev = current;\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = prev;\n\t}\n\tpublic void reverseListRecursive(Node current){\n\t\tif(current == null || current.next == null){\n\t\t\thead = current;\n\t\t\treturn;\n\t\t}\n\t\treverseListRecursive(current.next);\n\t\tNode next = current.next;\n\t\tnext.next = current;\n\t\tcurrent.next = null;\n\t}\n\tpublic void reverseListRecursive(){\n\t\treverseListRecursive(head);\n\t}\n\tpublic void reverseListRecursive(Node current, Node prev){\n\t\tif(current == null){\n\t\t\thead = prev;\n\t\t\treturn;\n\t\t}\n\t\tNode next = current.next;\n\t\tcurrent.next = prev;\n\t\treverseListRecursive(next, current);\n\t}\n\tpublic void reverseListRecursive2(){\n\t\treverseListRecursive(head, null);\n\t}\n\tpublic void reverseListRecursive2(Node current, Node prev){\n\t\tif(current == null){\n\t\t\thead = prev;\n\t\t\treturn;\n\t\t}\n\t\tNode next = current.next;\n\t\tcurrent.next = prev;\n\t\treverseListRecursive2(next, current);\n\t}\n\tpublic void reverseListRecursive3(){\n\t\treverseListRecursive2(head, null);\n\t}\n\tpublic void reverseListRecursive3(Node\n",
        "\tNode head;\n\tpublic Clazz(Node head){\n\t\tthis.head = head;\n\t}\n\tpublic void printList(){\n\t\tNode current = head;\n\t\twhile(current != null){\n\t\t\tSystem.out.print(current.data + \" \");\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\tpublic void reverseList(){\n\t\tNode current = head;\n\t\tNode prev = null;\n\t\tNode next = null;\n\t\twhile(current != null){\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = prev;\n\t\t\tprev = current;\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = prev;\n\t}\n\tpublic void reverseListRecursive(Node current, Node prev){\n\t\tif(current == null)\n\t\t\treturn;\n\t\tNode next = current.next;\n\t\tcurrent.next = prev;\n\t\treverseListRecursive(next, current);\n\t\thead = current;\n\t}\n\tpublic void reverseListRecursive(){\n\t\treverseListRecursive(head, null);\n\t}\n\tpublic void reverseListRecursive2(Node current, Node prev){\n\t\tif(current == null)\n\t\t\treturn;\n\t\tNode next = current.next;\n\t\tcurrent.next = prev;\n\t\treverseListRecursive2(next, current);\n\t\thead = current;\n\t}\n\tpublic void reverseListRecursive2(){\n\t\treverseListRecursive2(head, null);\n\t}\n\tpublic void reverseListRecursive3(Node current, Node prev){\n\t\tif(current == null)\n\t\t\treturn;\n\t\tNode next = current.next;\n\t\tcurrent.next = prev;\n\t\treverseListRecursive3(next, current);\n\t\thead = current;\n\t}\n\tpublic void reverseListRecursive3(){\n\t\treverseListRecursive3(head, null);\n\t}\n\tpublic void reverseListRecursive4(Node current, Node prev){\n\t\tif(current == null)\n\t\t\treturn;\n",
        "\tNode head;\n\tpublic class Node{\n\t\tpublic int data;\n\t\tpublic Node next;\n\t\tpublic Node(int data){\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\tpublic void insert(int data){\n\t\tNode newNode = new Node(data);\n\t\tif(head == null){\n\t\t\thead = newNode;\n\t\t}\n\t\telse{\n\t\t\tNode current = head;\n\t\t\twhile(current.next != null){\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\t\t\tcurrent.next = newNode;\n\t\t}\n\t}\n\tpublic void print(){\n\t\tNode current = head;\n\t\twhile(current != null){\n\t\t\tSystem.out.print(current.data + \" \");\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\tpublic void reverse(){\n\t\tNode current = head;\n\t\tNode previous = null;\n\t\tNode next = null;\n\t\twhile(current != null){\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = previous;\n\t\t\tprevious = current;\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = previous;\n\t}\n\tpublic void reverseRecursive(){\n\t\thead = reverseRecursive(head);\n\t}\n\tpublic Node reverseRecursive(Node current){\n\t\tif(current == null || current.next == null){\n\t\t\treturn current;\n\t\t}\n\t\tNode next = current.next;\n\t\tNode newHead = reverseRecursive(next);\n\t\tnext.next = current;\n\t\tcurrent.next = null;\n\t\treturn newHead;\n\t}\n\tpublic void reverseRecursive2(){\n\t\tNode current = head;\n\t\tNode previous = null;\n\t\tNode next = null;\n\t\twhile(current != null){\n\t\t\tnext = current.next;\n\t\t\tcurrent.next = previous;\n\t\t\tprevious = current;\n\t\t\tcurrent = next;\n\t\t}\n\t\thead = previous\n",
        "\tclass Node{\n\t\tint val;\n\t\tNode next;\n\t\tNode(int val){\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\tpublic Node reverse(Node head){\n\t\tNode prev = null;\n\t\tNode curr = head;\n\t\tNode next = null;\n\t\twhile(curr != null){\n\t\t\tnext = curr.next;\n\t\t\tcurr.next = prev;\n\t\t\tprev = curr;\n\t\t\tcurr = next;\n\t\t}\n\t\treturn prev;\n\t}\n}\n",
        "\tNode head;\n\tpublic class Node{\n\t\tpublic int data;\n\t\tpublic Node next;\n\t\tpublic Node(int d){\n\t\t\tdata = d;\n\t\t\tnext = null;\n\t\t}\n\t}\n\tpublic void printList(){\n\t\tNode n = head;\n\t\twhile(n != null){\n\t\t\tSystem.out.print(n.data + \" \");\n\t\t\tn = n.next;\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic void insert(int d){\n\t\tNode n = new Node(d);\n\t\tn.next = head;\n\t\thead = n;\n\t}\n\tpublic void insert(int d, int pos){\n\t\tNode n = new Node(d);\n\t\tNode temp = head;\n\t\tfor(int i = 0; i < pos - 1; i++){\n\t\t\ttemp = temp.next;\n\t\t}\n\t\tn.next = temp.next;\n\t\ttemp.next = n;\n\t}\n\tpublic void delete(int pos){\n\t\tNode temp = head;\n\t\tfor(int i = 0; i < pos - 1; i++){\n\t\t\ttemp = temp.next;\n\t\t}\n\t\ttemp.next = temp.next.next;\n\t}\n\tpublic void delete(int d){\n\t\tNode temp = head;\n\t\twhile(temp.next != null){\n\t\t\tif(temp.next.data == d){\n\t\t\t\ttemp.next = temp.next.next;\n\t\t\t}\n\t\t\ttemp = temp.next;\n\t\t}\n\t}\n\tpublic void delete(){\n\t\thead = head.next;\n\t}\n\tpublic void delete(Node n){\n\t\tNode temp = head;\n\t\twhile(temp.next != null){\n\t\t\tif(temp.next == n){\n\t\t\t\ttemp.next = temp.next.next;\n\t\t\t}\n\t\t\ttemp = temp.next;\n\t\t}\n\t}\n\tpublic void delete(Node n1,\n",
        "\tclass Node{\n\t\tpublic int val;\n\t\tpublic Node next;\n\t\tpublic Node(int val){\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\tpublic Node head;\n\tpublic Node tail;\n\tpublic int size;\n\tpublic Clazz(){\n\t\thead = null;\n\t\ttail = null;\n\t\tsize = 0;\n\t}\n\tpublic void add(int val){\n\t\tNode newNode = new Node(val);\n\t\tif(head == null){\n\t\t\thead = newNode;\n\t\t\ttail = newNode;\n\t\t}\n\t\telse{\n\t\t\ttail.next = newNode;\n\t\t\ttail = newNode;\n\t\t}\n\t\tsize++;\n\t}\n\tpublic void add(int index, int val){\n\t\tif(index < 0 || index > size){\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tNode newNode = new Node(val);\n\t\tif(index == 0){\n\t\t\tnewNode.next = head;\n\t\t\thead = newNode;\n\t\t}\n\t\telse{\n\t\t\tNode prev = head;\n\t\t\tfor(int i = 0; i < index - 1; i++){\n\t\t\t\tprev = prev.next;\n\t\t\t}\n\t\t\tnewNode.next = prev.next;\n\t\t\tprev.next = newNode;\n\t\t}\n\t\tsize++;\n\t}\n\tpublic void remove(int index){\n\t\tif(index < 0 || index >= size){\n\t\t\tthrow new IndexOutOfBoundsException();\n\t\t}\n\t\tif(index == 0){\n\t\t\thead = head.next;\n\t\t}\n\t\telse{\n\t\t\tNode prev = head;\n\t\t\tfor(int i = 0; i < index - 1; i++){\n\t\t\t\tprev = prev.next;\n\t\t\t}\n\t\t\tprev.next = prev.next.next;\n\t\t}\n\t\tsize--;\n\t}\n\tpublic int get(\n",
        "\tclass Node{\n\t\tint val;\n\t\tNode next;\n\t\tNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic Node copyRandomList(Node head){\n\t\tif(head == null) return null;\n\t\tNode cur = head;\n\t\twhile(cur != null){\n\t\t\tNode newNode = new Node(cur.val);\n\t\t\tnewNode.next = cur.next;\n\t\t\tcur.next = newNode;\n\t\t\tcur = newNode.next;\n\t\t}\n\t\tcur = head;\n\t\twhile(cur != null){\n\t\t\tif(cur.next.next != null) cur.next.next = cur.next.next.next;\n\t\t\tcur = cur.next.next;\n\t\t}\n\t\tcur = head;\n\t\tNode newHead = head.next;\n\t\twhile(cur != null){\n\t\t\tNode newNode = cur.next;\n\t\t\tif(cur.random != null) newNode.random = cur.random.next;\n\t\t\tcur.next = newNode.next;\n\t\t\tcur = cur.next;\n\t\t}\n\t\treturn newHead;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2083",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s.",
    "snippets": [
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, \"\", res);\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, String cur, List<String> res){\n\t\tif(start == s.length() && cur.length() == 4){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1; i <= 3; i++){\n\t\t\tif(start + i > s.length()) break;\n\t\t\tString sub = s.substring(start, start + i);\n\t\t\tif(sub.length() > 1 && sub.charAt(0) == '0') continue;\n\t\t\tif(sub.length() > 1 && sub.length() < 3 && sub.charAt(0) == '0') continue;\n\t\t\tif(sub.length() > 3) break;\n\t\t\thelper(s, start + i, cur + sub + \".\", res);\n\t\t}\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, \"\", res);\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, String cur, List<String> res){\n\t\tif(start == s.length() && cur.length() == 4){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1; i <= 3; i++){\n\t\t\tif(start + i > s.length()) break;\n\t\t\tString sub = s.substring(start, start + i);\n\t\t\tif(sub.length() > 1 && sub.charAt(0) == '0') break;\n\t\t\tif(sub.length() > 1 && sub.charAt(0) == '0' && sub.charAt(1) != '.') break;\n\t\t\tif(sub.length() > 2 && sub.charAt(0) == '0' && sub.charAt(1) == '0') break;\n\t\t\tif(sub.length() > 3 && sub.charAt(0) == '0' && sub.charAt(1) == '0' && sub.charAt(2) != '.') break;\n\t\t\tif(sub.length() > 3 && sub.charAt(0) == '0' && sub.charAt(1) == '0' && sub.charAt(2) == '0') break;\n\t\t\tif(sub.length() > 3 && sub.charAt(0) == '0' && sub.charAt(1) == '0' && sub.charAt(2) == '0' && sub.charAt(3) != '.') break;\n\t\t\thelper(s, start + i, cur + sub + \".\", res);\n\t\t}\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, res, new StringBuilder());\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, List<String> res, StringBuilder sb){\n\t\tif(start == s.length() && sb.length() == s.length() + 3){\n\t\t\tres.add(sb.toString());\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < s.length() && i < start + 3; i++){\n\t\t\tif(i != start && s.charAt(start) == '0') break;\n\t\t\tif(Integer.parseInt(s.substring(start, i + 1)) > 255) break;\n\t\t\tsb.append(s.substring(start, i + 1) + \".\");\n\t\t\thelper(s, i + 1, res, sb);\n\t\t\tsb.delete(sb.length() - (i - start + 1), sb.length());\n\t\t}\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, res, new StringBuilder());\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, List<String> res, StringBuilder sb){\n\t\tif(start == s.length() && sb.length() == s.length()){\n\t\t\tres.add(sb.toString());\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < s.length() && i < start + 3; i++){\n\t\t\tif(i != start && s.charAt(start) == '0') break;\n\t\t\tif(Integer.parseInt(s.substring(start, i + 1)) > 255) break;\n\t\t\tsb.append(s.substring(start, i + 1) + \".\");\n\t\t\thelper(s, i + 1, res, sb);\n\t\t\tsb.deleteCharAt(sb.length() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, \"\", res);\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, String cur, List<String> res){\n\t\tif(start == s.length() && cur.length() == s.length()){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1; i <= 3; i++){\n\t\t\tif(start + i > s.length()) break;\n\t\t\tString sub = s.substring(start, start + i);\n\t\t\tif(isValid(sub)){\n\t\t\t\thelper(s, start + i, cur + sub + \".\", res);\n\t\t\t}\n\t\t}\n\t}\n\tpublic boolean isValid(String s){\n\t\tif(s.length() > 1 && s.charAt(0) == '0') return false;\n\t\tint num = Integer.parseInt(s);\n\t\treturn num >= 0 && num <= 255;\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, \"\", res);\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, String cur, List<String> res){\n\t\tif(start == s.length() && cur.length() == 4){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1; i <= 3; i++){\n\t\t\tif(start + i > s.length()) break;\n\t\t\tString tmp = s.substring(start, start + i);\n\t\t\tif(tmp.length() > 1 && tmp.charAt(0) == '0') continue;\n\t\t\tif(tmp.length() > 1 && tmp.length() < 3 && tmp.charAt(0) == '0') continue;\n\t\t\tif(tmp.length() > 3) continue;\n\t\t\thelper(s, start + i, cur + tmp + \".\", res);\n\t\t}\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, res, new StringBuilder());\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, List<String> res, StringBuilder sb){\n\t\tif(start == s.length() && sb.length() == s.length()){\n\t\t\tres.add(sb.toString());\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < s.length(); i++){\n\t\t\tif(i > start && s.charAt(start) == '0') break;\n\t\t\tif(i > start && s.charAt(start) == '0' && s.charAt(start+1) != '0') break;\n\t\t\tif(i > start && s.charAt(start) == '0' && s.charAt(start+1) == '0' && s.charAt(start+2) != '0') break;\n\t\t\tif(i > start && s.charAt(start) == '0' && s.charAt(start+1) == '0' && s.charAt(start+2) == '0' && s.charAt(start+3) != '0') break;\n\t\t\tif(i > start && s.charAt(start) == '0' && s.charAt(start+1) == '0' && s.charAt(start+2) == '0' && s.charAt(start+3) == '0' && s.charAt(start+4) != '0') break;\n\t\t\tif(i > start && s.charAt(start) == '0' && s.charAt(start+1) == '0' && s.charAt(start+2) == '0' && s.charAt(start+3) == '0' && s.charAt(start+4) == '0' &&\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length() < 4 || s.length() > 12) return res;\n\t\thelper(s, 0, \"\", res);\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, String cur, List<String> res){\n\t\tif(start == s.length() && cur.length() == 4){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 1; i <= 3; i++){\n\t\t\tif(start + i > s.length()) break;\n\t\t\tString sub = s.substring(start, start + i);\n\t\t\tif(sub.length() > 1 && sub.charAt(0) == '0') continue;\n\t\t\tif(sub.length() > 1 && sub.charAt(0) == '0' && sub.charAt(1) != '.') continue;\n\t\t\tif(sub.length() > 2 && sub.charAt(0) == '0' && sub.charAt(1) == '0') continue;\n\t\t\tif(sub.length() > 3 && sub.charAt(0) == '0' && sub.charAt(1) == '0' && sub.charAt(2) != '.') continue;\n\t\t\tif(sub.length() > 4 && sub.charAt(0) == '0' && sub.charAt(1) == '0' && sub.charAt(2) == '0') continue;\n\t\t\tif(sub.length() > 4 && sub.charAt(0) == '0' && sub.charAt(1) == '0' && sub.charAt(2) == '0' && sub.charAt(3) != '.') continue;\n\t\t\thelper(s, start + i, cur + sub + \".\", res);\n\t\t}\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length()<4 || s.length()>12) return res;\n\t\thelper(s, 0, \"\", res);\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, String cur, List<String> res){\n\t\tif(start==s.length() && cur.length()==4){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=1; i<4; i++){\n\t\t\tif(start+i>s.length()) break;\n\t\t\tString sub = s.substring(start, start+i);\n\t\t\tif(sub.length()>1 && sub.charAt(0)=='0') break;\n\t\t\tif(sub.length()>3) break;\n\t\t\thelper(s, start+i, cur+sub+\".\", res);\n\t\t}\n\t}\n}\n",
        "\tList<String> restoreIpAddresses(String s) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(s.length()<4 || s.length()>12) return res;\n\t\thelper(s, 0, \"\", res);\n\t\treturn res;\n\t}\n\tpublic void helper(String s, int start, String cur, List<String> res){\n\t\tif(start==s.length() && cur.length()==4){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=1; i<4; i++){\n\t\t\tif(start+i>s.length()) break;\n\t\t\tString sub = s.substring(start, start+i);\n\t\t\tif(sub.length()>1 && sub.charAt(0)=='0') continue;\n\t\t\tif(sub.length()>3) continue;\n\t\t\thelper(s, start+i, cur+sub+\".\", res);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2084",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return the number of prime numbers that are strictly less than n.",
    "snippets": [
        "\tint countPrimes(int n) {\n\t\tint count = 0;\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tif(isPrime(i)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isPrime(int n){\n\t\tif(n == 2){\n\t\t\treturn true;\n\t\t}\n\t\tfor(int i = 2; i <= Math.sqrt(n); i++){\n\t\t\tif(n % i == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countPrimes(int n) {\n\t\tint count = 0;\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tif(isPrime(i)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isPrime(int n){\n\t\tif(n <= 1){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 2; i <= Math.sqrt(n); i++){\n\t\t\tif(n % i == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countPrimes(int n) {\n\t\tint count = 0;\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tif(isPrime(i)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isPrime(int n){\n\t\tif(n == 2) return true;\n\t\tif(n % 2 == 0) return false;\n\t\tfor(int i = 3; i * i <= n; i += 2){\n\t\t\tif(n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countPrimeSetBits(int L, int R) {\n\t\tint count = 0;\n\t\tfor(int i = L; i <= R; i++){\n\t\t\tif(isPrime(i)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isPrime(int n){\n\t\tif(n == 1){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 2; i <= Math.sqrt(n); i++){\n\t\t\tif(n % i == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countPrimeSetBits(int L, int R) {\n\t\tint count = 0;\n\t\tfor(int i = L; i <= R; i++){\n\t\t\tif(isPrime(i)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic boolean isPrime(int n){\n\t\tif(n == 2) return true;\n\t\tif(n % 2 == 0) return false;\n\t\tfor(int i = 3; i * i <= n; i += 2){\n\t\t\tif(n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countPrimeSetBits(int L, int R) {\n\t\tint count = 0;\n\t\tfor(int i = L; i <= R; i++){\n\t\t\tif(isPrime(i)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isPrime(int n){\n\t\tif(n == 1) return false;\n\t\tif(n == 2) return true;\n\t\tfor(int i = 2; i <= Math.sqrt(n); i++){\n\t\t\tif(n % i == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2085",
    "source": "leetcode",
    "language": "java",
    "query": "The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree. A subtree of a tree T is the tree consisting of a node in T and all its descendant nodes.",
    "snippets": [
        "\tint[] findSubtree(int[] edges, int n) {\n\t\tint[] parent = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor (int[] edge : edges) {\n\t\t\tint a = find(parent, edge[0]);\n\t\t\tint b = find(parent, edge[1]);\n\t\t\tif (a != b) {\n\t\t\t\tparent[a] = b;\n\t\t\t}\n\t\t}\n\t\tint[] result = new int[edges.length];\n\t\tint index = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (parent[i] == i) {\n\t\t\t\tresult[index++] = i;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(result, index);\n\t}\n\tpublic int find(int[] parent, int i) {\n\t\tif (parent[i] == i) {\n\t\t\treturn i;\n\t\t}\n\t\treturn parent[i] = find(parent, parent[i]);\n\t}\n}\n",
        "\tstatic int[] findSubtree(int[] edges, int n) {\n\t\tint[] parent = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor (int[] edge : edges) {\n\t\t\tint a = find(parent, edge[0]);\n\t\t\tint b = find(parent, edge[1]);\n\t\t\tif (a != b) {\n\t\t\t\tparent[a] = b;\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[edges.length];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint a = find(parent, edges[i][0]);\n\t\t\tint b = find(parent, edges[i][1]);\n\t\t\tif (a == b) {\n\t\t\t\tans[i] = 1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static int find(int[] parent, int i) {\n\t\tif (parent[i] == i) {\n\t\t\treturn i;\n\t\t}\n\t\treturn find(parent, parent[i]);\n\t}\n}\n",
        "\tstatic int[] findSubtree(int[] edges, int n) {\n\t\tint[] parent = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor (int[] edge : edges) {\n\t\t\tint a = edge[0];\n\t\t\tint b = edge[1];\n\t\t\tint pa = find(parent, a);\n\t\t\tint pb = find(parent, b);\n\t\t\tif (pa != pb) {\n\t\t\t\tparent[pa] = pb;\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[edges.length];\n\t\tfor (int i = 0; i < edges.length; i++) {\n\t\t\tint a = edges[i][0];\n\t\t\tint b = edges[i][1];\n\t\t\tint pa = find(parent, a);\n\t\t\tint pb = find(parent, b);\n\t\t\tif (pa == pb) {\n\t\t\t\tans[i] = 1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tpublic static int find(int[] parent, int i) {\n\t\tif (parent[i] == i) {\n\t\t\treturn i;\n\t\t}\n\t\treturn find(parent, parent[i]);\n\t}\n}\n",
        "\tstatic int[] findSubtree(int n, int[][] edges){\n\t\tint[] parent = new int[n];\n\t\tfor(int i = 0; i < n; i++) parent[i] = i;\n\t\tfor(int[] e : edges) {\n\t\t\tint a = find(parent, e[0]);\n\t\t\tint b = find(parent, e[1]);\n\t\t\tif(a != b) parent[a] = b;\n\t\t}\n\t\tint[] ans = new int[n];\n\t\tfor(int i = 0; i < n; i++) ans[i] = find(parent, i);\n\t\treturn ans;\n\t}\n\tpublic static int find(int[] parent, int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = find(parent, parent[i]);\n\t}\n}\n",
        "\tstatic int[] getAncestors(int[] edges, int node){\n\t\tint[] ancestors = new int[edges.length];\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tif(edges[i][0] == node){\n\t\t\t\tancestors[i] = edges[i][1];\n\t\t\t}\n\t\t\telse if(edges[i][1] == node){\n\t\t\t\tancestors[i] = edges[i][0];\n\t\t\t}\n\t\t}\n\t\treturn ancestors;\n\t}\n\tpublic\n\tstatic int[] getDescendants(int[] edges, int node){\n\t\tint[] descendants = new int[edges.length];\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tif(edges[i][0] == node){\n\t\t\t\tdescendants[i] = edges[i][1];\n\t\t\t}\n\t\t\telse if(edges[i][1] == node){\n\t\t\t\tdescendants[i] = edges[i][0];\n\t\t\t}\n\t\t}\n\t\treturn descendants;\n\t}\n\tpublic\n\tstatic int[] getSubtree(int[] edges, int node){\n\t\tint[] subtree = new int[edges.length];\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tif(edges[i][0] == node){\n\t\t\t\tsubtree[i] = edges[i][1];\n\t\t\t}\n\t\t\telse if(edges[i][1] == node){\n\t\t\t\tsubtree[i] = edges[i][0];\n\t\t\t}\n\t\t}\n\t\treturn subtree;\n\t}\n\tpublic\n\tstatic int[] getSubtreeSize(int[] edges, int node){\n\t\tint[] subtreeSize = new int[edges.length];\n\t\tfor(int i = 0; i < edges.length; i++){\n\t\t\tif(edges[i][0]\n",
        "\tint[] findMinHeightTrees(int n, int[][] edges) {\n\t\tif(n == 1) return new int[]{0};\n\t\tint[] ans = new int[2];\n\t\tint[] degree = new int[n];\n\t\tfor(int[] edge : edges){\n\t\t\tdegree[edge[0]]++;\n\t\t\tdegree[edge[1]]++;\n\t\t}\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(degree[i] == 1) q.offer(i);\n\t\t}\n\t\twhile(q.size() > 1){\n\t\t\tint size = q.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tint cur = q.poll();\n\t\t\t\tfor(int[] edge : edges){\n\t\t\t\t\tif(edge[0] == cur){\n\t\t\t\t\t\tdegree[edge[1]]--;\n\t\t\t\t\t\tif(degree[edge[1]] == 1) q.offer(edge[1]);\n\t\t\t\t\t}\n\t\t\t\t\tif(edge[1] == cur){\n\t\t\t\t\t\tdegree[edge[0]]--;\n\t\t\t\t\t\tif(degree[edge[0]] == 1) q.offer(edge[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[0] = q.poll();\n\t\tans[1] = q.poll();\n\t\treturn ans;\n\t}\n}\n",
        "\tint[] findSubtree(int[] edges, int n){\n\t\tint[] parent = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor(int[] edge : edges){\n\t\t\tint a = edge[0];\n\t\t\tint b = edge[1];\n\t\t\tint pa = find(parent, a);\n\t\t\tint pb = find(parent, b);\n\t\t\tif(pa != pb){\n\t\t\t\tparent[pa] = pb;\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[edges.length];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(parent[i] == i){\n\t\t\t\tres[index++] = i;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(res, index);\n\t}\n\tprivate int find(int[] parent, int i){\n\t\tif(parent[i] == i){\n\t\t\treturn i;\n\t\t}\n\t\treturn find(parent, parent[i]);\n\t}\n}\n",
        "\tint[] findSubtrees(int n, int[][] edges, String[] names) {\n\t\tint[] parent = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor (int[] e : edges) {\n\t\t\tint a = e[0], b = e[1];\n\t\t\tint pa = find(parent, a);\n\t\t\tint pb = find(parent, b);\n\t\t\tif (pa != pb) {\n\t\t\t\tparent[pa] = pb;\n\t\t\t}\n\t\t}\n\t\tMap<Integer, Set<Integer>> map = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap.put(i, new HashSet<Integer>());\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p = find(parent, i);\n\t\t\tmap.get(p).add(i);\n\t\t}\n\t\tSet<Integer> ans = new HashSet<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (map.get(i).size() > 1) {\n\t\t\t\tans.add(i);\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[ans.size()];\n\t\tint i = 0;\n\t\tfor (int x : ans) {\n\t\t\tres[i++] = x;\n\t\t}\n\t\treturn res;\n\t}\n\tprivate int find(int[] parent, int x) {\n\t\tif (parent[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\treturn parent[x] = find(parent, parent[x]);\n\t}\n}\n",
        "\tint[] findSubtree(int n, int[][] edges, int[] parent){\n\t\tint[] ans = new int[n];\n\t\tint[] size = new int[n];\n\t\tint[] root = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\troot[i] = i;\n\t\t\tsize[i] = 1;\n\t\t}\n\t\tfor(int[] e : edges){\n\t\t\tint a = e[0];\n\t\t\tint b = e[1];\n\t\t\tint ra = find(root, a);\n\t\t\tint rb = find(root, b);\n\t\t\tif(ra != rb){\n\t\t\t\troot[ra] = rb;\n\t\t\t\tsize[rb] += size[ra];\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(size[i] > max){\n\t\t\t\tmax = size[i];\n\t\t\t\tans[0] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint cur = ans[i - 1];\n\t\t\tint par = parent[cur];\n\t\t\tint r = find(root, par);\n\t\t\tans[i] = r;\n\t\t}\n\t\treturn ans;\n\t}\n\tint find(int[] root, int x){\n\t\tif(root[x] == x) return x;\n\t\treturn root[x] = find(root, root[x]);\n\t}\n}\n",
        "\tint[] findSubtree(int n, int[][] edges, int[] a, int[] b) {\n\t\tint[] parent = new int[n];\n\t\tfor(int i = 0; i < n; i++) parent[i] = i;\n\t\tfor(int[] e : edges) {\n\t\t\tint ai = e[0], bi = e[1];\n\t\t\tint pa = find(parent, ai), pb = find(parent, bi);\n\t\t\tif(pa != pb) {\n\t\t\t\tparent[pa] = pb;\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\tint ai = a[i], bi = b[i];\n\t\t\tint pa = find(parent, ai), pb = find(parent, bi);\n\t\t\tif(pa == pb) {\n\t\t\t\tans[i] = 1;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tint find(int[] parent, int i) {\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = find(parent, parent[i]);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2086",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums [j]-1).",
    "snippets": [
        "\tint maxProduct(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint temp = max;\n\t\t\tmax = Math.max(nums[i], Math.max(max*nums[i], min*nums[i]));\n\t\t\tmin = Math.min(nums[i], Math.min(temp*nums[i], min*nums[i]));\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxProduct(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint temp = max;\n\t\t\tmax = Math.max(nums[i], Math.max(nums[i] * max, nums[i] * min));\n\t\t\tmin = Math.min(nums[i], Math.min(nums[i] * temp, nums[i] * min));\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxProduct(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint temp = max;\n\t\t\tmax = Math.max(Math.max(max*nums[i], min*nums[i]), nums[i]);\n\t\t\tmin = Math.min(Math.min(temp*nums[i], min*nums[i]), nums[i]);\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxProduct(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint temp = max;\n\t\t\tmax = Math.max(Math.max(nums[i]*max, nums[i]), nums[i]*min);\n\t\t\tmin = Math.min(Math.min(nums[i]*temp, nums[i]), nums[i]*min);\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxProduct(int[] nums) {\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint res = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] < 0){\n\t\t\t\tint tmp = min;\n\t\t\t\tmin = max;\n\t\t\t\tmax = tmp;\n\t\t\t}\n\t\t\tmax = Math.max(nums[i], max * nums[i]);\n\t\t\tmin = Math.min(nums[i], min * nums[i]);\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2087",
    "source": "leetcode",
    "language": "java",
    "query": "Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.",
    "snippets": [
        "\tstatic class TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic static int[] findFrequentTreeSum(TreeNode root){\n\t\tif(root == null) return new int[0];\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\thelper(root, map);\n\t\tint max = 0;\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) > max){\n\t\t\t\tmax = map.get(key);\n\t\t\t}\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) == max){\n\t\t\t\tlist.add(key);\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tres[i] = list.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int helper(TreeNode root, Map<Integer, Integer> map){\n\t\tif(root == null) return 0;\n\t\tint left = helper(root.left, map);\n\t\tint right = helper(root.right, map);\n\t\tint sum = left + right + root.val;\n\t\tif(map.containsKey(sum)){\n\t\t\tmap.put(sum, map.get(sum) + 1);\n\t\t}else{\n\t\t\tmap.put(sum, 1);\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic class TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic static class Solution{\n\t\tpublic int[] findFrequentTreeSum(TreeNode root){\n\t\t\tif(root == null) return new int[0];\n\t\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\t\thelper(root, map);\n\t\t\tint max = 0;\n\t\t\tfor(int key : map.keySet()){\n\t\t\t\tif(map.get(key) > max){\n\t\t\t\t\tmax = map.get(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tfor(int key : map.keySet()){\n\t\t\t\tif(map.get(key) == max){\n\t\t\t\t\tlist.add(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] res = new int[list.size()];\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\tres[i] = list.get(i);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tpublic int helper(TreeNode root, Map<Integer, Integer> map){\n\t\t\tif(root == null) return 0;\n\t\t\tint left = helper(root.left, map);\n\t\t\tint right = helper(root.right, map);\n\t\t\tint sum = left + right + root.val;\n\t\t\tif(map.containsKey(sum)){\n\t\t\t\tmap.put(sum, map.get(sum) + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap.put(sum, 1);\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n}\n",
        "\tstatic class TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tTreeNode root = new TreeNode(1);\n\t\troot.left = new TreeNode(2);\n\t\troot.right = new TreeNode(3);\n\t\troot.left.left = new TreeNode(4);\n\t\troot.left.right = new TreeNode(5);\n\t\troot.right.left = new TreeNode(6);\n\t\troot.right.right = new TreeNode(7);\n\t\troot.left.left.left = new TreeNode(8);\n\t\troot.left.left.right = new TreeNode(9);\n\t\troot.left.right.left = new TreeNode(10);\n\t\troot.left.right.right = new TreeNode(11);\n\t\troot.right.left.left = new TreeNode(12);\n\t\troot.right.left.right = new TreeNode(13);\n\t\troot.right.right.left = new TreeNode(14);\n\t\troot.right.right.right = new TreeNode(15);\n\t\troot.left.left.left.left = new TreeNode(16);\n\t\troot.left.left.left.right = new TreeNode(17);\n\t\troot.left.left.right.left = new TreeNode(18);\n\t\troot.left.left.right.right = new TreeNode(19);\n\t\troot.left.right.left.left = new TreeNode(20);\n\t\troot.left.right.left.right = new TreeNode(21);\n\t\troot.left.right.right.left = new TreeNode(22);\n\t\troot.left.right.right.right = new TreeNode(23);\n\t\troot.right.left.left.left = new TreeNode(24);\n\t\troot.right.left.left.right = new TreeNode(25);\n\t\troot.right.left.right.left =\n",
        "\tstatic class TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic static class Solution{\n\t\tpublic int[] findFrequentTreeSum(TreeNode root){\n\t\t\tif(root == null) return new int[0];\n\t\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\t\thelper(root, map);\n\t\t\tint max = 0;\n\t\t\tfor(int key : map.keySet()){\n\t\t\t\tif(map.get(key) > max){\n\t\t\t\t\tmax = map.get(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tfor(int key : map.keySet()){\n\t\t\t\tif(map.get(key) == max){\n\t\t\t\t\tlist.add(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] res = new int[list.size()];\n\t\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\t\tres[i] = list.get(i);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tpublic int helper(TreeNode root, Map<Integer, Integer> map){\n\t\t\tif(root == null) return 0;\n\t\t\tint left = helper(root.left, map);\n\t\t\tint right = helper(root.right, map);\n\t\t\tint sum = left + right + root.val;\n\t\t\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\n\t\t\treturn sum;\n\t\t}\n\t}\n}\n",
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic int[] findFrequentTreeSum(TreeNode root){\n\t\tif(root == null) return new int[0];\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\thelper(root, map);\n\t\tint max = 0;\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) > max) max = map.get(key);\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) == max) list.add(key);\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tres[i] = list.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic int helper(TreeNode root, Map<Integer, Integer> map){\n\t\tif(root == null) return 0;\n\t\tint left = helper(root.left, map);\n\t\tint right = helper(root.right, map);\n\t\tint sum = left + right + root.val;\n\t\tif(map.containsKey(sum)){\n\t\t\tmap.put(sum, map.get(sum) + 1);\n\t\t}else{\n\t\t\tmap.put(sum, 1);\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic class TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic static int[] findFrequentTreeSum(TreeNode root){\n\t\tif(root == null) return new int[0];\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\thelper(root, map);\n\t\tint max = 0;\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) > max) max = map.get(key);\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) == max) list.add(key);\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tres[i] = list.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int helper(TreeNode root, Map<Integer, Integer> map){\n\t\tif(root == null) return 0;\n\t\tint left = helper(root.left, map);\n\t\tint right = helper(root.right, map);\n\t\tint sum = left + right + root.val;\n\t\tif(map.containsKey(sum)){\n\t\t\tmap.put(sum, map.get(sum) + 1);\n\t\t}else{\n\t\t\tmap.put(sum, 1);\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic class TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic static int[] findFrequentTreeSum(TreeNode root){\n\t\tif(root == null) return new int[0];\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\thelper(root, map);\n\t\tint max = 0;\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) > max){\n\t\t\t\tmax = map.get(key);\n\t\t\t}\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) == max){\n\t\t\t\tlist.add(key);\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tres[i] = list.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void helper(TreeNode root, Map<Integer, Integer> map){\n\t\tif(root == null) return;\n\t\tint sum = root.val;\n\t\tif(root.left != null){\n\t\t\tsum += helper(root.left, map);\n\t\t}\n\t\tif(root.right != null){\n\t\t\tsum += helper(root.right, map);\n\t\t}\n\t\tif(map.containsKey(sum)){\n\t\t\tmap.put(sum, map.get(sum) + 1);\n\t\t}else{\n\t\t\tmap.put(sum, 1);\n\t\t}\n\t\treturn;\n\t}\n}\n",
        "\tstatic class Node{\n\t\tint val;\n\t\tNode left;\n\t\tNode right;\n\t\tNode(int val){\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\tpublic static int[] findFrequentTreeSum(Node root){\n\t\tif(root == null) return new int[0];\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\thelper(root, map);\n\t\tint max = 0;\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) > max) max = map.get(key);\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor(int key : map.keySet()){\n\t\t\tif(map.get(key) == max) list.add(key);\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor(int i = 0; i < list.size(); i++){\n\t\t\tres[i] = list.get(i);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int helper(Node root, Map<Integer, Integer> map){\n\t\tif(root == null) return 0;\n\t\tint left = helper(root.left, map);\n\t\tint right = helper(root.right, map);\n\t\tint sum = left + right + root.val;\n\t\tif(map.containsKey(sum)) map.put(sum, map.get(sum) + 1);\n\t\telse map.put(sum, 1);\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic int max = 0;\n\tpublic static int maxFreq(TreeNode root){\n\t\tif(root == null) return 0;\n\t\tint left = maxFreq(root.left);\n\t\tint right = maxFreq(root.right);\n\t\tint sum = left + right + root.val;\n\t\tif(sum > max){\n\t\t\tmax = sum;\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic static void main(String[] args){\n\t\tTreeNode root = new TreeNode(1);\n\t\troot.left = new TreeNode(2);\n\t\troot.right = new TreeNode(3);\n\t\troot.left.left = new TreeNode(4);\n\t\troot.left.right = new TreeNode(5);\n\t\troot.right.left = new TreeNode(6);\n\t\troot.right.right = new TreeNode(7);\n\t\troot.left.left.left = new TreeNode(8);\n\t\troot.left.left.right = new TreeNode(9);\n\t\troot.left.right.left = new TreeNode(10);\n\t\troot.left.right.right = new TreeNode(11);\n\t\troot.right.left.left = new TreeNode(12);\n\t\troot.right.left.right = new TreeNode(13);\n\t\troot.right.right.left = new TreeNode(14);\n\t\troot.right.right.right = new TreeNode(15);\n\t\tSystem.out.println(maxFreq(root));\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2088",
    "source": "leetcode",
    "language": "java",
    "query": "You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "snippets": [
        "\tint maxProfit(int[] prices) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] < min){\n\t\t\t\tmin = prices[i];\n\t\t\t}\n\t\t\tif(prices[i] - min > max){\n\t\t\t\tmax = prices[i] - min;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint maxProfit = 0;\n\t\tint minPrice = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < prices.length; i++) {\n\t\t\tif (prices[i] < minPrice) {\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tif (prices[i] - minPrice > maxProfit) {\n\t\t\t\tmaxProfit = prices[i] - minPrice;\n\t\t\t}\n\t\t}\n\t\treturn maxProfit;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint max = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tmin = Math.min(min, prices[i]);\n\t\t\tmax = Math.max(max, prices[i] - min);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tif(prices.length == 0) return 0;\n\t\tint min = prices[0];\n\t\tint max = 0;\n\t\tfor(int i = 1; i < prices.length; i++){\n\t\t\tif(prices[i] < min){\n\t\t\t\tmin = prices[i];\n\t\t\t}\n\t\t\tif(prices[i] - min > max){\n\t\t\t\tmax = prices[i] - min;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxProfit(int[] prices) {\n\t\tint maxProfit = 0;\n\t\tint minPrice = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < prices.length; i++) {\n\t\t\tif (prices[i] < minPrice) {\n\t\t\t\tminPrice = prices[i];\n\t\t\t}\n\t\t\tif (prices[i] - minPrice > maxProfit) {\n\t\t\t\tmaxProfit = prices[i] - minPrice;\n\t\t\t}\n\t\t}\n\t\treturn maxProfit;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2089",
    "source": "leetcode",
    "language": "java",
    "query": "Nim Game involves removing stones from a heap. The one who removes the last stone is the winner.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] heap = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tint[] heap2 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap2[i] = heap[i];\n\t\t}\n\t\tint[] heap3 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap3[i] = heap[i];\n\t\t}\n\t\tint[] heap4 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap4[i] = heap[i];\n\t\t}\n\t\tint[] heap5 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap5[i] = heap[i];\n\t\t}\n\t\tint[] heap6 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap6[i] = heap[i];\n\t\t}\n\t\tint[] heap7 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap7[i] = heap[i];\n\t\t}\n\t\tint[] heap8 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap8[i] = heap[i];\n\t\t}\n\t\tint[] heap9 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap9[i] = heap[i];\n\t\t}\n\t\tint[] heap10 = new int[n];\n\t\tfor(int i = 0; i < n; i++\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] heap = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap[i] = i+1;\n\t\t}\n\t\tint i = 0;\n\t\tint j = n-1;\n\t\twhile(i < j){\n\t\t\tif(heap[i] > heap[j]){\n\t\t\t\tint temp = heap[i];\n\t\t\t\theap[i] = heap[j];\n\t\t\t\theap[j] = temp;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tSystem.out.print(heap[k] + \" \");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] heap = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tint[] heap2 = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap2[i] = heap[i];\n\t\t}\n\t\tint count = 0;\n\t\twhile(heap[0] != 0){\n\t\t\theap[0]--;\n\t\t\theap[1]--;\n\t\t\tcount++;\n\t\t\tif(heap[0] == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(heap[i] == 0){\n\t\t\t\t\theap[i] = heap2[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint[] heap = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap[i] = i+1;\n\t\t}\n\t\tint[] heap2 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap2[i] = i+1;\n\t\t}\n\t\tint count = 0;\n\t\twhile(heap.length > 0 && heap2.length > 0){\n\t\t\tint x = heap[0];\n\t\t\tint y = heap2[0];\n\t\t\tif(x == y){\n\t\t\t\theap = remove(heap);\n\t\t\t\theap2 = remove(heap2);\n\t\t\t}\n\t\t\telse if(x > y){\n\t\t\t\theap2 = remove(heap2);\n\t\t\t}\n\t\t\telse{\n\t\t\t\theap = remove(heap);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tif(heap.length == 0){\n\t\t\tSystem.out.println(\"Player 2 wins\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Player 1 wins\");\n\t\t}\n\t}\n\tpublic static int[] remove(int[] heap){\n\t\tint[] newHeap = new int[heap.length-1];\n\t\tfor(int i = 0; i < heap.length-1; i++){\n\t\t\tnewHeap[i] = heap[i+1];\n\t\t}\n\t\treturn newHeap;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] heap = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap[i] = in.nextInt();\n\t\t}\n\t\tint[] heap2 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap2[i] = in.nextInt();\n\t\t}\n\t\tint[] heap3 = new int[n+m];\n\t\tfor(int i = 0; i < n+m; i++){\n\t\t\theap3[i] = 0;\n\t\t}\n\t\tint j = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap3[i] = heap[i];\n\t\t}\n\t\tfor(int i = n; i < n+m; i++){\n\t\t\theap3[i] = heap2[j];\n\t\t\tj++;\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n+m; i++){\n\t\t\tif(heap3[i] == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count == n+m){\n\t\t\tSystem.out.println(\"Draw\");\n\t\t}\n\t\telse if(count > n){\n\t\t\tSystem.out.println(\"Second\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"First\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[] heap = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap[i] = in.nextInt();\n\t\t}\n\t\tint[] stone = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstone[i] = in.nextInt();\n\t\t}\n\t\tint[] heap_copy = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\theap_copy[i] = heap[i];\n\t\t}\n\t\tint[] stone_copy = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tstone_copy[i] = stone[i];\n\t\t}\n\t\tint count = 0;\n\t\tint count_copy = 0;\n\t\tint count_stone = 0;\n\t\tint count_heap = 0;\n\t\tint count_heap_copy = 0;\n\t\tint count_stone_copy = 0;\n\t\tint count_stone_copy_copy = 0;\n\t\tint count_heap_copy_copy = 0;\n\t\tint count_heap_copy_copy_copy = 0;\n\t\tint count_heap_copy_copy_copy_copy = 0;\n\t\tint count_heap_copy_copy_copy_copy_copy = 0;\n\t\tint count_heap_copy_copy_copy_copy_copy_copy = 0;\n\t\tint count_heap_copy_copy_copy_copy_copy_copy_copy = 0;\n\t\tint count_heap_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n\t\tint count_heap_copy_copy_copy_copy_copy_copy_copy_copy_copy = 0;\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint[] stones = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstones[i] = i+1;\n\t\t}\n\t\tint[] heap = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap[i] = stones[i];\n\t\t}\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n && j < m){\n\t\t\tif(stones[i] < heap[j]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(i == n){\n\t\t\tSystem.out.println(\"Nim\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Bob\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint[] stones = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstones[i] = i+1;\n\t\t}\n\t\tint[] heap = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap[i] = stones[i];\n\t\t}\n\t\tint count = 0;\n\t\twhile(count < n){\n\t\t\tint i = 0;\n\t\t\twhile(i < m){\n\t\t\t\tif(heap[i] == stones[count]){\n\t\t\t\t\theap[i] = 0;\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif(count == n){\n\t\t\tSystem.out.println(\"Player 1 wins\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Player 2 wins\");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint m = Integer.parseInt(args[1]);\n\t\tint[] stones = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tstones[i] = i+1;\n\t\t}\n\t\tint[] heap = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap[i] = i+1;\n\t\t}\n\t\tint[] heap2 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap2[i] = i+1;\n\t\t}\n\t\tint[] heap3 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap3[i] = i+1;\n\t\t}\n\t\tint[] heap4 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap4[i] = i+1;\n\t\t}\n\t\tint[] heap5 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap5[i] = i+1;\n\t\t}\n\t\tint[] heap6 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap6[i] = i+1;\n\t\t}\n\t\tint[] heap7 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap7[i] = i+1;\n\t\t}\n\t\tint[] heap8 = new int[m];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\theap8[i] = i+1;\n\t\t}\n\t\tint[] heap9 = new int[m];\n\t\tfor(int i = 0; i\n"
    ],
    "results": 10
},{
    "id": "2090",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.",
    "snippets": [
        "\tint numOfPeople(int n){\n\t\tint[] dp = new int[n+1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tdp[i] = (dp[i-1] + dp[i-2]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tstatic int numberOfPeople(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint peopleIndex(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint finalPrep(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint numFriendRequests(int[] ages) {\n\t\tint[] count = new int[121];\n\t\tfor(int age: ages){\n\t\t\tcount[age]++;\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i = 0; i < 121; i++){\n\t\t\tfor(int j = i; j < 121; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(j - i > 20) break;\n\t\t\t\tif(j - i < 6) continue;\n\t\t\t\tif(i > j) continue;\n\t\t\t\tres += (count[i] * count[j]);\n\t\t\t\tres %= 1000000007;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint numWays(int n) {\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return 2;\n\t\tint[] dp = new int[n+1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 2;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tdp[i] = (dp[i-1] + dp[i-2]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint numWays(int n) {\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return 2;\n\t\tif(n == 2) return 4;\n\t\tint[] dp = new int[n+1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 2;\n\t\tdp[2] = 4;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % 1000000007;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2091",
    "source": "leetcode",
    "language": "java",
    "query": "We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row. Each glass holds one cup of champagne. When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] glasses = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tint current = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tcurrent += glasses[i];\n\t\t\tglasses[i] = total - current;\n\t\t}\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tSystem.out.println(glasses[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] glasses = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] glasses = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tint current = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tcurrent += glasses[i];\n\t\t\tglasses[i] = current;\n\t\t}\n\t\tint total2 = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal2 += glasses[i];\n\t\t}\n\t\tSystem.out.println(total2);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] glasses = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tcount += glasses[i];\n\t\t\tglasses[i] = count;\n\t\t}\n\t\tint[] glasses2 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses2[i] = glasses[i];\n\t\t}\n\t\tint[] glasses3 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses3[i] = glasses2[i];\n\t\t}\n\t\tint[] glasses4 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses4[i] = glasses3[i];\n\t\t}\n\t\tint[] glasses5 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses5[i] = glasses4[i];\n\t\t}\n\t\tint[] glasses6 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses6[i] = glasses5[i];\n\t\t}\n\t\tint[] glasses7 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses7[i] = glasses6[i];\n\t\t}\n\t\tint[] glasses8 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses8[i] = glasses7[i];\n\t\t}\n\t\tint\n",
        "\tstatic void main(String[] args){\n\t\tint[] glasses = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tint current = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tcurrent += glasses[i];\n\t\t\tglasses[i] = current;\n\t\t}\n\t\tint[] glasses2 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses2[i] = glasses[i];\n\t\t}\n\t\tint[] glasses3 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses3[i] = glasses[i];\n\t\t}\n\t\tint[] glasses4 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses4[i] = glasses[i];\n\t\t}\n\t\tint[] glasses5 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses5[i] = glasses[i];\n\t\t}\n\t\tint[] glasses6 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses6[i] = glasses[i];\n\t\t}\n\t\tint[] glasses7 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses7[i] = glasses[i];\n\t\t}\n\t\tint[] glasses8 = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses8[i] = glasses[i];\n\t\t}\n\t\tint[] glasses9 = new int\n",
        "\tstatic void main(String[] args){\n\t\tint[] glasses = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tint current = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tcurrent += glasses[i];\n\t\t\tglasses[i] = current;\n\t\t}\n\t\tint total2 = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal2 += glasses[i];\n\t\t}\n\t\tSystem.out.println(total);\n\t\tSystem.out.println(total2);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] glasses = new int[100];\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tint current = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\tcurrent += glasses[i];\n\t\t\tglasses[i] = current;\n\t\t}\n\t\tint total_glasses = 0;\n\t\tfor(int i = 0; i < 100; i++){\n\t\t\ttotal_glasses += glasses[i];\n\t\t}\n\t\tSystem.out.println(total_glasses);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 100;\n\t\tint[] glasses = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tglasses[i] = i + 1;\n\t\t}\n\t\tint total = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttotal += glasses[i];\n\t\t}\n\t\tint total_left = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttotal_left += glasses[i];\n\t\t\tglasses[i] = total - total_left;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(glasses[i]);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2092",
    "source": "leetcode",
    "language": "java",
    "query": "A string is called palindrome if is one that reads the same backward as well as forward. You are given a string s consisting only of letters 'a' and 'b' In a single step you can remove one palindromic sequence from s.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString s = \"aabaa\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removePalindrome(s));\n\t}\n\tpublic static String removePalindrome(String s){\n\t\tif(s.length() == 0) return \"\";\n\t\tif(s.length() == 1) return \"\";\n\t\tif(s.length() == 2) return \"\";\n\t\tif(s.length() == 3) return \"\";\n\t\tif(s.length() == 4) return \"\";\n\t\tif(s.length() == 5) return \"\";\n\t\tif(s.length() == 6) return \"\";\n\t\tif(s.length() == 7) return \"\";\n\t\tif(s.length() == 8) return \"\";\n\t\tif(s.length() == 9) return \"\";\n\t\tif(s.length() == 10) return \"\";\n\t\tif(s.length() == 11) return \"\";\n\t\tif(s.length() == 12) return \"\";\n\t\tif(s.length() == 13) return \"\";\n\t\tif(s.length() == 14) return \"\";\n\t\tif(s.length() == 15) return \"\";\n\t\tif(s.length() == 16) return \"\";\n\t\tif(s.length() == 17) return \"\";\n\t\tif(s.length() == 18) return \"\";\n\t\tif(s.length() == 19) return \"\";\n\t\tif(s.length() == 20) return \"\";\n\t\tif(s.length() == 21) return \"\";\n\t\tif(s.length() == 22) return \"\";\n\t\tif(s.length() == 23) return \"\";\n\t\tif(s.length() == 24) return \"\";\n\t\tif(s.length() == 25) return \"\";\n\t\tif(s.length() == 26) return \"\";\n\t\tif(s.length() == 27) return \"\";\n\t\tif(s.length() == 28) return \"\";\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"ababa\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removePalindrome(s));\n\t}\n\tpublic static String removePalindrome(String s){\n\t\tif(s.length() == 0) return \"\";\n\t\tif(s.length() == 1) return \"\";\n\t\tif(s.length() == 2) return s.charAt(0) == s.charAt(1) ? \"\" : s;\n\t\tif(s.charAt(0) == s.charAt(s.length() - 1)){\n\t\t\treturn removePalindrome(s.substring(1, s.length() - 1));\n\t\t}\n\t\treturn s;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"aabaa\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removePalindrome(s));\n\t}\n\tpublic static String removePalindrome(String s){\n\t\tif(s.length() == 0)\n\t\t\treturn \"\";\n\t\tif(s.length() == 1)\n\t\t\treturn \"\";\n\t\tif(s.length() == 2)\n\t\t\treturn \"\";\n\t\tif(s.length() == 3)\n\t\t\treturn \"\";\n\t\tif(s.length() == 4)\n\t\t\treturn \"\";\n\t\tif(s.length() == 5)\n\t\t\treturn \"\";\n\t\tif(s.length() == 6)\n\t\t\treturn \"\";\n\t\tif(s.length() == 7)\n\t\t\treturn \"\";\n\t\tif(s.length() == 8)\n\t\t\treturn \"\";\n\t\tif(s.length() == 9)\n\t\t\treturn \"\";\n\t\tif(s.length() == 10)\n\t\t\treturn \"\";\n\t\tif(s.length() == 11)\n\t\t\treturn \"\";\n\t\tif(s.length() == 12)\n\t\t\treturn \"\";\n\t\tif(s.length() == 13)\n\t\t\treturn \"\";\n\t\tif(s.length() == 14)\n\t\t\treturn \"\";\n\t\tif(s.length() == 15)\n\t\t\treturn \"\";\n\t\tif(s.length() == 16)\n\t\t\treturn \"\";\n\t\tif(s.length() == 17)\n\t\t\treturn \"\";\n\t\tif(s.length() == 18)\n\t\t\treturn \"\";\n\t\tif(s.length() == 19)\n\t\t\treturn \"\";\n\t\tif(s.length() == 20)\n\t\t\treturn \"\";\n\t\tif(s.length() == 21)\n\t\t\treturn \"\";\n\t\tif(s.length() == 22)\n\t\t\treturn \"\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"ababa\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removePalindrome(s));\n\t}\n\tpublic static String removePalindrome(String s){\n\t\tif(s.length() == 0) return \"\";\n\t\tif(s.length() == 1) return \"\";\n\t\tif(s.length() == 2) return \"\";\n\t\tif(s.length() == 3) return \"\";\n\t\tif(s.length() == 4) return \"\";\n\t\tif(s.length() == 5) return \"\";\n\t\tif(s.length() == 6) return \"\";\n\t\tif(s.length() == 7) return \"\";\n\t\tif(s.length() == 8) return \"\";\n\t\tif(s.length() == 9) return \"\";\n\t\tif(s.length() == 10) return \"\";\n\t\tif(s.length() == 11) return \"\";\n\t\tif(s.length() == 12) return \"\";\n\t\tif(s.length() == 13) return \"\";\n\t\tif(s.length() == 14) return \"\";\n\t\tif(s.length() == 15) return \"\";\n\t\tif(s.length() == 16) return \"\";\n\t\tif(s.length() == 17) return \"\";\n\t\tif(s.length() == 18) return \"\";\n\t\tif(s.length() == 19) return \"\";\n\t\tif(s.length() == 20) return \"\";\n\t\tif(s.length() == 21) return \"\";\n\t\tif(s.length() == 22) return \"\";\n\t\tif(s.length() == 23) return \"\";\n\t\tif(s.length() == 24) return \"\";\n\t\tif(s.length() == 25) return \"\";\n\t\tif(s.length() == 26) return \"\";\n\t\tif(s.length() == 27) return \"\";\n\t\tif(s.length() == 28) return \"\";\n",
        "\tstatic boolean isPalindrome(String s){\n\t\tint i=0;\n\t\tint j=s.length()-1;\n\t\twhile(i<j){\n\t\t\tif(s.charAt(i)!=s.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void main(String[] args){\n\t\tString s=\"ababa\";\n\t\tSystem.out.println(isPalindrome(s));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"ababab\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removePalindrome(s));\n\t}\n\tpublic static String removePalindrome(String s){\n\t\tif(s.length() == 0) return \"\";\n\t\tif(s.length() == 1) return \"\";\n\t\tif(s.length() == 2) return \"\";\n\t\tif(s.length() == 3) return \"\";\n\t\tif(s.length() == 4) return \"\";\n\t\tif(s.length() == 5) return \"\";\n\t\tif(s.length() == 6) return \"\";\n\t\tif(s.length() == 7) return \"\";\n\t\tif(s.length() == 8) return \"\";\n\t\tif(s.length() == 9) return \"\";\n\t\tif(s.length() == 10) return \"\";\n\t\tif(s.length() == 11) return \"\";\n\t\tif(s.length() == 12) return \"\";\n\t\tif(s.length() == 13) return \"\";\n\t\tif(s.length() == 14) return \"\";\n\t\tif(s.length() == 15) return \"\";\n\t\tif(s.length() == 16) return \"\";\n\t\tif(s.length() == 17) return \"\";\n\t\tif(s.length() == 18) return \"\";\n\t\tif(s.length() == 19) return \"\";\n\t\tif(s.length() == 20) return \"\";\n\t\tif(s.length() == 21) return \"\";\n\t\tif(s.length() == 22) return \"\";\n\t\tif(s.length() == 23) return \"\";\n\t\tif(s.length() == 24) return \"\";\n\t\tif(s.length() == 25) return \"\";\n\t\tif(s.length() == 26) return \"\";\n\t\tif(s.length() == 27) return \"\";\n\t\tif(s.length() == 28) return \"\";\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"ababab\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removePalindrome(s));\n\t}\n\tpublic static String removePalindrome(String s){\n\t\tif(s.length() == 0) return \"\";\n\t\tif(s.length() == 1) return \"\";\n\t\tif(s.length() == 2){\n\t\t\tif(s.charAt(0) == s.charAt(1)) return \"\";\n\t\t\telse return s;\n\t\t}\n\t\tif(s.charAt(0) == s.charAt(s.length()-1)){\n\t\t\treturn removePalindrome(s.substring(1, s.length()-1));\n\t\t}\n\t\telse{\n\t\t\treturn s.substring(1, s.length());\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"ababab\";\n\t\tSystem.out.println(s);\n\t\tSystem.out.println(removePalindrome(s));\n\t}\n\tpublic static String removePalindrome(String s){\n\t\tif(s.length() == 0) return \"\";\n\t\tif(s.length() == 1) return \"\";\n\t\tif(s.length() == 2){\n\t\t\tif(s.charAt(0) == s.charAt(1)) return \"\";\n\t\t\telse return s;\n\t\t}\n\t\tif(s.charAt(0) == s.charAt(s.length()-1)){\n\t\t\treturn removePalindrome(s.substring(1, s.length()-1));\n\t\t}\n\t\telse{\n\t\t\treturn s.substring(0, s.length()-1);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2093",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an array of n strings strs, all of the same length. We may choose any deletion indices, and we delete all the characters for each string. Return the minimum possible value of answer.length.",
    "snippets": [
        "\tint minDeletionSize(String[] strs) {\n\t\tint min = strs[0].length();\n\t\tfor(int i = 0; i < strs.length; i++){\n\t\t\tfor(int j = 0; j < strs[i].length(); j++){\n\t\t\t\tfor(int k = i + 1; k < strs.length; k++){\n\t\t\t\t\tif(strs[i].charAt(j) > strs[k].charAt(j)){\n\t\t\t\t\t\tmin = Math.min(min, strs[i].length() - j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minDeletionSize(String[] strs) {\n\t\tint min = strs[0].length();\n\t\tfor(int i = 0; i < strs[0].length(); i++){\n\t\t\tfor(int j = 0; j < strs.length; j++){\n\t\t\t\tif(strs[j].charAt(i) > strs[j+1].charAt(i)){\n\t\t\t\t\tmin = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minDeletionSize(String[] strs) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < strs[0].length(); i++) {\n\t\t\tchar[] ch = new char[strs.length];\n\t\t\tfor (int j = 0; j < strs.length; j++) {\n\t\t\t\tch[j] = strs[j].charAt(i);\n\t\t\t}\n\t\t\tArrays.sort(ch);\n\t\t\tfor (int j = 0; j < strs.length; j++) {\n\t\t\t\tif (ch[j] != strs[j].charAt(i)) {\n\t\t\t\t\tmin = Math.min(min, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minDeletionSize(String[] strs) {\n\t\tint min = 0;\n\t\tfor(int i = 0; i < strs[0].length(); i++){\n\t\t\tfor(int j = 0; j < strs.length; j++){\n\t\t\t\tfor(int k = j + 1; k < strs.length; k++){\n\t\t\t\t\tif(strs[j].charAt(i) > strs[k].charAt(i)){\n\t\t\t\t\t\tmin++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minDeletionSize(String[] strs) {\n\t\tint min = 0;\n\t\tfor(int i = 0; i < strs[0].length(); i++){\n\t\t\tfor(int j = 0; j < strs.length; j++){\n\t\t\t\tif(strs[j].charAt(i) > strs[j+1].charAt(i)){\n\t\t\t\t\tmin++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2094",
    "source": "leetcode",
    "language": "java",
    "query": "Given a positive integer n, you can apply one of the following operations. If n is even, replace n with n / 2 or n + 1 or n - 1. Return the minimum number of operations needed for n to become 1.",
    "snippets": [
        "\tint minOperations(int n) {\n\t\tint count = 0;\n\t\twhile(n != 1){\n\t\t\tif(n % 2 == 0){\n\t\t\t\tn = n / 2;\n\t\t\t}else{\n\t\t\t\tn = n + 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int n) {\n\t\tint count = 0;\n\t\twhile(n != 1){\n\t\t\tif(n % 2 == 0){\n\t\t\t\tn = n / 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tn = n - 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2095",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.",
    "snippets": [
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint n = nums.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = i;\n\t\t\twhile (left[i] > 0 && Math.abs(nums[i] - nums[left[i] - 1]) <= limit) {\n\t\t\t\tleft[i]--;\n\t\t\t}\n\t\t\tres = Math.max(res, i - left[i] + 1);\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tright[i] = i;\n\t\t\twhile (right[i] < n - 1 && Math.abs(nums[i] - nums[right[i] + 1]) <= limit) {\n\t\t\t\tright[i]++;\n\t\t\t}\n\t\t\tres = Math.max(res, right[i] - i + 1);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint n = nums.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = i;\n\t\t\twhile (left[i] > 0 && Math.abs(nums[i] - nums[left[i] - 1]) <= limit) {\n\t\t\t\tleft[i]--;\n\t\t\t}\n\t\t\tans = Math.max(ans, i - left[i] + 1);\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tright[i] = i;\n\t\t\twhile (right[i] < n - 1 && Math.abs(nums[i] - nums[right[i] + 1]) <= limit) {\n\t\t\t\tright[i]++;\n\t\t\t}\n\t\t\tans = Math.max(ans, right[i] - i + 1);\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint n = nums.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = i;\n\t\t\twhile (left[i] > 0 && nums[i] - nums[left[i] - 1] > limit) {\n\t\t\t\tleft[i] = left[left[i] - 1];\n\t\t\t}\n\t\t\tans = Math.max(ans, i - left[i] + 1);\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tright[i] = i;\n\t\t\twhile (right[i] < n - 1 && nums[right[i] + 1] - nums[i] > limit) {\n\t\t\t\tright[i] = right[right[i] + 1];\n\t\t\t}\n\t\t\tans = Math.max(ans, right[i] - i + 1);\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint n = nums.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tleft[i] = i;\n\t\t\twhile(left[i] > 0 && nums[left[i]-1] > nums[i] && nums[left[i]-1] - nums[i] <= limit){\n\t\t\t\tleft[i]--;\n\t\t\t}\n\t\t\tmax = Math.max(max, i - left[i] + 1);\n\t\t}\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tright[i] = i;\n\t\t\twhile(right[i] < n - 1 && nums[right[i]+1] > nums[i] && nums[right[i]+1] - nums[i] <= limit){\n\t\t\t\tright[i]++;\n\t\t\t}\n\t\t\tmax = Math.max(max, right[i] - i + 1);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint n = nums.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tint sum = 0;\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum += nums[i];\n\t\t\tleft[i] = sum;\n\t\t}\n\t\tsum = 0;\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tsum += nums[i];\n\t\t\tright[i] = sum;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint diff = Math.abs(left[i] - right[j]);\n\t\t\t\tif (diff <= limit) {\n\t\t\t\t\tres = Math.max(res, j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint n = nums.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = 1;\n\t\t\tright[i] = 1;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (Math.abs(nums[i] - nums[j]) <= limit) {\n\t\t\t\t\tleft[i] = Math.max(left[i], left[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tfor (int j = n - 1; j > i; j--) {\n\t\t\t\tif (Math.abs(nums[i] - nums[j]) <= limit) {\n\t\t\t\t\tright[i] = Math.max(right[i], right[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = Math.max(res, left[i] + right[i] - 1);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint max = 0;\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tint sum = 0;\n\t\twhile(right < nums.length){\n\t\t\tsum += nums[right];\n\t\t\twhile(sum > limit && left < right){\n\t\t\t\tsum -= nums[left];\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\tmax = Math.max(max, right - left + 1);\n\t\t\tright++;\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestSubarray(int[] nums, int limit) {\n\t\tint n = nums.length;\n\t\tint[] sums = new int[n];\n\t\tsums[0] = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tsums[i] = sums[i - 1] + nums[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tif (Math.abs(sums[j] - sums[i]) <= limit) {\n\t\t\t\t\tans = Math.max(ans, j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2096",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd. Return any answer array that satisfies this condition.",
    "snippets": [
        "\tint[] sortArray(int[] nums){\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = 0;\n\t\tfor(int k = 0; k < nums.length; k++){\n\t\t\tif(nums[k] % 2 == 0){\n\t\t\t\tres[i] = nums[k];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres[nums.length - 1 - j] = nums[k];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArray(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = 0;\n\t\tfor(int k = 0; k < nums.length; k++){\n\t\t\tif(nums[k] % 2 == 0){\n\t\t\t\tres[i++] = nums[k];\n\t\t\t}else{\n\t\t\t\tres[nums.length - 1 - j++] = nums[k];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArray(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = 0;\n\t\tfor (int k = 0; k < nums.length; k++) {\n\t\t\tif (nums[k] % 2 == 1) {\n\t\t\t\tres[i] = nums[k];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[nums.length - 1 - j] = nums[k];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArrayByParity(int[] A) {\n\t\tint[] B = new int[A.length];\n\t\tint i = 0, j = 0;\n\t\twhile(i < A.length && j < A.length){\n\t\t\tif(A[i] % 2 == 0){\n\t\t\t\tB[j] = A[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\twhile(i < A.length){\n\t\t\tB[j] = A[i];\n\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\treturn B;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2097",
    "source": "leetcode",
    "language": "java",
    "query": "A subarray is a contiguous subsequence of the array. Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.",
    "snippets": [
        "\tint maxProduct(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint tmp = max;\n\t\t\tmax = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);\n\t\t\tmin = Math.min(Math.min(tmp * nums[i], min * nums[i]), nums[i]);\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxProduct(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint temp = max;\n\t\t\tmax = Math.max(Math.max(max*nums[i], min*nums[i]), nums[i]);\n\t\t\tmin = Math.min(Math.min(temp*nums[i], min*nums[i]), nums[i]);\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2098",
    "source": "leetcode",
    "language": "java",
    "query": "An array nums of length n is beautiful if: nums is a permutation of the integers in the range [1, n]. For every 0 <= i < j < n, there is no index k with i < k < j. There will be at least one valid answer for the given n.",
    "snippets": [
        "\tboolean isBeautiful(int[] nums){\n\t\tint[] count = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tcount[nums[i] - 1]++;\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(count[i] != 1) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isBeautiful(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] count = new int[n + 1];\n\t\tfor (int num : nums) {\n\t\t\tcount[num]++;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (count[i] == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isBeautiful(int[] nums) {\n\t\tint[] count = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tcount[nums[i] - 1]++;\n\t\t}\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isBeautiful(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] count = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcount[nums[i]]++;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (count[i] != 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isBeautiful(int[] nums){\n\t\tint n = nums.length;\n\t\tint[] count = new int[n+1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[nums[i]]++;\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(count[i] == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isBeautiful(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 1; i++){\n\t\t\tif(nums[i] == nums[i + 1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2099",
    "source": "leetcode",
    "language": "java",
    "query": "Vertical area is an area of fixed-width extending infinitely along the y-axis. The widest vertical area is the one with the maximum width. Points on the edge of a vertical area are not considered included in the area.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] c = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] d = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] e = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] f = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] g = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] h = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] i = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] j = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] k = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] l = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] m = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] n = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] o = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] p = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] q = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] r = {1,2,3,\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5,6,7,8,9,10};\n\t\tint max = 0;\n\t\tint max_index = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(a[i] > max){\n\t\t\t\tmax = a[i];\n\t\t\t\tmax_index = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max_index);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9,10};\n\t\tint max = 0;\n\t\tint max_index = 0;\n\t\tint min = 0;\n\t\tint min_index = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t\tmax_index = i;\n\t\t\t}\n\t\t\tif(arr[i] < min){\n\t\t\t\tmin = arr[i];\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max_index - min_index);\n\t}\n}\n",
        "\tstatic int maxWidth(int[][] points){\n\t\tint max = 0;\n\t\tint n = points.length;\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx[i] = points[i][0];\n\t\t\ty[i] = points[i][1];\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tint left = 0;\n\t\tint right = 0;\n\t\twhile(right < n){\n\t\t\twhile(right < n && y[right] == y[right - 1]){\n\t\t\t\tright++;\n\t\t\t}\n\t\t\twhile(right < n && x[right] == x[right - 1]){\n\t\t\t\tright++;\n\t\t\t}\n\t\t\twhile(left < n && y[left] == y[left - 1]){\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\twhile(left < n && x[left] == x[left - 1]){\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\tmax = Math.max(max, right - left);\n\t\t\tright++;\n\t\t\tleft++;\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[][] points = {{1,1},{1,3},{3,1},{3,3}};\n\t\tSystem.out.println(new Clazz().maxArea(points));\n\t}\n\tpublic int maxArea(int[][] points){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < points.length; i++){\n\t\t\tfor(int j = i + 1; j < points.length; j++){\n\t\t\t\tint x1 = points[i][0];\n\t\t\t\tint y1 = points[i][1];\n\t\t\t\tint x2 = points[j][0];\n\t\t\t\tint y2 = points[j][1];\n\t\t\t\tint area = Math.abs(x1 - x2) * Math.abs(y1 - y2);\n\t\t\t\tif(area > max)\n\t\t\t\t\tmax = area;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxWidth(int[][] points){\n\t\tint max = 0;\n\t\tint[] x = new int[points.length];\n\t\tint[] y = new int[points.length];\n\t\tfor(int i = 0; i < points.length; i++){\n\t\t\tx[i] = points[i][0];\n\t\t\ty[i] = points[i][1];\n\t\t}\n\t\tArrays.sort(x);\n\t\tArrays.sort(y);\n\t\tint left = 0;\n\t\tint right = 0;\n\t\twhile(left < x.length && right < y.length){\n\t\t\tif(x[left] < y[right]){\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright++;\n\t\t\t}\n\t\t\tmax = Math.max(max, right - left);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxWidth(int[] A, int[] B, int[] C){\n\t\tint max = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < A.length && j < B.length && k < C.length){\n\t\t\tint a = A[i];\n\t\t\tint b = B[j];\n\t\t\tint c = C[k];\n\t\t\tint min = Math.min(a, Math.min(b, c));\n\t\t\tint max = Math.max(a, Math.max(b, c));\n\t\t\tint width = max - min;\n\t\t\tif(width > max){\n\t\t\t\tmax = width;\n\t\t\t}\n\t\t\tif(a < b && a < c){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(b < a && b < c){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(c < a && c < b){\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2100",
    "source": "leetcode",
    "language": "java",
    "query": "There is a programming language with only four operations and one variable X. The value of X is 0.",
    "snippets": [
        "\tvoid method(){\n\t\tint X = 0;\n\t\tX = X + 1;\n\t\tX = X - 1;\n\t\tX = X * 2;\n\t\tX = X / 2;\n\t}\n}\n",
        "\tvoid method(){\n\t\tX = X + 1;\n\t\tX = X - 1;\n\t\tX = X * 1;\n\t\tX = X / 1;\n\t}\n}\n",
        "\tint x = 0;\n\tpublic void inc(){\n\t\tx++;\n\t}\n\tpublic void dec(){\n\t\tx--;\n\t}\n\tpublic void print(){\n\t\tSystem.out.println(x);\n\t}\n}\n"
    ],
    "results": 4
},{
    "id": "2101",
    "source": "leetcode",
    "language": "java",
    "query": "A critical point in a linked list is defined as either a local maxima or a local minima. A node can only be a localmaxima if there exists both a previous node and a next node.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\n\t\tlist.add(1);\n\t\tlist.add(2);\n\t\tlist.add(3);\n\t\tlist.add(4);\n\t\tlist.add(5);\n\t\tlist.add(6);\n\t\tlist.add(7);\n\t\tlist.add(8);\n\t\tlist.add(9);\n\t\tlist.add(10);\n\t\tlist.add(11);\n\t\tlist.add(12);\n\t\tlist.add(13);\n\t\tlist.add(14);\n\t\tlist.add(15);\n\t\tlist.add(16);\n\t\tlist.add(17);\n\t\tlist.add(18);\n\t\tlist.add(19);\n\t\tlist.add(20);\n\t\tlist.add(21);\n\t\tlist.add(22);\n\t\tlist.add(23);\n\t\tlist.add(24);\n\t\tlist.add(25);\n\t\tlist.add(26);\n\t\tlist.add(27);\n\t\tlist.add(28);\n\t\tlist.add(29);\n\t\tlist.add(30);\n\t\tlist.add(31);\n\t\tlist.add(32);\n\t\tlist.add(33);\n\t\tlist.add(34);\n\t\tlist.add(35);\n\t\tlist.add(36);\n\t\tlist.add(37);\n\t\tlist.add(38);\n\t\tlist.add(39);\n\t\tlist.add(40);\n\t\tlist.add(41);\n\t\tlist.add(42);\n\t\tlist.add(43);\n\t\tlist.add(44);\n\t\tlist.add(45);\n\t\tlist.add(46);\n\t\tlist.add(47);\n\t\tlist.add(48);\n\t\tlist.add(49);\n\t\tlist.add(50);\n\t\tlist.add(51);\n\t\tlist.add(52);\n",
        "\tstatic void main(String[] args){\n\t\tNode head = new Node(1);\n\t\thead.next = new Node(2);\n\t\thead.next.next = new Node(3);\n\t\thead.next.next.next = new Node(4);\n\t\thead.next.next.next.next = new Node(5);\n\t\thead.next.next.next.next.next = new Node(6);\n\t\thead.next.next.next.next.next.next = new Node(7);\n\t\thead.next.next.next.next.next.next.next = new Node(8);\n\t\thead.next.next.next.next.next.next.next.next = new Node(9);\n\t\thead.next.next.next.next.next.next.next.next.next = new Node(10);\n\t\thead.next.next.next.next.next.next.next.next.next.next = new Node(11);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next = new Node(12);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next = new Node(13);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(14);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(15);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(16);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(17);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(18);\n",
        "\tNode findCriticalPoint(Node head){\n\t\tNode curr = head;\n\t\tNode prev = null;\n\t\tNode next = null;\n\t\twhile(curr != null){\n\t\t\tnext = curr.next;\n\t\t\tif(prev != null && next != null){\n\t\t\t\tif(prev.data < curr.data && curr.data < next.data){\n\t\t\t\t\treturn curr;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev = curr;\n\t\t\tcurr = curr.next;\n\t\t}\n\t\treturn null;\n\t}\n}\n",
        "\tstatic class Node{\n\t\tint data;\n\t\tNode next;\n\t\tNode(int data){\n\t\t\tthis.data=data;\n\t\t}\n\t}\n\tpublic static Node insert(Node head,int data){\n\t\tNode new_node=new Node(data);\n\t\tif(head==null){\n\t\t\thead=new_node;\n\t\t\treturn head;\n\t\t}\n\t\tNode temp=head;\n\t\twhile(temp.next!=null){\n\t\t\ttemp=temp.next;\n\t\t}\n\t\ttemp.next=new_node;\n\t\treturn head;\n\t}\n\tpublic static void printList(Node head){\n\t\tNode temp=head;\n\t\twhile(temp!=null){\n\t\t\tSystem.out.print(temp.data+\" \");\n\t\t\ttemp=temp.next;\n\t\t}\n\t}\n\tpublic static Node removeDuplicates(Node head){\n\t\tNode temp=head;\n\t\twhile(temp.next!=null){\n\t\t\tif(temp.data==temp.next.data){\n\t\t\t\ttemp.next=temp.next.next;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttemp=temp.next;\n\t\t\t}\n\t\t}\n\t\treturn head;\n\t}\n\tpublic static Node removeDuplicates2(Node head){\n\t\tNode temp=head;\n\t\twhile(temp!=null){\n\t\t\tNode runner=temp;\n\t\t\twhile(runner.next!=null){\n\t\t\t\tif(runner.next.data==temp.data){\n\t\t\t\t\trunner.next=runner.next.next;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trunner=runner.next;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttemp=temp.next;\n\t\t}\n\t\treturn head;\n\t}\n\tpublic static Node removeDuplicates3(Node head){\n\t\tNode temp=head;\n\t\twhile(temp!=null){\n",
        "\tClazz(int x){\n\t\tthis.x = x;\n\t}\n\tpublic int x;\n\tpublic Clazz next;\n\tpublic Clazz prev;\n}\n"
    ],
    "results": 10
},{
    "id": "2102",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed array nums consisting of n positive integers. You can choose an index i and change nums[i] into any positive integer.",
    "snippets": [
        "\tint firstMissingPositive(int[] nums) {\n\t\tint n = nums.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\twhile(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]){\n\t\t\t\tint temp = nums[nums[i] - 1];\n\t\t\t\tnums[nums[i] - 1] = nums[i];\n\t\t\t\tnums[i] = temp;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] != i + 1)\n\t\t\t\treturn i + 1;\n\t\t}\n\t\treturn n + 1;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < prices.length - 1; i++){\n\t\t\tif(prices[i] < prices[i + 1]){\n\t\t\t\tmax += prices[i + 1] - prices[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint[] nums;\n\tpublic Clazz(int[] nums){\n\t\tthis.nums = nums;\n\t}\n\tpublic int[] reset(){\n\t\treturn nums;\n\t}\n\tpublic int[] shuffle(){\n\t\tint[] newNums = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tnewNums[i] = nums[i];\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint j = (int)(Math.random()*nums.length);\n\t\t\tint temp = newNums[i];\n\t\t\tnewNums[i] = newNums[j];\n\t\t\tnewNums[j] = temp;\n\t\t}\n\t\treturn newNums;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2103",
    "source": "leetcode",
    "language": "java",
    "query": "There is an n x n grid, with the top-left cell at (0, 0) and the bottom-right cell at  (n - 1, n - 1) You are given the integer n and an integer array startPos where startPos = [startrow, startcol] indicates that a robot is initially at cell.",
    "snippets": [
        "\tint[] findPath(int n, int[] startPos){\n\t\tint[] res = new int[2];\n\t\tres[0] = startPos[0];\n\t\tres[1] = startPos[1];\n\t\treturn res;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 3;\n\t\tint[] startPos = {0, 0};\n\t\tint[] move = {0, 1};\n\t\tint[] move2 = {0, 2};\n\t\tint[] move3 = {1, 0};\n\t\tint[] move4 = {1, 1};\n\t\tint[] move5 = {1, 2};\n\t\tint[] move6 = {2, 0};\n\t\tint[] move7 = {2, 1};\n\t\tint[] move8 = {2, 2};\n\t\tint[] move9 = {3, 0};\n\t\tint[] move10 = {3, 1};\n\t\tint[] move11 = {3, 2};\n\t\tint[] move12 = {4, 0};\n\t\tint[] move13 = {4, 1};\n\t\tint[] move14 = {4, 2};\n\t\tint[] move15 = {5, 0};\n\t\tint[] move16 = {5, 1};\n\t\tint[] move17 = {5, 2};\n\t\tint[] move18 = {6, 0};\n\t\tint[] move19 = {6, 1};\n\t\tint[] move20 = {6, 2};\n\t\tint[] move21 = {7, 0};\n\t\tint[] move22 = {7, 1};\n\t\tint[] move23 = {7, 2};\n\t\tint[] move24 = {8, 0};\n\t\tint[] move25 = {8, 1};\n\t\tint[] move26 = {8, 2};\n\t\tint[] move27 = {9, 0};\n\t\tint[] move28 = {9, 1};\n\t\tint[] move29 = {9, 2};\n\t\tint[] move30 = {10, 0};\n\t\tint[] move31 = {10, 1};\n\t\tint[] move32 = {10, 2};\n\t\tint[] move33 = {11, 0};\n\t\tint[] move34 = {11, 1};\n\t\tint[] move35 = {11, 2};\n\t\tint[] move36 = {12, 0};\n",
        "\tstatic void main(String[] args){\n\t\tint n = 3;\n\t\tint[] startPos = {0, 0};\n\t\tint[] move = {0, 1};\n\t\tint[] move2 = {0, 2};\n\t\tint[] move3 = {1, 0};\n\t\tint[] move4 = {2, 0};\n\t\tint[] move5 = {2, 1};\n\t\tint[] move6 = {2, 2};\n\t\tint[] move7 = {1, 2};\n\t\tint[] move8 = {1, 1};\n\t\tint[] move9 = {0, 2};\n\t\tint[] move10 = {0, 1};\n\t\tint[] move11 = {1, 1};\n\t\tint[] move12 = {1, 2};\n\t\tint[] move13 = {2, 2};\n\t\tint[] move14 = {2, 1};\n\t\tint[] move15 = {2, 0};\n\t\tint[] move16 = {1, 0};\n\t\tint[] move17 = {0, 0};\n\t\tint[] move18 = {0, 1};\n\t\tint[] move19 = {1, 1};\n\t\tint[] move20 = {1, 2};\n\t\tint[] move21 = {2, 2};\n\t\tint[] move22 = {2, 1};\n\t\tint[] move23 = {2, 0};\n\t\tint[] move24 = {1, 0};\n\t\tint[] move25 = {0, 0};\n\t\tint[] move26 = {0, 1};\n\t\tint[] move27 = {1, 1};\n\t\tint[] move28 = {1, 2};\n\t\tint[] move29 = {2, 2};\n\t\tint[] move30 = {2, 1};\n\t\tint[] move31 = {2, 0};\n\t\tint[] move32 = {1, 0};\n\t\tint[] move33 = {0, 0};\n\t\tint[] move34 = {0, 1};\n\t\tint[] move35 = {1, 1};\n\t\tint[] move36 = {1, 2};\n",
        "\tstatic void main(String[] args){\n\t\tint n = 3;\n\t\tint[] startPos = {0, 0};\n\t\tint[] movePos = {0, 1};\n\t\tint[] endPos = {2, 2};\n\t\tSystem.out.println(robotPath(n, startPos, movePos, endPos));\n\t}\n\tpublic static int robotPath(int n, int[] startPos, int[] movePos, int[] endPos){\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tdp[startPos[0]][startPos[1]] = 1;\n\t\treturn dfs(n, startPos, movePos, endPos, dp);\n\t}\n\tpublic static int dfs(int n, int[] startPos, int[] movePos, int[] endPos, int[][] dp){\n\t\tif(startPos[0] == endPos[0] && startPos[1] == endPos[1]){\n\t\t\treturn dp[endPos[0]][endPos[1]];\n\t\t}\n\t\tint x = startPos[0];\n\t\tint y = startPos[1];\n\t\tint[] nextPos = new int[2];\n\t\tnextPos[0] = x + movePos[0];\n\t\tnextPos[1] = y + movePos[1];\n\t\tif(nextPos[0] < 0 || nextPos[0] >= n || nextPos[1] < 0 || nextPos[1] >= n || dp[nextPos[0]][nextPos[1]] == -1){\n\t\t\treturn 0;\n\t\t}\n\t\treturn dp[nextPos[0]][nextPos[1]] + dfs(n, nextPos, movePos, endPos, dp);\n\t}\n}\n",
        "\tint[][] robot(int n, int[] startPos){\n\t\tint[][] grid = new int[n][n];\n\t\tint row = startPos[0];\n\t\tint col = startPos[1];\n\t\tint[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\t\tint dir = 0;\n\t\tint count = 0;\n\t\twhile(count < n * n){\n\t\t\tgrid[row][col] = count + 1;\n\t\t\tint nextRow = row + dirs[dir][0];\n\t\t\tint nextCol = col + dirs[dir][1];\n\t\t\tif(nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || grid[nextRow][nextCol] != 0){\n\t\t\t\tdir = (dir + 1) % 4;\n\t\t\t}\n\t\t\trow += dirs[dir][0];\n\t\t\tcol += dirs[dir][1];\n\t\t\tcount++;\n\t\t}\n\t\treturn grid;\n\t}\n}\n",
        "\tstatic void move(int n, int[] startPos){\n\t\tint row = startPos[0];\n\t\tint col = startPos[1];\n\t\tint[][] grid = new int[n][n];\n\t\tint count = 1;\n\t\tgrid[row][col] = count;\n\t\twhile(count < n*n){\n\t\t\tcount++;\n\t\t\tif(row == 0 && col == n - 1){\n\t\t\t\trow++;\n\t\t\t\tcol--;\n\t\t\t}\n\t\t\telse if(row == n - 1 && col == n - 1){\n\t\t\t\trow--;\n\t\t\t\tcol--;\n\t\t\t}\n\t\t\telse if(row == n - 1 && col == 0){\n\t\t\t\trow--;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t\telse if(row == 0 && col == 0){\n\t\t\t\trow++;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t\telse if(row == 0){\n\t\t\t\trow++;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t\telse if(row == n - 1){\n\t\t\t\trow--;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t\telse if(col == 0){\n\t\t\t\trow--;\n\t\t\t\tcol++;\n\t\t\t}\n\t\t\telse if(col == n - 1){\n\t\t\t\trow++;\n\t\t\t\tcol--;\n\t\t\t}\n\t\t\tgrid[row][col] = count;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tSystem.out.print(grid[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tint n = 5;\n\t\tint[] startPos = {0, 0};\n\t\tmove(n, startPos);\n",
        "\tstatic void main(String[] args){\n\t\tint n = 3;\n\t\tint[] startPos = {0, 0};\n\t\tint[] moves = {2, -1};\n\t\tSystem.out.println(robotSim(n, startPos, moves));\n\t}\n\tpublic static int robotSim(int n, int[] startPos, int[] moves) {\n\t\tint[][] grid = new int[n][n];\n\t\tint x = startPos[0];\n\t\tint y = startPos[1];\n\t\tint res = 0;\n\t\tfor(int i = 0; i < moves.length; i++){\n\t\t\tint dir = moves[i];\n\t\t\tif(dir == -1){\n\t\t\t\tx--;\n\t\t\t}else if(dir == 1){\n\t\t\t\tx++;\n\t\t\t}else if(dir == -2){\n\t\t\t\ty--;\n\t\t\t}else if(dir == 2){\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tif(x < 0 || x >= n || y < 0 || y >= n){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tres += grid[x][y];\n\t\t\tgrid[x][y]++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[][] robot(int n, int[] startPos) {\n\t\tint[][] res = new int[n][n];\n\t\tint row = startPos[0];\n\t\tint col = startPos[1];\n\t\tint[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\t\tint d = 0;\n\t\tfor(int i = 0; i < n * n; i++){\n\t\t\tres[row][col] = i + 1;\n\t\t\tint nextRow = row + dir[d][0];\n\t\t\tint nextCol = col + dir[d][1];\n\t\t\tif(nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || res[nextRow][nextCol] != 0){\n\t\t\t\td = (d + 1) % 4;\n\t\t\t}\n\t\t\trow += dir[d][0];\n\t\t\tcol += dir[d][1];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tvoid move(int[][] grid, int[] startPos){\n\t\tint n = grid.length;\n\t\tint[] curPos = startPos;\n\t\tint[] nextPos = new int[2];\n\t\twhile(true){\n\t\t\tnextPos = getNextPos(grid, curPos);\n\t\t\tif(nextPos[0] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurPos = nextPos;\n\t\t}\n\t}\n\t\n\tpublic\n\tint[] getNextPos(int[][] grid, int[] curPos){\n\t\tint[] nextPos = new int[2];\n\t\tint row = curPos[0];\n\t\tint col = curPos[1];\n\t\tif(row - 1 >= 0 && grid[row - 1][col] == 1){\n\t\t\tnextPos[0] = row - 1;\n\t\t\tnextPos[1] = col;\n\t\t\treturn nextPos;\n\t\t}\n\t\tif(row + 1 < grid.length && grid[row + 1][col] == 1){\n\t\t\tnextPos[0] = row + 1;\n\t\t\tnextPos[1] = col;\n\t\t\treturn nextPos;\n\t\t}\n\t\tif(col - 1 >= 0 && grid[row][col - 1] == 1){\n\t\t\tnextPos[0] = row;\n\t\t\tnextPos[1] = col - 1;\n\t\t\treturn nextPos;\n\t\t}\n\t\tif(col + 1 < grid.length && grid[row][col + 1] == 1){\n\t\t\tnextPos[0] = row;\n\t\t\tnextPos[1] = col + 1;\n\t\t\treturn nextPos;\n\t\t}\n\t\tnextPos[0] = -1;\n\t\tnextPos[1] = -1;\n\t\treturn nextPos;\n\t}\n}\n",
        "\tint[][] robot(int n, int[] startPos) {\n\t\tint[][] grid = new int[n][n];\n\t\tint[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\t\tint row = startPos[0];\n\t\tint col = startPos[1];\n\t\tint direction = 0;\n\t\tint count = 0;\n\t\twhile(count < n * n){\n\t\t\tgrid[row][col] = count + 1;\n\t\t\trow += directions[direction][0];\n\t\t\tcol += directions[direction][1];\n\t\t\tif(row < 0 || row >= n || col < 0 || col >= n){\n\t\t\t\tdirection = (direction + 1) % 4;\n\t\t\t\trow += directions[direction][0];\n\t\t\t\tcol += directions[direction][1];\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn grid;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2104",
    "source": "leetcode",
    "language": "java",
    "query": "Test cases are generated such that digit occurs at least once in number. Return the resulting string after removing exactly one occurrence of digit.",
    "snippets": [
        "\tString removeDigit(String str, char digit){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\tif(str.charAt(i) != digit){\n\t\t\t\tsb.append(str.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeDigit(String num, char digit){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < num.length(); i++){\n\t\t\tif(num.charAt(i) != digit){\n\t\t\t\tsb.append(num.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeDigit(String number, char digit){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < number.length(); i++){\n\t\t\tif(number.charAt(i) != digit){\n\t\t\t\tsb.append(number.charAt(i));\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeDigit(String num, char digit){\n\t\tStringBuilder sb = new StringBuilder(num);\n\t\tint index = sb.indexOf(digit);\n\t\tif(index == -1){\n\t\t\treturn num;\n\t\t}\n\t\tsb.deleteCharAt(index);\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString removeDigit(String num, char digit){\n\t\tStringBuilder sb = new StringBuilder(num);\n\t\tint index = sb.indexOf(digit);\n\t\tif(index == -1) return num;\n\t\tsb.deleteCharAt(index);\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2105",
    "source": "leetcode",
    "language": "java",
    "query": "The test cases are generated such that there are no cycles anywhere in the entire linked structure. Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.",
    "snippets": [
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode curA = headA;\n\t\tNode curB = headB;\n\t\tint lenA = 0;\n\t\tint lenB = 0;\n\t\twhile(curA != null){\n\t\t\tlenA++;\n\t\t\tcurA = curA.next;\n\t\t}\n\t\twhile(curB != null){\n\t\t\tlenB++;\n\t\t\tcurB = curB.next;\n\t\t}\n\t\tint diff = Math.abs(lenA - lenB);\n\t\tif(lenA > lenB){\n\t\t\tcurA = headA;\n\t\t\tcurB = headB;\n\t\t}else{\n\t\t\tcurA = headB;\n\t\t\tcurB = headA;\n\t\t}\n\t\tfor(int i = 0; i < diff; i++){\n\t\t\tcurA = curA.next;\n\t\t}\n\t\twhile(curA != curB){\n\t\t\tcurA = curA.next;\n\t\t\tcurB = curB.next;\n\t\t}\n\t\treturn curA;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode p1 = headA;\n\t\tNode p2 = headB;\n\t\tint len1 = 0;\n\t\tint len2 = 0;\n\t\twhile(p1 != null){\n\t\t\tlen1++;\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p2 != null){\n\t\t\tlen2++;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\tint diff = Math.abs(len1 - len2);\n\t\tif(len1 > len2){\n\t\t\tp1 = headA;\n\t\t\tp2 = headB;\n\t\t}else{\n\t\t\tp1 = headB;\n\t\t\tp2 = headA;\n\t\t}\n\t\tfor(int i = 0; i < diff; i++){\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p1 != p2){\n\t\t\tp1 = p1.next;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\treturn p1;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode p1 = headA;\n\t\tNode p2 = headB;\n\t\tint lenA = 0;\n\t\tint lenB = 0;\n\t\twhile(p1 != null){\n\t\t\tlenA++;\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p2 != null){\n\t\t\tlenB++;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\tint diff = Math.abs(lenA - lenB);\n\t\tif(lenA > lenB){\n\t\t\tp1 = headA;\n\t\t\tp2 = headB;\n\t\t}else{\n\t\t\tp1 = headB;\n\t\t\tp2 = headA;\n\t\t}\n\t\tfor(int i = 0; i < diff; i++){\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p1 != p2){\n\t\t\tp1 = p1.next;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\treturn p1;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode p1 = headA;\n\t\tNode p2 = headB;\n\t\tint lenA = 0;\n\t\tint lenB = 0;\n\t\twhile(p1 != null){\n\t\t\tlenA++;\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p2 != null){\n\t\t\tlenB++;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\tint diff = Math.abs(lenA - lenB);\n\t\tif(lenA > lenB){\n\t\t\tp1 = headA;\n\t\t\tp2 = headB;\n\t\t}\n\t\telse{\n\t\t\tp1 = headB;\n\t\t\tp2 = headA;\n\t\t}\n\t\twhile(diff-- > 0) p1 = p1.next;\n\t\twhile(p1 != p2){\n\t\t\tp1 = p1.next;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\treturn p1;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode p1 = headA;\n\t\tNode p2 = headB;\n\t\tint len1 = 0;\n\t\tint len2 = 0;\n\t\twhile(p1 != null){\n\t\t\tlen1++;\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p2 != null){\n\t\t\tlen2++;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\tint diff = Math.abs(len1 - len2);\n\t\tif(len1 > len2){\n\t\t\tp1 = headA;\n\t\t\tp2 = headB;\n\t\t}else{\n\t\t\tp1 = headB;\n\t\t\tp2 = headA;\n\t\t}\n\t\twhile(diff-- > 0){\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p1 != p2){\n\t\t\tp1 = p1.next;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\treturn p1;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode p1 = headA;\n\t\tNode p2 = headB;\n\t\tint len1 = 0;\n\t\tint len2 = 0;\n\t\twhile(p1 != null){\n\t\t\tlen1++;\n\t\t\tp1 = p1.next;\n\t\t}\n\t\twhile(p2 != null){\n\t\t\tlen2++;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\tint diff = Math.abs(len1 - len2);\n\t\tif(len1 > len2){\n\t\t\tp1 = headA;\n\t\t\tp2 = headB;\n\t\t}else{\n\t\t\tp1 = headB;\n\t\t\tp2 = headA;\n\t\t}\n\t\twhile(diff > 0){\n\t\t\tp1 = p1.next;\n\t\t\tdiff--;\n\t\t}\n\t\twhile(p1 != p2){\n\t\t\tp1 = p1.next;\n\t\t\tp2 = p2.next;\n\t\t}\n\t\treturn p1;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode p1 = headA;\n\t\tNode p2 = headB;\n\t\twhile(p1 != p2){\n\t\t\tp1 = p1.next;\n\t\t\tp2 = p2.next;\n\t\t\tif(p1 == p2) return p1;\n\t\t\tif(p1 == null) p1 = headB;\n\t\t\tif(p2 == null) p2 = headA;\n\t\t}\n\t\treturn p1;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA == null || headB == null) return null;\n\t\tNode p = headA;\n\t\tNode q = headB;\n\t\twhile(p != q){\n\t\t\tp = p.next;\n\t\t\tq = q.next;\n\t\t\tif(p == q) return p;\n\t\t\tif(p == null) p = headB;\n\t\t\tif(q == null) q = headA;\n\t\t}\n\t\treturn p;\n\t}\n}\n",
        "\tNode getIntersectionNode(Node headA, Node headB) {\n\t\tif(headA==null||headB==null) return null;\n\t\tNode pA=headA;\n\t\tNode pB=headB;\n\t\twhile(pA!=pB){\n\t\t\tpA=pA.next;\n\t\t\tpB=pB.next;\n\t\t\tif(pA==pB) return pA;\n\t\t\tif(pA==null){\n\t\t\t\tpA=headB;\n\t\t\t}\n\t\t\tif(pB==null){\n\t\t\t\tpB=headA;\n\t\t\t}\n\t\t}\n\t\treturn pA;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2106",
    "source": "leetcode",
    "language": "java",
    "query": "Return the kth positive integer that is missing from this array. Given an array of positive integers sorted in a strictly increasing order, and an integer k.",
    "snippets": [
        "\tint missing(int[] array, int k){\n\t\tint i = 0;\n\t\tint j = array.length - 1;\n\t\twhile(i < j){\n\t\t\tint mid = (i + j) / 2;\n\t\t\tif(array[mid] == mid + k){\n\t\t\t\ti = mid + 1;\n\t\t\t}else{\n\t\t\t\tj = mid;\n\t\t\t}\n\t\t}\n\t\treturn i + k;\n\t}\n}\n",
        "\tint missing(int[] array, int k){\n\t\tint i = 0;\n\t\tint j = array.length - 1;\n\t\twhile(i < j){\n\t\t\tint mid = (i + j) / 2;\n\t\t\tif(array[mid] == mid + k)\n\t\t\t\ti = mid + 1;\n\t\t\telse\n\t\t\t\tj = mid;\n\t\t}\n\t\treturn i + k;\n\t}\n}\n",
        "\tint missing(int[] a, int k){\n\t\tint i = 0;\n\t\tint j = a.length - 1;\n\t\twhile(i < j){\n\t\t\tint mid = (i + j) / 2;\n\t\t\tif(a[mid] == mid + k){\n\t\t\t\ti = mid + 1;\n\t\t\t}else{\n\t\t\t\tj = mid;\n\t\t\t}\n\t\t}\n\t\treturn i + k;\n\t}\n}\n",
        "\tint findKthPositive(int[] A, int k){\n\t\tint i = 0;\n\t\tint j = A.length - 1;\n\t\twhile(i < j){\n\t\t\tint mid = (i + j) / 2;\n\t\t\tif(A[mid] > k)\n\t\t\t\tj = mid;\n\t\t\telse\n\t\t\t\ti = mid + 1;\n\t\t}\n\t\treturn A[i] > k ? A[i] : k;\n\t}\n}\n",
        "\tint missing(int[] array, int k){\n\t\tint i = 0;\n\t\tint j = array.length - 1;\n\t\tint mid = 0;\n\t\twhile(i < j){\n\t\t\tmid = (i + j) / 2;\n\t\t\tif(array[mid] == mid + k){\n\t\t\t\ti = mid + 1;\n\t\t\t}else{\n\t\t\t\tj = mid;\n\t\t\t}\n\t\t}\n\t\treturn i + k;\n\t}\n}\n",
        "\tint missing(int[] a, int k) {\n\t\tint n = a.length;\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile (i < j) {\n\t\t\tint m = (i + j) / 2;\n\t\t\tif (a[m] - a[i] - (m - i) > k) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\treturn a[i] + k - (i - 1);\n\t}\n}\n",
        "\tint missing(int[] a, int k){\n\t\tint n = a.length;\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile(i < j){\n\t\t\tint mid = (i + j) / 2;\n\t\t\tif(a[mid] == k + mid)\n\t\t\t\ti = mid + 1;\n\t\t\telse\n\t\t\t\tj = mid;\n\t\t}\n\t\treturn k + i;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2107",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of aNon-Zero area, return 0.",
    "snippets": [
        "\tint largestPerimeter(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint max = 0;\n\t\tfor (int i = nums.length - 1; i >= 2; i--) {\n\t\t\tif (nums[i - 1] + nums[i - 2] > nums[i]) {\n\t\t\t\tmax = Math.max(max, nums[i] + nums[i - 1] + nums[i - 2]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint largestPerimeter(int[] A) {\n\t\tArrays.sort(A);\n\t\tint max = 0;\n\t\tfor (int i = A.length - 1; i >= 2; i--) {\n\t\t\tif (A[i - 1] + A[i - 2] > A[i]) {\n\t\t\t\tmax = Math.max(max, A[i] + A[i - 1] + A[i - 2]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint largestPerimeter(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint max = 0;\n\t\tfor(int i = nums.length - 1; i >= 2; i--){\n\t\t\tif(nums[i] < nums[i - 1] + nums[i - 2]){\n\t\t\t\tmax = Math.max(max, nums[i] + nums[i - 1] + nums[i - 2]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint largestPerimeter(int[] A) {\n\t\tArrays.sort(A);\n\t\tint max = 0;\n\t\tfor (int i = A.length - 1; i >= 2; i--) {\n\t\t\tif (A[i - 1] + A[i - 2] > A[i]) {\n\t\t\t\tmax = A[i - 1] + A[i - 2] + A[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint largestPerimeter(int[] A) {\n\t\tArrays.sort(A);\n\t\tint max = 0;\n\t\tfor(int i = A.length - 1; i >= 2; i--){\n\t\t\tif(A[i] < A[i - 1] + A[i - 2]){\n\t\t\t\tmax = A[i] + A[i - 1] + A[i - 2];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint largestPerimeter(int[] A) {\n\t\tArrays.sort(A);\n\t\tint i = A.length - 1;\n\t\twhile (i >= 2) {\n\t\t\tif (A[i - 2] + A[i - 1] > A[i]) {\n\t\t\t\treturn A[i] + A[i - 1] + A[i - 2];\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint largestPerimeter(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tfor(int i = nums.length-1; i >= 2; i--){\n\t\t\tif(nums[i-1] + nums[i-2] > nums[i]){\n\t\t\t\treturn nums[i-1] + nums[i-2] + nums[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2108",
    "source": "leetcode",
    "language": "java",
    "query": "When a customer is paying, their bill is represented as two parallel integer arrays product and amount. The jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought.",
    "snippets": [
        "\tint[] product;\n\tint[] amount;\n\tpublic Clazz(int[] product, int[] amount){\n\t\tthis.product = product;\n\t\tthis.amount = amount;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] product = {1,2,3,4,5};\n\t\tint[] amount = {1,2,3,4,5};\n\t\tint[] product2 = {1,2,3,4,5};\n\t\tint[] amount2 = {1,2,3,4,5};\n\t\tint[] product3 = {1,2,3,4,5};\n\t\tint[] amount3 = {1,2,3,4,5};\n\t\tint[] product4 = {1,2,3,4,5};\n\t\tint[] amount4 = {1,2,3,4,5};\n\t\tint[] product5 = {1,2,3,4,5};\n\t\tint[] amount5 = {1,2,3,4,5};\n\t\tint[] product6 = {1,2,3,4,5};\n\t\tint[] amount6 = {1,2,3,4,5};\n\t\tint[] product7 = {1,2,3,4,5};\n\t\tint[] amount7 = {1,2,3,4,5};\n\t\tint[] product8 = {1,2,3,4,5};\n\t\tint[] amount8 = {1,2,3,4,5};\n\t\tint[] product9 = {1,2,3,4,5};\n\t\tint[] amount9 = {1,2,3,4,5};\n\t\tint[] product10 = {1,2,3,4,5};\n\t\tint[] amount10 = {1,2,3,4,5};\n\t\tint[] product11 = {1,2,3,4,5};\n\t\tint[] amount11 = {1,2,3,4,5};\n\t\tint[] product12 = {1,2,3,4,5};\n\t\tint[] amount12 = {1,2,3,4,5};\n\t\tint[] product13 = {1,2,3,4,5};\n\t\tint[] amount13 = {1,2,3,4,\n",
        "\tint[] product;\n\tint[] amount;\n\tpublic Clazz(int[] product, int[] amount){\n\t\tthis.product = product;\n\t\tthis.amount = amount;\n\t}\n\tpublic int[] getProduct(){\n\t\treturn product;\n\t}\n\tpublic int[] getAmount(){\n\t\treturn amount;\n\t}\n}\n",
        "\tstatic int[] product;\n\tstatic int[] amount;\n\tpublic static void main(String[] args){\n\t\tproduct = new int[]{1,2,3,4,5};\n\t\tamount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,4,5};\n\t\tint[] amount = new int[]{1,2,3,4,5};\n\t\tint[] product = new int[]{1,2,3,\n",
        "\tstatic void main(String[] args){\n\t\tint[] product = {1,2,3,4,5};\n\t\tint[] amount = {5,5,5,5,5};\n\t\tint[] product2 = {1,2,3,4,5};\n\t\tint[] amount2 = {5,5,5,5,5};\n\t\tint[] product3 = {1,2,3,4,5};\n\t\tint[] amount3 = {5,5,5,5,5};\n\t\tint[] product4 = {1,2,3,4,5};\n\t\tint[] amount4 = {5,5,5,5,5};\n\t\tint[] product5 = {1,2,3,4,5};\n\t\tint[] amount5 = {5,5,5,5,5};\n\t\tint[] product6 = {1,2,3,4,5};\n\t\tint[] amount6 = {5,5,5,5,5};\n\t\tint[] product7 = {1,2,3,4,5};\n\t\tint[] amount7 = {5,5,5,5,5};\n\t\tint[] product8 = {1,2,3,4,5};\n\t\tint[] amount8 = {5,5,5,5,5};\n\t\tint[] product9 = {1,2,3,4,5};\n\t\tint[] amount9 = {5,5,5,5,5};\n\t\tint[] product10 = {1,2,3,4,5};\n\t\tint[] amount10 = {5,5,5,5,5};\n\t\tint[] product11 = {1,2,3,4,5};\n\t\tint[] amount11 = {5,5,5,5,5};\n\t\tint[] product12 = {1,2,3,4,5};\n\t\tint[] amount12 = {5,5,5,5,5};\n\t\tint[] product13 = {1,2,3,4,5};\n\t\tint[] amount13 = {5,5,5,5,\n"
    ],
    "results": 10
},{
    "id": "2109",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.",
    "snippets": [
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tArrays.sort(nums);\n\t\treturn dfs(nums, nums.length - 1, k, target, 0, 0);\n\t}\n\tpublic boolean dfs(int[] nums, int index, int k, int target, int sum, int count) {\n\t\tif (count == k) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum == target) {\n\t\t\treturn dfs(nums, index, k, target, 0, count + 1);\n\t\t}\n\t\tif (index < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (dfs(nums, index - 1, k, target, sum + nums[index], count)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn dfs(nums, index - 1, k, target, sum, count);\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tArrays.sort(nums);\n\t\treturn dfs(nums, k, target, 0, 0, new int[k]);\n\t}\n\tprivate boolean dfs(int[] nums, int k, int target, int index, int sum, int[] subset) {\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum == target) {\n\t\t\treturn dfs(nums, k - 1, target, 0, 0, subset);\n\t\t}\n\t\tfor (int i = index; i < nums.length; i++) {\n\t\t\tif (sum + nums[i] > target) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsubset[k - 1] = nums[i];\n\t\t\tif (dfs(nums, k, target, i + 1, sum + nums[i], subset)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tArrays.sort(nums);\n\t\treturn dfs(nums, nums.length - 1, target, k, 0, 0);\n\t}\n\tpublic boolean dfs(int[] nums, int index, int target, int k, int sum, int count) {\n\t\tif (count == k) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum == target && dfs(nums, nums.length - 1, target, k, 0, count + 1)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (index < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (dfs(nums, index - 1, target, k, sum + nums[index], count)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn dfs(nums, index - 1, target, k, sum, count);\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tint[] dp = new int[target + 1];\n\t\tdp[0] = 1;\n\t\tfor (int num : nums) {\n\t\t\tfor (int i = target; i >= num; i--) {\n\t\t\t\tdp[i] |= dp[i - num];\n\t\t\t}\n\t\t}\n\t\treturn dp[target] != 0;\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tboolean[] visited = new boolean[nums.length];\n\t\treturn dfs(nums, visited, 0, 0, target);\n\t}\n\tpublic\n\tboolean dfs(int[] nums, boolean[] visited, int index, int sum, int target) {\n\t\tif (sum == target) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum > target) {\n\t\t\treturn false;\n\t\t}\n\t\tif (index == nums.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i = index; i < nums.length; i++) {\n\t\t\tif (!visited[i] && dfs(nums, visited, i + 1, sum + nums[i], target)) {\n\t\t\t\tvisited[i] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tArrays.sort(nums);\n\t\treturn dfs(nums, nums.length - 1, k, target, 0, 0);\n\t}\n\tprivate boolean dfs(int[] nums, int index, int k, int target, int sum, int count) {\n\t\tif (count == k) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum == target) {\n\t\t\treturn dfs(nums, index, k, target, 0, count + 1);\n\t\t}\n\t\tif (index < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (dfs(nums, index - 1, k, target, sum + nums[index], count)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (dfs(nums, index - 1, k, target, sum, count)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) return true;\n\t\tif (sum % k != 0) return false;\n\t\tint target = sum / k;\n\t\tboolean[] visited = new boolean[nums.length];\n\t\treturn dfs(nums, visited, 0, 0, target);\n\t}\n\tpublic boolean dfs(int[] nums, boolean[] visited, int index, int cur, int target) {\n\t\tif (cur == target) return dfs(nums, visited, 0, 0, target);\n\t\tif (cur > target) return false;\n\t\tif (index == nums.length) return true;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (visited[i]) continue;\n\t\t\tvisited[i] = true;\n\t\t\tif (dfs(nums, visited, index + 1, cur + nums[i], target)) return true;\n\t\t\tvisited[i] = false;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (k == 0 || sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tboolean[] visited = new boolean[nums.length];\n\t\treturn dfs(nums, visited, 0, 0, k, target);\n\t}\n\tpublic\n\tboolean dfs(int[] nums, boolean[] visited, int start, int cur, int k, int target) {\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (cur == target) {\n\t\t\treturn dfs(nums, visited, 0, 0, k - 1, target);\n\t\t}\n\t\tfor (int i = start; i < nums.length; i++) {\n\t\t\tif (visited[i]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvisited[i] = true;\n\t\t\tif (dfs(nums, visited, i + 1, cur + nums[i], k, target)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvisited[i] = false;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean canPartitionKSubsets(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (k == 1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum % k != 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint target = sum / k;\n\t\tArrays.sort(nums);\n\t\treturn dfs(nums, 0, k, target, 0, 0);\n\t}\n\tpublic boolean dfs(int[] nums, int index, int k, int target, int sum, int count) {\n\t\tif (count == k) {\n\t\t\treturn true;\n\t\t}\n\t\tif (sum == target) {\n\t\t\treturn dfs(nums, 0, k, target, 0, count + 1);\n\t\t}\n\t\tfor (int i = index; i < nums.length; i++) {\n\t\t\tif (dfs(nums, i + 1, k, target, sum + nums[i], count)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2110",
    "source": "leetcode",
    "language": "java",
    "query": "The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down. Every move incurs some cost. There is an m x n grid, where (0, 0) is the top-left cell.",
    "snippets": [
        "\tint minCost(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n",
        "\tint minCost(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tdp[0][0] = grid[0][0];\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tdp[i][0] = dp[i-1][0] + grid[i][0];\n\t\t}\n\t\tfor(int j = 1; j < n; j++){\n\t\t\tdp[0][j] = dp[0][j-1] + grid[0][j];\n\t\t}\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + grid[i][j];\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n",
        "\tstatic int minCost(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tdp[0][0] = grid[0][0];\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tdp[i][0] = dp[i-1][0] + grid[i][0];\n\t\t}\n\t\tfor(int j = 1; j < n; j++){\n\t\t\tdp[0][j] = dp[0][j-1] + grid[0][j];\n\t\t}\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n",
        "\tstatic int minCost(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tdp[0][0] = grid[0][0];\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tdp[i][0] = dp[i-1][0] + grid[i][0];\n\t\t}\n\t\tfor(int j = 1; j < n; j++){\n\t\t\tdp[0][j] = dp[0][j-1] + grid[0][j];\n\t\t}\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tfor(int j = 1; j < n; j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + grid[i][j];\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n",
        "\tvoid goHome(int[][] grid){\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[m-1][n-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2111",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed integer array nums of length n. Each num contains a valid split at index i if the following are true: 1 + 1 is greater than or equal to the sum of the last n - i - 1 elements.",
    "snippets": [
        "\tint splitArray(int[] nums, int m) {\n\t\tint n = nums.length;\n\t\tint[] sums = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsums[i + 1] = sums[i] + nums[i];\n\t\t}\n\t\tint max = sums[n];\n\t\tint min = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tmax = Math.max(max, sums[i]);\n\t\t\tmin = Math.min(min, sums[i]);\n\t\t}\n\t\twhile (min <= max) {\n\t\t\tint mid = (min + max) / 2;\n\t\t\tif (valid(sums, m, mid)) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tpublic boolean valid(int[] sums, int m, int target) {\n\t\tint count = 1;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < sums.length; i++) {\n\t\t\tif (sums[i] >= target) {\n\t\t\t\tcount++;\n\t\t\t\tsum = 0;\n\t\t\t} else {\n\t\t\t\tsum += sums[i];\n\t\t\t\tif (sum >= target) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tsum = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > m) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint splitArray(int[] nums, int m) {\n\t\tint n = nums.length;\n\t\tint[] sums = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsums[i + 1] = sums[i] + nums[i];\n\t\t}\n\t\tint max = sums[n];\n\t\tint min = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tmax = Math.max(max, sums[i]);\n\t\t\tmin = Math.min(min, sums[i]);\n\t\t}\n\t\twhile (min <= max) {\n\t\t\tint mid = (min + max) / 2;\n\t\t\tif (canSplit(sums, m, mid)) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tprivate boolean canSplit(int[] sums, int m, int target) {\n\t\tint count = 1;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < sums.length; i++) {\n\t\t\tif (sums[i] > target) {\n\t\t\t\tcount++;\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t\tsum += sums[i];\n\t\t\tif (sum > target) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (count > m) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint splitArray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] sums = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsums[i + 1] = sums[i] + nums[i];\n\t\t}\n\t\tint max = sums[n];\n\t\tint res = max;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tmax = Math.max(max, sums[i]);\n\t\t\tres = Math.min(res, max - sums[i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint splitArray(int[] nums, int m) {\n\t\tint n = nums.length;\n\t\tint[] sum = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum[i + 1] = sum[i] + nums[i];\n\t\t}\n\t\tint max = sum[n];\n\t\tint min = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tmax = Math.max(max, sum[i]);\n\t\t\tmin = Math.min(min, sum[i]);\n\t\t}\n\t\twhile (min < max) {\n\t\t\tint mid = (min + max) / 2;\n\t\t\tif (canSplit(mid, sum, m)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tpublic boolean canSplit(int mid, int[] sum, int m) {\n\t\tint count = 1;\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < sum.length; i++) {\n\t\t\tif (sum[i] > mid) {\n\t\t\t\tcur = sum[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (count > m) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint splitArray(int[] nums, int m) {\n\t\tint n = nums.length;\n\t\tint[] sum = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum[i + 1] = sum[i] + nums[i];\n\t\t}\n\t\tint max = sum[n];\n\t\tint min = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tmax = Math.max(max, sum[i]);\n\t\t\tmin = Math.min(min, sum[i]);\n\t\t}\n\t\twhile (min <= max) {\n\t\t\tint mid = (min + max) / 2;\n\t\t\tif (canSplit(nums, m, mid)) {\n\t\t\t\tmax = mid - 1;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tpublic boolean canSplit(int[] nums, int m, int mid) {\n\t\tint count = 1;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (sum + nums[i] > mid) {\n\t\t\t\tcount++;\n\t\t\t\tsum = nums[i];\n\t\t\t} else {\n\t\t\t\tsum += nums[i];\n\t\t\t}\n\t\t\tif (count > m) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint splitArray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] sums = new int[n];\n\t\tsums[0] = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tsums[i] = sums[i - 1] + nums[i];\n\t\t}\n\t\tint max = sums[n - 1];\n\t\tint min = nums[0];\n\t\tint res = max - min;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tmax = Math.max(max, sums[i - 1]);\n\t\t\tmin = Math.min(min, sums[n - i]);\n\t\t\tres = Math.min(res, max - min);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint splitArray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] sums = new int[n];\n\t\tsums[0] = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tsums[i] = sums[i - 1] + nums[i];\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tint sum = sums[j] - sums[i];\n\t\t\t\tif (sum >= nums[i] && sum >= nums[j]) {\n\t\t\t\t\tres = Math.min(res, j - i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res == Integer.MAX_VALUE ? -1 : res;\n\t}\n}\n",
        "\tint splitArray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] sums = new int[n];\n\t\tsums[0] = nums[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tsums[i] = sums[i - 1] + nums[i];\n\t\t}\n\t\tint max = sums[n - 1];\n\t\tint res = max;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tint sum = sums[i] - sums[j];\n\t\t\t\tif (sum > max) {\n\t\t\t\t\tmax = sum;\n\t\t\t\t\tres = Math.max(res, max);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint splitArray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] sum = new int[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum[i + 1] = sum[i] + nums[i];\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\tif (sum[j] - sum[i] >= sum[n]) {\n\t\t\t\t\tres = Math.max(res, j - i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tboolean valid(int[] nums, int n) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum += nums[i];\n\t\t\tif (sum >= n - i - 1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2112",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for. If original is found in nums, multiply it by two (i.e., set original = 2 * original). Otherwise, stop the process.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint original = 5;\n\t\tint index = search(nums, original);\n\t\tif(index != -1){\n\t\t\tnums[index] = 2 * nums[index];\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tSystem.out.print(nums[i] + \" \");\n\t\t}\n\t}\n\tpublic static int search(int[] nums, int original){\n\t\tint index = -1;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == original){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint original = 5;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == original){\n\t\t\t\tnums[i] = 2 * original;\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i == index){\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.print(nums[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint original = 5;\n\t\tint index = search(nums, original);\n\t\tif(index != -1){\n\t\t\tnums[index] = 2 * nums[index];\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tSystem.out.print(nums[i] + \" \");\n\t\t}\n\t}\n\tpublic static int search(int[] nums, int original){\n\t\tint left = 0;\n\t\tint right = nums.length - 1;\n\t\twhile(left <= right){\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif(nums[mid] == original){\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\telse if(nums[mid] > original){\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint original = 5;\n\t\tint index = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == original){\n\t\t\t\tnums[i] = 2 * original;\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i == index){\n\t\t\t\tSystem.out.print(\"*\" + nums[i] + \"*\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.print(nums[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint original = 5;\n\t\tint index = search(nums, original);\n\t\tif(index != -1){\n\t\t\tnums[index] = 2 * nums[index];\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tSystem.out.print(nums[i] + \" \");\n\t\t}\n\t}\n\tpublic static int search(int[] nums, int original){\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == original){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tvoid clazz(int[] nums, int original){\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == original){\n\t\t\t\tnums[i] = 2 * original;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args) {\n\t\tint[] nums = {1,2,3,4,5,6,7,8,9,10};\n\t\tint original = 5;\n\t\tint index = findIndex(nums, original);\n\t\tif(index != -1){\n\t\t\tnums[index] = 2 * nums[index];\n\t\t}\n\t\tprintArray(nums);\n\t}\n\tpublic static int findIndex(int[] nums, int original){\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == original){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static void printArray(int[] nums){\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tSystem.out.print(nums[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tvoid method(int[] nums, int original){\n\t\tint index = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == original){\n\t\t\t\tnums[i] = 2 * original;\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(index == 0){\n\t\t\tSystem.out.println(\"Not found\");\n\t\t}\n\t}\n}\n",
        "\tvoid clazz(int[] nums, int original){\n\t\tint i = 0;\n\t\twhile(i < nums.length){\n\t\t\tif(nums[i] == original){\n\t\t\t\tnums[i] = 2 * original;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2113",
    "source": "leetcode",
    "language": "java",
    "query": "Your country has an infinite number of lakes. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.",
    "snippets": [
        "\tvoid method(){\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tif(a[i] == 5){\n\t\t\t\ta[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid method(){\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tif(a[i] == 5){\n\t\t\t\tSystem.out.println(\"5\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[][] lakes = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlakes[i][0] = Integer.parseInt(args[i*2+1]);\n\t\t\tlakes[i][1] = Integer.parseInt(args[i*2+2]);\n\t\t}\n\t\tint[][] ans = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans[i][0] = lakes[i][0];\n\t\t\tans[i][1] = lakes[i][1];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tif(lakes[i][0] <= lakes[j][0] && lakes[i][1] >= lakes[j][0]){\n\t\t\t\t\t\tans[i][0] = Math.max(ans[i][0], lakes[j][1]+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(lakes[i][0] >= lakes[j][0] && lakes[i][1] <= lakes[j][1]){\n\t\t\t\t\t\tans[i][1] = Math.min(ans[i][1], lakes[j][0]-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(ans[i][0] + \" \" + ans[i][1]);\n\t\t}\n\t}\n}\n",
        "\tvoid method(){\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tif(a[i] == 5){\n\t\t\t\tSystem.out.println(\"Found 5\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[][] lakes = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tlakes[i][0] = Integer.parseInt(args[i*2+1]);\n\t\t\tlakes[i][1] = Integer.parseInt(args[i*2+2]);\n\t\t}\n\t\tint[][] flood = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tflood[i][0] = Integer.parseInt(args[i*2+1+n*2]);\n\t\t\tflood[i][1] = Integer.parseInt(args[i*2+2+n*2]);\n\t\t}\n\t\tint[][] avoid = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tavoid[i][0] = Integer.parseInt(args[i*2+1+n*3]);\n\t\t\tavoid[i][1] = Integer.parseInt(args[i*2+2+n*3]);\n\t\t}\n\t\tint[][] result = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tresult[i][0] = Integer.parseInt(args[i*2+1+n*4]);\n\t\t\tresult[i][1] = Integer.parseInt(args[i*2+2+n*4]);\n\t\t}\n\t\tint[][] result2 = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tresult2[i][0] = Integer.parseInt(args[i*2+1+n*5]);\n\t\t\tresult2[i][1] = Integer.parseInt(args[i*2+2+n*5]);\n\t\t}\n\t\tint[][] result3 = new\n",
        "\tvoid method(){\n\t\tint[][] a = new int[10][10];\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\ta[i][j] = i + j;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif(a[i][j] == 0){\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] lakes = {0,1,0,2,1,0,1,3,2,1,2,1};\n\t\tint[] avoid = {1,4,5};\n\t\tint[] result = avoidFlood(lakes, avoid);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n\tpublic static int[] avoidFlood(int[] lakes, int[] avoid){\n\t\tint[] result = new int[lakes.length];\n\t\tfor(int i = 0; i < lakes.length; i++){\n\t\t\tif(lakes[i] == 0){\n\t\t\t\tresult[i] = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint j = 0;\n\t\t\t\twhile(j < avoid.length && avoid[j] != i){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j == avoid.length){\n\t\t\t\t\tresult[i] = 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresult[i] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 7
},{
    "id": "2114",
    "source": "leetcode",
    "language": "java",
    "query": "Solve a given equation and return the value of 'x' in the form of a string. The equation contains only '+', '-' operation, the variable 'x', and its coefficient. You should return \"No solution\" if there is no solution for the equation.",
    "snippets": [
        "\tString solveEquation(String equation) {\n\t\tString[] arr = equation.split(\"=\");\n\t\tString[] left = arr[0].split(\"\\\\+\");\n\t\tString[] right = arr[1].split(\"\\\\+\");\n\t\tint x = 0;\n\t\tint left_x = 0;\n\t\tint right_x = 0;\n\t\tfor(String s : left){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tleft_x -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tleft_x += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tx += Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tfor(String s : right){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tright_x -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tright_x += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tx -= Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tif(left_x == right_x && x == 0){\n\t\t\treturn \"Infinite solutions\";\n\t\t}else if(left_x == right_x && x != 0){\n\t\t\treturn \"No solution\";\n\t\t}else{\n\t\t\treturn \"x=\" + (right_x - left_x) / (x);\n\t\t}\n\t}\n}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] arr = equation.split(\"=\");\n\t\tString[] left = arr[0].split(\"\\\\+\");\n\t\tString[] right = arr[1].split(\"\\\\+\");\n\t\tint x = 0;\n\t\tint leftSum = 0;\n\t\tint rightSum = 0;\n\t\tfor(String s : left){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tx -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tx += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tleftSum -= Integer.parseInt(s.substring(0, s.indexOf(\"-\")));\n\t\t\t\t}else{\n\t\t\t\t\tleftSum += Integer.parseInt(s.substring(0, s.indexOf(\"+\")));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String s : right){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tx -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tx += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\trightSum -= Integer.parseInt(s.substring(0, s.indexOf(\"-\")));\n\t\t\t\t}else{\n\t\t\t\t\trightSum += Integer.parseInt(s.substring(0, s.indexOf(\"+\")));\n\t\t\t\t}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] arr = equation.split(\"=\");\n\t\tString[] left = arr[0].split(\"\\\\+\");\n\t\tString[] right = arr[1].split(\"\\\\+\");\n\t\tint x = 0;\n\t\tint left_x = 0;\n\t\tint right_x = 0;\n\t\tfor(String s : left){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.charAt(0) == '-'){\n\t\t\t\t\tleft_x -= Integer.parseInt(s.substring(1));\n\t\t\t\t}else{\n\t\t\t\t\tleft_x += Integer.parseInt(s.substring(1));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tx += Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tfor(String s : right){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.charAt(0) == '-'){\n\t\t\t\t\tright_x -= Integer.parseInt(s.substring(1));\n\t\t\t\t}else{\n\t\t\t\t\tright_x += Integer.parseInt(s.substring(1));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tx -= Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tif(left_x == right_x && x == 0){\n\t\t\treturn \"Infinite solutions\";\n\t\t}else if(left_x == right_x && x != 0){\n\t\t\treturn \"No solution\";\n\t\t}else{\n\t\t\treturn \"x=\" + (right_x - left_x) / (x);\n\t\t}\n\t}\n}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] strs = equation.split(\"=\");\n\t\tString[] left = strs[0].split(\"\\\\+\");\n\t\tString[] right = strs[1].split(\"\\\\+\");\n\t\tint leftSum = 0;\n\t\tint rightSum = 0;\n\t\tfor(String s : left){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tleftSum -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tleftSum += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tleftSum += Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tfor(String s : right){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\trightSum -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\trightSum += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trightSum += Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tif(leftSum == rightSum){\n\t\t\treturn \"x=0\";\n\t\t}else if(leftSum == 0){\n\t\t\treturn \"x=\" + (rightSum/right.length);\n\t\t}else if(rightSum == 0){\n\t\t\treturn \"x=\" + (leftSum/left.length);\n\t\t}else{\n\t\t\treturn \"No solution\";\n\t\t}\n\t}\n}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] strs = equation.split(\"=\");\n\t\tString[] left = strs[0].split(\"\\\\+\");\n\t\tString[] right = strs[1].split(\"\\\\+\");\n\t\tint x = 0;\n\t\tint leftSum = 0;\n\t\tint rightSum = 0;\n\t\tfor(String s : left){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tx -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tx += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tleftSum -= Integer.parseInt(s.substring(0, s.indexOf(\"-\")));\n\t\t\t\t}else{\n\t\t\t\t\tleftSum += Integer.parseInt(s.substring(0, s.indexOf(\"+\")));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String s : right){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tx -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tx += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\trightSum -= Integer.parseInt(s.substring(0, s.indexOf(\"-\")));\n\t\t\t\t}else{\n\t\t\t\t\trightSum += Integer.parseInt(s.substring(0, s.indexOf(\"+\")));\n\t\t\t\t}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] strs = equation.split(\"=\");\n\t\tString[] left = strs[0].split(\"\\\\+\");\n\t\tString[] right = strs[1].split(\"\\\\+\");\n\t\tint x = 0;\n\t\tint left_x = 0;\n\t\tint right_x = 0;\n\t\tfor(String s : left){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tleft_x -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tleft_x += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tx += Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tfor(String s : right){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tright_x -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tright_x += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tx -= Integer.parseInt(s);\n\t\t\t}\n\t\t}\n\t\tif(left_x == right_x && x == 0){\n\t\t\treturn \"Infinite solutions\";\n\t\t}else if(left_x == right_x && x != 0){\n\t\t\treturn \"No solution\";\n\t\t}else{\n\t\t\treturn \"x=\" + (right_x - left_x) / (x + left_x);\n\t\t}\n\t}\n}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] split = equation.split(\"=\");\n\t\tString[] left = split[0].split(\"\\\\+\");\n\t\tString[] right = split[1].split(\"\\\\+\");\n\t\tint x = 0;\n\t\tint leftSum = 0;\n\t\tint rightSum = 0;\n\t\tfor(String s : left){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tx -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tx += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tleftSum -= Integer.parseInt(s.substring(0, s.indexOf(\"-\")));\n\t\t\t\t}else{\n\t\t\t\t\tleftSum += Integer.parseInt(s.substring(0, s.indexOf(\"+\")));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(String s : right){\n\t\t\tif(s.contains(\"x\")){\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\tx -= Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}else{\n\t\t\t\t\tx += Integer.parseInt(s.substring(0, s.indexOf(\"x\")));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(s.contains(\"-\")){\n\t\t\t\t\trightSum -= Integer.parseInt(s.substring(0, s.indexOf(\"-\")));\n\t\t\t\t}else{\n\t\t\t\t\trightSum += Integer.parseInt(s.substring(0, s.indexOf(\"+\")));\n\t\t\t\t}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] str = equation.split(\"=\");\n\t\tString[] left = str[0].split(\"\\\\+\");\n\t\tString[] right = str[1].split(\"\\\\+\");\n\t\tint x = 0;\n\t\tint leftNum = 0;\n\t\tint rightNum = 0;\n\t\tfor(int i = 0; i < left.length; i++){\n\t\t\tif(left[i].contains(\"x\")){\n\t\t\t\tif(left[i].charAt(0) == '-'){\n\t\t\t\t\tleftNum -= Integer.parseInt(left[i].substring(1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tleftNum += Integer.parseInt(left[i].substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tleftNum += Integer.parseInt(left[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < right.length; i++){\n\t\t\tif(right[i].contains(\"x\")){\n\t\t\t\tif(right[i].charAt(0) == '-'){\n\t\t\t\t\trightNum -= Integer.parseInt(right[i].substring(1));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trightNum += Integer.parseInt(right[i].substring(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trightNum += Integer.parseInt(right[i]);\n\t\t\t}\n\t\t}\n\t\tx = leftNum - rightNum;\n\t\tif(x == 0){\n\t\t\tif(leftNum == 0){\n\t\t\t\treturn \"Infinite solutions\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn \"No solution\";\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn \"x=\" + x;\n\t\t}\n\t}\n}\n",
        "\tString solveEquation(String equation) {\n\t\tString[] str = equation.split(\"=\");\n\t\tString[] str1 = str[0].split(\"[+]\");\n\t\tString[] str2 = str[1].split(\"[+]\");\n\t\tint x = 0;\n\t\tint x1 = 0;\n\t\tint x2 = 0;\n\t\tint x3 = 0;\n\t\tint x4 = 0;\n\t\tint x5 = 0;\n\t\tint x6 = 0;\n\t\tint x7 = 0;\n\t\tint x8 = 0;\n\t\tint x9 = 0;\n\t\tint x10 = 0;\n\t\tint x11 = 0;\n\t\tint x12 = 0;\n\t\tint x13 = 0;\n\t\tint x14 = 0;\n\t\tint x15 = 0;\n\t\tint x16 = 0;\n\t\tint x17 = 0;\n\t\tint x18 = 0;\n\t\tint x19 = 0;\n\t\tint x20 = 0;\n\t\tint x21 = 0;\n\t\tint x22 = 0;\n\t\tint x23 = 0;\n\t\tint x24 = 0;\n\t\tint x25 = 0;\n\t\tint x26 = 0;\n\t\tint x27 = 0;\n\t\tint x28 = 0;\n\t\tint x29 = 0;\n\t\tint x30 = 0;\n\t\tint x31 = 0;\n\t\tint x32 = 0;\n\t\tint x33 = 0;\n\t\tint x34 = 0;\n\t\tint x35 = 0;\n\t\tint x36 = 0;\n\t\tint x37 = 0;\n\t\tint x38 = 0;\n\t\tint x39 = 0;\n\t\tint x40 = 0;\n\t\tint x41 = 0;\n\t\tint x42 = 0;\n\t\tint x43 = 0;\n\t\tint x44 = 0;\n\t\tint x45 = 0;\n\t\tint x46 = 0;\n\t\tint x47 = 0;\n\t\tint x48 = 0;\n"
    ],
    "results": 10
},{
    "id": "2115",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array nums and two integers limit and goal. Return the minimum number of elements you need to add to make the sum of the array equal to goal. The array must maintain its property that abs(nums[i], limit.",
    "snippets": [
        "\tint minOperations(int[] nums, int limit, int goal) {\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum > goal){\n\t\t\t\tsum = nums[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(sum < goal){\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int[] nums, int limit, int goal) {\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum > goal){\n\t\t\t\tsum = nums[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(sum + limit >= goal){\n\t\t\treturn count;\n\t\t}\n\t\treturn count + 1;\n\t}\n}\n",
        "\tint minAddToMakeGood(int[] nums, int limit) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint[] nums2 = new int[nums.length + count];\n\t\tint j = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tnums2[j] = nums[i] - limit;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnums2[j] = nums[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(nums2);\n\t\tint count2 = 0;\n\t\tfor(int i = 0; i < nums2.length; i++){\n\t\t\tif(nums2[i] < 0){\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t}\n\t\treturn count2;\n\t}\n}\n",
        "\tint minAddToMakeGood(int[] nums, int limit) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint[] nums2 = new int[nums.length + count];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tnums2[index] = nums[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] <= limit){\n\t\t\t\tnums2[index] = nums[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tint count2 = 0;\n\t\tfor(int i = 0; i < nums2.length; i++){\n\t\t\tif(nums2[i] > limit){\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t}\n\t\treturn count2;\n\t}\n}\n",
        "\tint minAddToMakeGood(int[] nums, int limit) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint[] nums2 = new int[nums.length + count];\n\t\tint j = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tnums2[j] = nums[i] - limit;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnums2[j] = nums[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tint count2 = 0;\n\t\tfor(int i = 0; i < nums2.length; i++){\n\t\t\tif(nums2[i] > limit){\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t}\n\t\treturn count2;\n\t}\n}\n",
        "\tint minAddToMakeGood(int[] nums, int limit) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint[] nums2 = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tnums2[i] = nums[i] - limit;\n\t\t}\n\t\tint[] nums3 = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tnums3[i] = nums[i] + limit;\n\t\t}\n\t\tint count2 = 0;\n\t\tfor(int i = 0; i < nums2.length; i++){\n\t\t\tif(nums2[i] > limit){\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t}\n\t\tint count3 = 0;\n\t\tfor(int i = 0; i < nums3.length; i++){\n\t\t\tif(nums3[i] > limit){\n\t\t\t\tcount3++;\n\t\t\t}\n\t\t}\n\t\treturn Math.min(count, Math.min(count2, count3));\n\t}\n}\n",
        "\tint minSubArrayLen(int[] nums, int limit) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\twhile(end < nums.length){\n\t\t\tsum += nums[end];\n\t\t\twhile(sum > limit){\n\t\t\t\tsum -= nums[start];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tif(sum == limit){\n\t\t\t\tmin = Math.min(min, end - start + 1);\n\t\t\t}\n\t\t\tend++;\n\t\t}\n\t\treturn min == Integer.MAX_VALUE ? 0 : min;\n\t}\n}\n",
        "\tint minAddToMakeGood(int[] nums, int limit) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < nums.length){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(i + 1 < nums.length && nums[i] + nums[i + 1] > limit){\n\t\t\t\t\tcount++;\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minAddToMakeGood(int[] nums, int limit) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < nums.length){\n\t\t\tif(nums[i] > limit){\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tif(i + 1 < nums.length && Math.abs(nums[i] - nums[i + 1]) <= limit){\n\t\t\t\t\ti++;\n\t\t\t\t}else{\n\t\t\t\t\tcount++;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minSubArrayLen(int[] nums, int limit) {\n\t\tint min = nums.length + 1;\n\t\tint sum = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\twhile(end < nums.length){\n\t\t\tsum += nums[end];\n\t\t\twhile(sum > limit){\n\t\t\t\tsum -= nums[start];\n\t\t\t\tstart++;\n\t\t\t}\n\t\t\tif(sum == limit){\n\t\t\t\tmin = Math.min(min, end - start + 1);\n\t\t\t}\n\t\t\tend++;\n\t\t}\n\t\treturn min == nums.length + 1 ? 0 : min;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2116",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed array of n integers differences, which describes the differences between each pair of consecutive integers. For example, given differences = [1, -3, 4], lower = 1, upper = 6, the hidden sequence is a sequence of length 4 whose elements are in between 1 and 6.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] differences = {1, -3, 4};\n\t\tint lower = 1;\n\t\tint upper = 6;\n\t\tSystem.out.println(findHiddenSequence(differences, lower, upper));\n\t}\n\tpublic static int findHiddenSequence(int[] differences, int lower, int upper){\n\t\tint[] dp = new int[upper + 1];\n\t\tdp[0] = 1;\n\t\tfor(int i = 0; i < differences.length; i++){\n\t\t\tfor(int j = differences[i]; j <= upper; j++){\n\t\t\t\tdp[j] += dp[j - differences[i]];\n\t\t\t}\n\t\t}\n\t\treturn dp[upper];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] differences = {1, -3, 4};\n\t\tint lower = 1;\n\t\tint upper = 6;\n\t\tint[] result = hiddenSequence(differences, lower, upper);\n\t\tSystem.out.println(Arrays.toString(result));\n\t}\n\tpublic static int[] hiddenSequence(int[] differences, int lower, int upper){\n\t\tint[] result = new int[differences.length];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < differences.length; i++){\n\t\t\tsum += differences[i];\n\t\t\tresult[i] = sum;\n\t\t}\n\t\tint[] result2 = new int[result.length];\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tresult2[i] = result[i] + lower;\n\t\t}\n\t\tint[] result3 = new int[result.length];\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tresult3[i] = result[i] + upper;\n\t\t}\n\t\tint[] result4 = new int[result.length];\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tresult4[i] = result[i] + upper + lower;\n\t\t}\n\t\tint[] result5 = new int[result.length];\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tresult5[i] = result[i] + upper + lower + upper;\n\t\t}\n\t\tint[] result6 = new int[result.length];\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tresult6[i] = result[i] + upper + lower + upper + lower;\n\t\t}\n\t\tint[] result7 = new int[result.length];\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tresult7[i] = result[i\n",
        "\tstatic int[] hiddenSequence(int[] differences, int lower, int upper){\n\t\tint[] result = new int[differences.length];\n\t\tint index = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < differences.length; i++){\n\t\t\tsum += differences[i];\n\t\t\tif(sum >= lower && sum <= upper){\n\t\t\t\tresult[index] = sum;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(result, index);\n\t}\n}\n",
        "\tstatic int[] hiddenSequence(int[] differences, int lower, int upper){\n\t\tint[] result = new int[differences.length];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < differences.length; i++){\n\t\t\tif(differences[i] >= lower && differences[i] <= upper){\n\t\t\t\tresult[index] = differences[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(result, index);\n\t}\n}\n",
        "\tstatic int[] hiddenSeq(int[] differences, int lower, int upper){\n\t\tint[] result = new int[differences.length];\n\t\tint index = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < differences.length; i++){\n\t\t\tsum += differences[i];\n\t\t\tif(sum >= lower && sum <= upper){\n\t\t\t\tresult[index] = sum;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(result, index);\n\t}\n}\n",
        "\tstatic int[] hiddenSeq(int[] differences, int lower, int upper){\n\t\tint[] result = new int[differences.length];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < differences.length){\n\t\t\tif(differences[i] > 0){\n\t\t\t\tresult[j] = lower + differences[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresult[j] = lower + differences[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] hiddenSeq(int[] differences, int lower, int upper){\n\t\tint[] result = new int[differences.length];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < differences.length; i++){\n\t\t\tif(differences[i] >= lower && differences[i] <= upper){\n\t\t\t\tresult[index] = differences[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2117",
    "source": "leetcode",
    "language": "java",
    "query": "A string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, a has a character strictly smaller than the corresponding character in b. If there is no way to replace a character to make it not a palindrome, return an empty string.",
    "snippets": [
        "\tString makePalindrome(String a){\n\t\tint i = 0;\n\t\tint j = a.length() - 1;\n\t\twhile(i < j){\n\t\t\tif(a.charAt(i) < a.charAt(j)){\n\t\t\t\treturn a.substring(i, j + 1);\n\t\t\t}\n\t\t\telse if(a.charAt(i) > a.charAt(j)){\n\t\t\t\treturn a.substring(j, i + 1);\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString makePalindrome(String a){\n\t\tint i = 0;\n\t\tint j = a.length() - 1;\n\t\twhile(i < j){\n\t\t\tif(a.charAt(i) < a.charAt(j)){\n\t\t\t\treturn a.substring(i + 1, j + 1) + a.substring(i, i + 1) + a.substring(j, j + 1);\n\t\t\t}\n\t\t\tif(a.charAt(i) > a.charAt(j)){\n\t\t\t\treturn a.substring(i, i + 1) + a.substring(j + 1, j + 2) + a.substring(i + 1, j);\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString makePalindrome(String a){\n\t\tint i = 0;\n\t\tint j = a.length() - 1;\n\t\twhile(i < j){\n\t\t\tif(a.charAt(i) > a.charAt(j)){\n\t\t\t\treturn a.substring(i, j + 1);\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString makePalindrome(String a){\n\t\tint i = 0;\n\t\tint j = a.length() - 1;\n\t\twhile(i < j){\n\t\t\tif(a.charAt(i) < a.charAt(j)){\n\t\t\t\treturn a.substring(i, j + 1);\n\t\t\t}\n\t\t\tif(a.charAt(i) > a.charAt(j)){\n\t\t\t\treturn a.substring(j, i + 1);\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tString makePalindrome(String a){\n\t\tif(a.length()==0) return \"\";\n\t\tint i=0;\n\t\twhile(i<a.length()&&a.charAt(i)==a.charAt(a.length()-1-i)) i++;\n\t\tif(i==a.length()) return a;\n\t\tif(a.charAt(i)<a.charAt(a.length()-1-i)) return a.substring(0,i)+a.substring(i+1)+a.charAt(i)+a.substring(i);\n\t\telse return a.substring(0,a.length()-1-i)+a.charAt(a.length()-1-i)+a.substring(a.length()-i);\n\t}\n}\n",
        "\tString makePalindrome(String a){\n\t\tif(a.length()==0) return \"\";\n\t\tint i=0;\n\t\twhile(i<a.length()&&a.charAt(i)==a.charAt(a.length()-1-i)) i++;\n\t\tif(i==a.length()) return \"\";\n\t\tif(a.charAt(i)<a.charAt(a.length()-1-i)) return a.substring(0,i)+a.substring(i+1,a.length()-1-i)+a.charAt(i);\n\t\telse return a.substring(0,a.length()-1-i)+a.charAt(a.length()-1-i)+a.substring(i,a.length()-1-i)+a.charAt(i);\n\t}\n}\n",
        "\tString shortestPalindrome(String s) {\n\t\tint n = s.length();\n\t\tString t = s + \"#\" + new StringBuilder(s).reverse().toString();\n\t\tint[] p = new int[t.length()];\n\t\tint m = 0;\n\t\tfor (int i = 1; i < t.length(); i++) {\n\t\t\tp[i] = m;\n\t\t\twhile (t.charAt(i + m) == t.charAt(m)) m++;\n\t\t\tp[i] = m;\n\t\t\tm = Math.max(m - 1, 0);\n\t\t}\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile (i < n) {\n\t\t\tif (j == n) {\n\t\t\t\tk = p[j] + n - i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s.charAt(i) == t.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tif (j == 0) {\n\t\t\t\t\ti++;\n\t\t\t\t} else {\n\t\t\t\t\tj = p[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn s.substring(k) + s;\n\t}\n}\n",
        "\tString shortestPalindrome(String s) {\n\t\tif(s == null || s.length() == 0) return s;\n\t\tint len = s.length();\n\t\tString rev = new StringBuilder(s).reverse().toString();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tif(s.charAt(i) == rev.charAt(i)){\n\t\t\t\tsb.append(s.charAt(i));\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(sb.length() == len){\n\t\t\treturn sb.toString();\n\t\t}\n\t\tString pre = sb.toString();\n\t\tString post = rev.substring(pre.length());\n\t\treturn post + shortestPalindrome(pre + post);\n\t}\n}\n",
        "\tString longestPalindrome(String s) {\n\t\tint n = s.length();\n\t\tif (n == 0) return \"\";\n\t\tint max = 0;\n\t\tString res = \"\";\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString a = helper(s, i, i);\n\t\t\tString b = helper(s, i, i + 1);\n\t\t\tif (a.length() > max) {\n\t\t\t\tmax = a.length();\n\t\t\t\tres = a;\n\t\t\t}\n\t\t\tif (b.length() > max) {\n\t\t\t\tmax = b.length();\n\t\t\t\tres = b;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic String helper(String s, int i, int j) {\n\t\twhile (i >= 0 && j < s.length() && s.charAt(i) == s.charAt(j)) {\n\t\t\ti--;\n\t\t\tj++;\n\t\t}\n\t\treturn s.substring(i + 1, j);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2118",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, return all the different possible increasing subsequences of the given array with at least two elements. You may return the answer in any order.",
    "snippets": [
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, 0, new ArrayList<>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> res){\n\t\tif(list.size() >= 2) res.add(new ArrayList<>(list));\n\t\tif(index == nums.length) return;\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.isEmpty() || list.get(list.size() - 1) <= nums[i]){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t\thelper(nums, i + 1, list, res);\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, 0, new ArrayList<>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> res){\n\t\tif(list.size() >= 2) res.add(new ArrayList<>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.size() > 0 && nums[i] <= list.get(list.size() - 1)) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, i + 1, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, 0, new ArrayList<>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> res){\n\t\tif(list.size() >= 2) res.add(new ArrayList<>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.size() == 0 || list.get(list.size() - 1) <= nums[i]){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t\thelper(nums, i + 1, list, res);\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tList<Integer> list = new ArrayList<>();\n\t\thelper(nums, 0, list, res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> res){\n\t\tif(list.size() >= 2) res.add(new ArrayList<>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.size() == 0 || list.get(list.size() - 1) <= nums[i]){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t\thelper(nums, i + 1, list, res);\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, 0, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> res){\n\t\tif(list.size() >= 2) res.add(new ArrayList<Integer>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.isEmpty() || list.get(list.size() - 1) <= nums[i]){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t\thelper(nums, i + 1, list, res);\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(res, new ArrayList<>(), nums, 0);\n\t\treturn res;\n\t}\n\tprivate void helper(List<List<Integer>> res, List<Integer> list, int[] nums, int index){\n\t\tif(list.size() >= 2) res.add(new ArrayList<>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.size() == 0 || list.get(list.size() - 1) <= nums[i]){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t\thelper(res, list, nums, i + 1);\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\thelper(nums, 0, new ArrayList<>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> cur, List<List<Integer>> res){\n\t\tif(cur.size() >= 2) res.add(new ArrayList<>(cur));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(cur.isEmpty() || cur.get(cur.size() - 1) <= nums[i]){\n\t\t\t\tcur.add(nums[i]);\n\t\t\t\thelper(nums, i + 1, cur, res);\n\t\t\t\tcur.remove(cur.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\thelper(nums, 0, list, res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> res){\n\t\tif(list.size() >= 2) res.add(new ArrayList<Integer>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.size() > 0 && nums[i] < list.get(list.size() - 1)) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, i + 1, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0) return result;\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\thelper(nums, 0, list, result);\n\t\treturn result;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> result){\n\t\tif(list.size() >= 2) result.add(new ArrayList<Integer>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.size() == 0 || list.get(list.size() - 1) <= nums[i]){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t\thelper(nums, i + 1, list, result);\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> findSubsequences(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums.length == 0) return res;\n\t\thelper(res, new ArrayList<>(), nums, 0);\n\t\treturn res;\n\t}\n\tpublic void helper(List<List<Integer>> res, List<Integer> list, int[] nums, int index){\n\t\tif(list.size() >= 2) res.add(new ArrayList<>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(list.size() == 0 || list.get(list.size() - 1) <= nums[i]){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t\thelper(res, list, nums, i + 1);\n\t\t\t\tlist.remove(list.size() - 1);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2119",
    "source": "leetcode",
    "language": "java",
    "query": "The functions get and put must each run in O(1) average time complexity. The data structure follows the constraints of a Least Recently Used (LRU) cache.",
    "snippets": [
        "\tvoid get(int key){\n\t\t\n\t}\n\tpublic\n\tvoid put(int key, int value){\n\t\t\n\t}\n}\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic void get(int key){\n\t\t\n\t}\n\tpublic void put(int key, int value){\n\t\t\n\t}\n}\n",
        "\tclass LRUCache{\n\t\tpublic LRUCache(int capacity) {\n\t\t\t\n\t\t}\n\t\tpublic int get(int key) {\n\t\t\t\n\t\t}\n\t\tpublic void put(int key, int value) {\n\t\t\t\n\t\t}\n\t}\n}\n",
        "\tclass LRUCache {\n\t\tprivate int capacity;\n\t\tprivate Map<Integer, Integer> map;\n\t\tprivate List<Integer> list;\n\t\tpublic LRUCache(int capacity) {\n\t\t\tthis.capacity = capacity;\n\t\t\tmap = new HashMap<Integer, Integer>();\n\t\t\tlist = new LinkedList<Integer>();\n\t\t}\n\t\tpublic int get(int key) {\n\t\t\tif(map.containsKey(key)){\n\t\t\t\tlist.remove(key);\n\t\t\t\tlist.add(key);\n\t\t\t\treturn map.get(key);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tpublic void put(int key, int value) {\n\t\t\tif(map.containsKey(key)){\n\t\t\t\tlist.remove(key);\n\t\t\t\tlist.add(key);\n\t\t\t\tmap.put(key, value);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(list.size() == capacity){\n\t\t\t\t\tint removed = list.remove(0);\n\t\t\t\t\tmap.remove(removed);\n\t\t\t\t}\n\t\t\t\tlist.add(key);\n\t\t\t\tmap.put(key, value);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tclass LRUCache {\n\t\tprivate Map<Integer, Integer> map;\n\t\tprivate LinkedList<Integer> list;\n\t\tprivate int capacity;\n\t\tpublic LRUCache(int capacity) {\n\t\t\tmap = new HashMap<Integer, Integer>();\n\t\t\tlist = new LinkedList<Integer>();\n\t\t\tthis.capacity = capacity;\n\t\t}\n\t\tpublic int get(int key) {\n\t\t\tif(map.containsKey(key)){\n\t\t\t\tlist.remove(key);\n\t\t\t\tlist.add(key);\n\t\t\t\treturn map.get(key);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\tpublic void put(int key, int value) {\n\t\t\tif(map.containsKey(key)){\n\t\t\t\tlist.remove(key);\n\t\t\t\tlist.add(key);\n\t\t\t\tmap.put(key, value);\n\t\t\t}else{\n\t\t\t\tif(list.size() == capacity){\n\t\t\t\t\tint remove = list.remove();\n\t\t\t\t\tmap.remove(remove);\n\t\t\t\t}\n\t\t\t\tlist.add(key);\n\t\t\t\tmap.put(key, value);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2120",
    "source": "leetcode",
    "language": "java",
    "query": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. You must find a solution with a memory complexity better than O(n2)",
    "snippets": [
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n-1][n-1];\n\t\twhile(lo < hi){\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif(count(matrix, mid) < k)\n\t\t\t\tlo = mid + 1;\n\t\t\telse\n\t\t\t\thi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n\tpublic int count(int[][] matrix, int target){\n\t\tint n = matrix.length;\n\t\tint i = n - 1, j = 0, cnt = 0;\n\t\twhile(i >= 0 && j < n){\n\t\t\tif(matrix[i][j] <= target)\n\t\t\t\tcnt += i + 1;\n\t\t\tif(matrix[i][j] > target)\n\t\t\t\ti--;\n\t\t\telse\n\t\t\t\tj++;\n\t\t}\n\t\treturn cnt;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n-1][n-1];\n\t\twhile(lo < hi){\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif(count(matrix, mid) < k) lo = mid + 1;\n\t\t\telse hi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n\tpublic int count(int[][] matrix, int target){\n\t\tint n = matrix.length, i = n - 1, j = 0, cnt = 0;\n\t\twhile(i >= 0 && j < n){\n\t\t\tif(matrix[i][j] <= target) j++;\n\t\t\telse i--;\n\t\t\tcnt += i + 1;\n\t\t}\n\t\treturn cnt;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n-1][n-1];\n\t\twhile(lo < hi){\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif(count(matrix, mid) < k) lo = mid + 1;\n\t\t\telse hi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n\tpublic int count(int[][] matrix, int target){\n\t\tint n = matrix.length;\n\t\tint i = n - 1, j = 0;\n\t\tint count = 0;\n\t\twhile(i >= 0 && j < n){\n\t\t\tif(matrix[i][j] <= target) j++;\n\t\t\telse i--;\n\t\t\tcount += i + 1;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n-1][n-1];\n\t\twhile(lo < hi) {\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif(count(matrix, mid) < k) lo = mid + 1;\n\t\t\telse hi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n\tpublic int count(int[][] matrix, int target) {\n\t\tint n = matrix.length;\n\t\tint lo = 0, hi = n * n - 1;\n\t\twhile(lo <= hi) {\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif(matrix[mid / n][mid % n] < target) lo = mid + 1;\n\t\t\telse hi = mid - 1;\n\t\t}\n\t\treturn lo;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n-1][n-1];\n\t\twhile(lo < hi){\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif(count(matrix, mid) < k)\n\t\t\t\tlo = mid + 1;\n\t\t\telse\n\t\t\t\thi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n\tpublic int count(int[][] matrix, int target){\n\t\tint n = matrix.length, i = n - 1, j = 0, cnt = 0;\n\t\twhile(i >= 0 && j < n){\n\t\t\tif(matrix[i][j] <= target)\n\t\t\t\tcnt += i + 1;\n\t\t\tif(matrix[i][j] > target)\n\t\t\t\tj++;\n\t\t\ti--;\n\t\t}\n\t\treturn cnt;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n-1][n-1];\n\t\twhile(lo < hi){\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint j = 0;\n\t\t\t\twhile(j < n && matrix[i][j] <= mid) j++;\n\t\t\t\tcount += j;\n\t\t\t}\n\t\t\tif(count < k) lo = mid + 1;\n\t\t\telse hi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n-1][n-1];\n\t\twhile(lo < hi){\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif(count(matrix, mid) < k) lo = mid + 1;\n\t\t\telse hi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n\tpublic int count(int[][] matrix, int target){\n\t\tint n = matrix.length, count = 0;\n\t\tint i = n - 1, j = 0;\n\t\twhile(i >= 0 && j < n){\n\t\t\tif(matrix[i][j] <= target) j++;\n\t\t\telse i--;\n\t\t\tcount += i + 1;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tint lo = matrix[0][0], hi = matrix[n - 1][n - 1];\n\t\twhile (lo < hi) {\n\t\t\tint mid = lo + (hi - lo) / 2;\n\t\t\tif (countSmaller(matrix, mid) < k)\n\t\t\t\tlo = mid + 1;\n\t\t\telse\n\t\t\t\thi = mid;\n\t\t}\n\t\treturn lo;\n\t}\n\tprivate int countSmaller(int[][] matrix, int target) {\n\t\tint n = matrix.length;\n\t\tint count = 0, i = n - 1, j = 0;\n\t\twhile (i >= 0 && j < n) {\n\t\t\tif (matrix[i][j] <= target) {\n\t\t\t\tcount += i + 1;\n\t\t\t\tj++;\n\t\t\t} else\n\t\t\t\ti--;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint kthSmallest(int[][] matrix, int k) {\n\t\tint n = matrix.length;\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tpq.offer(matrix[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < k-1; i++){\n\t\t\tpq.poll();\n\t\t}\n\t\treturn pq.poll();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2121",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string date representing a Gregorian calendar date, return the day number of the year.",
    "snippets": [
        "\tint dayOfYear(String date) {\n\t\tint[] days = {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tint year = Integer.parseInt(date.substring(0,4));\n\t\tint month = Integer.parseInt(date.substring(5,7));\n\t\tint day = Integer.parseInt(date.substring(8));\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < month - 1; i++){\n\t\t\tsum += days[i];\n\t\t}\n\t\tif(year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n\t\t\tdays[2] = 29;\n\t\t}\n\t\treturn sum + day;\n\t}\n}\n",
        "\tint dayOfYear(String date) {\n\t\tint[] days = {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tint year = Integer.parseInt(date.substring(0,4));\n\t\tint month = Integer.parseInt(date.substring(5,7));\n\t\tint day = Integer.parseInt(date.substring(8,10));\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < month - 1; i++){\n\t\t\tsum += days[i];\n\t\t}\n\t\tsum += day;\n\t\tif(year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n\t\t\tsum += 1;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint dayOfYear(String date) {\n\t\tint[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\t\tint year = Integer.parseInt(date.substring(0, 4));\n\t\tint month = Integer.parseInt(date.substring(5, 7));\n\t\tint day = Integer.parseInt(date.substring(8, 10));\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < month - 1; i++) {\n\t\t\tsum += days[i];\n\t\t}\n\t\tsum += day;\n\t\tif (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {\n\t\t\tsum += 1;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint dayOfYear(String date) {\n\t\tint[] days = {31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tint year = Integer.parseInt(date.substring(0,4));\n\t\tint month = Integer.parseInt(date.substring(5,7));\n\t\tint day = Integer.parseInt(date.substring(8));\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < month - 1; i++){\n\t\t\tsum += days[i];\n\t\t}\n\t\tsum += day;\n\t\tif(year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n\t\t\tdays[1] = 29;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint dayOfYear(String date) {\n\t\tint[] days = {31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tint year = Integer.parseInt(date.substring(0,4));\n\t\tint month = Integer.parseInt(date.substring(5,7));\n\t\tint day = Integer.parseInt(date.substring(8));\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < month - 1; i++){\n\t\t\tsum += days[i];\n\t\t}\n\t\tsum += day;\n\t\tif(year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n\t\t\tsum += 1;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint dayOfYear(String date) {\n\t\tint[] month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\t\tint year = Integer.parseInt(date.substring(0, 4));\n\t\tint month_ = Integer.parseInt(date.substring(5, 7));\n\t\tint day = Integer.parseInt(date.substring(8, 10));\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < month_ - 1; i++) {\n\t\t\tsum += month[i];\n\t\t}\n\t\tsum += day;\n\t\tif (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {\n\t\t\tsum += 1;\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tstatic int dayOfYear(String date) {\n\t\tint year = Integer.parseInt(date.substring(0,4));\n\t\tint month = Integer.parseInt(date.substring(5,7));\n\t\tint day = Integer.parseInt(date.substring(8,10));\n\t\tint[] days = {31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tif(year%4==0 && year%100!=0 || year%400==0){\n\t\t\tdays[1] = 29;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i=0;i<month-1;i++){\n\t\t\tsum += days[i];\n\t\t}\n\t\treturn sum+day;\n\t}\n}\n",
        "\tint dayOfYear(String date) {\n\t\tint[] monthDays = {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\t\tint year = Integer.parseInt(date.substring(0,4));\n\t\tint month = Integer.parseInt(date.substring(5,7));\n\t\tint day = Integer.parseInt(date.substring(8,10));\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < month - 1; i++){\n\t\t\tsum += monthDays[i];\n\t\t}\n\t\tsum += day;\n\t\tif(year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n\t\t\tsum += 1;\n\t\t}\n\t\treturn sum;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2122",
    "source": "leetcode",
    "language": "java",
    "query": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you can move to either index i or index i + 1.",
    "snippets": [
        "\tint minimumTotal(List<List<Integer>> triangle) {\n\t\tint n = triangle.size();\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][0] = triangle.get(n - 1).get(i);\n\t\t}\n\t\tfor(int i = n - 2; i >= 0; i--){\n\t\t\tfor(int j = 0; j <= i; j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][0];\n\t}\n}\n",
        "\tint minimumTotal(List<List<Integer>> triangle) {\n\t\tint n = triangle.size();\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][0] = triangle.get(n - 1).get(i);\n\t\t}\n\t\tfor(int i = n - 2; i >= 0; i--){\n\t\t\tfor(int j = 0; j < triangle.get(i).size(); j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][0];\n\t}\n}\n",
        "\tint minimumTotal(List<List<Integer>> triangle) {\n\t\tint n = triangle.size();\n\t\tint[] dp = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i] = triangle.get(n-1).get(i);\n\t\t}\n\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\tfor(int j = 0; j < triangle.get(i).size(); j++){\n\t\t\t\tdp[j] = Math.min(dp[j], dp[j+1]) + triangle.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\treturn dp[0];\n\t}\n}\n",
        "\tint minimumTotal(int[][] triangle) {\n\t\tint n = triangle.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][0] = triangle[i][0];\n\t\t}\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < i+1; j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j];\n\t\t\t}\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmin = Math.min(min, dp[n-1][i]);\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minimumPathSum(int[][] triangle) {\n\t\tint row = triangle.length;\n\t\tint col = triangle[0].length;\n\t\tint[][] dp = new int[row][col];\n\t\tdp[0][0] = triangle[0][0];\n\t\tfor(int i = 1; i < row; i++){\n\t\t\tfor(int j = 0; j < col; j++){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + triangle[i][j];\n\t\t\t\t}else if(j == col-1){\n\t\t\t\t\tdp[i][j] = dp[i-1][j-1] + triangle[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[row-1][col-1];\n\t}\n}\n",
        "\tint minimumTotal(int[][] triangle) {\n\t\tint[][] dp = new int[triangle.length][triangle[0].length];\n\t\tfor(int i = 0; i < triangle.length; i++){\n\t\t\tfor(int j = 0; j < triangle[0].length; j++){\n\t\t\t\tif(i == 0){\n\t\t\t\t\tdp[i][j] = triangle[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i-1][j+1]) + triangle[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[triangle.length-1][0];\n\t}\n}\n",
        "\tint minimumTotal(List<List<Integer>> triangle) {\n\t\tint row = triangle.size();\n\t\tint[] dp = new int[row];\n\t\tfor(int i = 0; i < row; i++){\n\t\t\tdp[i] = triangle.get(row - 1).get(i);\n\t\t}\n\t\tfor(int i = row - 2; i >= 0; i--){\n\t\t\tfor(int j = 0; j < triangle.get(i).size(); j++){\n\t\t\t\tdp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);\n\t\t\t}\n\t\t}\n\t\treturn dp[0];\n\t}\n}\n",
        "\tint minimumTotal(int[][] triangle) {\n\t\tint[] dp = new int[triangle[triangle.length - 1].length];\n\t\tfor (int i = 0; i < triangle.length; i++) {\n\t\t\tfor (int j = 0; j < triangle[i].length; j++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tdp[j] = triangle[i][j];\n\t\t\t\t} else {\n\t\t\t\t\tdp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2123",
    "source": "leetcode",
    "language": "java",
    "query": "The game involves two robots playing on a 2D grid. The first robot moves from (0, 0) to (1, n-1), collecting the points on its path. The second robot wants to minimize the number of points collected by the first.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[][] grid = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tgrid[i][j] = (int)(Math.random()*10);\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdp[0][n-1] = grid[0][n-1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i > 0){\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i-1][j] + grid[i][j]);\n\t\t\t\t}\n\t\t\t\tif(j > 0){\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j-1] + grid[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n-1][n-1]);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[][] grid = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tgrid[i][j] = (int)(Math.random()*10);\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tdp[0][n-1] = grid[0][n-1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i > 0){\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i-1][j] + grid[i][j]);\n\t\t\t\t}\n\t\t\t\tif(j > 0){\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j-1] + grid[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n-1][0]);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[][] grid = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tgrid[i][j] = (int)(Math.random()*10);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Grid:\");\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tSystem.out.print(grid[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"DP:\");\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tSystem.out.\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[][] grid = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tgrid[i][j] = (int)(Math.random() * 10);\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == 0 && j == 0){\n\t\t\t\t\tdp[i][j] = grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(i == 0){\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse if(j == 0){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + grid[i][j];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n-1][n-1]);\n\t}\n}\n",
        "\tint minPoints(int[][] grid){\n\t\tint n = grid.length;\n\t\tint m = grid[0].length;\n\t\tint[][] dp = new int[n][m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(i > 0){\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j > 0){\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][j-1] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = dp[n-1][m-1];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif(i > 0 && j > 0){\n\t\t\t\t\tres = Math.min(res, dp[i-1][j-1] + dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minPoints(int[][] grid){\n\t\tint n = grid.length;\n\t\tint m = grid[0].length;\n\t\tint[][] dp = new int[n][m];\n\t\tint[][] visited = new int[n][m];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\tvisited[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif(grid[i][j] == 1){\n\t\t\t\t\tif(i - 1 >= 0 && grid[i - 1][j] == 1){\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t\tvisited[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif(j - 1 >= 0 && grid[i][j - 1] == 1){\n\t\t\t\t\t\tdp[i][j] += dp[i][j - 1];\n\t\t\t\t\t\tvisited[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif(grid[i][j] == 1 && visited[i][j] == 0){\n\t\t\t\t\tres = Math.min(res, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res == Integer.MAX_VALUE ? 0 : res;\n",
        "\tint minScore(int n){\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[0][i] = i;\n\t\t}\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + 1;\n\t\t\t}\n\t\t}\n\t\treturn dp[n-1][n-1];\n\t}\n}\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic int minPoints(int[][] points){\n\t\tint n = points.length;\n\t\tint[][] dists = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdists[i][j] = (int)Math.sqrt((points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]));\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tmin = Math.min(min, dists[j][i] + dp[j]);\n\t\t\t}\n\t\t\tdp[i] = min;\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2124",
    "source": "leetcode",
    "language": "java",
    "query": "You must write an algorithm that runs in O(n) time. Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
    "snippets": [
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tint max = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint left = nums[i] - 1;\n\t\t\tint right = nums[i] + 1;\n\t\t\tint count = 1;\n\t\t\twhile(set.contains(left)){\n\t\t\t\tset.remove(left);\n\t\t\t\tleft--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\twhile(set.contains(right)){\n\t\t\t\tset.remove(right);\n\t\t\t\tright++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tint max = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(!set.contains(nums[i])) continue;\n\t\t\tint count = 1;\n\t\t\tint left = nums[i] - 1;\n\t\t\twhile(set.contains(left)){\n\t\t\t\tset.remove(left);\n\t\t\t\tleft--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tint right = nums[i] + 1;\n\t\t\twhile(set.contains(right)){\n\t\t\t\tset.remove(right);\n\t\t\t\tright++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tint max = 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint count = 1;\n\t\t\tint num = nums[i];\n\t\t\twhile(set.contains(num + 1)){\n\t\t\t\tcount++;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint count = 1;\n\t\t\tif(set.contains(nums[i] - 1)) continue;\n\t\t\tint j = nums[i] + 1;\n\t\t\twhile(set.contains(j)){\n\t\t\t\tcount++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tmax = Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums.length==0) return 0;\n\t\tint max=1;\n\t\tHashSet<Integer> set=new HashSet<Integer>();\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tint left=nums[i]-1;\n\t\t\tint right=nums[i]+1;\n\t\t\tint count=1;\n\t\t\twhile(set.contains(left)){\n\t\t\t\tset.remove(left);\n\t\t\t\tleft--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\twhile(set.contains(right)){\n\t\t\t\tset.remove(right);\n\t\t\t\tright++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmax=Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums.length==0) return 0;\n\t\tint max=1;\n\t\tHashSet<Integer> set=new HashSet<Integer>();\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tint count=1;\n\t\t\tint num=nums[i];\n\t\t\twhile(set.contains(num+1)){\n\t\t\t\tcount++;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tmax=Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums.length==0) return 0;\n\t\tint max=1;\n\t\tSet<Integer> set=new HashSet<Integer>();\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tint left=nums[i]-1;\n\t\t\tint right=nums[i]+1;\n\t\t\tint count=1;\n\t\t\twhile(set.contains(left)){\n\t\t\t\tset.remove(left);\n\t\t\t\tleft--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\twhile(set.contains(right)){\n\t\t\t\tset.remove(right);\n\t\t\t\tright++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmax=Math.max(max, count);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint longestConsecutive(int[] nums) {\n\t\tif(nums.length==0) return 0;\n\t\tint max=0;\n\t\tSet<Integer> set=new HashSet<Integer>();\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tset.add(nums[i]);\n\t\t}\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tif(!set.contains(nums[i]-1)){\n\t\t\t\tint j=nums[i];\n\t\t\t\twhile(set.contains(j)){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tmax=Math.max(max,j-nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2125",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.",
    "snippets": [
        "\tString convertToTitle(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n>0){\n\t\t\tn--;\n\t\t\tsb.append((char)('A'+n%26));\n\t\t\tn/=26;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString convertToTitle(int columnNumber) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (columnNumber > 0) {\n\t\t\tcolumnNumber--;\n\t\t\tsb.append((char) (columnNumber % 26 + 'A'));\n\t\t\tcolumnNumber /= 26;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString convertToTitle(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n>0){\n\t\t\tn--;\n\t\t\tsb.insert(0, (char)(n%26+'A'));\n\t\t\tn/=26;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString convertToTitle(int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n > 0){\n\t\t\tn--;\n\t\t\tsb.append((char)(n % 26 + 'A'));\n\t\t\tn /= 26;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString convertToTitle(int columnNumber) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(columnNumber > 0){\n\t\t\tsb.insert(0, (char)((columnNumber - 1) % 26 + 'A'));\n\t\t\tcolumnNumber = (columnNumber - 1) / 26;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2126",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.",
    "snippets": [
        "\tint findMaxLength(int[] nums) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tmap.put(0, -1);\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (nums[i] == 0) {\n\t\t\t\tsum--;\n\t\t\t} else {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t\tif (map.containsKey(sum)) {\n\t\t\t\tmax = Math.max(max, i - map.get(sum));\n\t\t\t} else {\n\t\t\t\tmap.put(sum, i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaxLength(int[] nums) {\n\t\tint max = 0;\n\t\tint[] count = new int[2];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tcount[nums[i]]++;\n\t\t\tif (count[0] == count[1]) {\n\t\t\t\tmax = Math.max(max, i + 1);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaxLength(int[] nums) {\n\t\tint max = 0;\n\t\tint[] count = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 0){\n\t\t\t\tcount[i] = -1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = i; j < nums.length; j++){\n\t\t\t\tsum += count[j];\n\t\t\t\tif(sum == 0){\n\t\t\t\t\tmax = Math.max(max, j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaxLength(int[] nums) {\n\t\tint max = 0;\n\t\tint[] count = new int[nums.length];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (nums[i] == 0) {\n\t\t\t\tcount[i] = -1;\n\t\t\t} else {\n\t\t\t\tcount[i] = 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tif (count[i] == count[j]) {\n\t\t\t\t\tmax = Math.max(max, j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaxLength(int[] nums) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint[] count = new int[2];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i] == 0 ? -1 : 1;\n\t\t\tif(sum == 0){\n\t\t\t\tmax = i + 1;\n\t\t\t}\n\t\t\tcount[sum + 1] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] > 0){\n\t\t\t\tmax = Math.max(max, count[i] + count[0] - 1);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaxLength(int[] nums) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint[] count = new int[2];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i] == 0 ? -1 : 1;\n\t\t\tif (sum == 0) {\n\t\t\t\tmax = i + 1;\n\t\t\t}\n\t\t\tif (count[sum + 1] == 0) {\n\t\t\t\tcount[sum + 1] = i + 1;\n\t\t\t}\n\t\t\tif (count[sum] > 0) {\n\t\t\t\tmax = Math.max(max, i - count[sum] + 1);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaxLength(int[] nums) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint[] count = new int[2];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i] == 0 ? -1 : 1;\n\t\t\tif(sum == 0){\n\t\t\t\tmax = i + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(count[sum + 1] == 0){\n\t\t\t\t\tcount[sum + 1] = i + 1;\n\t\t\t\t}\n\t\t\t\tmax = Math.max(max, i - count[sum]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2127",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers piles where piles[i] is the number of coins in the ith pile. There are 3n piles of coins of varying size, you and your friends will take piles of Coins.",
    "snippets": [
        "\tstatic int min(int a, int b){\n\t\treturn a<b?a:b;\n\t}\n\tpublic static int min(int a, int b, int c){\n\t\treturn min(min(a,b),c);\n\t}\n\tpublic static int min(int a, int b, int c, int d){\n\t\treturn min(min(a,b),min(c,d));\n\t}\n\tpublic static int min(int a, int b, int c, int d, int e){\n\t\treturn min(min(a,b),min(c,d),e);\n\t}\n\tpublic static int min(int a, int b, int c, int d, int e, int f){\n\t\treturn min(min(a,b),min(c,d),min(e,f));\n\t}\n\tpublic static int min(int a, int b, int c, int d, int e, int f, int g){\n\t\treturn min(min(a,b),min(c,d),min(e,f),g);\n\t}\n\tpublic static int min(int a, int b, int c, int d, int e, int f, int g, int h){\n\t\treturn min(min(a,b),min(c,d),min(e,f),min(g,h));\n\t}\n\tpublic static int min(int a, int b, int c, int d, int e, int f, int g, int h, int i){\n\t\treturn min(min(a,b),min(c,d),min(e,f),min(g,h),i);\n\t}\n\tpublic static int min(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j){\n\t\treturn min(min(a,b),min(c,d),min(e,f),min(g,h),min(i,j));\n\t}\n\tpublic static int min(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j,\n",
        "\tstatic int[] piles;\n\tpublic static void main(String[] args){\n\t\tpiles = new int[]{1,2,3,4,5,6,7,8,9,10};\n\t\tSystem.out.println(solve(piles));\n\t}\n\tpublic static int solve(int[] piles){\n\t\tint n = piles.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = piles[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdp[i][j] = Math.max(dp[i][j - 1] + piles[j], dp[i + 1][j] + piles[i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint minCoins(int[] piles) {\n\t\tint n = piles.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = piles[i];\n\t\t}\n\t\tfor (int len = 2; len <= n; len++) {\n\t\t\tfor (int i = 0; i + len - 1 < n; i++) {\n\t\t\t\tint j = i + len - 1;\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + piles[i] * piles[k + 1] * piles[j + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint minCostToMoveChips(int[] piles) {\n\t\tint odd = 0, even = 0;\n\t\tfor (int i = 0; i < piles.length; i++) {\n\t\t\tif (piles[i] % 2 == 0) {\n\t\t\t\teven++;\n\t\t\t} else {\n\t\t\t\todd++;\n\t\t\t}\n\t\t}\n\t\treturn Math.min(odd, even);\n\t}\n}\n",
        "\tint min(int a, int b){\n\t\treturn a<b?a:b;\n\t}\n\tpublic int minCoins(int[] piles) {\n\t\tint n = piles.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdp[i][i] = piles[i];\n\t\t}\n\t\tfor(int len=2;len<=n;len++){\n\t\t\tfor(int i=0;i<n-len+1;i++){\n\t\t\t\tint j = i+len-1;\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\tfor(int k=i;k<=j;k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i][k-1]+dp[k+1][j]+piles[i-1]*piles[k]*piles[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n-1];\n\t}\n}\n",
        "\tint min(int a, int b){\n\t\treturn a<b?a:b;\n\t}\n\tpublic int min3(int a, int b, int c){\n\t\treturn min(min(a,b),c);\n\t}\n\tpublic int minCost(int[] piles){\n\t\tint n = piles.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdp[i][i] = piles[i];\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<n-i;j++){\n\t\t\t\tdp[j][j+i] = min3(dp[j][j+i-1]+piles[j],dp[j+1][j+i]+piles[j+1],dp[j+2][j+i]+piles[j+2]);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n-1];\n\t}\n}\n",
        "\tint minCostToMoveCoins(int[] piles) {\n\t\tint n = piles.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = piles[i];\n\t\t}\n\t\tfor (int len = 2; len <= n; len++) {\n\t\t\tfor (int i = 0; i + len - 1 < n; i++) {\n\t\t\t\tint j = i + len - 1;\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\tfor (int k = i; k <= j; k++) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + (j - k) * piles[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint minCostToMoveCoin(int[] piles) {\n\t\tint n = piles.length;\n\t\tint[] dp = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + Math.abs(piles[i] - piles[j]));\n\t\t\t}\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint minNumberOfCoins(int[] piles) {\n\t\tint[] dp = new int[piles.length];\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < piles.length; i++) {\n\t\t\tsum += piles[i];\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < piles.length; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (piles[i] > piles[j]) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[piles.length - 1];\n\t}\n}\n",
        "\tstatic int[] piles;\n\tpublic static void main(String[] args){\n\t\tpiles = new int[]{3,1,5,2};\n\t\tSystem.out.println(solve(piles));\n\t}\n\tpublic static int solve(int[] piles){\n\t\tint n = piles.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = piles[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdp[i][j] = Math.max(dp[i][j-1] + piles[j], piles[i] + dp[i+1][j]);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2128",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. LCA is defined between two nodes p and q.",
    "snippets": [
        "\tTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\tif(root == null) return null;\n\t\tif(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);\n\t\tif(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\tif(root == null) return null;\n\t\tif(root.val > p.val && root.val > q.val)\n\t\t\treturn lowestCommonAncestor(root.left, p, q);\n\t\telse if(root.val < p.val && root.val < q.val)\n\t\t\treturn lowestCommonAncestor(root.right, p, q);\n\t\telse\n\t\t\treturn root;\n\t}\n}\n",
        "\tNode lowestCommonAncestor(Node root, Node p, Node q) {\n\t\tif(root == null) return null;\n\t\tif(root == p || root == q) return root;\n\t\tNode left = lowestCommonAncestor(root.left, p, q);\n\t\tNode right = lowestCommonAncestor(root.right, p, q);\n\t\tif(left != null && right != null) return root;\n\t\treturn left == null ? right : left;\n\t}\n}\n",
        "\tTreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\t\tif(root == null) return null;\n\t\tif(root.val == p.val || root.val == q.val) return root;\n\t\tTreeNode left = lowestCommonAncestor(root.left, p, q);\n\t\tTreeNode right = lowestCommonAncestor(root.right, p, q);\n\t\tif(left != null && right != null) return root;\n\t\treturn left == null ? right : left;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2129",
    "source": "leetcode",
    "language": "java",
    "query": "A prefix of a string is a substring that occurs at the beginning of the string. You are given a string array words and a string s.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"};\n\t\tString s = \"abcdefghijklmnopqrstuvwxyz\";\n\t\tSystem.out.println(isPrefix(words,s));\n\t}\n\tpublic static boolean isPrefix(String[] words, String s){\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].startsWith(s)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"i\", \"am\", \"a\", \"student\", \"from\", \"a\", \"university\"};\n\t\tString s = \"student\";\n\t\tSystem.out.println(isPrefix(words, s));\n\t}\n\tpublic static boolean isPrefix(String[] words, String s){\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].startsWith(s)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"cat\",\"bat\",\"rat\"};\n\t\tString s = \"the cattle was rattled by the battery\";\n\t\tSystem.out.println(findSubstring(words,s));\n\t}\n\tpublic static List<Integer> findSubstring(String[] words, String s) {\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(words == null || words.length == 0 || s == null || s.length() == 0){\n\t\t\treturn result;\n\t\t}\n\t\tint len = words[0].length();\n\t\tint num = words.length;\n\t\tint totalLen = len * num;\n\t\tif(s.length() < totalLen){\n\t\t\treturn result;\n\t\t}\n\t\tMap<String,Integer> map = new HashMap<String,Integer>();\n\t\tfor(String word : words){\n\t\t\tif(map.containsKey(word)){\n\t\t\t\tmap.put(word,map.get(word)+1);\n\t\t\t}else{\n\t\t\t\tmap.put(word,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < s.length() - totalLen + 1; i++){\n\t\t\tMap<String,Integer> temp = new HashMap<String,Integer>(map);\n\t\t\tint j = i;\n\t\t\twhile(j < i + totalLen){\n\t\t\t\tString str = s.substring(j,j+len);\n\t\t\t\tif(temp.containsKey(str)){\n\t\t\t\t\ttemp.put(str,temp.get(str)-1);\n\t\t\t\t\tif(temp.get(str) == 0){\n\t\t\t\t\t\ttemp.remove(str);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj += len;\n\t\t\t}\n\t\t\tif(temp.isEmpty()){\n\t\t\t\tresult.add\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"cat\",\"bat\",\"rat\"};\n\t\tString s = \"the cattle was rattled by the battery\";\n\t\tSystem.out.println(findSubstring(s,words));\n\t}\n\tpublic static List<Integer> findSubstring(String s, String[] words) {\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(s == null || words == null || words.length == 0)\n\t\t\treturn result;\n\t\tint wordLen = words[0].length();\n\t\tint len = s.length();\n\t\tint num = words.length;\n\t\tint totalLen = wordLen * num;\n\t\tif(len < totalLen)\n\t\t\treturn result;\n\t\tMap<String,Integer> map = new HashMap<String,Integer>();\n\t\tfor(String word : words){\n\t\t\tif(map.containsKey(word))\n\t\t\t\tmap.put(word,map.get(word)+1);\n\t\t\telse\n\t\t\t\tmap.put(word,1);\n\t\t}\n\t\tfor(int i = 0; i < len - totalLen + 1; i++){\n\t\t\tMap<String,Integer> temp = new HashMap<String,Integer>();\n\t\t\tfor(int j = 0; j < num; j++){\n\t\t\t\tString word = s.substring(i + j * wordLen,i + (j + 1) * wordLen);\n\t\t\t\tif(temp.containsKey(word))\n\t\t\t\t\ttemp.put(word,temp.get(word)+1);\n\t\t\t\telse\n\t\t\t\t\ttemp.put(word,1);\n\t\t\t}\n\t\t\tif(temp.equals(map))\n\t\t\t\tresult.add(i);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"ab\",\"abc\",\"abcd\",\"abcde\",\"abcdef\",\"abcdefg\"};\n\t\tString s = \"abcdefg\";\n\t\tSystem.out.println(isPrefix(words,s));\n\t}\n\tpublic static boolean isPrefix(String[] words,String s){\n\t\tfor(int i = 0;i<words.length;i++){\n\t\t\tif(words[i].startsWith(s)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"cat\", \"dog\", \"apple\"};\n\t\tString s = \"apple\";\n\t\tSystem.out.println(isPrefix(words, s));\n\t}\n\tpublic static boolean isPrefix(String[] words, String s){\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].startsWith(s)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"cat\",\"dog\",\"rabbit\",\"mouse\"};\n\t\tString s = \"rabbit\";\n\t\tSystem.out.println(isPrefix(words,s));\n\t}\n\tpublic static boolean isPrefix(String[] words,String s){\n\t\tfor(int i=0;i<words.length;i++){\n\t\t\tif(words[i].startsWith(s)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"ab\",\"abc\",\"abd\",\"abcd\",\"abcde\"};\n\t\tString s = \"abcde\";\n\t\tSystem.out.println(isPrefix(words,s));\n\t}\n\tpublic static boolean isPrefix(String[] words, String s){\n\t\tfor(String word:words){\n\t\t\tif(word.startsWith(s)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"cat\",\"dog\",\"rabbit\",\"mouse\"};\n\t\tString s = \"rabbit\";\n\t\tSystem.out.println(findSubstring(words,s));\n\t}\n\tpublic static int findSubstring(String[] words, String s) {\n\t\tint count = 0;\n\t\tint len = words.length;\n\t\tint len_s = s.length();\n\t\tint len_word = words[0].length();\n\t\tint len_all = len_word * len;\n\t\tif(len_s < len_all){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i = 0; i < len_s - len_all + 1; i++){\n\t\t\tString temp = s.substring(i,i+len_all);\n\t\t\tif(isValid(words,temp)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic static boolean isValid(String[] words, String s){\n\t\tint len = words.length;\n\t\tint len_word = words[0].length();\n\t\tint len_all = len_word * len;\n\t\tif(s.length() != len_all){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tString temp = s.substring(i*len_word,(i+1)*len_word);\n\t\t\tif(!words[i].equals(temp)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"cat\",\"dog\",\"rabbit\",\"mouse\"};\n\t\tString s = \"rabbit\";\n\t\tSystem.out.println(findSubstring(words,s));\n\t}\n\tpublic static int findSubstring(String[] words, String s) {\n\t\tint count = 0;\n\t\tint len = words.length;\n\t\tint len_s = s.length();\n\t\tint len_word = words[0].length();\n\t\tint len_all = len_word * len;\n\t\tif(len_s < len_all){\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i = 0; i < len_s - len_all + 1; i++){\n\t\t\tString sub = s.substring(i,i+len_all);\n\t\t\tif(isSubstring(words,sub)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic static boolean isSubstring(String[] words, String s){\n\t\tint len = words.length;\n\t\tint len_word = words[0].length();\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tString word = words[i];\n\t\t\tif(!s.contains(word)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tint index = s.indexOf(word);\n\t\t\tif(index != 0 && index % len_word != 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ts = s.substring(index+len_word);\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2130",
    "source": "leetcode",
    "language": "java",
    "query": "The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backward) for which the stock price was less than or equal to today's price. For example, if the price of a stock over the next 7 days were [100,80,60,70,75,85], then the stock spans would be [1,1,.1,2,1,4,6].",
    "snippets": [
        "\tstatic int span(int[] prices){\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] <= prices[i+1]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tif(count > max){\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int span(int[] prices){\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] <= prices[i+1]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint span(int[] prices){\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] <= prices[i+1]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint span(int[] prices){\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] <= prices[i+1]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tif(count > max){\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int getSpan(int[] prices){\n\t\tint span = 0;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tif(prices[i] <= max){\n\t\t\t\tspan++;\n\t\t\t}else{\n\t\t\t\tmax = prices[i];\n\t\t\t\tspan = 1;\n\t\t\t}\n\t\t}\n\t\treturn span;\n\t}\n}\n",
        "\tint[] stockSpan(int[] prices){\n\t\tint[] result = new int[prices.length];\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\twhile(!stack.isEmpty() && prices[stack.peek()] <= prices[i]){\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tif(stack.isEmpty()){\n\t\t\t\tresult[i] = i + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresult[i] = i - stack.peek();\n\t\t\t}\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] stockSpan(int[] prices){\n\t\tint[] result = new int[prices.length];\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\twhile(!stack.isEmpty() && prices[i] >= prices[stack.peek()]){\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tif(stack.isEmpty()){\n\t\t\t\tresult[i] = i + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresult[i] = i - stack.peek();\n\t\t\t}\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] stockSpan(int[] prices){\n\t\tint[] res = new int[prices.length];\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\twhile(!stack.isEmpty() && prices[stack.peek()] <= prices[i]){\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tres[i] = stack.isEmpty() ? i + 1 : i - stack.peek();\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] stockSpans(int[] prices){\n\t\tint[] spans = new int[prices.length];\n\t\tfor(int i = prices.length-1; i>=0; i--){\n\t\t\tint span = 1;\n\t\t\tfor(int j = i-1; j>=0; j--){\n\t\t\t\tif(prices[i]>=prices[j]){\n\t\t\t\t\tspan++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspans[i] = span;\n\t\t}\n\t\treturn spans;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2131",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array arr. You can choose a set of integers and remove all the occurrences of these integers in the array. Return the minimum size of the set so that at least half of the integers of the array are removed.",
    "snippets": [
        "\tint minSetSize(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] count = new int[10001];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcount[arr[i]]++;\n\t\t}\n\t\tint res = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < 10001; i++){\n\t\t\tif(count[i] > 0){\n\t\t\t\tsum += count[i];\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tif(sum * 2 > n){\n\t\t\treturn res;\n\t\t}\n\t\treturn res - 1;\n\t}\n}\n",
        "\tint minSetSize(int[] arr) {\n\t\tint count = 0;\n\t\tint len = arr.length;\n\t\tint[] map = new int[10001];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tmap[arr[i]]++;\n\t\t}\n\t\tArrays.sort(map);\n\t\tfor(int i = 0; i < 10001; i++){\n\t\t\tif(map[i] != 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(count >= len/2){\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minSetSize(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[10001];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt[arr[i]]++;\n\t\t}\n\t\tint res = 0;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 10001; i++) {\n\t\t\tif (cnt[i] > 0) {\n\t\t\t\tsum += cnt[i];\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tif (sum * 2 <= n) {\n\t\t\treturn res;\n\t\t}\n\t\tint left = 0;\n\t\tint right = res - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right + 1) / 2;\n\t\t\tif (sum - cnt[mid] * mid >= n / 2) {\n\t\t\t\tleft = mid;\n\t\t\t} else {\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n}\n",
        "\tint minSetSize(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[10001];\n\t\tfor (int x : arr) cnt[x]++;\n\t\tint ans = 0, sum = 0;\n\t\tfor (int i = 0; i < 10001; i++) {\n\t\t\tif (cnt[i] > 0) {\n\t\t\t\tsum += cnt[i];\n\t\t\t\tans++;\n\t\t\t\tif (sum * 2 <= n) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint minSetSize(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[10001];\n\t\tfor(int x: arr) cnt[x]++;\n\t\tint res = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < 10001; i++){\n\t\t\tif(cnt[i] > 0){\n\t\t\t\tsum += cnt[i];\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tif(sum >= n/2) break;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minSetSize(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[10001];\n\t\tfor (int x : arr)\n\t\t\tcnt[x]++;\n\t\tint ans = 0;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 10001; i++) {\n\t\t\tif (cnt[i] > 0) {\n\t\t\t\tsum += cnt[i];\n\t\t\t\tans++;\n\t\t\t\tif (sum * 2 <= n)\n\t\t\t\t\tans--;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint minSetSize(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[10001];\n\t\tfor(int x: arr) cnt[x]++;\n\t\tint ans = 0;\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < 10001; i++){\n\t\t\tif(cnt[i] > 0){\n\t\t\t\tsum += cnt[i];\n\t\t\t\tans++;\n\t\t\t}\n\t\t\tif(sum >= n/2) break;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint minSetSize(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[10001];\n\t\tfor (int a : arr) {\n\t\t\tcnt[a]++;\n\t\t}\n\t\tint res = 0;\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 10001; i++) {\n\t\t\tif (cnt[i] > 0) {\n\t\t\t\tsum += cnt[i];\n\t\t\t\tres++;\n\t\t\t}\n\t\t\tif (sum >= n / 2) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minSet(int[] arr) {\n\t\tint n = arr.length;\n\t\tint[] cnt = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcnt[i] = 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (arr[i] == arr[j]) {\n\t\t\t\t\tcnt[i]++;\n\t\t\t\t\tcnt[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum += cnt[i];\n\t\t}\n\t\tint res = n;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (cnt[i] == 0) {\n\t\t\t\tres--;\n\t\t\t}\n\t\t}\n\t\tif (sum < n) {\n\t\t\treturn res;\n\t\t} else {\n\t\t\treturn n / 2;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2132",
    "source": "leetcode",
    "language": "java",
    "query": "You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed) Your goal is to maximize your total score by potentially playing each token in one of two ways.",
    "snippets": [
        "\tint maxScore(int[] tokens){\n\t\tint n = tokens.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = tokens[0];\n\t\tdp[1] = Math.max(tokens[0], tokens[1]);\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tdp[i] = Math.max(dp[i-1], dp[i-2] + tokens[i]);\n\t\t}\n\t\treturn dp[n-1];\n\t}\n}\n",
        "\tint bag[];\n\tint power;\n\tint score;\n\tpublic Clazz(int[] bag, int power){\n\t\tthis.bag = bag;\n\t\tthis.power = power;\n\t\tthis.score = 0;\n\t}\n\tpublic int getScore(){\n\t\treturn score;\n\t}\n\tpublic void play(int i){\n\t\tif(i>=bag.length) return;\n\t\tif(power>=bag[i]){\n\t\t\tpower -= bag[i];\n\t\t\tscore += bag[i];\n\t\t}\n\t\telse{\n\t\t\tscore += power;\n\t\t\tpower = 0;\n\t\t}\n\t}\n\tpublic void play(int i, int j){\n\t\tif(i>=bag.length) return;\n\t\tif(power>=bag[i]){\n\t\t\tpower -= bag[i];\n\t\t\tscore += bag[i];\n\t\t}\n\t\tif(power>=bag[j]){\n\t\t\tpower -= bag[j];\n\t\t\tscore += bag[j];\n\t\t}\n\t}\n}\n",
        "\tint bag[];\n\tint power;\n\tint score;\n\tpublic Clazz(int[] bag, int power){\n\t\tthis.bag = bag;\n\t\tthis.power = power;\n\t\tthis.score = 0;\n\t}\n\tpublic int getScore(){\n\t\treturn score;\n\t}\n\tpublic void play(int i){\n\t\tif(i<0 || i>=bag.length) return;\n\t\tif(power<bag[i]) return;\n\t\tpower -= bag[i];\n\t\tscore += bag[i];\n\t}\n\tpublic void play(int i, int j){\n\t\tif(i<0 || i>=bag.length) return;\n\t\tif(j<0 || j>=bag.length) return;\n\t\tif(power<bag[i]+bag[j]) return;\n\t\tpower -= bag[i]+bag[j];\n\t\tscore += bag[i]+bag[j];\n\t}\n}\n",
        "\tint bag(int[] tokens){\n\t\tint n = tokens.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = tokens[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdp[i][j] = Math.max(dp[i][j - 1] + tokens[j], dp[i + 1][j] + tokens[i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint bag(int[] tokens){\n\t\tint n = tokens.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = tokens[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tdp[i][j] = Math.max(dp[i][j - 1] + tokens[j], dp[i - 1][j] + tokens[i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[n - 1][n - 1];\n\t}\n}\n",
        "\tint maxScore(int[] tokens) {\n\t\tint n = tokens.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = tokens[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdp[i][j] = Math.max(dp[i][j - 1] + tokens[j], dp[i + 1][j] + tokens[i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint bag(int[] tokens){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < tokens.length; i++){\n\t\t\tsum += tokens[i];\n\t\t}\n\t\treturn sum;\n\t}\n\tpublic\n\tint bag2(int[] tokens){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < tokens.length; i++){\n\t\t\tsum += tokens[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2133",
    "source": "leetcode",
    "language": "java",
    "query": "A prefix of a string s is any leading contiguous substring of s. Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.",
    "snippets": [
        "\tstatic boolean isPrefix(String sentence, String searchWord){\n\t\tString[] words = sentence.split(\" \");\n\t\tfor(String word: words){\n\t\t\tif(word.startsWith(searchWord)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean isPrefix(String sentence, String searchWord){\n\t\tString[] words = sentence.split(\" \");\n\t\tfor(String word: words){\n\t\t\tif(word.startsWith(searchWord)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2134",
    "source": "leetcode",
    "language": "java",
    "query": "A lattice point is a point with integer coordinates. Given a 2D integer array circles where circles[i] = [xi, yi, ri], return the number of lattice points inside at least one circle.",
    "snippets": [
        "\tint numPoints(int[][] circles) {\n\t\tint n = circles.length;\n\t\tint[][] points = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpoints[i][0] = circles[i][0];\n\t\t\tpoints[i][1] = circles[i][1];\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tif(Math.abs(points[i][0] - points[j][0]) <= circles[i][2] + circles[j][2] && Math.abs(points[i][1] - points[j][1]) <= circles[i][2] + circles[j][2]){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint numPoints(int[][] circles) {\n\t\tint n = circles.length;\n\t\tint[][] points = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpoints[i][0] = circles[i][0];\n\t\t\tpoints[i][1] = circles[i][1];\n\t\t}\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\telse\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(dp[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(Math.abs(points[i][0] - points[j][0]) <= circles[i][2] + circles[j][2] && Math.abs(points[i][1] - points[j][1]) <= circles[i][2] + circles[j][2])\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(dp[i][j] == 1)\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint countPoints(int[][] circles) {\n\t\tint n = circles.length;\n\t\tint[][] points = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpoints[i][0] = circles[i][0];\n\t\t\tpoints[i][1] = circles[i][1];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (Math.abs(points[i][0] - points[j][0]) <= circles[i][2] + circles[j][2] && Math.abs(points[i][1] - points[j][1]) <= circles[i][2] + circles[j][2])\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint countPoints(int[][] circles) {\n\t\tint n = circles.length;\n\t\tint[][] points = new int[n][2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpoints[i][0] = circles[i][0];\n\t\t\tpoints[i][1] = circles[i][1];\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i == j) continue;\n\t\t\t\tif (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\n\t\t\t\t\tans++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (points[i][0] == points[j][0]) {\n\t\t\t\t\tif (Math.abs(points[i][1] - points[j][1]) <= circles[i][2] + circles[j][2]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t} else if (points[i][1] == points[j][1]) {\n\t\t\t\t\tif (Math.abs(points[i][0] - points[j][0]) <= circles[i][2] + circles[j][2]) {\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdouble x = (points[j][0] - points[i][0]) / (double) (points[i][1] - points[j][1]);\n\t\t\t\t\tdouble y = (points[i][1] * points[j][0] - points[j][1] * points[i][0]) / (double) (points[i][1] - points[j][1]);\n\t\t\t\t\tdouble r = Math.sqrt(x * x + y * y);\n\t\t\t\t\tif (r <= circles\n",
        "\tint countPoints(int[][] circles) {\n\t\tint n = circles.length;\n\t\tint[][] points = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x = circles[i][0];\n\t\t\tint y = circles[i][1];\n\t\t\tint r = circles[i][2];\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i == j) continue;\n\t\t\t\tint x2 = circles[j][0];\n\t\t\t\tint y2 = circles[j][1];\n\t\t\t\tint r2 = circles[j][2];\n\t\t\t\tif(x2 - x == 0 && y2 - y == 0){\n\t\t\t\t\tif(r2 > r) return 0;\n\t\t\t\t\telse return 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble a = (x2 - x) / (y2 - y);\n\t\t\t\t\tdouble b = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\t\t\t\t\tdouble c = b / (a * a + 1);\n\t\t\t\t\tdouble d = Math.sqrt(c);\n\t\t\t\t\tif(d > r) return 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n}\n",
        "\tint countPoints(int[][] circles) {\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < circles.length; i++){\n\t\t\tint x = circles[i][0];\n\t\t\tint y = circles[i][1];\n\t\t\tint r = circles[i][2];\n\t\t\tans += (x - r) * (x - r) + (y - r) * (y - r);\n\t\t\tans += (x + r) * (x + r) + (y - r) * (y - r);\n\t\t\tans += (x + r) * (x + r) + (y + r) * (y + r);\n\t\t\tans += (x - r) * (x - r) + (y + r) * (y + r);\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic int count(int[][] circles){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < circles.length; i++){\n\t\t\tint x = circles[i][0];\n\t\t\tint y = circles[i][1];\n\t\t\tint r = circles[i][2];\n\t\t\tint x1 = x - r;\n\t\t\tint y1 = y - r;\n\t\t\tint x2 = x + r;\n\t\t\tint y2 = y + r;\n\t\t\tfor(int j = x1; j <= x2; j++){\n\t\t\t\tfor(int k = y1; k <= y2; k++){\n\t\t\t\t\tif(Math.sqrt(Math.pow(j - x, 2) + Math.pow(k - y, 2)) <= r){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2135",
    "source": "leetcode",
    "language": "java",
    "query": "The power of an integer x is defined as the number of steps needed to transform x into 1 using the following steps. For example, the power of x = 3 is 7 because 3 needs 7 steps to become 1.",
    "snippets": [
        "\tstatic int power(int x){\n\t\tint count = 0;\n\t\twhile(x != 1){\n\t\t\tif(x % 2 == 0){\n\t\t\t\tx = x / 2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx = x * 3 + 1;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int power(int x){\n\t\tif(x == 1) return 0;\n\t\tif(x == 2) return 1;\n\t\tif(x == 3) return 2;\n\t\tif(x == 4) return 3;\n\t\tif(x == 5) return 4;\n\t\tif(x == 6) return 5;\n\t\tif(x == 7) return 6;\n\t\tif(x == 8) return 7;\n\t\tif(x == 9) return 8;\n\t\tif(x == 10) return 9;\n\t\tif(x == 11) return 10;\n\t\tif(x == 12) return 11;\n\t\tif(x == 13) return 12;\n\t\tif(x == 14) return 13;\n\t\tif(x == 15) return 14;\n\t\tif(x == 16) return 15;\n\t\tif(x == 17) return 16;\n\t\tif(x == 18) return 17;\n\t\tif(x == 19) return 18;\n\t\tif(x == 20) return 19;\n\t\tif(x == 21) return 20;\n\t\tif(x == 22) return 21;\n\t\tif(x == 23) return 22;\n\t\tif(x == 24) return 23;\n\t\tif(x == 25) return 24;\n\t\tif(x == 26) return 25;\n\t\tif(x == 27) return 26;\n\t\tif(x == 28) return 27;\n\t\tif(x == 29) return 28;\n\t\tif(x == 30) return 29;\n\t\tif(x == 31) return 30;\n\t\tif(x == 32) return 31;\n\t\tif(x == 33) return 32;\n\t\tif(x == 34) return 33;\n\t\tif(x == 35) return 34;\n\t\tif(x == 36) return 35;\n\t\tif(x == 37) return 36;\n\t\tif(x == 38) return 37;\n\t\tif(x == 39) return 38;\n\t\tif(x == 40) return 39;\n\t\tif(x == 41) return 40\n"
    ],
    "results": 10
},{
    "id": "2136",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place without making a copy of the array.",
    "snippets": [
        "\tvoid moveZeroes(int[] nums) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(j < nums.length){\n\t\t\tif(nums[j] != 0){\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\twhile(i < nums.length){\n\t\t\tnums[i] = 0;\n\t\t\ti++;\n\t\t}\n\t}\n}\n",
        "\tvoid moveZeroes(int[] nums) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(j < nums.length){\n\t\t\tif(nums[j] != 0){\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tfor(int k = i; k < nums.length; k++){\n\t\t\tnums[k] = 0;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2137",
    "source": "leetcode",
    "language": "java",
    "query": "Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year.",
    "snippets": [
        "\tString dayOfTheWeek(int day, int month, int year) {\n\t\tString[] week = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\tCalendar c = Calendar.getInstance();\n\t\tc.set(year, month - 1, day);\n\t\treturn week[c.get(Calendar.DAY_OF_WEEK) - 1];\n\t}\n}\n",
        "\tString dayOfTheWeek(int day, int month, int year) {\n\t\tString[] week = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.set(year, month - 1, day);\n\t\treturn week[cal.get(Calendar.DAY_OF_WEEK) - 1];\n\t}\n}\n",
        "\tString dayOfTheWeek(int day, int month, int year) {\n\t\tString[] days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\tCalendar cal = Calendar.getInstance();\n\t\tcal.set(year, month-1, day);\n\t\treturn days[cal.get(Calendar.DAY_OF_WEEK)];\n\t}\n}\n",
        "\tstatic String dayOfTheWeek(int day, int month, int year){\n\t\tString[] week = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\tint[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\t\tint[] leapMonthDays = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\t\tint[] days = new int[12];\n\t\tfor(int i = 0; i < 12; i++){\n\t\t\tif(i == 1){\n\t\t\t\tif(year % 4 == 0 && year % 100 != 0 || year % 400 == 0){\n\t\t\t\t\tdays[i] = leapMonthDays[i];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdays[i] = monthDays[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays[i] = monthDays[i];\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < month - 1; i++){\n\t\t\tsum += days[i];\n\t\t}\n\t\tsum += day;\n\t\treturn week[sum % 7];\n\t}\n}\n",
        "\tstatic String dayOfWeek(int d, int m, int y){\n\t\tString[] week = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\t\tint[] month = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5};\n\t\tint[] year = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] century = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] day = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] leap = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek2 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek3 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek4 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek5 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek6 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek7 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek8 = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\t\tint[] dayOfWeek9 = {0, 0,\n"
    ],
    "results": 10
},{
    "id": "2138",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, handle multiple queries of the following type: Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.",
    "snippets": [
        "\tint[] sumRange(int[] nums, int[] queries) {\n\t\tint[] result = new int[queries.length];\n\t\tint[] sum = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum[i] = (i == 0 ? nums[i] : sum[i-1] + nums[i]);\n\t\t}\n\t\tfor(int i = 0; i < queries.length; i++){\n\t\t\tint left = queries[i][0];\n\t\t\tint right = queries[i][1];\n\t\t\tresult[i] = sum[right] - (left == 0 ? 0 : sum[left-1]);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sumRange(int[] nums, int left, int right) {\n\t\tint[] result = new int[2];\n\t\tint sum = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\tresult[0] = left;\n\t\tresult[1] = right;\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sumOfArray(int[] nums, int[] queries) {\n\t\tint[] result = new int[queries.length];\n\t\tint[] sum = new int[nums.length];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum[i] = (i == 0) ? nums[i] : sum[i - 1] + nums[i];\n\t\t}\n\t\tfor (int i = 0; i < queries.length; i++) {\n\t\t\tint left = queries[i][0];\n\t\t\tint right = queries[i][1];\n\t\t\tif (left == 0) {\n\t\t\t\tresult[i] = sum[right];\n\t\t\t} else {\n\t\t\t\tresult[i] = sum[right] - sum[left - 1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sumRange(int[] nums, int[] queries) {\n\t\tint[] res = new int[queries.length];\n\t\tint[] sum = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum[i] = (i == 0 ? nums[i] : sum[i-1] + nums[i]);\n\t\t}\n\t\tfor(int i = 0; i < queries.length; i++){\n\t\t\tint left = queries[i][0];\n\t\t\tint right = queries[i][1];\n\t\t\tres[i] = sum[right] - (left == 0 ? 0 : sum[left-1]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sumOfArray(int[] nums, int[] queries) {\n\t\tint[] result = new int[queries.length];\n\t\tint[] sum = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum[i] = (i == 0) ? nums[i] : sum[i - 1] + nums[i];\n\t\t}\n\t\tfor(int i = 0; i < queries.length; i++){\n\t\t\tint left = queries[i][0];\n\t\t\tint right = queries[i][1];\n\t\t\tresult[i] = (left == 0) ? sum[right] : sum[right] - sum[left - 1];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sumRange(int[] nums, int left, int right) {\n\t\tint[] res = new int[1];\n\t\tres[0] = 0;\n\t\tfor(int i = left; i <= right; i++){\n\t\t\tres[0] += nums[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sumOfArray(int[] nums, int[] queries) {\n\t\tint[] result = new int[queries.length];\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\tnums[i] = sum;\n\t\t}\n\t\tfor (int i = 0; i < queries.length; i++) {\n\t\t\tint left = queries[i][0];\n\t\t\tint right = queries[i][1];\n\t\t\tresult[i] = nums[right] - (left == 0 ? 0 : nums[left - 1]);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sumOfArray(int[] nums, int[] queries){\n\t\tint[] result = new int[queries.length];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tnums[i] = sum;\n\t\t}\n\t\tfor(int i = 0; i < queries.length; i++){\n\t\t\tint left = queries[i][0];\n\t\t\tint right = queries[i][1];\n\t\t\tresult[i] = nums[right] - nums[left - 1];\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2139",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.",
    "snippets": [
        "\tint findMaxConsecutiveOnes(int[] nums, int k) {\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tif(count > max){\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2140",
    "source": "leetcode",
    "language": "java",
    "query": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2. The integers in the lists may be returned in any order.",
    "snippets": [
        "\tList<Integer>[] twoSum(int[] nums, int target) {\n\t\tList<Integer>[] result = new List<Integer>[2];\n\t\tresult[0] = new ArrayList<Integer>();\n\t\tresult[1] = new ArrayList<Integer>();\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (map.containsKey(nums[i])) {\n\t\t\t\tresult[0].add(map.get(nums[i]));\n\t\t\t\tresult[1].add(i);\n\t\t\t}\n\t\t\tmap.put(target - nums[i], i);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer>[] twoSum(int[] nums, int target) {\n\t\tList<Integer>[] result = new List<Integer>[2];\n\t\tresult[0] = new ArrayList<Integer>();\n\t\tresult[1] = new ArrayList<Integer>();\n\t\tint[] map = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmap[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint complement = target - nums[i];\n\t\t\tint j = binarySearch(nums, 0, nums.length - 1, complement);\n\t\t\tif(j != -1){\n\t\t\t\tif(map[i] < map[j]){\n\t\t\t\t\tresult[0].add(map[i]);\n\t\t\t\t\tresult[1].add(map[j]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tresult[0].add(map[j]);\n\t\t\t\t\tresult[1].add(map[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic int binarySearch(int[] nums, int left, int right, int target){\n\t\tif(left > right) return -1;\n\t\tint mid = (left + right) / 2;\n\t\tif(nums[mid] == target) return mid;\n\t\tif(nums[mid] > target) return binarySearch(nums, left, mid - 1, target);\n\t\telse return binarySearch(nums, mid + 1, right, target);\n\t}\n}\n",
        "\tList<Integer>[] twoSum(int[] nums, int target) {\n\t\tList<Integer>[] result = new List<Integer>[2];\n\t\tresult[0] = new ArrayList<Integer>();\n\t\tresult[1] = new ArrayList<Integer>();\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(target - nums[i])){\n\t\t\t\tresult[0].add(map.get(target - nums[i]));\n\t\t\t\tresult[1].add(i);\n\t\t\t}\n\t\t\tmap.put(nums[i], i);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer>[] twoSum(int[] nums, int target) {\n\t\tList<Integer>[] result = new List<Integer>[2];\n\t\tresult[0] = new ArrayList<Integer>();\n\t\tresult[1] = new ArrayList<Integer>();\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (map.containsKey(nums[i])) {\n\t\t\t\tresult[0].add(map.get(nums[i]));\n\t\t\t\tresult[1].add(i);\n\t\t\t} else {\n\t\t\t\tmap.put(target - nums[i], i);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> twoSum(int[] nums, int target) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(nums[i])){\n\t\t\t\tlist.add(map.get(nums[i]));\n\t\t\t\tlist.add(i);\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\tmap.put(target - nums[i], i);\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> twoSum(int[] nums, int target) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(target - nums[i])){\n\t\t\t\tlist.add(map.get(target - nums[i]));\n\t\t\t\tlist.add(i);\n\t\t\t\treturn list;\n\t\t\t}\n\t\t\tmap.put(nums[i], i);\n\t\t}\n\t\treturn list;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2141",
    "source": "leetcode",
    "language": "java",
    "query": "A valid \"croak\" means a frog is printing five letters 'c', 'r', 'o', 'a', and 'k' sequentially. The frogs have to print all five letters to finish a croak. Return the minimum number of different frogs to finish all the croaks in the given string.",
    "snippets": [
        "\tint minNumberOfFrogs(String croakOfFrogs) {\n\t\tint[] count = new int[5];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < croakOfFrogs.length(); i++) {\n\t\t\tchar c = croakOfFrogs.charAt(i);\n\t\t\tif (c == 'c') {\n\t\t\t\tcount[0]++;\n\t\t\t} else if (c == 'r') {\n\t\t\t\tcount[1]++;\n\t\t\t} else if (c == 'o') {\n\t\t\t\tcount[2]++;\n\t\t\t} else if (c == 'a') {\n\t\t\t\tcount[3]++;\n\t\t\t} else if (c == 'k') {\n\t\t\t\tcount[4]++;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (i >= 4 && count[0] == count[1] && count[1] == count[2] && count[2] == count[3] && count[3] == count[4]) {\n\t\t\t\tres++;\n\t\t\t\tcount[0] = count[1] = count[2] = count[3] = count[4] = 0;\n\t\t\t}\n\t\t}\n\t\treturn res == 0 ? -1 : res;\n\t}\n}\n",
        "\tint minNumberOfFrogs(String croakOfFrogs) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint aa = 0;\n\t\tint bb = 0;\n\t\tint cc = 0;\n\t\tint dd = 0;\n\t\tint ee = 0;\n\t\tint ff = 0;\n\t\tint gg = 0;\n\t\tint hh = 0;\n\t\tint ii = 0;\n\t\tint jj = 0;\n\t\tint kk = 0;\n\t\tint ll = 0;\n\t\tint mm = 0;\n\t\tint nn = 0;\n\t\tint oo = 0;\n\t\tint pp = 0;\n\t\tint qq = 0;\n\t\tint rr = 0;\n\t\tint ss = 0;\n\t\tint tt = 0;\n\t\tint uu = 0;\n\t\tint vv = 0;\n\t\tint ww = 0;\n\t\tint xx = 0;\n\t\tint yy = 0;\n\t\tint zz = 0;\n\t\tint aaa = 0;\n\t\tint bbb = 0;\n\t\tint ccc = 0;\n\t\tint ddd = 0;\n\t\tint eee = 0;\n\t\tint fff = 0;\n\t\tint ggg = 0;\n\t\tint hhh = 0;\n\t\tint iii = 0;\n\t\tint jjj =\n",
        "\tint minFrogs(String croakOfFrogs) {\n\t\tint[] count = new int[5];\n\t\tint res = 0;\n\t\tfor(int i = 0; i < croakOfFrogs.length(); i++){\n\t\t\tchar c = croakOfFrogs.charAt(i);\n\t\t\tif(c == 'c'){\n\t\t\t\tcount[0]++;\n\t\t\t}\n\t\t\telse if(c == 'r'){\n\t\t\t\tcount[1]++;\n\t\t\t}\n\t\t\telse if(c == 'o'){\n\t\t\t\tcount[2]++;\n\t\t\t}\n\t\t\telse if(c == 'a'){\n\t\t\t\tcount[3]++;\n\t\t\t}\n\t\t\telse if(c == 'k'){\n\t\t\t\tcount[4]++;\n\t\t\t}\n\t\t\tif(count[0] == count[1] && count[1] == count[2] && count[2] == count[3] && count[3] == count[4]){\n\t\t\t\tres++;\n\t\t\t\tcount[0] = 0;\n\t\t\t\tcount[1] = 0;\n\t\t\t\tcount[2] = 0;\n\t\t\t\tcount[3] = 0;\n\t\t\t\tcount[4] = 0;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minNumberOfFrogs(String croakOfFrogs) {\n\t\tint[] count = new int[5];\n\t\tint res = 0;\n\t\tfor(int i = 0; i < croakOfFrogs.length(); i++){\n\t\t\tchar c = croakOfFrogs.charAt(i);\n\t\t\tif(c == 'c'){\n\t\t\t\tcount[0]++;\n\t\t\t}else if(c == 'r'){\n\t\t\t\tcount[1]++;\n\t\t\t}else if(c == 'o'){\n\t\t\t\tcount[2]++;\n\t\t\t}else if(c == 'a'){\n\t\t\t\tcount[3]++;\n\t\t\t}else if(c == 'k'){\n\t\t\t\tcount[4]++;\n\t\t\t}else{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(i >= 4){\n\t\t\t\tif(count[0] == count[1] && count[1] == count[2] && count[2] == count[3] && count[3] == count[4]){\n\t\t\t\t\tres++;\n\t\t\t\t\tcount[0] = count[1] = count[2] = count[3] = count[4] = 0;\n\t\t\t\t}else{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minFrogs(String croakOfFrogs) {\n\t\tint n = croakOfFrogs.length();\n\t\tint[] count = new int[5];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar c = croakOfFrogs.charAt(i);\n\t\t\tif (c == 'c') {\n\t\t\t\tcount[0]++;\n\t\t\t} else if (c == 'r') {\n\t\t\t\tcount[1]++;\n\t\t\t} else if (c == 'o') {\n\t\t\t\tcount[2]++;\n\t\t\t} else if (c == 'a') {\n\t\t\t\tcount[3]++;\n\t\t\t} else if (c == 'k') {\n\t\t\t\tcount[4]++;\n\t\t\t}\n\t\t\tif (i >= 4 && count[0] == count[1] && count[1] == count[2] && count[2] == count[3] && count[3] == count[4]) {\n\t\t\t\tres++;\n\t\t\t\tcount[0] = count[1] = count[2] = count[3] = count[4] = 0;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minFrogs(String croakOfFrogs) {\n\t\tint[] count = new int[5];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < croakOfFrogs.length(); i++) {\n\t\t\tchar c = croakOfFrogs.charAt(i);\n\t\t\tif (c == 'c') {\n\t\t\t\tcount[0]++;\n\t\t\t} else if (c == 'r') {\n\t\t\t\tcount[1]++;\n\t\t\t} else if (c == 'o') {\n\t\t\t\tcount[2]++;\n\t\t\t} else if (c == 'a') {\n\t\t\t\tcount[3]++;\n\t\t\t} else if (c == 'k') {\n\t\t\t\tcount[4]++;\n\t\t\t}\n\t\t\tif (i >= 4 && count[0] == count[1] && count[1] == count[2] && count[2] == count[3] && count[3] == count[4]) {\n\t\t\t\tres++;\n\t\t\t\tcount[0] = count[1] = count[2] = count[3] = count[4] = 0;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minNumberOfFrogs(String croakOfFrogs) {\n\t\tint count = 0;\n\t\tint[] counts = new int[5];\n\t\tfor (int i = 0; i < croakOfFrogs.length(); i++) {\n\t\t\tchar c = croakOfFrogs.charAt(i);\n\t\t\tif (c == 'c') {\n\t\t\t\tcounts[0]++;\n\t\t\t} else if (c == 'r') {\n\t\t\t\tcounts[1]++;\n\t\t\t} else if (c == 'o') {\n\t\t\t\tcounts[2]++;\n\t\t\t} else if (c == 'a') {\n\t\t\t\tcounts[3]++;\n\t\t\t} else if (c == 'k') {\n\t\t\t\tcounts[4]++;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tif (counts[i] == 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcount += counts[i] / 5;\n\t\t\tcounts[i] %= 5;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2142",
    "source": "leetcode",
    "language": "java",
    "query": "An integer x is a multiple of k if there exists an integer n such that x = n * k. Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to aMultiple of k.",
    "snippets": [
        "\tboolean checkSubarraySum(int[] nums, int k) {\n\t\tif(nums.length<2) return false;\n\t\tint sum=0;\n\t\tMap<Integer,Integer> map=new HashMap<>();\n\t\tmap.put(0,-1);\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tsum+=nums[i];\n\t\t\tif(k!=0) sum%=k;\n\t\t\tif(map.containsKey(sum)){\n\t\t\t\tif(i-map.get(sum)>1) return true;\n\t\t\t}\n\t\t\telse map.put(sum,i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean checkSubarraySum(int[] nums, int k) {\n\t\tif(nums.length<2) return false;\n\t\tint sum=0;\n\t\tMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n\t\tmap.put(0,-1);\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tsum+=nums[i];\n\t\t\tif(k!=0) sum%=k;\n\t\t\tif(map.containsKey(sum)){\n\t\t\t\tif(i-map.get(sum)>1) return true;\n\t\t\t}\n\t\t\telse map.put(sum,i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean checkSubarraySum(int[] nums, int k) {\n\t\tif(nums == null || nums.length < 2) return false;\n\t\tint sum = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tmap.put(0, -1);\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(k != 0) sum %= k;\n\t\t\tif(map.containsKey(sum)){\n\t\t\t\tif(i - map.get(sum) > 1) return true;\n\t\t\t}\n\t\t\telse map.put(sum, i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean checkSubarraySum(int[] nums, int k) {\n\t\tif(nums.length<2) return false;\n\t\tint[] sums = new int[nums.length];\n\t\tsums[0] = nums[0];\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tsums[i] = sums[i-1]+nums[i];\n\t\t}\n\t\tfor(int i=0;i<nums.length-1;i++){\n\t\t\tfor(int j=i+1;j<nums.length;j++){\n\t\t\t\tif((sums[j]-sums[i])%k==0) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean checkSubarraySum(int[] nums, int k) {\n\t\tif(nums.length<2) return false;\n\t\tint sum=0;\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tsum+=nums[i];\n\t\t\tif(sum%k==0) return true;\n\t\t\tif(i>0&&sum%k==nums[i-1]) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2143",
    "source": "leetcode",
    "language": "java",
    "query": "Find the shortest completing word in words. Ignore numbers and spaces in licensePlate. If a letter appears more than once, it must appear in the word the same number of times or more.",
    "snippets": [
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString res = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tint len = licensePlate.length();\n\t\tfor(String word : words){\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tif(licensePlate.charAt(i) == word.charAt(i)){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == min){\n\t\t\t\tif(word.length() < res.length()){\n\t\t\t\t\tres = word;\n\t\t\t\t}\n\t\t\t}else if(count < min){\n\t\t\t\tres = word;\n\t\t\t\tmin = count;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString res = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tint len = licensePlate.length();\n\t\tfor(String word : words){\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tif(word.indexOf(licensePlate.charAt(i)) != -1)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(count == min)\n\t\t\t\tres = word.length() < res.length() ? word : res;\n\t\t\telse if(count < min){\n\t\t\t\tres = word;\n\t\t\t\tmin = count;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString res = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tint len = licensePlate.length();\n\t\tfor(String word : words){\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tif(word.indexOf(licensePlate.charAt(i)) != -1)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(count == min){\n\t\t\t\tif(word.compareTo(res) < 0)\n\t\t\t\t\tres = word;\n\t\t\t}\n\t\t\telse if(count < min){\n\t\t\t\tmin = count;\n\t\t\t\tres = word;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString res = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tMap<Character, Integer> map = new HashMap<>();\n\t\tfor (char c : licensePlate.toCharArray()) {\n\t\t\tif (Character.isLetter(c)) {\n\t\t\t\tmap.put(Character.toLowerCase(c), map.getOrDefault(Character.toLowerCase(c), 0) + 1);\n\t\t\t}\n\t\t}\n\t\tfor (String word : words) {\n\t\t\tMap<Character, Integer> map2 = new HashMap<>(map);\n\t\t\tfor (char c : word.toCharArray()) {\n\t\t\t\tif (map2.containsKey(c)) {\n\t\t\t\t\tmap2.put(c, map2.get(c) - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int v : map2.values()) {\n\t\t\t\tcount += v;\n\t\t\t}\n\t\t\tif (count < min) {\n\t\t\t\tmin = count;\n\t\t\t\tres = word;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString res = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tMap<Character, Integer> map = new HashMap<>();\n\t\tfor (char c : licensePlate.toCharArray()) {\n\t\t\tif (Character.isLetter(c)) {\n\t\t\t\tmap.put(Character.toLowerCase(c), map.getOrDefault(Character.toLowerCase(c), 0) + 1);\n\t\t\t}\n\t\t}\n\t\tfor (String word : words) {\n\t\t\tMap<Character, Integer> tmp = new HashMap<>(map);\n\t\t\tfor (char c : word.toCharArray()) {\n\t\t\t\tif (tmp.containsKey(c)) {\n\t\t\t\t\ttmp.put(c, tmp.get(c) - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (int v : tmp.values()) {\n\t\t\t\tcount += v;\n\t\t\t}\n\t\t\tif (count < min) {\n\t\t\t\tmin = count;\n\t\t\t\tres = word;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString res = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tHashMap<Character, Integer> map = new HashMap<>();\n\t\tfor (char c : licensePlate.toCharArray()) {\n\t\t\tif (Character.isLetter(c)) {\n\t\t\t\tmap.put(Character.toLowerCase(c), map.getOrDefault(Character.toLowerCase(c), 0) + 1);\n\t\t\t}\n\t\t}\n\t\tfor (String word : words) {\n\t\t\tHashMap<Character, Integer> map2 = new HashMap<>();\n\t\t\tfor (char c : word.toCharArray()) {\n\t\t\t\tmap2.put(c, map2.getOrDefault(c, 0) + 1);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tfor (char c : map.keySet()) {\n\t\t\t\tif (map2.containsKey(c) && map2.get(c) >= map.get(c)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count == map.size() && word.length() < min) {\n\t\t\t\tres = word;\n\t\t\t\tmin = word.length();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString result = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(String word : words){\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\t\tif(licensePlate.indexOf(word.charAt(i)) != -1){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == word.length() && count < min){\n\t\t\t\tmin = count;\n\t\t\t\tresult = word;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString ans = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < licensePlate.length(); i++){\n\t\t\tchar c = licensePlate.charAt(i);\n\t\t\tif(Character.isLetter(c)){\n\t\t\t\tcount[c-'a']++;\n\t\t\t}\n\t\t}\n\t\tfor(String word : words){\n\t\t\tint[] temp = count.clone();\n\t\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\t\tchar c = word.charAt(i);\n\t\t\t\tif(Character.isLetter(c)){\n\t\t\t\t\ttemp[c-'a']--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < 26; i++){\n\t\t\t\tsum += Math.abs(temp[i]);\n\t\t\t}\n\t\t\tif(sum < min){\n\t\t\t\tmin = sum;\n\t\t\t\tans = word;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic String shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString result = \"\";\n\t\tint minLength = Integer.MAX_VALUE;\n\t\tfor(String word: words){\n\t\t\tif(word.length() < minLength){\n\t\t\t\tminLength = word.length();\n\t\t\t\tresult = word;\n\t\t\t}\n\t\t}\n\t\tfor(String word: words){\n\t\t\tif(word.length() == minLength){\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\t\t\tif(word.charAt(i) == licensePlate.charAt(i)){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(count == minLength){\n\t\t\t\t\tresult = word;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tString shortestCompletingWord(String licensePlate, String[] words) {\n\t\tString result = \"\";\n\t\tint min = Integer.MAX_VALUE;\n\t\tint count = 0;\n\t\tString[] licensePlateArr = licensePlate.toLowerCase().replaceAll(\"[^a-zA-Z]\", \"\").split(\"\");\n\t\tfor(String word : words){\n\t\t\tcount = 0;\n\t\t\tfor(String letter : licensePlateArr){\n\t\t\t\tif(word.contains(letter)){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count == licensePlateArr.length && min > word.length()){\n\t\t\t\tmin = word.length();\n\t\t\t\tresult = word;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2144",
    "source": "leetcode",
    "language": "java",
    "query": "Return true if the value of the root is equal to the sum of the values of its two children. You are given the root of a binary tree that consists of exactly 3 nodes.",
    "snippets": [
        "\tboolean isSumEqual(Node root){\n\t\tif(root == null)\n\t\t\treturn false;\n\t\tif(root.left == null && root.right == null)\n\t\t\treturn false;\n\t\tif(root.left == null)\n\t\t\treturn root.val == root.right.val + root.right.val;\n\t\tif(root.right == null)\n\t\t\treturn root.val == root.left.val + root.left.val;\n\t\treturn root.val == root.left.val + root.right.val;\n\t}\n}\n",
        "\tboolean isSumEqual(TreeNode root){\n\t\tif(root == null) return false;\n\t\tif(root.left == null && root.right == null) return false;\n\t\tif(root.left == null) return root.val == root.right.val;\n\t\tif(root.right == null) return root.val == root.left.val;\n\t\treturn root.val == root.left.val + root.right.val;\n\t}\n}\n",
        "\tboolean isSumEqual(TreeNode root){\n\t\tif(root==null) return false;\n\t\tif(root.left==null && root.right==null) return false;\n\t\tif(root.left==null) return root.val==root.right.val+root.right.val;\n\t\tif(root.right==null) return root.val==root.left.val+root.left.val;\n\t\treturn root.val==root.left.val+root.right.val;\n\t}\n}\n",
        "\tboolean isSumOfTwoNodes(TreeNode root){\n\t\tif(root == null) return false;\n\t\tif(root.left == null && root.right == null) return false;\n\t\tif(root.left == null) return root.val == root.right.val + root.val;\n\t\tif(root.right == null) return root.val == root.left.val + root.val;\n\t\treturn root.val == root.left.val + root.right.val;\n\t}\n}\n",
        "\tboolean isSumTree(TreeNode root){\n\t\tif(root==null) return false;\n\t\tif(root.left==null && root.right==null) return true;\n\t\tif(root.left==null) return root.val==root.right.val && isSumTree(root.right);\n\t\tif(root.right==null) return root.val==root.left.val && isSumTree(root.left);\n\t\treturn root.val==root.left.val+root.right.val && isSumTree(root.left) && isSumTree(root.right);\n\t}\n}\n",
        "\tboolean isSumOfTwoNodes(TreeNode root){\n\t\tif(root==null)\n\t\t\treturn false;\n\t\tif(root.left==null&&root.right==null)\n\t\t\treturn false;\n\t\tif(root.left==null)\n\t\t\treturn root.val==root.right.val+root.right.val;\n\t\tif(root.right==null)\n\t\t\treturn root.val==root.left.val+root.left.val;\n\t\treturn root.val==root.left.val+root.right.val;\n\t}\n}\n",
        "\tboolean isSumOfTwoChildren(Node root){\n\t\tif(root==null)\n\t\t\treturn false;\n\t\tif(root.left==null && root.right==null)\n\t\t\treturn false;\n\t\tif(root.left==null)\n\t\t\treturn root.val==root.right.val+root.left.val;\n\t\tif(root.right==null)\n\t\t\treturn root.val==root.left.val+root.right.val;\n\t\treturn root.val==root.left.val+root.right.val;\n\t}\n}\n",
        "\tboolean isSumOfChildren(TreeNode root){\n\t\tif(root==null)\n\t\t\treturn false;\n\t\tif(root.left==null&&root.right==null)\n\t\t\treturn false;\n\t\tif(root.left==null)\n\t\t\treturn root.val==root.right.val+root.right.val;\n\t\tif(root.right==null)\n\t\t\treturn root.val==root.left.val+root.left.val;\n\t\treturn root.val==root.left.val+root.right.val;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2145",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation.",
    "snippets": [
        "\tboolean wordBreak(String s, List<String> wordDict) {\n\t\tif(s == null || s.length() == 0) return false;\n\t\tboolean[] dp = new boolean[s.length() + 1];\n\t\tdp[0] = true;\n\t\tfor(int i = 1; i <= s.length(); i++){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(dp[j] && wordDict.contains(s.substring(j, i))){\n\t\t\t\t\tdp[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[s.length()];\n\t}\n}\n",
        "\tboolean wordBreak(String s, List<String> wordDict) {\n\t\tif(s == null || s.length() == 0)\n\t\t\treturn false;\n\t\tif(wordDict == null || wordDict.size() == 0)\n\t\t\treturn false;\n\t\tboolean[] dp = new boolean[s.length() + 1];\n\t\tdp[0] = true;\n\t\tfor(int i = 1; i <= s.length(); i++){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(dp[j] && wordDict.contains(s.substring(j, i))){\n\t\t\t\t\tdp[i] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[s.length()];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2146",
    "source": "leetcode",
    "language": "java",
    "query": "The CombinationIterator class was designed to make it easier to write code with lowercase letters and numbers.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tCombinationIterator iterator = new CombinationIterator(\"abc\");\n\t\twhile(iterator.hasNext()){\n\t\t\tSystem.out.println(iterator.next());\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args) {\n\t\tCombinationIterator iterator = new CombinationIterator(\"abc\", 2);\n\t\tSystem.out.println(iterator.hasNext());\n\t\tSystem.out.println(iterator.next());\n\t\tSystem.out.println(iterator.hasNext());\n\t\tSystem.out.println(iterator.next());\n\t\tSystem.out.println(iterator.hasNext());\n\t\tSystem.out.println(iterator.next());\n\t\tSystem.out.println(iterator.hasNext());\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tCombinationIterator iterator = new CombinationIterator(\"abc\");\n\t\tSystem.out.println(iterator.hasNext());\n\t\tSystem.out.println(iterator.next());\n\t\tSystem.out.println(iterator.hasNext());\n\t\tSystem.out.println(iterator.next());\n\t\tSystem.out.println(iterator.hasNext());\n\t\tSystem.out.println(iterator.next());\n\t\tSystem.out.println(iterator.hasNext());\n\t}\n}\n",
        "\tstatic void main(String[] args) {\n\t\tCombinationIterator iterator = new CombinationIterator(\"12345\");\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t}\n\t}\n}\n",
        "\tvoid main(String[] args){\n\t\tCombinationIterator iterator = new CombinationIterator(\"ABCD\", 2);\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2147",
    "source": "leetcode",
    "language": "java",
    "query": "M is an m x n matrix with all 0's and an array of operations ops. ops[i] = [ai, bi] means M[x] should be incremented by one for all 0 <= x < ai and 0 <= y < bi.Count and return the number of maximum integers in the matrix after performing all the operations.",
    "snippets": [
        "\tint maxCount(int m, int n, int[][] ops) {\n\t\tint[][] matrix = new int[m][n];\n\t\tfor(int i = 0; i < ops.length; i++){\n\t\t\tint a = ops[i][0];\n\t\t\tint b = ops[i][1];\n\t\t\tfor(int x = 0; x < a; x++){\n\t\t\t\tfor(int y = 0; y < b; y++){\n\t\t\t\t\tmatrix[x][y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tmax = Math.max(max, matrix[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxCount(int m, int n, int[][] ops) {\n\t\tint[][] matrix = new int[m][n];\n\t\tfor(int i = 0; i < ops.length; i++){\n\t\t\tint ai = ops[i][0];\n\t\t\tint bi = ops[i][1];\n\t\t\tfor(int x = 0; x < ai; x++){\n\t\t\t\tfor(int y = 0; y < bi; y++){\n\t\t\t\t\tmatrix[x][y]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tmax = Math.max(max, matrix[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxCount(int m, int n, int[][] ops) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < ops.length; i++){\n\t\t\tint a = ops[i][0];\n\t\t\tint b = ops[i][1];\n\t\t\tmax = Math.max(max, a*b);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxCount(int m, int n, int[][] ops) {\n\t\tint[][] matrix = new int[m][n];\n\t\tfor(int i = 0; i < ops.length; i++){\n\t\t\tint ai = ops[i][0];\n\t\t\tint bi = ops[i][1];\n\t\t\tfor(int j = 0; j < ai; j++){\n\t\t\t\tfor(int k = 0; k < bi; k++){\n\t\t\t\t\tmatrix[j][k]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tmax = Math.max(max, matrix[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxCount(int m, int n, int[][] ops) {\n\t\tint[][] matrix = new int[m][n];\n\t\tfor(int i = 0; i < ops.length; i++){\n\t\t\tint a = ops[i][0];\n\t\t\tint b = ops[i][1];\n\t\t\tfor(int j = 0; j < a; j++){\n\t\t\t\tfor(int k = 0; k < b; k++){\n\t\t\t\t\tmatrix[j][k]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tmax = Math.max(max, matrix[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxCount(int m, int n, int[][] ops) {\n\t\tint max = 0;\n\t\tfor (int i = 0; i < ops.length; i++) {\n\t\t\tmax = Math.max(max, ops[i][0] * ops[i][1]);\n\t\t}\n\t\tint[][] matrix = new int[max + 1][max + 1];\n\t\tfor (int i = 0; i < ops.length; i++) {\n\t\t\tfor (int j = 0; j < ops[i][0]; j++) {\n\t\t\t\tfor (int k = 0; k < ops[i][1]; k++) {\n\t\t\t\t\tmatrix[j][k]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxCount = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmaxCount = Math.max(maxCount, matrix[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn maxCount;\n\t}\n}\n",
        "\tint count(int[][] M, int[] ops) {\n\t\tint n = M.length;\n\t\tint m = M[0].length;\n\t\tint[][] dp = new int[n][m];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tdp[i][j] = M[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ops.length; i++) {\n\t\t\tint a = ops[i];\n\t\t\tint b = ops[i + 1];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < m; k++) {\n\t\t\t\t\tif (j < a && k < b) {\n\t\t\t\t\t\tdp[j][k] = Math.max(dp[j][k], dp[j][k] + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tmax = Math.max(max, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2148",
    "source": "leetcode",
    "language": "java",
    "query": "Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "\tint numSubseq(int[] nums, int target) {\n\t\tint n = nums.length;\n\t\tint mod = 1000000007;\n\t\tint[] dp = new int[target + 1];\n\t\tdp[0] = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = target; j >= nums[i]; j--){\n\t\t\t\tdp[j] = (dp[j] + dp[j - nums[i]]) % mod;\n\t\t\t}\n\t\t}\n\t\treturn dp[target];\n\t}\n}\n",
        "\tint numSubseq(int[] nums, int target) {\n\t\tint n = nums.length;\n\t\tint mod = 1000000007;\n\t\tint[] dp = new int[target + 1];\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = target; j >= nums[i]; j--) {\n\t\t\t\tdp[j] += dp[j - nums[i]];\n\t\t\t\tdp[j] %= mod;\n\t\t\t}\n\t\t}\n\t\treturn dp[target];\n\t}\n}\n",
        "\tint numSubseq(int[] nums, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = nums.length;\n\t\tint[] dp = new int[target + 1];\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = target; j >= nums[i]; j--) {\n\t\t\t\tdp[j] += dp[j - nums[i]];\n\t\t\t\tdp[j] %= mod;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i <= target; i++) {\n\t\t\tres += dp[i];\n\t\t\tres %= mod;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint numSubseq(int[] nums, int target) {\n\t\tint n = nums.length;\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n][target + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][0] = 1;\n\t\t}\n\t\tfor (int i = 1; i <= target; i++) {\n\t\t\tdp[0][i] = 0;\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 1; j <= target; j++) {\n\t\t\t\tif (nums[i] <= j) {\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i - 1][j - nums[i]]) % mod;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = dp[i - 1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n - 1][target];\n\t}\n}\n",
        "\tint numSubseq(int[] nums, int target) {\n\t\tint n = nums.length;\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n][target + 1];\n\t\tdp[0][nums[0]] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j <= target; j++) {\n\t\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i - 1][j - nums[i]]) % mod;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int j = 0; j <= target; j++) {\n\t\t\tans = (ans + dp[n - 1][j]) % mod;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint numSubseq(int[] nums, int target) {\n\t\tint mod = 1000000007;\n\t\tint n = nums.length;\n\t\tlong[][] dp = new long[n + 1][target + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 0; j <= target; j++) {\n\t\t\t\tdp[i][j] = (dp[i - 1][j] + dp[i - 1][j - nums[i - 1]]) % mod;\n\t\t\t}\n\t\t}\n\t\treturn (int) (dp[n][target] % mod);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2149",
    "source": "leetcode",
    "language": "java",
    "query": "An integer n is a power of four, if there exists an integer x such that n == 4x. Given an integer n, return true if it is a powers of four. Otherwise, return false.",
    "snippets": [
        "\tboolean isPowerOfFour(int num) {\n\t\tif(num==1) return true;\n\t\tif(num%4!=0) return false;\n\t\treturn isPowerOfFour(num/4);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2150",
    "source": "leetcode",
    "language": "java",
    "query": "Remove any number of beans (possibly none) from each bag such that the number in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] bags = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] beans = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] result = removeBeans(bags, beans);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n\tpublic static int[] removeBeans(int[] bags, int[] beans){\n\t\tint[] result = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tresult[i] = bags[i];\n\t\t}\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tint index = findIndex(result, beans[i]);\n\t\t\tif(index != -1){\n\t\t\t\tresult[index]--;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static int findIndex(int[] arr, int num){\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] == num){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] bags = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] beans = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] result = removeBeans(bags,beans);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n\tpublic static int[] removeBeans(int[] bags, int[] beans){\n\t\tint[] result = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tresult[i] = bags[i];\n\t\t}\n\t\tint[] temp = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\ttemp[i] = bags[i];\n\t\t}\n\t\tint[] temp2 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\ttemp2[i] = beans[i];\n\t\t}\n\t\tint[] temp3 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\ttemp3[i] = beans[i];\n\t\t}\n\t\tint count = 0;\n\t\tint count2 = 0;\n\t\tint count3 = 0;\n\t\tint count4 = 0;\n\t\tint count5 = 0;\n\t\tint count6 = 0;\n\t\tint count7 = 0;\n\t\tint count8 = 0;\n\t\tint count9 = 0;\n\t\tint count10 = 0;\n\t\tint count11 = 0;\n\t\tint count12 = 0;\n\t\tint count13 = 0;\n\t\tint count14 = 0;\n\t\tint count15 = 0;\n\t\tint count16 = 0;\n\t\tint count17 = 0;\n",
        "\tvoid method(int[] bags, int[] beans){\n\t\tint[] beansInBags = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbeansInBags[i] = beans[i];\n\t\t}\n\t\tint beansToRemove = 0;\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbeansToRemove += beansInBags[i];\n\t\t}\n\t\tint beansToRemovePerBag = beansToRemove / bags.length;\n\t\tint beansToRemovePerBagRemainder = beansToRemove % bags.length;\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(beansInBags[i] > beansToRemovePerBag){\n\t\t\t\tbeansInBags[i] -= beansToRemovePerBag;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbeansInBags[i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(beansInBags[i] > 0){\n\t\t\t\tbeansInBags[i]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(beansInBags[i] > 0){\n\t\t\t\tbeansInBags[i]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(beansInBags[i] > 0){\n\t\t\t\tbeansInBags[i]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(beansInBags[i] > 0){\n\t\t\t\tbeansInBags[i]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] bagsCopy = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbagsCopy[i] = bags[i];\n\t\t}\n\t\tint[] beansCopy = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeansCopy[i] = beans[i];\n\t\t}\n\t\tint[] bagsCopy2 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbagsCopy2[i] = bags[i];\n\t\t}\n\t\tint[] beansCopy2 = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeansCopy2[i] = beans[i];\n\t\t}\n\t\tint[] bagsCopy3 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbagsCopy3[i] = bags[i];\n\t\t}\n\t\tint[] beansCopy3 = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeansCopy3[i] = beans[i];\n\t\t}\n\t\tint[] bagsCopy4 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbagsCopy4[i] = bags[i];\n\t\t}\n\t\tint[] beansCopy4 = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeansCopy4[i] = beans[i];\n\t\t}\n\t\tint[] bagsCopy5 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbagsCopy5[i] = bags[i];\n\t\t}\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] bagsCopy = bags.clone();\n\t\tint[] beansCopy = beans.clone();\n\t\tint[] bagsCopy2 = bags.clone();\n\t\tint[] beansCopy2 = beans.clone();\n\t\tint[] bagsCopy3 = bags.clone();\n\t\tint[] beansCopy3 = beans.clone();\n\t\tint[] bagsCopy4 = bags.clone();\n\t\tint[] beansCopy4 = beans.clone();\n\t\tint[] bagsCopy5 = bags.clone();\n\t\tint[] beansCopy5 = beans.clone();\n\t\tint[] bagsCopy6 = bags.clone();\n\t\tint[] beansCopy6 = beans.clone();\n\t\tint[] bagsCopy7 = bags.clone();\n\t\tint[] beansCopy7 = beans.clone();\n\t\tint[] bagsCopy8 = bags.clone();\n\t\tint[] beansCopy8 = beans.clone();\n\t\tint[] bagsCopy9 = bags.clone();\n\t\tint[] beansCopy9 = beans.clone();\n\t\tint[] bagsCopy10 = bags.clone();\n\t\tint[] beansCopy10 = beans.clone();\n\t\tint[] bagsCopy11 = bags.clone();\n\t\tint[] beansCopy11 = beans.clone();\n\t\tint[] bagsCopy12 = bags.clone();\n\t\tint[] beansCopy12 = beans.clone();\n\t\tint[] bagsCopy13 = bags.clone();\n\t\tint[] beansCopy13 = beans.clone();\n\t\tint[] bagsCopy14 = bags.clone();\n\t\tint[] beansCopy14 = beans.clone();\n\t\tint[] bagsCopy15 = bags.clone();\n\t\tint[] beansCopy15 = beans.clone();\n\t\tint[] bagsCopy16 = bags.clone();\n\t\tint[] beansCopy16 = beans.clone();\n\t\tint[] bagsCopy17 = bags.clone();\n\t\tint[] beansCopy17 = beans.clone();\n\t\tint[] bagsCopy18 = bags.clone();\n\t\tint[] beansCopy18 = beans.clone();\n\t\tint[] bagsCopy19 = bags.clone();\n\t\tint[] beans\n",
        "\tvoid solve(int[] a, int[] b, int[] c){\n\t\tint n = a.length;\n\t\tint m = b.length;\n\t\tint k = c.length;\n\t\tint[] aa = new int[n];\n\t\tint[] bb = new int[m];\n\t\tint[] cc = new int[k];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\taa[i] = a[i];\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tbb[i] = b[i];\n\t\t}\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tcc[i] = c[i];\n\t\t}\n\t\tint ans = 0;\n\t\twhile(true){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint min_i = -1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(aa[i] > 0 && aa[i] < min){\n\t\t\t\t\tmin = aa[i];\n\t\t\t\t\tmin_i = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min_i == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint min_j = -1;\n\t\t\tfor(int j = 0; j < m; j++){\n\t\t\t\tif(bb[j] > 0 && bb[j] < min){\n\t\t\t\t\tmin = bb[j];\n\t\t\t\t\tmin_j = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min_j == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint min_k = -1;\n\t\t\tfor(int k = 0; k < k; k++){\n\t\t\t\tif(cc[k] > 0 && cc[k] < min){\n\t\t\t\t\tmin =\n",
        "\tvoid f(int[] bags, int[] beans){\n\t\tint n = bags.length;\n\t\tint m = beans.length;\n\t\tint[][] dp = new int[n+1][m+1];\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= m; j++){\n\t\t\t\tif(bags[i-1] == beans[j-1]){\n\t\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(dp[n][m]);\n\t}\n}\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] bagsCopy = new int[bags.length];\n\t\tint[] beansCopy = new int[beans.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbagsCopy[i] = bags[i];\n\t\t\tbeansCopy[i] = beans[i];\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(bags[i] != 0){\n\t\t\t\tmin = Math.min(min, beans[i]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(bags[i] != 0){\n\t\t\t\tbeans[i] -= min;\n\t\t\t\tbags[i] -= min;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(bags[i] != 0){\n\t\t\t\tbeans[i] += bagsCopy[i];\n\t\t\t\tbags[i] += bagsCopy[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tif(beans[i] != 0){\n\t\t\t\tbeans[i] += beansCopy[i];\n\t\t\t\tbeans[i] += beansCopy[i];\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid f(int n, int k, int[] bags){\n\t\tint[] beans = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tbeans[i] = bags[i];\n\t\t}\n\t\tint count = 0;\n\t\twhile(count < k){\n\t\t\tint min = beans[0];\n\t\t\tint minIndex = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(beans[i] < min){\n\t\t\t\t\tmin = beans[i];\n\t\t\t\t\tminIndex = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbeans[minIndex] = beans[minIndex] - 1;\n\t\t\tcount++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(beans[i] > 0){\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2151",
    "source": "leetcode",
    "language": "java",
    "query": "Each node in the tree has node.val coins. In one move, we may choose two adjacent nodes and move one coin from one node to another.",
    "snippets": [
        "\tint maxCoins(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[][] dp = new int[n + 2][n + 2];\n\t\tint[] nums2 = new int[n + 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnums2[i + 1] = nums[i];\n\t\t}\n\t\tnums2[0] = 1;\n\t\tnums2[n + 1] = 1;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tfor (int j = 0; j < n + 2; j++) {\n\t\t\t\tif (i == 0 || j == 0 || i == n + 1 || j == n + 1) {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 1; k < n + 1; k++) {\n\t\t\tfor (int i = 1; i < n + 1; i++) {\n\t\t\t\tfor (int j = 1; j < n + 1; j++) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][k - 1] + dp[k][j] + nums2[i] * nums2[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n + 1][n + 1];\n\t}\n}\n",
        "\tint maxCoins(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[][] dp = new int[n + 2][n + 2];\n\t\tint[] nums2 = new int[n + 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnums2[i + 1] = nums[i];\n\t\t}\n\t\tnums2[0] = 1;\n\t\tnums2[n + 1] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][k - 1] + nums2[k] * nums2[i] * nums2[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][n];\n\t}\n}\n",
        "\tint maxCoins(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[][] dp = new int[n + 2][n + 2];\n\t\tint[] nums2 = new int[n + 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnums2[i + 1] = nums[i];\n\t\t}\n\t\tnums2[0] = 1;\n\t\tnums2[n + 1] = 1;\n\t\tfor (int i = 0; i < n + 2; i++) {\n\t\t\tfor (int j = 0; j < n + 2; j++) {\n\t\t\t\tif (i == 0 || j == 0 || i == n + 1 || j == n + 1) {\n\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = Integer.MIN_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxCoins(nums2, 0, n + 1, dp);\n\t}\n\tpublic int maxCoins(int[] nums, int left, int right, int[][] dp) {\n\t\tif (dp[left][right] != Integer.MIN_VALUE) {\n\t\t\treturn dp[left][right];\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = left + 1; i < right; i++) {\n\t\t\tres = Math.max(res, nums[left] * nums[i] * nums[right] + maxCoins(nums, left, i, dp) + maxCoins(nums, i, right, dp));\n\t\t}\n\t\tdp[left][right] = res;\n\t\treturn res;\n\t}\n}\n",
        "\tint maxCoins(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[][] dp = new int[n + 2][n + 2];\n\t\tint[] nums2 = new int[n + 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnums2[i + 1] = nums[i];\n\t\t}\n\t\tnums2[0] = 1;\n\t\tnums2[n + 1] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][k - 1] + nums2[i] * nums2[k] * nums2[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][n];\n\t}\n}\n",
        "\tint getMinimumCoins(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (i >= coins[j]) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount];\n\t}\n}\n",
        "\tint maxCoins(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[][] dp = new int[n + 1][n + 1];\n\t\tint[] nums2 = new int[n + 2];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tnums2[i + 1] = nums[i];\n\t\t}\n\t\tnums2[0] = 1;\n\t\tnums2[n + 1] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i - 1][k - 1] + nums2[i] * nums2[j] * nums2[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][n];\n\t}\n}\n",
        "\tint getMinimumCoins(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (i - coins[j] >= 0) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];\n\t}\n}\n",
        "\tint rob(TreeNode root) {\n\t\tint[] res = robHelper(root);\n\t\treturn Math.max(res[0], res[1]);\n\t}\n\tprivate int[] robHelper(TreeNode root) {\n\t\tif (root == null) {\n\t\t\treturn new int[2];\n\t\t}\n\t\tint[] left = robHelper(root.left);\n\t\tint[] right = robHelper(root.right);\n\t\tint[] res = new int[2];\n\t\tres[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n\t\tres[1] = root.val + left[0] + right[0];\n\t\treturn res;\n\t}\n}\n",
        "\tint getMinimumCost(int[][] tree) {\n\t\tint n = tree.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(i != j && i != k && j != k){\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + tree[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tres = Math.min(res, dp[i][i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint getMinimumCost(int[][] input) {\n\t\tint n = input.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdp[i][j] = input[i][j] + Math.min(dp[i][j - 1], dp[j][j]);\n\t\t\t\tdp[j][i] = input[i][j] + Math.min(dp[j][j - 1], dp[i][i]);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2152",
    "source": "leetcode",
    "language": "java",
    "query": "In Pascal's triangle, each number is the sum of the two numbers directly above it as shown. Given an integer numRows, return the first NumRows of the triangle.",
    "snippets": [
        "\tList<List<Integer>> generate(int numRows) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(numRows == 0) return result;\n\t\tresult.add(new ArrayList<Integer>());\n\t\tresult.get(0).add(1);\n\t\tfor(int i = 1; i < numRows; i++){\n\t\t\tList<Integer> row = new ArrayList<Integer>();\n\t\t\trow.add(1);\n\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\trow.add(result.get(i-1).get(j-1) + result.get(i-1).get(j));\n\t\t\t}\n\t\t\trow.add(1);\n\t\t\tresult.add(row);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> generate(int numRows) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(numRows == 0) return result;\n\t\tList<Integer> first = new ArrayList<Integer>();\n\t\tfirst.add(1);\n\t\tresult.add(first);\n\t\tif(numRows == 1) return result;\n\t\tList<Integer> second = new ArrayList<Integer>();\n\t\tsecond.add(1);\n\t\tsecond.add(1);\n\t\tresult.add(second);\n\t\tif(numRows == 2) return result;\n\t\tfor(int i = 2; i < numRows; i++){\n\t\t\tList<Integer> row = new ArrayList<Integer>();\n\t\t\trow.add(1);\n\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\trow.add(result.get(i-1).get(j-1) + result.get(i-1).get(j));\n\t\t\t}\n\t\t\trow.add(1);\n\t\t\tresult.add(row);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> generate(int numRows) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(numRows == 0) return result;\n\t\tList<Integer> first = new ArrayList<Integer>();\n\t\tfirst.add(1);\n\t\tresult.add(first);\n\t\tif(numRows == 1) return result;\n\t\tList<Integer> second = new ArrayList<Integer>();\n\t\tsecond.add(1);\n\t\tsecond.add(1);\n\t\tresult.add(second);\n\t\tif(numRows == 2) return result;\n\t\tfor(int i = 2; i < numRows; i++){\n\t\t\tList<Integer> current = new ArrayList<Integer>();\n\t\t\tcurrent.add(1);\n\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\tcurrent.add(result.get(i-1).get(j-1) + result.get(i-1).get(j));\n\t\t\t}\n\t\t\tcurrent.add(1);\n\t\t\tresult.add(current);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> generate(int numRows) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(numRows == 0)\n\t\t\treturn result;\n\t\tresult.add(new ArrayList<Integer>());\n\t\tresult.get(0).add(1);\n\t\tfor(int i = 1; i < numRows; i++){\n\t\t\tList<Integer> temp = new ArrayList<Integer>();\n\t\t\ttemp.add(1);\n\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\ttemp.add(result.get(i-1).get(j-1) + result.get(i-1).get(j));\n\t\t\t}\n\t\t\ttemp.add(1);\n\t\t\tresult.add(temp);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> generate(int numRows) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tif(numRows == 0){\n\t\t\treturn list;\n\t\t}\n\t\tlist.add(1);\n\t\tfor(int i = 1; i < numRows; i++){\n\t\t\tint[] arr = new int[i+1];\n\t\t\tarr[0] = 1;\n\t\t\tarr[i] = 1;\n\t\t\tfor(int j = 1; j < i; j++){\n\t\t\t\tarr[j] = list.get(j-1) + list.get(j);\n\t\t\t}\n\t\t\tlist.addAll(Arrays.asList(arr));\n\t\t}\n\t\treturn list;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2153",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary tree with the following rules: root.val == 0 and tree.left != null, then tree.right.val is changed to 2 * x + 2. The binary tree is contaminated, which means all tree.val have been changed to -1.",
    "snippets": [
        "\tvoid change(TreeNode root){\n\t\tif(root == null) return;\n\t\tif(root.left != null){\n\t\t\troot.left.val = 2 * root.val + 2;\n\t\t\tchange(root.left);\n\t\t}\n\t\tif(root.right != null){\n\t\t\troot.right.val = 2 * root.val + 2;\n\t\t\tchange(root.right);\n\t\t}\n\t}\n}\n",
        "\tvoid change(TreeNode root){\n\t\tif(root == null) return;\n\t\tif(root.left != null) root.left.val = 2 * root.val + 2;\n\t\tchange(root.left);\n\t\tchange(root.right);\n\t}\n}\n",
        "\tTreeNode convertBinaryTree(TreeNode root){\n\t\tif(root == null) return null;\n\t\tif(root.left == null) return root;\n\t\tconvertBinaryTree(root.left);\n\t\tconvertBinaryTree(root.right);\n\t\tint tmp = root.val;\n\t\troot.val = root.right.val;\n\t\troot.right.val = 2 * tmp + 2;\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode convertBST(TreeNode root) {\n\t\tif(root == null) return null;\n\t\tconvertBST(root.right);\n\t\tint tmp = root.val;\n\t\troot.val = root.right.val;\n\t\troot.right.val = 2 * tmp + 2;\n\t\tconvertBST(root.left);\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode convertBinaryTree(TreeNode root){\n\t\tif(root == null) return null;\n\t\tif(root.left == null) return root;\n\t\tTreeNode left = convertBinaryTree(root.left);\n\t\tTreeNode right = convertBinaryTree(root.right);\n\t\troot.left = left;\n\t\troot.right = right;\n\t\troot.val = 2 * left.val + 2;\n\t\treturn root;\n\t}\n}\n",
        "\tTreeNode convertBST(TreeNode root) {\n\t\tif(root == null) return null;\n\t\tconvertBST(root.right);\n\t\tint sum = 0;\n\t\tTreeNode cur = root;\n\t\twhile(cur != null){\n\t\t\tsum += cur.val;\n\t\t\tcur.val = -1;\n\t\t\tcur = cur.left;\n\t\t}\n\t\troot.val += sum;\n\t\tconvertBST(root.left);\n\t\treturn root;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2154",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.",
    "snippets": [
        "\tint countNumbersWithUniqueDigits(int n) {\n\t\tif(n == 0) return 1;\n\t\tint res = 10;\n\t\tint uniqueDigits = 9;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tuniqueDigits *= (10 - i + 1);\n\t\t\tres += uniqueDigits;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countNumbersWithUniqueDigits(int n) {\n\t\tint res = 1;\n\t\tint uniqueDigits = 9;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tuniqueDigits *= (9 - i + 2);\n\t\t\tres += uniqueDigits;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countNumbersWithUniqueDigits(int n) {\n\t\tint res = 1;\n\t\tint uniqueDigits = 9;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tuniqueDigits *= (10 - i + 1);\n\t\t\tres += uniqueDigits;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countNumbersWithUniqueDigits(int n) {\n\t\tif(n == 0) return 1;\n\t\tint res = 10;\n\t\tint uniqueDigits = 9;\n\t\tint available = 9;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tuniqueDigits *= available;\n\t\t\tres += uniqueDigits;\n\t\t\tavailable--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countNumbersWithUniqueDigits(int n) {\n\t\tif(n == 0) return 1;\n\t\tint res = 10;\n\t\tint uniqueDigits = 9;\n\t\tint availableNumber = 9;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tuniqueDigits *= availableNumber;\n\t\t\tres += uniqueDigits;\n\t\t\tavailableNumber--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countNumbersWithUniqueDigits(int n) {\n\t\tint res = 1;\n\t\tint uniqueDigits = 9;\n\t\tint uniqueDigitsCount = 9;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tuniqueDigitsCount *= uniqueDigits;\n\t\t\tres += uniqueDigitsCount;\n\t\t\tuniqueDigits--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countNumbersWithUniqueDigits(int n) {\n\t\tint res = 1;\n\t\tint uniqueDigits = 9;\n\t\tint uniqueDigits2 = 9;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tuniqueDigits *= uniqueDigits2;\n\t\t\tres += uniqueDigits;\n\t\t\tuniqueDigits2--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int countNumbersWithUniqueDigits(int n) {\n\t\tif(n==0) return 1;\n\t\tint res=10;\n\t\tint uniqueDigits=9;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tuniqueDigits*=10-i+1;\n\t\t\tres+=uniqueDigits;\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2155",
    "source": "leetcode",
    "language": "java",
    "query": "You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i.",
    "snippets": [
        "\tint[] solution(int[] nums){\n\t\tint[] answer = new int[nums.length];\n\t\tint[] temp = new int[nums.length];\n\t\tint[] temp2 = new int[nums.length];\n\t\tint[] temp3 = new int[nums.length];\n\t\tint[] temp4 = new int[nums.length];\n\t\tint[] temp5 = new int[nums.length];\n\t\tint[] temp6 = new int[nums.length];\n\t\tint[] temp7 = new int[nums.length];\n\t\tint[] temp8 = new int[nums.length];\n\t\tint[] temp9 = new int[nums.length];\n\t\tint[] temp10 = new int[nums.length];\n\t\tint[] temp11 = new int[nums.length];\n\t\tint[] temp12 = new int[nums.length];\n\t\tint[] temp13 = new int[nums.length];\n\t\tint[] temp14 = new int[nums.length];\n\t\tint[] temp15 = new int[nums.length];\n\t\tint[] temp16 = new int[nums.length];\n\t\tint[] temp17 = new int[nums.length];\n\t\tint[] temp18 = new int[nums.length];\n\t\tint[] temp19 = new int[nums.length];\n\t\tint[] temp20 = new int[nums.length];\n\t\tint[] temp21 = new int[nums.length];\n\t\tint[] temp22 = new int[nums.length];\n\t\tint[] temp23 = new int[nums.length];\n\t\tint[] temp24 = new int[nums.length];\n\t\tint[] temp25 = new int[nums.length];\n\t\tint[] temp26 = new int[nums.length];\n\t\tint[] temp27 = new int[nums.length];\n\t\tint[] temp28 = new int[nums.length];\n\t\tint[] temp29 = new int[nums.length];\n\t\tint[] temp30 = new int[\n",
        "\tint[] solution(int[] nums){\n\t\tint[] answer = new int[nums.length];\n\t\tint[] temp = new int[nums.length];\n\t\tfor(int i=0; i<nums.length; i++){\n\t\t\ttemp[i] = nums[i];\n\t\t}\n\t\tfor(int i=0; i<nums.length; i++){\n\t\t\tint j = i;\n\t\t\tint count = 0;\n\t\t\twhile(temp[j]!=0){\n\t\t\t\tcount++;\n\t\t\t\tj = (j+temp[j])%nums.length;\n\t\t\t}\n\t\t\tanswer[i] = count;\n\t\t}\n\t\treturn answer;\n\t}\n}\n",
        "\tint[] circularArray(int[] nums){\n\t\tint[] res = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tres[i] = nums[(i + nums[i]) % nums.length];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] solution(int[] nums){\n\t\tint[] answer = new int[nums.length];\n\t\tint[] temp = new int[nums.length];\n\t\tfor(int i=0; i<nums.length; i++){\n\t\t\ttemp[i] = nums[i];\n\t\t}\n\t\tfor(int i=0; i<nums.length; i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j=0; j<nums.length; j++){\n\t\t\t\tif(temp[j]!=0){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tanswer[i] = count;\n\t\t\tfor(int j=0; j<nums.length; j++){\n\t\t\t\tif(temp[j]!=0){\n\t\t\t\t\ttemp[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}\n",
        "\tint[] solution(int[] nums){\n\t\tint[] result = new int[nums.length];\n\t\tint[] temp = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\ttemp[i] = nums[i];\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint j = i;\n\t\t\tint count = 0;\n\t\t\twhile(temp[j] != 0){\n\t\t\t\tcount++;\n\t\t\t\tj = (j + temp[j]) % nums.length;\n\t\t\t\tif(j == i){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult[i] = count;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] solution(int[] nums){\n\t\tint[] result = new int[nums.length];\n\t\tint[] temp = new int[nums.length];\n\t\tint[] temp2 = new int[nums.length];\n\t\tint[] temp3 = new int[nums.length];\n\t\tint[] temp4 = new int[nums.length];\n\t\tint[] temp5 = new int[nums.length];\n\t\tint[] temp6 = new int[nums.length];\n\t\tint[] temp7 = new int[nums.length];\n\t\tint[] temp8 = new int[nums.length];\n\t\tint[] temp9 = new int[nums.length];\n\t\tint[] temp10 = new int[nums.length];\n\t\tint[] temp11 = new int[nums.length];\n\t\tint[] temp12 = new int[nums.length];\n\t\tint[] temp13 = new int[nums.length];\n\t\tint[] temp14 = new int[nums.length];\n\t\tint[] temp15 = new int[nums.length];\n\t\tint[] temp16 = new int[nums.length];\n\t\tint[] temp17 = new int[nums.length];\n\t\tint[] temp18 = new int[nums.length];\n\t\tint[] temp19 = new int[nums.length];\n\t\tint[] temp20 = new int[nums.length];\n\t\tint[] temp21 = new int[nums.length];\n\t\tint[] temp22 = new int[nums.length];\n\t\tint[] temp23 = new int[nums.length];\n\t\tint[] temp24 = new int[nums.length];\n\t\tint[] temp25 = new int[nums.length];\n\t\tint[] temp26 = new int[nums.length];\n\t\tint[] temp27 = new int[nums.length];\n\t\tint[] temp28 = new int[nums.length];\n\t\tint[] temp29 = new int[nums.length];\n\t\tint[] temp30 = new int\n",
        "\tint[] circularArrayLoop(int[] nums) {\n\t\tint[] res = new int[2];\n\t\tif(nums.length == 0) return res;\n\t\tint n = nums.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] == 0) continue;\n\t\t\tif(circularArrayLoop(nums, i)){\n\t\t\t\tres[0] = i;\n\t\t\t\tres[1] = nums[i];\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tboolean circularArrayLoop(int[] nums, int start){\n\t\tint n = nums.length;\n\t\tint slow = start, fast = start;\n\t\tdo{\n\t\t\tslow = nums[slow] + slow;\n\t\t\tfast = nums[nums[fast] + fast] + fast;\n\t\t\tif(slow == fast) return true;\n\t\t}while(slow != fast);\n\t\treturn false;\n\t}\n}\n",
        "\tint[] circularArrayLoop(int[] nums) {\n\t\tint[] res = new int[2];\n\t\tif(nums.length == 0) return res;\n\t\tint n = nums.length;\n\t\tint[] visited = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(visited[i] == 1) continue;\n\t\t\tif(dfs(nums, i, visited)){\n\t\t\t\tres[0] = i;\n\t\t\t\tres[1] = 1;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean dfs(int[] nums, int i, int[] visited){\n\t\tif(visited[i] == 1) return false;\n\t\tvisited[i] = 1;\n\t\tint n = nums.length;\n\t\tint next = (i + nums[i]) % n;\n\t\tif(next == i) return true;\n\t\tif(dfs(nums, next, visited)) return true;\n\t\treturn false;\n\t}\n}\n",
        "\tint[] circularArrayLoop(int[] nums) {\n\t\tint[] res = new int[2];\n\t\tif(nums.length == 0) return res;\n\t\tint len = nums.length;\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tif(nums[i] == 0) continue;\n\t\t\tif(circularArrayLoop(nums, i)){\n\t\t\t\tres[0] = i;\n\t\t\t\tres[1] = nums[i];\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tboolean circularArrayLoop(int[] nums, int start){\n\t\tint len = nums.length;\n\t\tint slow = start, fast = start;\n\t\twhile(true){\n\t\t\tslow = nums[slow] + slow;\n\t\t\tfast = nums[nums[fast] + fast] + fast;\n\t\t\tif(slow == fast) break;\n\t\t\tif(slow < 0 || slow >= len || fast < 0 || fast >= len) return false;\n\t\t\tif(slow == start) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2156",
    "source": "leetcode",
    "language": "java",
    "query": "Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words. If you cannot redistribute all the spaces equally, place the extra spaces at the end. Return the string after rearranging the spaces.",
    "snippets": [
        "\tString RearrangeSpaces(String str) {\n\t\tString[] words = str.split(\" \");\n\t\tint count = 0;\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].length() == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint space = (words.length - 1) * count;\n\t\tint extra = str.length() - space - words[0].length() - words[words.length - 1].length();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].length() == 0){\n\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(words[i]);\n\t\t\t\tfor(int j = 0; j < extra; j++){\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString RearrangeSpaces(String str) {\n\t\tString[] words = str.split(\" \");\n\t\tint count = 0;\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].length() == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint space = (words.length - 1) * 2 - count;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].length() == 0){\n\t\t\t\tfor(int j = 0; j < space; j++){\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(words[i]);\n\t\t\t\tfor(int j = 0; j < space; j++){\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString RearrangeSpaces(String str){\n\t\tString[] words = str.split(\" \");\n\t\tint count = 0;\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].length() == 0){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint space = (words.length - 1) * count;\n\t\tint extra = str.length() - space - (words.length - 1);\n\t\tString result = \"\";\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].length() == 0){\n\t\t\t\tfor(int j = 0; j < extra; j++){\n\t\t\t\t\tresult += \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresult += words[i];\n\t\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\t\tresult += \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tString RearrangeSpaces(String str) {\n\t\tString[] words = str.split(\" \");\n\t\tint count = 0;\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tif (words[i].length() == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint space = (words.length - 1) / (count + 1);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tif (words[i].length() == 0) {\n\t\t\t\tfor (int j = 0; j < space; j++) {\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsb.append(words[i]);\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString().trim();\n\t}\n}\n",
        "\tString RearrangeSpaces(String str) {\n\t\tString[] words = str.split(\" \");\n\t\tint count = 0;\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tif (words[i].length() == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint space = (words.length - 1) * count;\n\t\tint extra = str.length() - space - words[0].length() * words.length;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tif (words[i].length() == 0) {\n\t\t\t\tfor (int j = 0; j < count; j++) {\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsb.append(words[i]);\n\t\t\t\tfor (int j = 0; j < extra; j++) {\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString RearrangeSpaces(String str) {\n\t\tString[] words = str.split(\" \");\n\t\tint count = 0;\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tif (words[i].length() == 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tint space = (words.length - 1) / (count + 1);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < words.length; i++) {\n\t\t\tif (words[i].length() == 0) {\n\t\t\t\tfor (int j = 0; j < space; j++) {\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsb.append(words[i]);\n\t\t\t\tfor (int j = 0; j < space; j++) {\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString RearrangeSpaces(String str) {\n\t\tString[] words = str.split(\" \");\n\t\tint spaceCount = 0;\n\t\tfor (String word : words) {\n\t\t\tspaceCount += word.length() - 1;\n\t\t}\n\t\tint spaceToAdd = spaceCount / (words.length - 1);\n\t\tint extraSpace = spaceCount % (words.length - 1);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (String word : words) {\n\t\t\tsb.append(word);\n\t\t\tfor (int i = 0; i < spaceToAdd; i++) {\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\tif (extraSpace > 0) {\n\t\t\t\tsb.append(\" \");\n\t\t\t\textraSpace--;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString RearrangeSpaces(String str) {\n\t\tString[] words = str.split(\" \");\n\t\tint spaceCount = 0;\n\t\tfor (String word : words) {\n\t\t\tspaceCount += word.length() - 1;\n\t\t}\n\t\tint extra = spaceCount % (words.length - 1);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (String word : words) {\n\t\t\tsb.append(word);\n\t\t\tfor (int i = 0; i < extra; i++) {\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString rearrangeSpaces(String text, int maxSpaces){\n\t\tString[] words = text.split(\" \");\n\t\tint count = 0;\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tcount += words[i].length();\n\t\t}\n\t\tint numSpaces = words.length - 1;\n\t\tint numExtraSpaces = count - numSpaces;\n\t\tif(numExtraSpaces % 2 != 0){\n\t\t\tnumExtraSpaces++;\n\t\t}\n\t\tint numEvenSpaces = numExtraSpaces / 2;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tsb.append(words[i]);\n\t\t\tif(i != words.length - 1){\n\t\t\t\tfor(int j = 0; j < numEvenSpaces; j++){\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString rearrangeSpaces(String text){\n\t\tString[] words = text.split(\" \");\n\t\tint count = 0;\n\t\tfor(String word: words){\n\t\t\tcount += word.length();\n\t\t}\n\t\tint avg = count / words.length;\n\t\tint extra = count % words.length;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String word: words){\n\t\t\tsb.append(word);\n\t\t\tfor(int i = 0; i < avg - word.length(); i++){\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < extra; i++){\n\t\t\tsb.append(\" \");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2157",
    "source": "leetcode",
    "language": "java",
    "query": "Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.",
    "snippets": [
        "\tint countSquares(int[][] matrix) {\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(matrix[i][j] == 1){\n\t\t\t\t\tif(i == 0 || j == 0){\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1;\n\t\t\t\t\t}\n\t\t\t\t\tcount += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSquares(int[][] matrix) {\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(matrix[i][j] == 1){\n\t\t\t\t\tif(i == 0 || j == 0){\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-1];\n\t\t\t\t\t}\n\t\t\t\t\tcount += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSquares(int[][] matrix) {\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (matrix[i][j] == 1) {\n\t\t\t\t\tif (i == 0 || j == 0) {\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t\tcount += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSquares(int[][] matrix) {\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (matrix[i][j] == 1) {\n\t\t\t\t\tif (i == 0 || j == 0) {\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t\tres += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countSquares(int[][] matrix) {\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (matrix[i][j] == 1) {\n\t\t\t\t\tif (i > 0 && j > 0) {\n\t\t\t\t\t\tdp[i][j] = matrix[i - 1][j - 1] + 1;\n\t\t\t\t\t}\n\t\t\t\t\tcount += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2158",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the array words.",
    "snippets": [
        "\tstatic boolean isConsistent(String allowed, String[] words){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tfor(int j = 0; j < words[i].length(); j++){\n\t\t\t\tcount[words[i].charAt(j) - 'a']++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < allowed.length(); i++){\n\t\t\tif(count[allowed.charAt(i) - 'a'] == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isConsistent(String allowed, String[] words){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tfor(int j = 0; j < words[i].length(); j++){\n\t\t\t\tcount[words[i].charAt(j) - 'a']++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < allowed.length(); i++){\n\t\t\tif(count[allowed.charAt(i) - 'a'] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isConsistent(String allowed, String[] words){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < allowed.length(); i++){\n\t\t\tcount[allowed.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tint[] temp = new int[26];\n\t\t\tfor(int j = 0; j < words[i].length(); j++){\n\t\t\t\ttemp[words[i].charAt(j) - 'a']++;\n\t\t\t}\n\t\t\tfor(int j = 0; j < 26; j++){\n\t\t\t\tif(temp[j] > count[j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isConsistent(String allowed, String[] words){\n\t\tif(allowed.length() == 0){\n\t\t\treturn true;\n\t\t}\n\t\tif(words.length == 0){\n\t\t\treturn false;\n\t\t}\n\t\tHashMap<Character, Integer> map = new HashMap<Character, Integer>();\n\t\tfor(int i = 0; i < allowed.length(); i++){\n\t\t\tif(map.containsKey(allowed.charAt(i))){\n\t\t\t\tmap.put(allowed.charAt(i), map.get(allowed.charAt(i)) + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap.put(allowed.charAt(i), 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tHashMap<Character, Integer> temp = new HashMap<Character, Integer>();\n\t\t\tfor(int j = 0; j < words[i].length(); j++){\n\t\t\t\tif(temp.containsKey(words[i].charAt(j))){\n\t\t\t\t\ttemp.put(words[i].charAt(j), temp.get(words[i].charAt(j)) + 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ttemp.put(words[i].charAt(j), 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!temp.equals(map)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isConsistent(String allowed, String[] words){\n\t\tif(words.length==0) return true;\n\t\tHashMap<Character,Integer> map = new HashMap<Character,Integer>();\n\t\tfor(int i=0;i<allowed.length();i++){\n\t\t\tchar c = allowed.charAt(i);\n\t\t\tif(map.containsKey(c)){\n\t\t\t\tmap.put(c,map.get(c)+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap.put(c,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<words.length;i++){\n\t\t\tString word = words[i];\n\t\t\tHashMap<Character,Integer> temp = new HashMap<Character,Integer>(map);\n\t\t\tfor(int j=0;j<word.length();j++){\n\t\t\t\tchar c = word.charAt(j);\n\t\t\t\tif(temp.containsKey(c)){\n\t\t\t\t\ttemp.put(c,temp.get(c)-1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isConsistent(String allowed, String[] words) {\n\t\tif(allowed.length() == 0) return true;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tfor(int j = 0; j < words[i].length(); j++){\n\t\t\t\tcount[words[i].charAt(j) - 'a']++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < allowed.length(); i++){\n\t\t\tif(count[allowed.charAt(i) - 'a'] == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2159",
    "source": "leetcode",
    "language": "java",
    "query": "We want to select three indices i, j and k where (0 <= i < j <= k < arr.length). Let's define a and b as follows.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint c = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tfor(i = 0; i < arr.length; i++){\n\t\t\tfor(j = i + 1; j < arr.length; j++){\n\t\t\t\tfor(k = j + 1; k < arr.length; k++){\n\t\t\t\t\tif(arr[i] + arr[j] + arr[k] == 15){\n\t\t\t\t\t\ta = arr[i];\n\t\t\t\t\t\tb = arr[j];\n\t\t\t\t\t\tc = arr[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a + \" \" + b + \" \" + c);\n\t}\n}\n",
        "\tvoid method(int[] arr){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = i + 1; j < arr.length; j++){\n\t\t\t\tfor(int k = j + 1; k < arr.length; k++){\n\t\t\t\t\tif(arr[i] + arr[j] + arr[k] == 0){\n\t\t\t\t\t\ta = i;\n\t\t\t\t\t\tb = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(a + \" \" + b);\n\t}\n}\n",
        "\tvoid method(int[] arr){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr.length){\n\t\t\twhile(j < arr.length){\n\t\t\t\twhile(k < arr.length){\n\t\t\t\t\tif(arr[i] + arr[j] + arr[k] == 0){\n\t\t\t\t\t\ta = arr[i];\n\t\t\t\t\t\tb = arr[j];\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(a + \" \" + b);\n\t}\n}\n",
        "\tint a(int[] arr){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint max = 0;\n\t\tfor(i = 0; i < arr.length; i++){\n\t\t\tfor(j = i; j < arr.length; j++){\n\t\t\t\tfor(k = j; k < arr.length; k++){\n\t\t\t\t\tif(arr[i] + arr[j] + arr[k] > max){\n\t\t\t\t\t\tmax = arr[i] + arr[j] + arr[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint a(int[] arr){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr.length){\n\t\t\twhile(j < arr.length){\n\t\t\t\twhile(k < arr.length){\n\t\t\t\t\tif(arr[i] + arr[j] + arr[k] == 0){\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tk = j + 1;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj = i + 1;\n\t\t\tk = j + 1;\n\t\t}\n\t\treturn 0;\n\t}\n}\n",
        "\tint a(int[] arr){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint max = 0;\n\t\tfor(int x = 0; x < arr.length; x++){\n\t\t\tfor(int y = x + 1; y < arr.length; y++){\n\t\t\t\tfor(int z = y + 1; z < arr.length; z++){\n\t\t\t\t\tif(arr[x] + arr[y] + arr[z] > max){\n\t\t\t\t\t\tmax = arr[x] + arr[y] + arr[z];\n\t\t\t\t\t\ti = x;\n\t\t\t\t\t\tj = y;\n\t\t\t\t\t\tk = z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint a(int[] arr){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint max = 0;\n\t\tfor(int x = 0; x < arr.length; x++){\n\t\t\tfor(int y = x; y < arr.length; y++){\n\t\t\t\tfor(int z = y; z < arr.length; z++){\n\t\t\t\t\tif(arr[x] + arr[y] + arr[z] > max){\n\t\t\t\t\t\tmax = arr[x] + arr[y] + arr[z];\n\t\t\t\t\t\ti = x;\n\t\t\t\t\t\tj = y;\n\t\t\t\t\t\tk = z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int a(int[] arr){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint max = 0;\n\t\tfor(int x = 0; x < arr.length; x++){\n\t\t\tfor(int y = 0; y < arr.length; y++){\n\t\t\t\tfor(int z = 0; z < arr.length; z++){\n\t\t\t\t\tif(x + y + z == arr.length){\n\t\t\t\t\t\tif(arr[x] + arr[y] + arr[z] > max){\n\t\t\t\t\t\t\tmax = arr[x] + arr[y] + arr[z];\n\t\t\t\t\t\t\ti = x;\n\t\t\t\t\t\t\tj = y;\n\t\t\t\t\t\t\tk = z;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint a(int[] arr){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint max = 0;\n\t\tfor(int a = 0; a < arr.length; a++){\n\t\t\tfor(int b = a; b < arr.length; b++){\n\t\t\t\tfor(int c = b; c < arr.length; c++){\n\t\t\t\t\tif(arr[a] + arr[b] + arr[c] > max){\n\t\t\t\t\t\tmax = arr[a] + arr[b] + arr[c];\n\t\t\t\t\t\ti = a;\n\t\t\t\t\t\tj = b;\n\t\t\t\t\t\tk = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2160",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.",
    "snippets": [
        "\tint countGoodTriplets(int[] arr, int a, int b, int c) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = i + 1; j < arr.length; j++){\n\t\t\t\tfor(int k = j + 1; k < arr.length; k++){\n\t\t\t\t\tif(Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[k] - arr[i]) <= c){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countGoodTriplets(int[] arr, int a, int b, int c) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = i + 1; j < arr.length; j++){\n\t\t\t\tfor(int k = j + 1; k < arr.length; k++){\n\t\t\t\t\tif(Math.abs(arr[i] - arr[j]) <= a && Math.abs(arr[j] - arr[k]) <= b && Math.abs(arr[i] - arr[k]) <= c){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countTriplets(int[] arr, int a, int b, int c) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = i+1; j < arr.length; j++){\n\t\t\t\tfor(int k = j+1; k < arr.length; k++){\n\t\t\t\t\tif(arr[i]*a + arr[j]*b + arr[k]*c == 0){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countTriplets(int[] arr, int a, int b, int c) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tint j = i + 1;\n\t\t\tint k = i + 2;\n\t\t\twhile(j < arr.length && arr[j] % a == 0){\n\t\t\t\twhile(k < arr.length && arr[k] % b == 0){\n\t\t\t\t\tif(arr[k] % c == 0)\n\t\t\t\t\t\tcount++;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int countTriplets(int[] arr, int a, int b, int c) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tfor(int j = i + 1; j < arr.length; j++){\n\t\t\t\tfor(int k = j + 1; k < arr.length; k++){\n\t\t\t\t\tif(arr[i] * a + arr[j] * b + arr[k] * c == 0){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2161",
    "source": "leetcode",
    "language": "java",
    "query": "Each number from 1 to n is grouped according to the sum of its digits. You are given an integer n.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tint[] count = new int[10];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint sum = 0;\n\t\t\twhile(arr[i] > 0){\n\t\t\t\tsum += arr[i] % 10;\n\t\t\t\tarr[i] /= 10;\n\t\t\t}\n\t\t\tcount[sum]++;\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.print(count[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tint[] count = new int[10];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint sum = 0;\n\t\t\twhile(arr[i] > 0){\n\t\t\t\tsum += arr[i] % 10;\n\t\t\t\tarr[i] /= 10;\n\t\t\t}\n\t\t\tcount[sum]++;\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(count[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tin.close();\n\t\tint[] count = new int[10];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint sum = 0;\n\t\t\twhile(arr[i] > 0){\n\t\t\t\tsum += arr[i] % 10;\n\t\t\t\tarr[i] /= 10;\n\t\t\t}\n\t\t\tcount[sum]++;\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(count[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = in.nextInt();\n\t\t}\n\t\tint[] count = new int[10];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint num = arr[i];\n\t\t\twhile(num > 0){\n\t\t\t\tcount[num%10]++;\n\t\t\t\tnum /= 10;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(count[i]);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2162",
    "source": "leetcode",
    "language": "java",
    "query": "A laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor. The test cases are guaranteed so that the ray will meet a receptor eventually.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = in.nextInt();\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = in.nextInt();\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = in.nextInt();\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = in.nextInt();\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = in.nextInt();\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = in.nextInt();\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ti[i] = in.nextInt();\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = in.nextInt();\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = in.nextInt();\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = in.nextInt();\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = in.nextInt();\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = in.nextInt();\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = in.nextInt();\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int j = 0; j < n; j++){\n\t\t\ti[j] = in.nextInt();\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int k = 0; k < n; k++){\n",
        "\tstatic void main(String[] args){\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint q = in.nextInt();\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = in.nextInt();\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = in.nextInt();\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = in.nextInt();\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = in.nextInt();\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = in.nextInt();\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = in.nextInt();\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = in.nextInt();\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = in.nextInt();\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int j = 0; j < n; j++){\n\t\t\ti[j] = in.nextInt();\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int j = 0; j < n; j++){\n"
    ],
    "results": 10
},{
    "id": "2163",
    "source": "leetcode",
    "language": "java",
    "query": "In English, we have a concept called root, which can be followed by some other word to form another longer word. For example, when the root \"an\" is followed by the successor word \"other\", we can form a new word \"another\"",
    "snippets": [
        "\tString rootWord;\n\tString successorWord;\n\tpublic Clazz(String rootWord, String successorWord){\n\t\tthis.rootWord = rootWord;\n\t\tthis.successorWord = successorWord;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"another\";\n\t\tString t = \"other\";\n\t\tSystem.out.println(isRoot(s,t));\n\t}\n\tpublic static boolean isRoot(String s, String t){\n\t\tif(s.length() < t.length())\n\t\t\treturn false;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < s.length() && j < t.length()){\n\t\t\tif(s.charAt(i) == t.charAt(j)){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif(j == t.length())\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString s = \"another\";\n\t\tString t = \"other\";\n\t\tSystem.out.println(isRoot(s,t));\n\t}\n\tpublic static boolean isRoot(String s, String t){\n\t\tif(s.length() < t.length()) return false;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < s.length() && j < t.length()){\n\t\t\tif(s.charAt(i) == t.charAt(j)){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif(j == t.length()) return true;\n\t\telse return false;\n\t}\n}\n",
        "\tString replaceWords(List<String> dict, String sentence) {\n\t\tTrie trie = new Trie();\n\t\tfor(String word : dict){\n\t\t\ttrie.insert(word);\n\t\t}\n\t\tString[] words = sentence.split(\" \");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String word : words){\n\t\t\tif(trie.search(word)){\n\t\t\t\tsb.append(word);\n\t\t\t\tsb.append(\" \");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tStringBuilder sb2 = new StringBuilder();\n\t\t\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\t\t\tsb2.append(word.charAt(i));\n\t\t\t\t\tif(trie.search(sb2.toString())){\n\t\t\t\t\t\tsb.append(sb2.toString());\n\t\t\t\t\t\tsb.append(\" \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sb.toString().trim();\n\t}\n}\n",
        "\tString replaceWords(List<String> dict, String sentence) {\n\t\tif(dict == null || dict.size() == 0) return sentence;\n\t\tString[] words = sentence.split(\" \");\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tString word = words[i];\n\t\t\tfor(String d : dict){\n\t\t\t\tif(word.startsWith(d)){\n\t\t\t\t\twords[i] = d;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn String.join(\" \", words);\n\t}\n}\n",
        "\tString[] generateParenthesis(int n) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tgenerate(res, \"\", 0, 0, n);\n\t\treturn res.toArray(new String[res.size()]);\n\t}\n\tpublic void generate(List<String> res, String cur, int open, int close, int max){\n\t\tif(cur.length() == max*2){\n\t\t\tres.add(cur);\n\t\t\treturn;\n\t\t}\n\t\tif(open < max)\n\t\t\tgenerate(res, cur+\"(\", open+1, close, max);\n\t\tif(close < open)\n\t\t\tgenerate(res, cur+\")\", open, close+1, max);\n\t}\n}\n",
        "\tstatic String root(String word){\n\t\tif(word.length()<=1) return word;\n\t\tString root = word.substring(0,1);\n\t\tString rest = word.substring(1);\n\t\tif(rest.startsWith(root)){\n\t\t\treturn root;\n\t\t}\n\t\treturn root(rest);\n\t}\n}\n",
        "\tString root(String word){\n\t\tif(word.length()<=1){\n\t\t\treturn word;\n\t\t}\n\t\tString root = word.substring(0,1);\n\t\tString rest = word.substring(1);\n\t\tString newWord = root+rest;\n\t\tif(newWord.equals(word)){\n\t\t\treturn word;\n\t\t}\n\t\treturn root(rest);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] words = {\"another\",\"ant\",\"antelope\",\"antler\",\"antonym\",\"anus\",\"anvil\",\"any\",\"ape\",\"apex\",\"apiary\",\"apollo\",\"apparel\",\"appeal\",\"appear\",\"appearance\",\"apple\",\"applewood\",\"appliance\",\"applicant\",\"application\",\"appointee\",\"appointment\",\"appreciate\",\"approach\",\"approval\",\"approve\",\"apricot\",\"apron\",\"apse\",\"aquarium\",\"arch\",\"archaeology\",\"archeology\",\"archer\",\"architect\",\"architecture\",\"archive\",\"area\",\"arena\",\"argue\",\"argument\",\"arise\",\"arm\",\"armadillo\",\"armament\",\"armchair\",\"armful\",\"armhole\",\"army\",\"aroma\",\"arose\",\"around\",\"arrange\",\"array\",\"arrest\",\"arrival\",\"arrive\",\"arrogance\",\"arrow\",\"arsenal\",\"arson\",\"art\",\"artery\",\"article\",\"artifact\",\"artificer\",\"artillery\",\"artwork\",\"asbestos\",\"ash\",\"ashtray\",\"aside\",\"ask\",\"aspect\",\"aspen\",\"asphalt\",\"\n"
    ],
    "results": 9
},{
    "id": "2164",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
    "snippets": [
        "\tvoid rotate(int[] nums, int k) {\n\t\tint len = nums.length;\n\t\tk = k % len;\n\t\treverse(nums, 0, len - 1);\n\t\treverse(nums, 0, k - 1);\n\t\treverse(nums, k, len - 1);\n\t}\n\tpublic void reverse(int[] nums, int start, int end){\n\t\twhile(start < end){\n\t\t\tint temp = nums[start];\n\t\t\tnums[start] = nums[end];\n\t\t\tnums[end] = temp;\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n}\n",
        "\tvoid rotate(int[] nums, int k) {\n\t\tint len = nums.length;\n\t\tk = k % len;\n\t\tint[] temp = new int[len];\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\ttemp[(i + k) % len] = nums[i];\n\t\t}\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tnums[i] = temp[i];\n\t\t}\n\t}\n}\n",
        "\tvoid rotate(int[] nums, int k) {\n\t\tint n = nums.length;\n\t\tk = k % n;\n\t\treverse(nums, 0, n - 1);\n\t\treverse(nums, 0, k - 1);\n\t\treverse(nums, k, n - 1);\n\t}\n\tpublic void reverse(int[] nums, int start, int end) {\n\t\twhile (start < end) {\n\t\t\tint temp = nums[start];\n\t\t\tnums[start] = nums[end];\n\t\t\tnums[end] = temp;\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n}\n",
        "\tvoid rotate(int[] nums, int k) {\n\t\tint n = nums.length;\n\t\tk = k % n;\n\t\treverse(nums, 0, n - k - 1);\n\t\treverse(nums, n - k, n - 1);\n\t\treverse(nums, 0, n - 1);\n\t}\n\tpublic\n\tvoid reverse(int[] nums, int start, int end) {\n\t\twhile (start < end) {\n\t\t\tint temp = nums[start];\n\t\t\tnums[start] = nums[end];\n\t\t\tnums[end] = temp;\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2165",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-' Reformat the phone number in a certain manner.",
    "snippets": [
        "\tstatic String formatPhoneNumber(String number){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < number.length(); i++){\n\t\t\tif(number.charAt(i) != ' ' && number.charAt(i) != '-'){\n\t\t\t\tsb.append(number.charAt(i));\n\t\t\t}\n\t\t}\n\t\tString result = sb.toString();\n\t\treturn result.substring(0, 3) + \"-\" + result.substring(3, 6) + \"-\" + result.substring(6, 10);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString number = \"123 456 789\";\n\t\tSystem.out.println(reformat(number));\n\t}\n\tpublic static String reformat(String number){\n\t\tString[] nums = number.split(\"[\\\\s-]\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i].length() == 1){\n\t\t\t\tsb.append(nums[i]);\n\t\t\t}\n\t\t\telse if(nums[i].length() == 2){\n\t\t\t\tsb.append(nums[i]);\n\t\t\t}\n\t\t\telse if(nums[i].length() == 3){\n\t\t\t\tsb.append(nums[i].charAt(0));\n\t\t\t\tsb.append(nums[i].charAt(1));\n\t\t\t\tsb.append(nums[i].charAt(2));\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic String reformat(String number){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < number.length(); i++){\n\t\t\tif(number.charAt(i) != ' ' && number.charAt(i) != '-'){\n\t\t\t\tsb.append(number.charAt(i));\n\t\t\t}\n\t\t}\n\t\tString s = sb.toString();\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(i % 3 == 0 && i != 0){\n\t\t\t\tsb2.append('-');\n\t\t\t}\n\t\t\tsb2.append(s.charAt(i));\n\t\t}\n\t\treturn sb2.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString number = \"123-456-7890\";\n\t\tSystem.out.println(reformat(number));\n\t}\n\tpublic static String reformat(String number){\n\t\tString[] nums = number.split(\"-|\\\\s\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(nums[0].length() == 3){\n\t\t\tsb.append(nums[0]);\n\t\t\tsb.append(\"-\");\n\t\t\tsb.append(nums[1]);\n\t\t\tsb.append(\"-\");\n\t\t\tsb.append(nums[2]);\n\t\t}\n\t\telse if(nums[0].length() == 4){\n\t\t\tsb.append(nums[0].substring(0,2));\n\t\t\tsb.append(\"-\");\n\t\t\tsb.append(nums[0].substring(2));\n\t\t\tsb.append(\"-\");\n\t\t\tsb.append(nums[1]);\n\t\t\tsb.append(\"-\");\n\t\t\tsb.append(nums[2]);\n\t\t}\n\t\telse{\n\t\t\tsb.append(nums[0]);\n\t\t\tsb.append(\"-\");\n\t\t\tsb.append(nums[1]);\n\t\t\tsb.append(\"-\");\n\t\t\tsb.append(nums[2]);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic void main(String[] args) {\n\t\tString number = \"123 456 789\";\n\t\tSystem.out.println(reformat(number));\n\t}\n\tpublic static String reformat(String number) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < number.length(); i++) {\n\t\t\tif (number.charAt(i) != ' ' && number.charAt(i) != '-') {\n\t\t\t\tsb.append(number.charAt(i));\n\t\t\t}\n\t\t}\n\t\tString result = sb.toString();\n\t\tif (result.length() == 10) {\n\t\t\treturn result;\n\t\t} else if (result.length() == 11) {\n\t\t\treturn result.substring(0, 1) + \"-\" + result.substring(1, 4) + \"-\" + result.substring(4, 7) + \"-\" + result.substring(7, 10);\n\t\t} else if (result.length() == 12) {\n\t\t\treturn result.substring(0, 2) + \"-\" + result.substring(2, 5) + \"-\" + result.substring(5, 8) + \"-\" + result.substring(8, 11);\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString number = \"123-456-7890\";\n\t\tString[] numberArray = number.split(\"-\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < numberArray.length; i++){\n\t\t\tsb.append(numberArray[i]);\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n}\n",
        "\tstatic String formatPhoneNumber(String number){\n\t\tString[] nums = number.split(\"[-\\\\s]\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i].length() == 3){\n\t\t\t\tsb.append(nums[i]);\n\t\t\t\tsb.append(\"-\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic String formatPhoneNumber(String number){\n\t\tString[] num = number.split(\"[- ]\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < num.length; i++){\n\t\t\tsb.append(num[i]);\n\t\t}\n\t\tString result = sb.toString();\n\t\treturn result.substring(0, 3) + \"-\" + result.substring(3, 6) + \"-\" + result.substring(6, 10);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2166",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array coins representing coins of different denominations. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "snippets": [
        "\tint fewestCoins(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (coins[j] <= i) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];\n\t}\n}\n",
        "\tint fewestCoins(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (i >= coins[j]) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];\n\t}\n}\n",
        "\tint fewestCoins(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < coins.length; j++) {\n\t\t\t\tif (i - coins[j] >= 0 && dp[i - coins[j]] != Integer.MAX_VALUE) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2167",
    "source": "leetcode",
    "language": "java",
    "query": "Two binary trees are considered leaf-similar if their leaf value sequence is the same. Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leafvalue sequence.",
    "snippets": [
        "\tboolean leafSimilar(TreeNode root1, TreeNode root2) {\n\t\tList<Integer> list1 = new ArrayList<Integer>();\n\t\tList<Integer> list2 = new ArrayList<Integer>();\n\t\tgetLeaf(root1, list1);\n\t\tgetLeaf(root2, list2);\n\t\treturn list1.equals(list2);\n\t}\n\tpublic void getLeaf(TreeNode root, List<Integer> list){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null){\n\t\t\tlist.add(root.val);\n\t\t\treturn;\n\t\t}\n\t\tgetLeaf(root.left, list);\n\t\tgetLeaf(root.right, list);\n\t}\n}\n",
        "\tboolean leafSimilar(TreeNode root1, TreeNode root2) {\n\t\tList<Integer> list1 = new ArrayList<Integer>();\n\t\tList<Integer> list2 = new ArrayList<Integer>();\n\t\tgetLeaf(root1, list1);\n\t\tgetLeaf(root2, list2);\n\t\treturn list1.equals(list2);\n\t}\n\tpublic void getLeaf(TreeNode root, List<Integer> list){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null){\n\t\t\tlist.add(root.val);\n\t\t}\n\t\tgetLeaf(root.left, list);\n\t\tgetLeaf(root.right, list);\n\t}\n}\n",
        "\tboolean leafSimilar(TreeNode root1, TreeNode root2) {\n\t\tList<Integer> list1 = new ArrayList<>();\n\t\tList<Integer> list2 = new ArrayList<>();\n\t\thelper(root1, list1);\n\t\thelper(root2, list2);\n\t\treturn list1.equals(list2);\n\t}\n\tpublic void helper(TreeNode root, List<Integer> list){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null) list.add(root.val);\n\t\thelper(root.left, list);\n\t\thelper(root.right, list);\n\t}\n}\n",
        "\tboolean leafSimilar(TreeNode root1, TreeNode root2) {\n\t\tList<Integer> list1 = new ArrayList<>();\n\t\tList<Integer> list2 = new ArrayList<>();\n\t\tgetLeaf(root1, list1);\n\t\tgetLeaf(root2, list2);\n\t\treturn list1.equals(list2);\n\t}\n\tpublic void getLeaf(TreeNode root, List<Integer> list){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null){\n\t\t\tlist.add(root.val);\n\t\t\treturn;\n\t\t}\n\t\tgetLeaf(root.left, list);\n\t\tgetLeaf(root.right, list);\n\t}\n}\n",
        "\tstatic boolean leafSimilar(TreeNode root1, TreeNode root2) {\n\t\tList<Integer> list1 = new ArrayList<Integer>();\n\t\tList<Integer> list2 = new ArrayList<Integer>();\n\t\tgetLeaf(root1, list1);\n\t\tgetLeaf(root2, list2);\n\t\treturn list1.equals(list2);\n\t}\n\tpublic static void getLeaf(TreeNode root, List<Integer> list){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null){\n\t\t\tlist.add(root.val);\n\t\t\treturn;\n\t\t}\n\t\tgetLeaf(root.left, list);\n\t\tgetLeaf(root.right, list);\n\t}\n}\n",
        "\tstatic boolean leafSimilar(TreeNode root1, TreeNode root2) {\n\t\tList<Integer> list1 = new ArrayList<Integer>();\n\t\tList<Integer> list2 = new ArrayList<Integer>();\n\t\tgetLeaf(root1, list1);\n\t\tgetLeaf(root2, list2);\n\t\treturn list1.equals(list2);\n\t}\n\tpublic static void getLeaf(TreeNode root, List<Integer> list){\n\t\tif(root == null) return;\n\t\tif(root.left == null && root.right == null){\n\t\t\tlist.add(root.val);\n\t\t}\n\t\tgetLeaf(root.left, list);\n\t\tgetLeaf(root.right, list);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2168",
    "source": "leetcode",
    "language": "java",
    "query": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. You are given an array of strings sentences. Each sentences[i] represents a single sentence.",
    "snippets": [
        "\tString[] findSentence(String[] sentences){\n\t\tString[] result = new String[sentences.length];\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tString[] words = sentences[i].split(\" \");\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int j = 0; j < words.length; j++){\n\t\t\t\tsb.append(words[j]);\n\t\t\t\tif(j != words.length - 1){\n\t\t\t\t\tsb.append(\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult[i] = sb.toString();\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"This is a sentence\", \"This is another sentence\"};\n\t\tString[] words = {\"This\", \"is\", \"a\", \"sentence\"};\n\t\tSystem.out.println(isSentence(sentences, words));\n\t}\n\tpublic static boolean isSentence(String[] sentences, String[] words){\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tString[] sentence = sentences[i].split(\" \");\n\t\t\tif(sentence.length != words.length){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor(int j = 0; j < sentence.length; j++){\n\t\t\t\tif(!sentence[j].equals(words[j])){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"This is a sentence\", \"This is another sentence\"};\n\t\tString[] words = {\"This\", \"is\", \"a\", \"sentence\"};\n\t\tSystem.out.println(findSentence(sentences, words));\n\t}\n\tpublic static int findSentence(String[] sentences, String[] words){\n\t\tint index = -1;\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tif(isSentence(sentences[i], words)){\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tpublic static boolean isSentence(String sentence, String[] words){\n\t\tString[] sentenceWords = sentence.split(\" \");\n\t\tif(sentenceWords.length != words.length){\n\t\t\treturn false;\n\t\t}\n\t\tfor(int i = 0; i < sentenceWords.length; i++){\n\t\t\tif(!sentenceWords[i].equals(words[i])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"This is a good day\", \"This is a bad day\", \"This is a good day\"};\n\t\tString[] words = {\"good\", \"bad\"};\n\t\tSystem.out.println(findSentence(sentences, words));\n\t}\n\tpublic static int findSentence(String[] sentences, String[] words){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tString[] sentence = sentences[i].split(\" \");\n\t\t\tfor(int j = 0; j < sentence.length; j++){\n\t\t\t\tfor(int k = 0; k < words.length; k++){\n\t\t\t\t\tif(sentence[j].equals(words[k])){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"Hello World\",\"Hello CodeEval\",\"Hello\",\"CodeEval\"};\n\t\tString[] words = {\"Hello\",\"World\",\"CodeEval\"};\n\t\tfor(String sentence:sentences){\n\t\t\tfor(String word:words){\n\t\t\t\tif(sentence.contains(word)){\n\t\t\t\t\tSystem.out.println(word);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"Hello World\",\"Hello CodeEval\",\"Hello CodeEval\",\"Hello CodeEval\"};\n\t\tString[] words = {\"Hello\",\"World\",\"CodeEval\"};\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tString[] sentence = sentences[i].split(\" \");\n\t\t\tfor(int j = 0; j < words.length; j++){\n\t\t\t\tfor(int k = 0; k < sentence.length; k++){\n\t\t\t\t\tif(sentence[k].equals(words[j])){\n\t\t\t\t\t\tSystem.out.println(sentences[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"Hello World\",\"Hello CodeEval\",\"Hello CodeEval\",\"Hello World\"};\n\t\tString[] words = {\"Hello\",\"World\",\"CodeEval\"};\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tString[] sentence = sentences[i].split(\" \");\n\t\t\tfor(int j = 0; j < words.length; j++){\n\t\t\t\tfor(int k = 0; k < sentence.length; k++){\n\t\t\t\t\tif(sentence[k].equals(words[j])){\n\t\t\t\t\t\tSystem.out.println(sentences[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid main(String[] args){\n\t\tString[] sentences = {\"Hello World\",\"Hello CodeEval\",\"Hello CodeEval\",\"Hello World\"};\n\t\tString[] words = {\"Hello\",\"World\",\"CodeEval\"};\n\t\tint[] result = new int[sentences.length];\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tresult[i] = count(sentences[i],words);\n\t\t}\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic int count(String sentence, String[] words){\n\t\tint count = 0;\n\t\tString[] sentenceArray = sentence.split(\" \");\n\t\tfor(int i = 0; i < sentenceArray.length; i++){\n\t\t\tfor(int j = 0; j < words.length; j++){\n\t\t\t\tif(sentenceArray[i].equals(words[j])){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"Hello, how are you?\", \"This is a test\", \"I am doing good\", \"Have a nice day\"};\n\t\tString[] words = {\"Hello\", \"how\", \"are\", \"you\", \"this\", \"is\", \"a\", \"test\", \"i\", \"am\", \"doing\", \"good\", \"have\", \"a\", \"nice\", \"day\"};\n\t\tSystem.out.println(Arrays.toString(sentences));\n\t\tSystem.out.println(Arrays.toString(words));\n\t\tSystem.out.println(Arrays.toString(sortSentences(sentences, words)));\n\t}\n\tpublic static String[] sortSentences(String[] sentences, String[] words){\n\t\tString[] sorted = new String[sentences.length];\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tsorted[i] = sortSentence(sentences[i], words);\n\t\t}\n\t\treturn sorted;\n\t}\n\tpublic static String sortSentence(String sentence, String[] words){\n\t\tString[] wordsInSentence = sentence.split(\" \");\n\t\tString[] sortedWords = new String[wordsInSentence.length];\n\t\tfor(int i = 0; i < wordsInSentence.length; i++){\n\t\t\tsortedWords[i] = sortWord(wordsInSentence[i], words);\n\t\t}\n\t\treturn String.join(\" \", sortedWords);\n\t}\n\tpublic static String sortWord(String word, String[] words){\n\t\tint index = Arrays.binarySearch(words, word);\n\t\tif(index < 0){\n\t\t\treturn word;\n\t\t}\n\t\telse{\n\t\t\treturn words[index];\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] sentences = {\"Hi, how are you?\", \"I am fine, thank you.\", \"Have a nice day.\"};\n\t\tSystem.out.println(longestSentence(sentences));\n\t}\n\tpublic static String longestSentence(String[] sentences){\n\t\tint max = 0;\n\t\tString longest = \"\";\n\t\tfor(int i = 0; i < sentences.length; i++){\n\t\t\tif(sentences[i].length() > max){\n\t\t\t\tmax = sentences[i].length();\n\t\t\t\tlongest = sentences[i];\n\t\t\t}\n\t\t}\n\t\treturn longest;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2169",
    "source": "leetcode",
    "language": "java",
    "query": "Return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. Return the empty string if there is no possible result.",
    "snippets": [
        "\tString findLongestWord(String s, String[] d) {\n\t\tString result = \"\";\n\t\tfor (String str : d) {\n\t\t\tif (isValid(s, str)) {\n\t\t\t\tif (str.length() > result.length() || (str.length() == result.length() && str.compareTo(result) < 0)) {\n\t\t\t\t\tresult = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isValid(String s, String str) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i < s.length() && j < str.length()) {\n\t\t\tif (s.charAt(i) == str.charAt(j)) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn j == str.length();\n\t}\n}\n",
        "\tString findLongestWord(String s, String[] d) {\n\t\tString longest = \"\";\n\t\tfor (String word : d) {\n\t\t\tif (isValid(s, word)) {\n\t\t\t\tif (word.length() > longest.length() || (word.length() == longest.length() && word.compareTo(longest) < 0)) {\n\t\t\t\t\tlongest = word;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn longest;\n\t}\n\tpublic boolean isValid(String s, String word) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i < s.length() && j < word.length()) {\n\t\t\tif (s.charAt(i) == word.charAt(j)) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn j == word.length();\n\t}\n}\n",
        "\tString findLongestWord(String s, String[] d) {\n\t\tString longest = \"\";\n\t\tfor (String word : d) {\n\t\t\tif (isSubsequence(s, word) && word.length() > longest.length()\n\t\t\t\t\t|| word.length() == longest.length()\n\t\t\t\t\t&& word.compareTo(longest) < 0)\n\t\t\t\tlongest = word;\n\t\t}\n\t\treturn longest;\n\t}\n\n\tprivate boolean isSubsequence(String s, String t) {\n\t\tint m = s.length(), n = t.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == t.charAt(j))\n\t\t\t\tj++;\n\t\t\ti++;\n\t\t}\n\t\treturn j == n;\n\t}\n}\n",
        "\tString findLongestWord(String s, String[] d) {\n\t\tString res = \"\";\n\t\tfor (String str : d) {\n\t\t\tif (isSubsequence(s, str)) {\n\t\t\t\tif (str.length() > res.length() || (str.length() == res.length() && str.compareTo(res) < 0)) {\n\t\t\t\t\tres = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isSubsequence(String s, String t) {\n\t\tint m = s.length(), n = t.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == t.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn i == m;\n\t}\n}\n",
        "\tString findLongestWord(String s, String[] d) {\n\t\tString longest = \"\";\n\t\tfor (String word : d) {\n\t\t\tif (isSubsequence(s, word) && word.length() > longest.length()\n\t\t\t\t\t|| word.length() == longest.length()\n\t\t\t\t\t&& word.compareTo(longest) < 0)\n\t\t\t\tlongest = word;\n\t\t}\n\t\treturn longest;\n\t}\n\tpublic boolean isSubsequence(String s, String t) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == t.charAt(j))\n\t\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\treturn i == m;\n\t}\n}\n",
        "\tString findLongestWord(String s, String[] d) {\n\t\tString res = \"\";\n\t\tfor (String str : d) {\n\t\t\tif (isSubstring(s, str)) {\n\t\t\t\tif (str.length() > res.length() || (str.length() == res.length() && str.compareTo(res) < 0)) {\n\t\t\t\t\tres = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isSubstring(String s, String t) {\n\t\tint[] map = new int[128];\n\t\tfor (int i = 0; i < t.length(); i++) {\n\t\t\tmap[t.charAt(i)]++;\n\t\t}\n\t\tint count = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (map[s.charAt(i)] > 0) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[s.charAt(i)]--;\n\t\t}\n\t\treturn count == t.length();\n\t}\n}\n",
        "\tString findLongestWord(String s, List<String> d) {\n\t\tString result = \"\";\n\t\tfor (String str : d) {\n\t\t\tif (isSubsequence(s, str)) {\n\t\t\t\tif (str.length() > result.length() || (str.length() == result.length() && str.compareTo(result) < 0)) {\n\t\t\t\t\tresult = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isSubsequence(String s, String t) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == t.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn i == m;\n\t}\n}\n",
        "\tString findLongestWord(String s, String[] d) {\n\t\tString res = \"\";\n\t\tfor (String word : d) {\n\t\t\tif (isSubsequence(s, word)) {\n\t\t\t\tif (word.length() > res.length() || (word.length() == res.length() && word.compareTo(res) < 0)) {\n\t\t\t\t\tres = word;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isSubsequence(String s, String t) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == t.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn i == m;\n\t}\n}\n",
        "\tString findLongestWord(String s, List<String> d) {\n\t\tString result = \"\";\n\t\tfor (String str : d) {\n\t\t\tif (isSubstring(s, str)) {\n\t\t\t\tif (str.length() > result.length() || (str.length() == result.length() && str.compareTo(result) < 0)) {\n\t\t\t\t\tresult = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isSubstring(String s, String str) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i < s.length() && j < str.length()) {\n\t\t\tif (s.charAt(i) == str.charAt(j)) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn j == str.length();\n\t}\n}\n",
        "\tString findLongestWord(String s, String[] d) {\n\t\tString result = \"\";\n\t\tfor (String str : d) {\n\t\t\tif (isSubstring(str, s) && (str.length() > result.length() || (str.length() == result.length() && str.compareTo(result) < 0))) {\n\t\t\t\tresult = str;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isSubstring(String str, String s) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i < str.length() && j < s.length()) {\n\t\t\tif (str.charAt(i) == s.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn i == str.length();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2170",
    "source": "leetcode",
    "language": "java",
    "query": "You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty sub-array of arr and reverse it.",
    "snippets": [
        "\tstatic int[] reverse(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tstatic int[] reverse2(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tstatic int[] reverse3(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tstatic int[] reverse4(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tstatic int[] reverse5(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tstatic int[] reverse6(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn res;\n\t}\n\tpublic\n\tstatic int[] reverse7(int[] arr){\n\t\tint[] res = new int\n",
        "\tstatic int[] reverse(int[] arr){\n\t\tint[] result = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tresult[i] = arr[arr.length - 1 - i];\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic int[] reverse2(int[] arr){\n\t\tint[] result = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tresult[i] = arr[arr.length - 1 - i];\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic int[] reverse3(int[] arr){\n\t\tint[] result = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tresult[i] = arr[arr.length - 1 - i];\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic int[] reverse4(int[] arr){\n\t\tint[] result = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tresult[i] = arr[arr.length - 1 - i];\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic int[] reverse5(int[] arr){\n\t\tint[] result = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tresult[i] = arr[arr.length - 1 - i];\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic int[] reverse6(int[] arr){\n\t\tint[] result = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tresult[i] = arr[arr.length - 1 - i];\n\t\t}\n\t\treturn result;\n\t}\n\tpublic\n\tstatic int[] reverse7(int[] arr){\n\t\tint[] result = new int\n",
        "\tint[] reverse(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - 1 - i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic void reverse(int[] arr, int[] target){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint aa = 0;\n\t\tint bb = 0;\n\t\tint cc = 0;\n\t\tint dd = 0;\n\t\tint ee = 0;\n\t\tint ff = 0;\n\t\tint gg = 0;\n\t\tint hh = 0;\n\t\tint ii = 0;\n\t\tint jj = 0;\n\t\tint kk = 0;\n\t\tint ll = 0;\n\t\tint mm = 0;\n\t\tint nn = 0;\n\t\tint oo = 0;\n\t\tint pp = 0;\n\t\tint qq = 0;\n\t\tint rr = 0;\n\t\tint ss = 0;\n\t\tint tt = 0;\n\t\tint uu = 0;\n\t\tint vv = 0;\n\t\tint ww = 0;\n\t\tint xx = 0;\n\t\tint yy = 0;\n\t\tint zz = 0;\n\t\tint aaa = 0;\n\t\tint bbb = 0;\n\t\tint ccc = 0;\n\t\tint ddd = 0;\n\t\tint eee = 0;\n\t\tint fff = 0;\n\t\tint ggg = 0;\n\t\tint hhh = 0;\n\t\tint iii = 0;\n\t\tint jjj =\n",
        "\tint[] reverse(int[] arr){\n\t\tint[] res = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tres[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic void reverse(int[] arr, int[] target){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\twhile(i < arr.length){\n\t\t\tif(arr[i] == target[j]){\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\twhile(k < arr.length){\n\t\t\tif(arr[k] == target[l]){\n\t\t\t\tl++;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\tint[] newArr = new int[l-j];\n\t\tint[] newTarget = new int[j-k];\n\t\tfor(int m = j; m < l; m++){\n\t\t\tnewArr[m-j] = arr[m];\n\t\t}\n\t\tfor(int n = k; n < j; n++){\n\t\t\tnewTarget[n-k] = target[n];\n\t\t}\n\t\tfor(int o = 0; o < newArr.length; o++){\n\t\t\tarr[o+k] = newArr[o];\n\t\t}\n\t\tfor(int p = 0; p < newTarget.length; p++){\n\t\t\ttarget[p+j] = newTarget[p];\n\t\t}\n\t}\n}\n",
        "\tint reverse(int[] arr, int[] target){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] == target[i]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint[] reverse(int[] arr, int[] target){\n\t\tint[] result = new int[target.length];\n\t\tfor(int i = 0; i < target.length; i++){\n\t\t\tresult[i] = arr[target[i]];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void reverse(int[] arr){\n\t\tint n = arr.length;\n\t\tfor(int i = 0; i < n/2; i++){\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[n-i-1];\n\t\t\tarr[n-i-1] = temp;\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9,10};\n\t\treverse(arr);\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tSystem.out.print(arr[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tstatic void reverse(int[] arr, int[] target){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i < arr.length && j < target.length){\n\t\t\tif(arr[i] == target[j]){\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tif(j == target.length){\n\t\t\tfor(k = 0; k < target.length; k++){\n\t\t\t\tSystem.out.print(target[k] + \" \");\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"Not found\");\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] target = {1,2,3,4,5,6,7,8,9,10};\n\t\treverse(arr, target);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2171",
    "source": "leetcode",
    "language": "java",
    "query": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. A node is a safe node if every possible path starting from that node leads to a terminal node.",
    "snippets": [
        "\tboolean[] visited;\n\tpublic\n\tboolean[] safe;\n\tpublic\n\tint[] graph;\n\tpublic\n\tint n;\n\tpublic\n\tClazz(int n){\n\t\tthis.n = n;\n\t\tvisited = new boolean[n];\n\t\tsafe = new boolean[n];\n\t\tgraph = new int[n];\n\t}\n\tpublic\n\tvoid addEdge(int a, int b){\n\t\tgraph[a] |= (1 << b);\n\t}\n\tpublic\n\tvoid dfs(int node){\n\t\tvisited[node] = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((graph[node] & (1 << i)) != 0){\n\t\t\t\tif(!visited[i]){\n\t\t\t\t\tdfs(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid solve(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tsafe[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid print(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(safe[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\tboolean[] visited;\n\tpublic\n\tboolean[] safe;\n\tpublic\n\tint[] graph;\n\tpublic\n\tint n;\n\tpublic\n\tClazz(int n){\n\t\tthis.n = n;\n\t\tvisited = new boolean[n];\n\t\tsafe = new boolean[n];\n\t\tgraph = new int[n];\n\t}\n\tpublic\n\tvoid addEdge(int a, int b){\n\t\tgraph[a] |= (1 << b);\n\t}\n\tpublic\n\tvoid dfs(int node){\n\t\tvisited[node] = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((graph[node] & (1 << i)) != 0 && !visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid solve(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tsafe[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid print(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(safe[i] ? \"1\" : \"0\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\tboolean[] visited;\n\tpublic\n\tboolean[] safe;\n\tpublic\n\tint[] graph;\n\tpublic\n\tint n;\n\tpublic\n\tClazz(int n){\n\t\tthis.n = n;\n\t\tvisited = new boolean[n];\n\t\tsafe = new boolean[n];\n\t\tgraph = new int[n];\n\t}\n\tpublic\n\tvoid addEdge(int a, int b){\n\t\tgraph[a] |= (1 << b);\n\t}\n\tpublic\n\tvoid dfs(int node){\n\t\tif(visited[node]) return;\n\t\tvisited[node] = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((graph[node] & (1 << i)) != 0){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tsafe[node] = true;\n\t}\n\tpublic\n\tvoid solve(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tboolean[] visited;\n\tpublic\n\tboolean[] safe;\n\tpublic\n\tint[] graph;\n\tpublic\n\tint n;\n\tpublic\n\tClazz(int n){\n\t\tthis.n = n;\n\t\tvisited = new boolean[n];\n\t\tsafe = new boolean[n];\n\t\tgraph = new int[n];\n\t}\n\tpublic\n\tvoid addEdge(int a, int b){\n\t\tgraph[a] |= (1 << b);\n\t}\n\tpublic\n\tvoid dfs(int node){\n\t\tvisited[node] = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((graph[node] & (1 << i)) != 0){\n\t\t\t\tif(!visited[i]){\n\t\t\t\t\tdfs(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid solve(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tsafe[i] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tboolean[] visited;\n\tpublic\n\tboolean[] safe;\n\tpublic\n\tint[] graph;\n\tpublic\n\tint n;\n\tpublic\n\tClazz(int n){\n\t\tthis.n = n;\n\t\tvisited = new boolean[n];\n\t\tsafe = new boolean[n];\n\t\tgraph = new int[n];\n\t}\n\tpublic\n\tvoid addEdge(int a, int b){\n\t\tgraph[a] |= (1 << b);\n\t}\n\tpublic\n\tvoid dfs(int node){\n\t\tvisited[node] = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((graph[node] & (1 << i)) != 0){\n\t\t\t\tif(!visited[i]){\n\t\t\t\t\tdfs(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid solve(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tsafe[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid print(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.print(safe[i] ? 1 : 0);\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n",
        "\tboolean[] visited;\n\tpublic\n\tboolean[] isSafe;\n\tpublic\n\tint[] graph;\n\tpublic\n\tint n;\n\tpublic\n\tClazz(int n){\n\t\tthis.n = n;\n\t\tvisited = new boolean[n];\n\t\tisSafe = new boolean[n];\n\t\tgraph = new int[n];\n\t}\n\tpublic\n\tvoid addEdge(int a, int b){\n\t\tgraph[a] = graph[a] | (1 << b);\n\t}\n\tpublic\n\tvoid dfs(int node){\n\t\tvisited[node] = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif((graph[node] & (1 << i)) > 0 && !visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tvoid solve(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!visited[i]){\n\t\t\t\tisSafe[i] = false;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2172",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. Athletes are placed based on their scores, where the 1st place athlete has the highest score.",
    "snippets": [
        "\tint rank(int[] score){\n\t\tint n = score.length;\n\t\tint[] rank = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\trank[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(score[i] < score[j]){\n\t\t\t\t\tint temp = rank[i];\n\t\t\t\t\trank[i] = rank[j];\n\t\t\t\t\trank[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(rank[i] == 1){\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint rank(int[] score){\n\t\tint n = score.length;\n\t\tint[] rank = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\trank[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(score[i] > score[j]){\n\t\t\t\t\tint temp = rank[i];\n\t\t\t\t\trank[i] = rank[j];\n\t\t\t\t\trank[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(rank[i] == i + 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint rank(int[] score){\n\t\tint n = score.length;\n\t\tint[] rank = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\trank[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(score[i] < score[j]){\n\t\t\t\t\tint temp = rank[i];\n\t\t\t\t\trank[i] = rank[j];\n\t\t\t\t\trank[j] = temp;\n\t\t\t\t\tint temp2 = score[i];\n\t\t\t\t\tscore[i] = score[j];\n\t\t\t\t\tscore[j] = temp2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(rank[i] == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint rank(int[] score){\n\t\tint n = score.length;\n\t\tint[] rank = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\trank[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(score[i] < score[j]){\n\t\t\t\t\tint temp = rank[i];\n\t\t\t\t\trank[i] = rank[j];\n\t\t\t\t\trank[j] = temp;\n\t\t\t\t\tint temp2 = score[i];\n\t\t\t\t\tscore[i] = score[j];\n\t\t\t\t\tscore[j] = temp2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint rank_ = 1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(rank[i] != rank_){\n\t\t\t\trank_++;\n\t\t\t}\n\t\t\trank[i] = rank_;\n\t\t}\n\t\treturn rank[n - 1];\n\t}\n}\n",
        "\tstatic int[] sort(int[] score){\n\t\tint[] sorted = new int[score.length];\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tsorted[i] = score[i];\n\t\t}\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tfor(int j = 0; j < score.length - 1; j++){\n\t\t\t\tif(sorted[j] < sorted[j + 1]){\n\t\t\t\t\tint temp = sorted[j];\n\t\t\t\t\tsorted[j] = sorted[j + 1];\n\t\t\t\t\tsorted[j + 1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sorted;\n\t}\n}\n",
        "\tstatic int[] sort(int[] score){\n\t\tint[] sorted = new int[score.length];\n\t\tint[] index = new int[score.length];\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tindex[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tint max = score[i];\n\t\t\tint maxIndex = i;\n\t\t\tfor(int j = i; j < score.length; j++){\n\t\t\t\tif(score[j] > max){\n\t\t\t\t\tmax = score[j];\n\t\t\t\t\tmaxIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsorted[i] = max;\n\t\t\tindex[i] = maxIndex;\n\t\t}\n\t\tint[] result = new int[score.length];\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tresult[i] = index[i];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] sort(int[] score){\n\t\tint[] sorted = new int[score.length];\n\t\tint[] index = new int[score.length];\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tindex[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tint max = score[i];\n\t\t\tint maxIndex = i;\n\t\t\tfor(int j = i; j < score.length; j++){\n\t\t\t\tif(score[j] > max){\n\t\t\t\t\tmax = score[j];\n\t\t\t\t\tmaxIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsorted[i] = max;\n\t\t\tindex[i] = maxIndex;\n\t\t}\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tscore[i] = sorted[i];\n\t\t\tindex[i] = sorted[i];\n\t\t}\n\t\treturn index;\n\t}\n}\n",
        "\tstatic int[] sort(int[] score){\n\t\tint[] sorted = new int[score.length];\n\t\tint[] temp = new int[score.length];\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\ttemp[i] = score[i];\n\t\t}\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tint max = temp[0];\n\t\t\tint index = 0;\n\t\t\tfor(int j = 0; j < temp.length; j++){\n\t\t\t\tif(temp[j] > max){\n\t\t\t\t\tmax = temp[j];\n\t\t\t\t\tindex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsorted[i] = max;\n\t\t\ttemp[index] = -1;\n\t\t}\n\t\treturn sorted;\n\t}\n}\n",
        "\tstatic int[] sort(int[] score){\n\t\tint[] sorted = new int[score.length];\n\t\tint[] temp = new int[score.length];\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\ttemp[i] = score[i];\n\t\t}\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tint max = temp[0];\n\t\t\tint maxIndex = 0;\n\t\t\tfor(int j = 0; j < temp.length; j++){\n\t\t\t\tif(temp[j] > max){\n\t\t\t\t\tmax = temp[j];\n\t\t\t\t\tmaxIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsorted[i] = max;\n\t\t\ttemp[maxIndex] = 0;\n\t\t}\n\t\treturn sorted;\n\t}\n}\n",
        "\tstatic int[] sort(int[] score){\n\t\tint[] sorted = new int[score.length];\n\t\tint[] unsorted = new int[score.length];\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tunsorted[i] = score[i];\n\t\t}\n\t\tfor(int i = 0; i < score.length; i++){\n\t\t\tint max = 0;\n\t\t\tint index = 0;\n\t\t\tfor(int j = 0; j < unsorted.length; j++){\n\t\t\t\tif(unsorted[j] > max){\n\t\t\t\t\tmax = unsorted[j];\n\t\t\t\t\tindex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsorted[i] = max;\n\t\t\tunsorted[index] = 0;\n\t\t}\n\t\treturn sorted;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2173",
    "source": "leetcode",
    "language": "java",
    "query": "Given three integers n, k, and target, return the number of possible ways to roll the dice so the sum of the face-up numbers equals target. Since the answer may be too large, return it modulo 109 + 7.",
    "snippets": [
        "\tint numRollsToTarget(int n, int k, int target) {\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n + 1][target + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= Math.min(target, i * k); j++) {\n\t\t\t\tfor (int x = 1; x <= k; x++) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - x];\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][target];\n\t}\n}\n",
        "\tint numRollsToTarget(int n, int k, int target) {\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n + 1][target + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= target; j++) {\n\t\t\t\tfor (int m = 1; m <= k && m <= j; m++) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - m];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][target] % mod;\n\t}\n}\n",
        "\tint numRollsToTarget(int n, int k, int target) {\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n+1][target+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= target; j++){\n\t\t\t\tfor(int x = 1; x <= k && x <= j; x++){\n\t\t\t\t\tdp[i][j] += dp[i-1][j-x];\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][target];\n\t}\n}\n",
        "\tint numRollsToTarget(int n, int k, int target) {\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n + 1][target + 1];\n\t\tdp[0][0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= target; j++) {\n\t\t\t\tfor (int x = 1; x <= k && x <= j; x++) {\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - x];\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][target];\n\t}\n}\n",
        "\tint numRollsToTarget(int n, int k, int target) {\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n+1][target+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= target; j++){\n\t\t\t\tif(j >= k){\n\t\t\t\t\tdp[i][j] = (dp[i-1][j-k] + dp[i-1][j]) % mod;\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][target];\n\t}\n}\n",
        "\tint numRollsToTarget(int n, int k, int target) {\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n+1][target+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= target; j++){\n\t\t\t\tfor(int x = 1; x <= k && j-x >= 0; x++){\n\t\t\t\t\tdp[i][j] += dp[i-1][j-x];\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][target];\n\t}\n}\n",
        "\tint numRollsToTarget(int n, int k, int t) {\n\t\tint mod = 1000000007;\n\t\tint[][] dp = new int[n+1][t+1];\n\t\tdp[0][0] = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 0; j <= t; j++){\n\t\t\t\tfor(int x = 1; x <= k && x <= j; x++){\n\t\t\t\t\tdp[i][j] += dp[i-1][j-x];\n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][t];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2174",
    "source": "leetcode",
    "language": "java",
    "query": "24-hour times are formatted as \"HH:MM\", where HH is between 00 and 23. The earliest 24-hour time is 00:00, and the latest is 23:59.",
    "snippets": [
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 12 && minute == 0){\n\t\t\treturn \"00:00\";\n\t\t}\n\t\tif(hour == 12 && minute == 1){\n\t\t\treturn \"00:01\";\n\t\t}\n\t\tif(hour == 12 && minute == 2){\n\t\t\treturn \"00:02\";\n\t\t}\n\t\tif(hour == 12 && minute == 3){\n\t\t\treturn \"00:03\";\n\t\t}\n\t\tif(hour == 12 && minute == 4){\n\t\t\treturn \"00:04\";\n\t\t}\n\t\tif(hour == 12 && minute == 5){\n\t\t\treturn \"00:05\";\n\t\t}\n\t\tif(hour == 12 && minute == 6){\n\t\t\treturn \"00:06\";\n\t\t}\n\t\tif(hour == 12 && minute == 7){\n\t\t\treturn \"00:07\";\n\t\t}\n\t\tif(hour == 12 && minute == 8){\n\t\t\treturn \"00:08\";\n\t\t}\n\t\tif(hour == 12 && minute == 9){\n\t\t\treturn \"00:09\";\n\t\t}\n\t\tif(hour == 12 && minute == 10){\n\t\t\treturn \"00:10\";\n\t\t}\n\t\tif(hour == 12 && minute == 11){\n\t\t\treturn \"00:11\";\n\t\t}\n\t\tif(hour == 12 && minute == 12){\n\t\t\treturn \"00:12\";\n\t\t}\n\t\tif(hour == 12 && minute == 13){\n\t\t\treturn \"00:13\";\n\t\t}\n\t\tif(hour == 12 && minute == 14){\n\t\t\treturn \"00:14\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"00:15\";\n\t\t}\n\t\tif(hour == 12 && minute ==\n",
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 12){\n\t\t\thour = 0;\n\t\t}\n\t\tif(time.contains(\"PM\")){\n\t\t\thour += 12;\n\t\t}\n\t\tString hourString = Integer.toString(hour);\n\t\tString minuteString = Integer.toString(minute);\n\t\tif(hour < 10){\n\t\t\thourString = \"0\" + hourString;\n\t\t}\n\t\tif(minute < 10){\n\t\t\tminuteString = \"0\" + minuteString;\n\t\t}\n\t\treturn hourString + \":\" + minuteString;\n\t}\n}\n",
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 12 && minute == 0){\n\t\t\treturn \"00:00\";\n\t\t}\n\t\tif(hour == 12 && minute == 30){\n\t\t\treturn \"12:30\";\n\t\t}\n\t\tif(hour == 12 && minute == 45){\n\t\t\treturn \"13:15\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"13:45\";\n\t\t}\n\t\tif(hour == 12 && minute == 45){\n\t\t\treturn \"13:15\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"13:45\";\n\t\t}\n\t\tif(hour == 12 && minute == 45){\n\t\t\treturn \"13:15\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"13:45\";\n\t\t}\n\t\tif(hour == 12 && minute == 45){\n\t\t\treturn \"13:15\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"13:45\";\n\t\t}\n\t\tif(hour == 12 && minute == 45){\n\t\t\treturn \"13:15\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"13:45\";\n\t\t}\n\t\tif(hour == 12 && minute == 45){\n\t\t\treturn \"13:15\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"13:45\";\n\t\t}\n\t\tif(hour == 12 && minute == 45){\n\t\t\treturn \"13:15\";\n\t\t}\n\t\tif(hour == 12 && minute == 15){\n\t\t\treturn \"13:45\";\n\t\t}\n\t\tif(hour == 12 && minute ==\n",
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArray = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArray[0]);\n\t\tint minute = Integer.parseInt(timeArray[1]);\n\t\tif(hour == 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn \"00:00\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn \"12:\" + minute;\n\t\t\t}\n\t\t}\n\t\telse if(hour < 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn hour + \":00\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn hour + \":\" + minute;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(minute == 0){\n\t\t\t\treturn (hour - 12) + \":00\";\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn (hour - 12) + \":\" + minute;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString time = \"00:00\";\n\t\tSystem.out.println(time);\n\t\ttime = \"23:59\";\n\t\tSystem.out.println(time);\n\t\ttime = \"24:00\";\n\t\tSystem.out.println(time);\n\t\ttime = \"00:60\";\n\t\tSystem.out.println(time);\n\t\ttime = \"24:60\";\n\t\tSystem.out.println(time);\n\t\ttime = \"25:00\";\n\t\tSystem.out.println(time);\n\t\ttime = \"25:01\";\n\t\tSystem.out.println(time);\n\t\ttime = \"25:60\";\n\t\tSystem.out.println(time);\n\t\ttime = \"25:61\";\n\t\tSystem.out.println(time);\n\t\ttime = \"26:00\";\n\t\tSystem.out.println(time);\n\t\ttime = \"26:01\";\n\t\tSystem.out.println(time);\n\t\ttime = \"26:60\";\n\t\tSystem.out.println(time);\n\t\ttime = \"26:61\";\n\t\tSystem.out.println(time);\n\t\ttime = \"27:00\";\n\t\tSystem.out.println(time);\n\t\ttime = \"27:01\";\n\t\tSystem.out.println(time);\n\t\ttime = \"27:60\";\n\t\tSystem.out.println(time);\n\t\ttime = \"27:61\";\n\t\tSystem.out.println(time);\n\t\ttime = \"28:00\";\n\t\tSystem.out.println(time);\n\t\ttime = \"28:01\";\n\t\tSystem.out.println(time);\n\t\ttime = \"28:60\";\n\t\tSystem.out.println(time);\n\t\ttime = \"28:61\";\n\t\tSystem.out.println(time);\n\t\ttime = \"29:00\";\n\t\tSystem.out.println(time);\n\t\ttime = \"29:01\";\n\t\tSystem.out.println(time);\n\t\ttime = \"\n",
        "\tstatic String timeConversion(String s) {\n\t\tString[] time = s.split(\":\");\n\t\tString hour = time[0];\n\t\tString minute = time[1];\n\t\tString second = time[2];\n\t\tString ampm = time[2].substring(2);\n\t\tif(ampm.equals(\"AM\")){\n\t\t\tif(hour.equals(\"12\")){\n\t\t\t\treturn \"00:\"+minute+\":\"+second.substring(0,2);\n\t\t\t}\n\t\t\treturn hour+\":\"+minute+\":\"+second.substring(0,2);\n\t\t}\n\t\telse{\n\t\t\tif(hour.equals(\"12\")){\n\t\t\t\treturn \"12:\"+minute+\":\"+second.substring(0,2);\n\t\t\t}\n\t\t\tint h = Integer.parseInt(hour);\n\t\t\th = h+12;\n\t\t\treturn h+\":\"+minute+\":\"+second.substring(0,2);\n\t\t}\n\t}\n}\n",
        "\tstatic String timeConversion(String s) {\n\t\tString[] time = s.split(\":\");\n\t\tString[] time2 = time[2].split(\"\");\n\t\tString[] time3 = time2[2].split(\"\");\n\t\tString[] time4 = time3[2].split(\"\");\n\t\tString[] time5 = time4[2].split(\"\");\n\t\tString[] time6 = time5[2].split(\"\");\n\t\tString[] time7 = time6[2].split(\"\");\n\t\tString[] time8 = time7[2].split(\"\");\n\t\tString[] time9 = time8[2].split(\"\");\n\t\tString[] time10 = time9[2].split(\"\");\n\t\tString[] time11 = time10[2].split(\"\");\n\t\tString[] time12 = time11[2].split(\"\");\n\t\tString[] time13 = time12[2].split(\"\");\n\t\tString[] time14 = time13[2].split(\"\");\n\t\tString[] time15 = time14[2].split(\"\");\n\t\tString[] time16 = time15[2].split(\"\");\n\t\tString[] time17 = time16[2].split(\"\");\n\t\tString[] time18 = time17[2].split(\"\");\n\t\tString[] time19 = time18[2].split(\"\");\n\t\tString[] time20 = time19[2].split(\"\");\n\t\tString[] time21 = time20[2].split(\"\");\n\t\tString[] time22 = time21[2].split(\"\");\n\t\tString[] time23 = time22[2].split(\"\");\n\t\tString[] time24 = time23[2].split(\"\");\n\t\tString[] time25 = time24[2].split(\"\");\n\t\tString[] time26 = time25[2].split(\"\");\n\t\tString[] time27 = time26[2].split(\"\");\n\t\tString[] time28 = time27[2].split(\"\");\n\t\tString[] time29 = time28[2].split(\"\");\n\t\tString[] time30 = time29[2].split(\"\");\n\t\tString[] time31 = time30[2\n",
        "\tstatic String to24Hour(String time){\n\t\tString[] timeArr = time.split(\":\");\n\t\tint hour = Integer.parseInt(timeArr[0]);\n\t\tint minute = Integer.parseInt(timeArr[1]);\n\t\tif(hour == 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn \"00:00\";\n\t\t\t}\n\t\t\treturn \"12:\" + minute;\n\t\t}\n\t\tif(hour < 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn hour + \":00\";\n\t\t\t}\n\t\t\treturn hour + \":\" + minute;\n\t\t}\n\t\tif(hour == 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn \"12:00\";\n\t\t\t}\n\t\t\treturn \"12:\" + minute;\n\t\t}\n\t\tif(hour > 12){\n\t\t\tif(minute == 0){\n\t\t\t\treturn (hour - 12) + \":00\";\n\t\t\t}\n\t\t\treturn (hour - 12) + \":\" + minute;\n\t\t}\n\t\treturn \"\";\n\t}\n}\n",
        "\tstatic String timeConversion(String s) {\n\t\tString[] time = s.split(\":\");\n\t\tString[] time2 = time[2].split(\"\");\n\t\tString ampm = time2[2];\n\t\tString hour = time[0];\n\t\tString minute = time[1];\n\t\tString time3 = \"\";\n\t\tif(ampm.equals(\"PM\")){\n\t\t\tif(hour.equals(\"12\")){\n\t\t\t\ttime3 = hour + \":\" + minute;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint hour2 = Integer.parseInt(hour) + 12;\n\t\t\t\ttime3 = hour2 + \":\" + minute;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(hour.equals(\"12\")){\n\t\t\t\ttime3 = \"00\" + \":\" + minute;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttime3 = hour + \":\" + minute;\n\t\t\t}\n\t\t}\n\t\treturn time3;\n\t}\n}\n",
        "\tstatic String convertTime(int num){\n\t\tString time = \"\";\n\t\tif(num/60 == 0){\n\t\t\ttime = \"00:\";\n\t\t}\n\t\telse{\n\t\t\ttime = (num/60) + \":\";\n\t\t}\n\t\tif(num%60 < 10){\n\t\t\ttime += \"0\" + (num%60);\n\t\t}\n\t\telse{\n\t\t\ttime += (num%60);\n\t\t}\n\t\treturn time;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2175",
    "source": "leetcode",
    "language": "java",
    "query": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color.",
    "snippets": [
        "\tvoid paint(int[][] image, int sr, int sc, int newColor) {\n\t\tif(image == null || image.length == 0 || image[0].length == 0) return;\n\t\tint oldColor = image[sr][sc];\n\t\tif(oldColor == newColor) return;\n\t\tdfs(image, sr, sc, oldColor, newColor);\n\t}\n\tprivate void dfs(int[][] image, int sr, int sc, int oldColor, int newColor){\n\t\tif(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length) return;\n\t\tif(image[sr][sc] != oldColor) return;\n\t\timage[sr][sc] = newColor;\n\t\tdfs(image, sr + 1, sc, oldColor, newColor);\n\t\tdfs(image, sr - 1, sc, oldColor, newColor);\n\t\tdfs(image, sr, sc + 1, oldColor, newColor);\n\t\tdfs(image, sr, sc - 1, oldColor, newColor);\n\t}\n}\n",
        "\tvoid paint(int[][] image, int sr, int sc, int newColor) {\n\t\tif(image == null || image.length == 0 || image[0].length == 0) return;\n\t\tint oldColor = image[sr][sc];\n\t\tif(oldColor == newColor) return;\n\t\thelper(image, sr, sc, oldColor, newColor);\n\t}\n\tprivate void helper(int[][] image, int sr, int sc, int oldColor, int newColor){\n\t\tif(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length) return;\n\t\tif(image[sr][sc] != oldColor) return;\n\t\timage[sr][sc] = newColor;\n\t\thelper(image, sr - 1, sc, oldColor, newColor);\n\t\thelper(image, sr + 1, sc, oldColor, newColor);\n\t\thelper(image, sr, sc - 1, oldColor, newColor);\n\t\thelper(image, sr, sc + 1, oldColor, newColor);\n\t}\n}\n",
        "\tvoid floodFill(int[][] image, int sr, int sc, int newColor) {\n\t\tif(image[sr][sc] == newColor) return;\n\t\tint oldColor = image[sr][sc];\n\t\timage[sr][sc] = newColor;\n\t\tif(sr-1 >= 0 && image[sr-1][sc] == oldColor) floodFill(image, sr-1, sc, newColor);\n\t\tif(sr+1 < image.length && image[sr+1][sc] == oldColor) floodFill(image, sr+1, sc, newColor);\n\t\tif(sc-1 >= 0 && image[sr][sc-1] == oldColor) floodFill(image, sr, sc-1, newColor);\n\t\tif(sc+1 < image[0].length && image[sr][sc+1] == oldColor) floodFill(image, sr, sc+1, newColor);\n\t}\n}\n",
        "\tvoid floodFill(int[][] image, int sr, int sc, int newColor) {\n\t\tif(image[sr][sc] == newColor) return;\n\t\tint oldColor = image[sr][sc];\n\t\timage[sr][sc] = newColor;\n\t\tif(sr > 0 && image[sr-1][sc] == oldColor) floodFill(image, sr-1, sc, newColor);\n\t\tif(sr < image.length-1 && image[sr+1][sc] == oldColor) floodFill(image, sr+1, sc, newColor);\n\t\tif(sc > 0 && image[sr][sc-1] == oldColor) floodFill(image, sr, sc-1, newColor);\n\t\tif(sc < image[0].length-1 && image[sr][sc+1] == oldColor) floodFill(image, sr, sc+1, newColor);\n\t}\n}\n",
        "\tvoid paint(int[][] image, int sr, int sc, int newColor) {\n\t\tint m = image.length;\n\t\tint n = image[0].length;\n\t\tint oldColor = image[sr][sc];\n\t\tif(oldColor == newColor) return;\n\t\tdfs(image, sr, sc, oldColor, newColor);\n\t}\n\tpublic void dfs(int[][] image, int sr, int sc, int oldColor, int newColor){\n\t\tif(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != oldColor) return;\n\t\timage[sr][sc] = newColor;\n\t\tdfs(image, sr - 1, sc, oldColor, newColor);\n\t\tdfs(image, sr + 1, sc, oldColor, newColor);\n\t\tdfs(image, sr, sc - 1, oldColor, newColor);\n\t\tdfs(image, sr, sc + 1, oldColor, newColor);\n\t}\n}\n",
        "\tvoid paint(int[][] image, int sr, int sc, int newColor){\n\t\tint oldColor = image[sr][sc];\n\t\tif(oldColor == newColor) return;\n\t\timage[sr][sc] = newColor;\n\t\tfor(int i = 0; i < image.length; i++){\n\t\t\tfor(int j = 0; j < image[0].length; j++){\n\t\t\t\tif(image[i][j] == oldColor){\n\t\t\t\t\tpaint(image, i, j, newColor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid paint(int[][] image, int sr, int sc, int newColor) {\n\t\tint m = image.length;\n\t\tint n = image[0].length;\n\t\tint oldColor = image[sr][sc];\n\t\tif(oldColor == newColor) return;\n\t\timage[sr][sc] = newColor;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(image[i][j] == oldColor){\n\t\t\t\t\tpaint(image, i, j, newColor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid paint(int[][] image, int sr, int sc, int newColor) {\n\t\tint m = image.length;\n\t\tint n = image[0].length;\n\t\tint oldColor = image[sr][sc];\n\t\tif(oldColor == newColor) return;\n\t\tdfs(image, sr, sc, oldColor, newColor);\n\t}\n\tprivate void dfs(int[][] image, int sr, int sc, int oldColor, int newColor){\n\t\tif(sr < 0 || sr >= image.length || sc < 0 || sc >= image[0].length || image[sr][sc] != oldColor) return;\n\t\timage[sr][sc] = newColor;\n\t\tdfs(image, sr - 1, sc, oldColor, newColor);\n\t\tdfs(image, sr + 1, sc, oldColor, newColor);\n\t\tdfs(image, sr, sc - 1, oldColor, newColor);\n\t\tdfs(image, sr, sc + 1, oldColor, newColor);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2176",
    "source": "leetcode",
    "language": "java",
    "query": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by somenumber of 1's (also possibly none) You can flip s[i] changing it from 0 to 1 or from 1 to 0.",
    "snippets": [
        "\tboolean isMonotone(String s){\n\t\tint i=0;\n\t\tint j=s.length()-1;\n\t\twhile(i<j){\n\t\t\tif(s.charAt(i)=='0'&&s.charAt(j)=='1'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(s.charAt(i)=='1'&&s.charAt(j)=='0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotoneIncreasing(String s){\n\t\tint i=0;\n\t\tint j=s.length()-1;\n\t\twhile(i<j){\n\t\t\tif(s.charAt(i)=='0'&&s.charAt(j)=='1'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(s.charAt(i)=='1'&&s.charAt(j)=='0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotoneIncreasing(String s){\n\t\tint n = s.length();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n && j < n){\n\t\t\tif(s.charAt(i) == '0'){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn j == n;\n\t}\n}\n",
        "\tboolean isMonotoneIncreasing(String s){\n\t\tint n = s.length();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(j < n){\n\t\t\twhile(j < n && s.charAt(j) == '0'){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\twhile(j < n && s.charAt(j) == '1'){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(j < n){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tj = i + 1;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotone(String s){\n\t\tint n = s.length();\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile(i < j){\n\t\t\tif(s.charAt(i) == '0' && s.charAt(j) == '1'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(s.charAt(i) == '1' && s.charAt(j) == '0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotoneIncreasing(String s){\n\t\tint n=s.length();\n\t\tint i=0;\n\t\tint j=0;\n\t\twhile(i<n&&j<n){\n\t\t\tif(s.charAt(i)=='0'){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(i==n){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
        "\tboolean isMonotoneIncreasing(String s){\n\t\tint n = s.length();\n\t\tint i = 0;\n\t\tint j = n-1;\n\t\twhile(i<j){\n\t\t\tif(s.charAt(i)=='0' && s.charAt(j)=='1'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(s.charAt(i)=='1' && s.charAt(j)=='0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotoneIncreasing(String s){\n\t\tint n = s.length();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n && s.charAt(i) == '0'){\n\t\t\ti++;\n\t\t}\n\t\twhile(j < n && s.charAt(j) == '1'){\n\t\t\tj++;\n\t\t}\n\t\tif(i == n || j == n){\n\t\t\treturn true;\n\t\t}\n\t\tif(s.charAt(i) == '1' && s.charAt(j) == '0'){\n\t\t\treturn false;\n\t\t}\n\t\twhile(i < j){\n\t\t\tif(s.charAt(i) == '0' && s.charAt(j) == '1'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isMonotone(String s){\n\t\tint len = s.length();\n\t\tint i = 0;\n\t\twhile(i < len && s.charAt(i) == '0'){\n\t\t\ti++;\n\t\t}\n\t\tif(i == len){\n\t\t\treturn true;\n\t\t}\n\t\tint j = i;\n\t\twhile(j < len && s.charAt(j) == '1'){\n\t\t\tj++;\n\t\t}\n\t\tif(j == len){\n\t\t\treturn true;\n\t\t}\n\t\tif(s.charAt(i) == '1' && s.charAt(j) == '0'){\n\t\t\treturn false;\n\t\t}\n\t\tif(s.charAt(i) == '0' && s.charAt(j) == '1'){\n\t\t\treturn false;\n\t\t}\n\t\tif(s.charAt(i) == '1'){\n\t\t\ti++;\n\t\t}\n\t\tif(s.charAt(j) == '1'){\n\t\t\tj++;\n\t\t}\n\t\twhile(i < j){\n\t\t\tif(s.charAt(i) == '0' && s.charAt(j) == '1'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif(s.charAt(i) == '1' && s.charAt(j) == '0'){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2177",
    "source": "leetcode",
    "language": "java",
    "query": "Given two positive integers n and k, the binary string Sn is formed as follows. It is guaranteed that k is valid for the given n.",
    "snippets": [
        "\tString getString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(k);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString getBinaryString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(k % 2);\n\t\t\tk /= 2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString getBinaryString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n > 0){\n\t\t\tsb.append(n % 2);\n\t\t\tn /= 2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tstatic String getBinaryString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(k % 2);\n\t\t\tk /= 2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tstatic String getBinaryString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsb.append(k);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString getBinaryString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n > 0){\n\t\t\tsb.append(n % 2);\n\t\t\tn /= 2;\n\t\t}\n\t\tString s = sb.reverse().toString();\n\t\treturn s.substring(0, k);\n\t}\n}\n",
        "\tString getBinaryString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n > 0){\n\t\t\tsb.append(n % 2);\n\t\t\tn = n / 2;\n\t\t}\n\t\tString s = sb.reverse().toString();\n\t\tStringBuilder sb2 = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(i < k)\n\t\t\t\tsb2.append(s.charAt(i));\n\t\t\telse\n\t\t\t\tsb2.append(\"0\");\n\t\t}\n\t\treturn sb2.toString();\n\t}\n}\n",
        "\tString getBinaryString(int n, int k){\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(n > 0){\n\t\t\tsb.append(n % 2);\n\t\t\tn = n / 2;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2178",
    "source": "leetcode",
    "language": "java",
    "query": "Given an m x n matrix, return all elements of the matrix in spiral order.",
    "snippets": [
        "\tList<Integer> spiralOrder(int[][] matrix) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0)\n\t\t\treturn res;\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint count = m * n;\n\t\tint i = 0, j = 0;\n\t\tint[][] visited = new int[m][n];\n\t\twhile(count > 0){\n\t\t\twhile(j < n && visited[i][j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i][j] = 1;\n\t\t\t\tj++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tj--;\n\t\t\ti++;\n\t\t\twhile(i < m && visited[i][j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i][j] = 1;\n\t\t\t\ti++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\ti--;\n\t\t\tj--;\n\t\t\twhile(j >= 0 && visited[i][j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i][j] = 1;\n\t\t\t\tj--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tj++;\n\t\t\ti--;\n\t\t\twhile(i >= 0 && visited[i][j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i][j] = 1;\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> spiralOrder(int[][] matrix) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;\n\t\tint row = matrix.length;\n\t\tint col = matrix[0].length;\n\t\tint left = 0;\n\t\tint right = col - 1;\n\t\tint top = 0;\n\t\tint bottom = row - 1;\n\t\twhile(left <= right && top <= bottom){\n\t\t\tfor(int i = left; i <= right; i++){\n\t\t\t\tres.add(matrix[top][i]);\n\t\t\t}\n\t\t\ttop++;\n\t\t\tfor(int i = top; i <= bottom; i++){\n\t\t\t\tres.add(matrix[i][right]);\n\t\t\t}\n\t\t\tright--;\n\t\t\tif(top <= bottom){\n\t\t\t\tfor(int i = right; i >= left; i--){\n\t\t\t\t\tres.add(matrix[bottom][i]);\n\t\t\t\t}\n\t\t\t\tbottom--;\n\t\t\t}\n\t\t\tif(left <= right){\n\t\t\t\tfor(int i = bottom; i >= top; i--){\n\t\t\t\t\tres.add(matrix[i][left]);\n\t\t\t\t}\n\t\t\t\tleft++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> spiralOrder(int[][] matrix) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0) return res;\n\t\tint m = matrix.length, n = matrix[0].length;\n\t\tint[] visited = new int[m*n];\n\t\tint count = 0;\n\t\tint i = 0, j = 0;\n\t\twhile(count < m*n){\n\t\t\twhile(j < n && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tj++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tj--;\n\t\t\ti++;\n\t\t\twhile(i < m && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\ti++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti--;\n\t\t\tj--;\n\t\t\twhile(j >= 0 && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tj--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tj++;\n\t\t\ti--;\n\t\t\twhile(i >= 0 && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\ti--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> spiralOrder(int[][] matrix) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(matrix.length == 0) return res;\n\t\tint m = matrix.length, n = matrix[0].length;\n\t\tint[] visited = new int[m*n];\n\t\tint count = 0;\n\t\tint[] dir = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n\t\tint x = 0, y = 0, d = 0;\n\t\twhile(count < m*n){\n\t\t\tres.add(matrix[x][y]);\n\t\t\tvisited[count] = 1;\n\t\t\tcount++;\n\t\t\tx += dir[d][0];\n\t\t\ty += dir[d][1];\n\t\t\tif(x < 0 || x >= m || y < 0 || y >= n || visited[x*n+y] == 1){\n\t\t\t\tx -= dir[d][0];\n\t\t\t\ty -= dir[d][1];\n\t\t\t\td = (d+1)%4;\n\t\t\t\tx += dir[d][0];\n\t\t\t\ty += dir[d][1];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> spiralOrder(int[][] matrix) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(matrix.length == 0) return res;\n\t\tint m = matrix.length, n = matrix[0].length;\n\t\tint[] visited = new int[m*n];\n\t\tint count = 0;\n\t\tint i = 0, j = 0;\n\t\twhile(count < m*n){\n\t\t\twhile(j < n && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tj++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tj--;\n\t\t\ti++;\n\t\t\twhile(i < m && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\ti++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti--;\n\t\t\tj--;\n\t\t\twhile(j >= 0 && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tj--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tj++;\n\t\t\ti--;\n\t\t\twhile(i >= 0 && visited[i*n+j] == 0){\n\t\t\t\tres.add(matrix[i][j]);\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\ti--;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> spiralOrder(int[][] matrix) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tif(matrix.length == 0) return list;\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint count = m * n;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\twhile(count > 0){\n\t\t\twhile(j < n){\n\t\t\t\tlist.add(matrix[i][j]);\n\t\t\t\tj++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tj--;\n\t\t\ti++;\n\t\t\twhile(i < m){\n\t\t\t\tlist.add(matrix[i][j]);\n\t\t\t\ti++;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\ti--;\n\t\t\tj--;\n\t\t\twhile(j >= l){\n\t\t\t\tlist.add(matrix[i][j]);\n\t\t\t\tj--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\tj++;\n\t\t\ti--;\n\t\t\twhile(i > k){\n\t\t\t\tlist.add(matrix[i][j]);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj++;\n\t\t\tk++;\n\t\t\tl++;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tvoid spiralOrder(int[][] matrix) {\n\t\tif(matrix == null || matrix.length == 0) return;\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[] visited = new int[m*n];\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(count < m*n){\n\t\t\twhile(j < n && visited[i*n+j] == 0){\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tcount++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tj--;\n\t\t\ti++;\n\t\t\twhile(i < m && visited[i*n+j] == 0){\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\ti--;\n\t\t\tj--;\n\t\t\twhile(j >= 0 && visited[i*n+j] == 0){\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tcount++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tj++;\n\t\t\ti--;\n\t\t\twhile(i >= 0 && visited[i*n+j] == 0){\n\t\t\t\tvisited[i*n+j] = 1;\n\t\t\t\tcount++;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor(int k = 0; k < m*n; k++){\n\t\t\tSystem.out.print(matrix[k/n][k%n] + \" \");\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2179",
    "source": "leetcode",
    "language": "java",
    "query": "Formally, a Fibonacci-like sequence is a list f of non-negative integers. Each integer fits in a 32-bit signed integer type. Each piece must not have extra leading zeroes.",
    "snippets": [
        "\tstatic int fib(int n){\n\t\tif(n==0) return 0;\n\t\tif(n==1) return 1;\n\t\treturn fib(n-1)+fib(n-2);\n\t}\n}\n",
        "\tstatic int fib(int n){\n\t\tif(n==0) return 0;\n\t\tif(n==1) return 1;\n\t\treturn fib(n-1)+fib(n-2);\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(fib(10));\n\t}\n}\n",
        "\tint fib(int n){\n\t\tif(n==0) return 0;\n\t\tif(n==1) return 1;\n\t\treturn fib(n-1)+fib(n-2);\n\t}\n}\n",
        "\tstatic int[] fib(int n){\n\t\tint[] fib = new int[n];\n\t\tfib[0] = 0;\n\t\tfib[1] = 1;\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tfib[i] = fib[i-1] + fib[i-2];\n\t\t}\n\t\treturn fib;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] f = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986, 102334155, 165580141, 267914296, 433494437, 701408733, 1134903170, 1836311903, 2971215073, 4807526976, 7778742049, 12586269025, 20365011074, 32951280099, 53316291173, 86267571272, 139583862445, 225851433717, 365435296162, 591286729879, 956722026041, 1548008755931, 2504730781961, 4052739537881, 6557470319842, 10610209857723, 17167680177565, 27777890035288, 44945570212853, 72723460248141, 117669030460994, 190392490709135, 308061521170129, 498454011879264, 806515533049393, 1304969544928657, 2111485077978050, 3416454622906707, 5527939700884757, 8944394323791464, 14472334024676221, 23416728348467685, 37889062373143906, 61305790721611591, 99194853094755497, 160500643816367088, 259695496911122585, 420196140727489673, 679891637638612258, 1100087778366101931, 1779979416004714189, 2880067194370816120, 4660046610375530309\n"
    ],
    "results": 10
},{
    "id": "2180",
    "source": "leetcode",
    "language": "java",
    "query": "The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] c = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] d = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] e = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] f = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] g = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] h = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] i = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] j = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] k = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] l = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] m = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] n = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] o = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] p = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] q = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] r = {1,2,3,\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic\n\tClazz(int a){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m){\n\t\t\n\t}\n\tpublic\n\tClazz(int a, int b, int c, int d, int e, int f, int g, int h, int i\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\ta[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.print(a[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tvoid\n\tmethod(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = b[n-i-1];\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = new int[4];\n\t\ta[0] = 1;\n\t\ta[1] = 2;\n\t\ta[2] = 3;\n\t\ta[3] = 4;\n\t\tint[] b = new int[4];\n\t\tb[0] = 2;\n\t\tb[1] = 3;\n\t\tb[2] = 4;\n\t\tb[3] = 1;\n\t\tSystem.out.println(isEqual(a,b));\n\t}\n\tpublic static boolean isEqual(int[] a, int[] b){\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(a[i] != b[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tvoid\n\tmethod(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = b[n-1-i];\n\t\t}\n\t}\n}\n",
        "\tstatic int[] solution(int[] A, int[] B){\n\t\tint[] C = new int[A.length];\n\t\tfor(int i = 0; i < A.length; i++){\n\t\t\tC[i] = A[i] + B[i];\n\t\t}\n\t\treturn C;\n\t}\n}\n",
        "\tvoid method(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t\tc[i] = a[i];\n\t\t}\n\t\tint[] d = new int[n];\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = a[i];\n\t\t\te[i] = a[i];\n\t\t}\n\t\tint[] f = new int[n];\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = a[i];\n\t\t\tg[i] = a[i];\n\t\t}\n\t\tint[] h = new int[n];\n\t\tint[] i = new int[n];\n\t\tfor(int j = 0; j < n; j++){\n\t\t\th[j] = a[j];\n\t\t\ti[j] = a[j];\n\t\t}\n\t\tint[] j = new int[n];\n\t\tint[] k = new int[n];\n\t\tfor(int l = 0; l < n; l++){\n\t\t\tj[l] = a[l];\n\t\t\tk[l] = a[l];\n\t\t}\n\t\tint[] l = new int[n];\n\t\tint[] m = new int[n];\n\t\tfor(int n1 = 0; n1 < n; n1++){\n\t\t\tl[n1] = a[n1];\n\t\t\tm[n1] = a[n1];\n\t\t}\n\t\tint[] n2 = new int[n];\n\t\tint[] o = new int[n];\n\t\tfor(int p = 0; p < n; p++){\n\t\t\tn2\n"
    ],
    "results": 10
},{
    "id": "2181",
    "source": "leetcode",
    "language": "java",
    "query": "There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.",
    "snippets": [
        "\tint numExchange(int numBottles, int numExchange) {\n\t\tint numFull = numBottles / numExchange;\n\t\tint numEmpty = numBottles % numExchange;\n\t\treturn numFull + numEmpty;\n\t}\n}\n",
        "\tint numExchange(int numBottles, int numExchange) {\n\t\tint numFullBottles = numBottles / numExchange;\n\t\tint numEmptyBottles = numBottles % numExchange;\n\t\treturn numFullBottles + numEmptyBottles;\n\t}\n}\n",
        "\tint numExchange(int numBottles, int numExchange){\n\t\tif(numBottles == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tif(numExchange == 0){\n\t\t\treturn numBottles;\n\t\t}\n\t\tif(numBottles == 1){\n\t\t\treturn 1;\n\t\t}\n\t\tif(numExchange == 1){\n\t\t\treturn numBottles - 1;\n\t\t}\n\t\treturn numBottles + numExchange(numBottles - 1, numExchange - 1);\n\t}\n}\n",
        "\tstatic int numExchange = 3;\n\tstatic int numBottles = 5;\n\tpublic static void main(String[] args){\n\t\tint numBottles = 5;\n\t\tint numExchange = 3;\n\t\tint numBottlesAfterExchange = numBottles - (numBottles/numExchange);\n\t\tSystem.out.println(numBottlesAfterExchange);\n\t}\n}\n",
        "\tint numExchange(int numBottles, int numExchange) {\n\t\tint numFullBottles = numBottles / (numExchange + 1);\n\t\tint numEmptyBottles = numBottles % (numExchange + 1);\n\t\treturn numFullBottles + numEmptyBottles;\n\t}\n}\n",
        "\tint numExchange(int numBottles, int numExchange){\n\t\tint numEmpty = numBottles - 1;\n\t\tint numFull = 1;\n\t\tint numBottlesLeft = numBottles;\n\t\twhile(numBottlesLeft > 0){\n\t\t\tnumBottlesLeft = numEmpty / numExchange;\n\t\t\tnumEmpty = numBottlesLeft * numExchange + numEmpty % numExchange;\n\t\t\tnumFull += numBottlesLeft;\n\t\t}\n\t\treturn numFull;\n\t}\n}\n",
        "\tint numExchange;\n\tint numBottles;\n\tpublic int numExchangeWater(int numBottles, int numExchange){\n\t\tint numBottlesEmpty = numBottles;\n\t\tint numBottlesFull = 0;\n\t\twhile(numBottlesEmpty > 0){\n\t\t\tnumBottlesEmpty = numBottlesEmpty - numExchange;\n\t\t\tnumBottlesFull = numBottlesFull + 1;\n\t\t}\n\t\treturn numBottlesFull;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2182",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s, return true if every 'a' appears before every 'b' in the string. Otherwise, return false.",
    "snippets": [
        "\tboolean isAB(String s){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(s.charAt(i) == 'b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a == b){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean\n\tab(String s){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(s.charAt(i) == 'b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a == b){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean aba(String s){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(s.charAt(i) == 'b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a == b){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean abb(String s){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(s.charAt(i) == 'b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a == b){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean abba(String s) {\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a == b){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
        "\tboolean allAbeforeB(String s){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(s.charAt(i) == 'b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a == b){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean\n\tab(String s){\n\t\tint a=0;\n\t\tint b=0;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(s.charAt(i)=='b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a==b){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
        "\tboolean\n\tab(String s){\n\t\tint a=0,b=0;\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='a'){\n\t\t\t\ta++;\n\t\t\t}\n\t\t\tif(s.charAt(i)=='b'){\n\t\t\t\tb++;\n\t\t\t}\n\t\t}\n\t\tif(a==b){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2183",
    "source": "leetcode",
    "language": "java",
    "query": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time. Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer.",
    "snippets": [
        "\tvoid lemonadeChange(int[] bills){\n\t\tint five = 0;\n\t\tint ten = 0;\n\t\tint twenty = 0;\n\t\tfor(int i = 0; i < bills.length; i++){\n\t\t\tif(bills[i] == 5){\n\t\t\t\tfive++;\n\t\t\t}\n\t\t\telse if(bills[i] == 10){\n\t\t\t\tten++;\n\t\t\t}\n\t\t\telse if(bills[i] == 20){\n\t\t\t\ttwenty++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(five > 0){\n\t\t\t\t\tfive--;\n\t\t\t\t\tbills[i] = 5;\n\t\t\t\t}\n\t\t\t\telse if(ten > 0 && ten > 0){\n\t\t\t\t\tten--;\n\t\t\t\t\tten--;\n\t\t\t\t\tbills[i] = 10;\n\t\t\t\t}\n\t\t\t\telse if(twenty > 0 && twenty > 0){\n\t\t\t\t\ttwenty--;\n\t\t\t\t\ttwenty--;\n\t\t\t\t\tbills[i] = 20;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t\tfor(int i = 0; i < bills.length; i++){\n\t\t\tSystem.out.print(bills[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tvoid lemonadeChange(int[] bills) {\n\t\tint five = 0;\n\t\tint ten = 0;\n\t\tfor (int i = 0; i < bills.length; i++) {\n\t\t\tif (bills[i] == 5) {\n\t\t\t\tfive++;\n\t\t\t} else if (bills[i] == 10) {\n\t\t\t\tif (five > 0) {\n\t\t\t\t\tfive--;\n\t\t\t\t\tten++;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (bills[i] == 20) {\n\t\t\t\tif (five > 0 && ten > 0) {\n\t\t\t\t\tfive--;\n\t\t\t\t\tten--;\n\t\t\t\t} else if (five > 3) {\n\t\t\t\t\tfive -= 3;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n}\n",
        "\tvoid lemonadeChange(int[] bills) {\n\t\tint five = 0;\n\t\tint ten = 0;\n\t\tfor (int i = 0; i < bills.length; i++) {\n\t\t\tif (bills[i] == 5) {\n\t\t\t\tfive++;\n\t\t\t} else if (bills[i] == 10) {\n\t\t\t\tif (five > 0) {\n\t\t\t\t\tfive--;\n\t\t\t\t\tten++;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (bills[i] == 20) {\n\t\t\t\tif (ten > 0 && five > 0) {\n\t\t\t\t\tten--;\n\t\t\t\t\tfive--;\n\t\t\t\t} else if (five >= 3) {\n\t\t\t\t\tfive -= 3;\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n}\n",
        "\tvoid lemonadeChange(int[] bills) {\n\t\tint five = 0;\n\t\tint ten = 0;\n\t\tfor(int i = 0; i < bills.length; i++){\n\t\t\tif(bills[i] == 5){\n\t\t\t\tfive++;\n\t\t\t}\n\t\t\telse if(bills[i] == 10){\n\t\t\t\tif(five > 0){\n\t\t\t\t\tfive--;\n\t\t\t\t\tten++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(bills[i] == 20){\n\t\t\t\tif(five > 0 && ten > 0){\n\t\t\t\t\tfive--;\n\t\t\t\t\tten--;\n\t\t\t\t}\n\t\t\t\telse if(five > 2){\n\t\t\t\t\tfive -= 3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n}\n",
        "\tstatic void lemonadeChange(int[] bills){\n\t\tint five = 0;\n\t\tint ten = 0;\n\t\tint twenty = 0;\n\t\tfor(int i = 0; i < bills.length; i++){\n\t\t\tif(bills[i] == 5){\n\t\t\t\tfive++;\n\t\t\t}\n\t\t\telse if(bills[i] == 10){\n\t\t\t\tten++;\n\t\t\t\tfive--;\n\t\t\t}\n\t\t\telse if(bills[i] == 20){\n\t\t\t\tif(ten > 0){\n\t\t\t\t\tten--;\n\t\t\t\t\tfive--;\n\t\t\t\t}\n\t\t\t\telse if(five >= 3){\n\t\t\t\t\tfive -= 3;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"YES\");\n\t}\n}\n"
    ],
    "results": 8
},{
    "id": "2184",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number.",
    "snippets": [
        "\tint[] sortedSquares(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = nums.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (Math.abs(nums[i]) > Math.abs(nums[j])) {\n\t\t\t\tres[i + j] = nums[i] * nums[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[i + j] = nums[j] * nums[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortedSquares(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = nums.length - 1;\n\t\twhile(i <= j){\n\t\t\tif(nums[i] * nums[i] > nums[j] * nums[j]){\n\t\t\t\tres[i + j] = nums[i] * nums[i];\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tres[i + j] = nums[j] * nums[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortedSquares(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\tint k = nums.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (nums[i] * nums[i] > nums[j] * nums[j]) {\n\t\t\t\tres[k] = nums[i] * nums[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[k] = nums[j] * nums[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortedSquares(int[] nums) {\n\t\tint[] result = new int[nums.length];\n\t\tint i = 0, j = nums.length - 1;\n\t\twhile(i <= j){\n\t\t\tif(Math.abs(nums[i]) > Math.abs(nums[j])){\n\t\t\t\tresult[i] = nums[i] * nums[i];\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tresult[j] = nums[j] * nums[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sortedSquares(int[] nums) {\n\t\tint[] result = new int[nums.length];\n\t\tint i = 0, j = nums.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (nums[i] * nums[i] > nums[j] * nums[j]) {\n\t\t\t\tresult[i + j] = nums[i] * nums[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tresult[i + j] = nums[j] * nums[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sortedSquares(int[] A) {\n\t\tint[] res = new int[A.length];\n\t\tint i = 0, j = A.length - 1;\n\t\tint k = A.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (Math.abs(A[i]) > Math.abs(A[j])) {\n\t\t\t\tres[k] = A[i] * A[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[k] = A[j] * A[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortedSquares(int[] A) {\n\t\tint[] res = new int[A.length];\n\t\tint i = 0, j = A.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (Math.abs(A[i]) > Math.abs(A[j])) {\n\t\t\t\tres[i + j] = A[i] * A[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[i + j] = A[j] * A[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortedSquares(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = nums.length - 1;\n\t\tint k = nums.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (Math.abs(nums[i]) > Math.abs(nums[j])) {\n\t\t\t\tres[k] = nums[i] * nums[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[k] = nums[j] * nums[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2185",
    "source": "leetcode",
    "language": "java",
    "query": "The score of nums is the difference between the maximum and minimum elements in nums. You are given an integer array nums and an integer k. You can apply this operation at most once for each index i.",
    "snippets": [
        "\tint score(int[] nums, int k){\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i >= k){\n\t\t\t\tmax = Math.max(max, nums[i - k]);\n\t\t\t\tmin = Math.min(min, nums[i - k]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn max - min;\n\t}\n}\n",
        "\tint score(int[] nums, int k){\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t}\n\t\t\tif(nums[i] < min){\n\t\t\t\tmin = nums[i];\n\t\t\t}\n\t\t}\n\t\treturn max - min;\n\t}\n}\n",
        "\tint score(int[] nums, int k){\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t}\n\t\t\tif(nums[i] < min){\n\t\t\t\tmin = nums[i];\n\t\t\t}\n\t\t}\n\t\treturn max - min;\n\t}\n}\n",
        "\tint scoreOfNums(int[] nums, int k){\n\t\tint max = Integer.MIN_VALUE;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i >= k){\n\t\t\t\tmax = Math.max(max, nums[i - k]);\n\t\t\t\tmin = Math.min(min, nums[i - k]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t}\n\t\t}\n\t\treturn max - min;\n\t}\n}\n",
        "\tint score(int[] nums, int k){\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t}\n\t\treturn max - min;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2186",
    "source": "leetcode",
    "language": "java",
    "query": "The Tribonacci sequence Tn is defined as follows:  T0 = 0, T1 = 1, T2 = 1. Tn+3 = Tn + Tn-1 + TN-2 for n >= 0.",
    "snippets": [
        "\tstatic int tribonacci(int n) {\n\t\tif(n==0) return 0;\n\t\tif(n==1) return 1;\n\t\tif(n==2) return 1;\n\t\tint[] arr = new int[n+1];\n\t\tarr[0] = 0;\n\t\tarr[1] = 1;\n\t\tarr[2] = 1;\n\t\tfor(int i=3;i<=n;i++){\n\t\t\tarr[i] = arr[i-1] + arr[i-2] + arr[i-3];\n\t\t}\n\t\treturn arr[n];\n\t}\n}\n",
        "\tstatic int tribonacci(int n) {\n\t\tif(n == 0) return 0;\n\t\tif(n == 1) return 1;\n\t\tif(n == 2) return 1;\n\t\treturn tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\n\t}\n}\n",
        "\tint tribonacci(int n) {\n\t\tif(n == 0) return 0;\n\t\tif(n == 1) return 1;\n\t\tif(n == 2) return 1;\n\t\tint[] arr = new int[n+1];\n\t\tarr[0] = 0;\n\t\tarr[1] = 1;\n\t\tarr[2] = 1;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tarr[i] = arr[i-1] + arr[i-2] + arr[i-3];\n\t\t}\n\t\treturn arr[n];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2187",
    "source": "leetcode",
    "language": "java",
    "query": "A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Given a string s and an array of strings words, return the number of words[i] that is a subsequences of s.",
    "snippets": [
        "\tint countSubsequences(String s, String[] words) {\n\t\tint count = 0;\n\t\tfor (String word : words) {\n\t\t\tif (isSubsequence(s, word)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isSubsequence(String s, String word) {\n\t\tint i = 0, j = 0;\n\t\twhile (i < s.length() && j < word.length()) {\n\t\t\tif (s.charAt(i) == word.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn j == word.length();\n\t}\n}\n",
        "\tint countSubsequences(String s, String[] words) {\n\t\tint count = 0;\n\t\tfor (String word : words) {\n\t\t\tif (isSubsequence(s, word)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic boolean isSubsequence(String s, String t) {\n\t\tint m = s.length();\n\t\tint n = t.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == t.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn i == m;\n\t}\n}\n",
        "\tint countSubsequences(String s, String[] words) {\n\t\tint count = 0;\n\t\tfor (String word : words) {\n\t\t\tif (s.contains(word)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint count(String s, String[] words) {\n\t\tint count = 0;\n\t\tfor(String word : words){\n\t\t\tif(s.contains(word)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSubsequences(String s, String[] words) {\n\t\tint res = 0;\n\t\tfor (String word : words) {\n\t\t\tif (isSubsequence(s, word))\n\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isSubsequence(String s, String t) {\n\t\tint m = s.length(), n = t.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == t.charAt(j))\n\t\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\treturn i == m;\n\t}\n}\n",
        "\tint countSubsequences(String s, String[] words) {\n\t\tint res = 0;\n\t\tfor (String word : words) {\n\t\t\tif (isSubsequence(s, word)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isSubsequence(String s, String word) {\n\t\tint m = s.length(), n = word.length();\n\t\tint i = 0, j = 0;\n\t\twhile (i < m && j < n) {\n\t\t\tif (s.charAt(i) == word.charAt(j)) {\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn j == n;\n\t}\n}\n",
        "\tint count(String s, String[] words) {\n\t\tint count = 0;\n\t\tfor (String word : words) {\n\t\t\tif (s.indexOf(word) != -1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numMatchingSubseq(String S, String[] words) {\n\t\tint count = 0;\n\t\tfor(String word:words){\n\t\t\tif(isSubsequence(S, word)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isSubsequence(String S, String word){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i<S.length() && j<word.length()){\n\t\t\tif(S.charAt(i) == word.charAt(j)){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn j == word.length();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2188",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down.",
    "snippets": [
        "\tint percentage(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count * 100 / s.length();\n\t}\n}\n",
        "\tint getPercentage(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count * 100 / s.length();\n\t}\n}\n",
        "\tint percentage(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn (count * 100) / s.length();\n\t}\n}\n",
        "\tstatic int count(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic static void main(String[] args){\n\t\tString s = \"Hello World\";\n\t\tchar letter = 'o';\n\t\tSystem.out.println(count(s, letter));\n\t}\n}\n",
        "\tstatic int count(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tstatic int percentage(String s, char letter){\n\t\tint count = count(s, letter);\n\t\treturn (count * 100) / s.length();\n\t}\n}\n",
        "\tint count(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tint percentage(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn (count * 100) / s.length();\n\t}\n}\n",
        "\tint count(String s, char letter){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == letter){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tint percentage(String s, char letter){\n\t\tint count = count(s, letter);\n\t\treturn (count * 100) / s.length();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2189",
    "source": "leetcode",
    "language": "java",
    "query": "A substring is a contiguous sequence of characters in a string. You are given a string s that consists of only digits. Check if we can split s into two or more non-empty substrings such that the numerical values of the substrings are in descending order.",
    "snippets": [
        "\tstatic boolean isSubstring(String s){\n\t\tif(s.length()<2) return false;\n\t\tint[] arr = new int[s.length()];\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tarr[i] = s.charAt(i)-'0';\n\t\t}\n\t\tfor(int i=0;i<s.length()-1;i++){\n\t\t\tif(arr[i]<arr[i+1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void main(String[] args){\n\t\tString s = \"12345\";\n\t\tSystem.out.println(isSubstring(s));\n\t}\n}\n",
        "\tstatic boolean check(String s){\n\t\tif(s.length()<2) return false;\n\t\tint i=0;\n\t\tint j=s.length()-1;\n\t\twhile(i<j){\n\t\t\tif(s.charAt(i)<s.charAt(j)){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn i==j;\n\t}\n}\n",
        "\tstatic boolean check(String s){\n\t\tint n = s.length();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = s.charAt(i) - '0';\n\t\t}\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile(i < j){\n\t\t\tif(arr[i] < arr[j]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif(i == j){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
        "\tstatic boolean check(String s){\n\t\tint n = s.length();\n\t\tint[] arr = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tarr[i] = s.charAt(i) - '0';\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(arr[i] < arr[j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean check(String s){\n\t\tint n = s.length();\n\t\tint[] nums = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnums[i] = s.charAt(i) - '0';\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(nums[i] < nums[j]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean check(String s){\n\t\tint n = s.length();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(s.charAt(i) < s.charAt(j)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isSubstring(String s){\n\t\tint n = s.length();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = i+1; j < n; j++){\n\t\t\t\tif(s.charAt(i) > s.charAt(j)){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void main(String[] args){\n\t\tString s = \"12345\";\n\t\tSystem.out.println(isSubstring(s));\n\t}\n}\n",
        "\tstatic boolean check(String s){\n\t\tint len = s.length();\n\t\tif(len<2) return false;\n\t\tint[] nums = new int[len];\n\t\tfor(int i=0;i<len;i++){\n\t\t\tnums[i] = s.charAt(i)-'0';\n\t\t}\n\t\tint max = nums[0];\n\t\tfor(int i=1;i<len;i++){\n\t\t\tif(nums[i]>max) max = nums[i];\n\t\t}\n\t\tint[] dp = new int[len];\n\t\tdp[0] = nums[0];\n\t\tfor(int i=1;i<len;i++){\n\t\t\tdp[i] = Math.max(dp[i-1],nums[i]);\n\t\t}\n\t\tfor(int i=0;i<len;i++){\n\t\t\tif(dp[i]==max) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isSubstring(String s){\n\t\tif(s.length()<2) return false;\n\t\tint i=0;\n\t\tint j=s.length()-1;\n\t\twhile(i<j){\n\t\t\tif(s.charAt(i)<s.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void main(String[] args){\n\t\tString s=\"123456789\";\n\t\tSystem.out.println(isSubstring(s));\n\t}\n}\n",
        "\tstatic boolean isSubstring(String s){\n\t\tint len = s.length();\n\t\tif(len<=1) return false;\n\t\tint[] arr = new int[len];\n\t\tfor(int i=0;i<len;i++){\n\t\t\tarr[i] = s.charAt(i)-'0';\n\t\t}\n\t\tfor(int i=0;i<len-1;i++){\n\t\t\tif(arr[i]<arr[i+1]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static void main(String[] args){\n\t\tString s = \"12345\";\n\t\tSystem.out.println(isSubstring(s));\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2190",
    "source": "leetcode",
    "language": "java",
    "query": "Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.",
    "snippets": [
        "\tListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tif(l1 == null) return l2;\n\t\tif(l2 == null) return l1;\n\t\tListNode head = null;\n\t\tif(l1.val < l2.val){\n\t\t\thead = l1;\n\t\t\tl1 = l1.next;\n\t\t}else{\n\t\t\thead = l2;\n\t\t\tl2 = l2.next;\n\t\t}\n\t\tListNode cur = head;\n\t\twhile(l1 != null && l2 != null){\n\t\t\tif(l1.val < l2.val){\n\t\t\t\tcur.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}else{\n\t\t\t\tcur.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif(l1 == null){\n\t\t\tcur.next = l2;\n\t\t}else{\n\t\t\tcur.next = l1;\n\t\t}\n\t\treturn head;\n\t}\n}\n",
        "\tListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tListNode head = new ListNode(0);\n\t\tListNode cur = head;\n\t\twhile(l1 != null && l2 != null){\n\t\t\tif(l1.val < l2.val){\n\t\t\t\tcur.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}else{\n\t\t\t\tcur.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif(l1 != null){\n\t\t\tcur.next = l1;\n\t\t}\n\t\tif(l2 != null){\n\t\t\tcur.next = l2;\n\t\t}\n\t\treturn head.next;\n\t}\n}\n",
        "\tListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tListNode dummy = new ListNode(0);\n\t\tListNode cur = dummy;\n\t\twhile(l1 != null && l2 != null){\n\t\t\tif(l1.val < l2.val){\n\t\t\t\tcur.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}else{\n\t\t\t\tcur.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif(l1 != null){\n\t\t\tcur.next = l1;\n\t\t}\n\t\tif(l2 != null){\n\t\t\tcur.next = l2;\n\t\t}\n\t\treturn dummy.next;\n\t}\n}\n",
        "\tListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tListNode head = new ListNode(0);\n\t\tListNode p = head;\n\t\twhile(l1 != null && l2 != null){\n\t\t\tif(l1.val < l2.val){\n\t\t\t\tp.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}else{\n\t\t\t\tp.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t\tp = p.next;\n\t\t}\n\t\tif(l1 != null){\n\t\t\tp.next = l1;\n\t\t}\n\t\tif(l2 != null){\n\t\t\tp.next = l2;\n\t\t}\n\t\treturn head.next;\n\t}\n}\n",
        "\tNode mergeTwoLists(Node l1, Node l2) {\n\t\tif(l1 == null) return l2;\n\t\tif(l2 == null) return l1;\n\t\tNode head = null;\n\t\tif(l1.val < l2.val){\n\t\t\thead = l1;\n\t\t\tl1 = l1.next;\n\t\t}else{\n\t\t\thead = l2;\n\t\t\tl2 = l2.next;\n\t\t}\n\t\tNode cur = head;\n\t\twhile(l1 != null && l2 != null){\n\t\t\tif(l1.val < l2.val){\n\t\t\t\tcur.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}else{\n\t\t\t\tcur.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif(l1 != null){\n\t\t\tcur.next = l1;\n\t\t}\n\t\tif(l2 != null){\n\t\t\tcur.next = l2;\n\t\t}\n\t\treturn head;\n\t}\n}\n",
        "\tNode mergeTwoLists(Node l1, Node l2) {\n\t\tif(l1 == null) return l2;\n\t\tif(l2 == null) return l1;\n\t\tNode head = null;\n\t\tif(l1.val < l2.val){\n\t\t\thead = l1;\n\t\t\tl1 = l1.next;\n\t\t}else{\n\t\t\thead = l2;\n\t\t\tl2 = l2.next;\n\t\t}\n\t\tNode cur = head;\n\t\twhile(l1 != null && l2 != null){\n\t\t\tif(l1.val < l2.val){\n\t\t\t\tcur.next = l1;\n\t\t\t\tl1 = l1.next;\n\t\t\t}else{\n\t\t\t\tcur.next = l2;\n\t\t\t\tl2 = l2.next;\n\t\t\t}\n\t\t\tcur = cur.next;\n\t\t}\n\t\tif(l1 == null){\n\t\t\tcur.next = l2;\n\t\t}else{\n\t\t\tcur.next = l1;\n\t\t}\n\t\treturn head;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2191",
    "source": "leetcode",
    "language": "java",
    "query": "A word is a maximal substring consisting of non-space characters only. Given a string s consisting of words and spaces, return the length of the last word in the string.",
    "snippets": [
        "\tint lengthOfLastWord(String s) {\n\t\tint len = s.length();\n\t\tint i = len - 1;\n\t\twhile (i >= 0 && s.charAt(i) == ' ') {\n\t\t\ti--;\n\t\t}\n\t\tint j = i;\n\t\twhile (j >= 0 && s.charAt(j) != ' ') {\n\t\t\tj--;\n\t\t}\n\t\treturn i - j;\n\t}\n}\n",
        "\tint lengthOfLastWord(String s) {\n\t\tint len = 0;\n\t\tint i = s.length() - 1;\n\t\twhile (i >= 0 && s.charAt(i) == ' ') {\n\t\t\ti--;\n\t\t}\n\t\twhile (i >= 0 && s.charAt(i) != ' ') {\n\t\t\ti--;\n\t\t\tlen++;\n\t\t}\n\t\treturn len;\n\t}\n}\n",
        "\tint lengthOfLastWord(String s) {\n\t\tint lastWordLength = 0;\n\t\tint wordLength = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) != ' ') {\n\t\t\t\twordLength++;\n\t\t\t} else {\n\t\t\t\tlastWordLength = wordLength;\n\t\t\t\twordLength = 0;\n\t\t\t}\n\t\t}\n\t\treturn wordLength > 0 ? wordLength : lastWordLength;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2192",
    "source": "leetcode",
    "language": "java",
    "query": "implement pow(x, n), which calculates x raised to the power n (i.e., xn).",
    "snippets": [
        "\tstatic double pow(double x, int n){\n\t\tif(n == 0)\n\t\t\treturn 1;\n\t\tif(n == 1)\n\t\t\treturn x;\n\t\tif(n < 0)\n\t\t\treturn 1/pow(x, -n);\n\t\tdouble half = pow(x, n/2);\n\t\tif(n % 2 == 0)\n\t\t\treturn half * half;\n\t\telse\n\t\t\treturn half * half * x;\n\t}\n}\n",
        "\tstatic double pow(double x, int n){\n\t\tif(n == 0)\n\t\t\treturn 1;\n\t\tif(n == 1)\n\t\t\treturn x;\n\t\tif(n < 0)\n\t\t\treturn 1/pow(x, -n);\n\t\tif(n % 2 == 0)\n\t\t\treturn pow(x*x, n/2);\n\t\telse\n\t\t\treturn x*pow(x*x, n/2);\n\t}\n}\n",
        "\tdouble myPow(double x, int n) {\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return x;\n\t\tif(n < 0) return 1 / myPow(x, -n);\n\t\tif(n % 2 == 0) return myPow(x * x, n / 2);\n\t\treturn x * myPow(x * x, n / 2);\n\t}\n}\n",
        "\tdouble myPow(double x, int n) {\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return x;\n\t\tif(n < 0) return 1/myPow(x, -n);\n\t\tdouble half = myPow(x, n/2);\n\t\tif(n % 2 == 0) return half * half;\n\t\telse return half * half * x;\n\t}\n}\n",
        "\tdouble myPow(double x, int n) {\n\t\tif(n == 0) return 1;\n\t\tif(n == 1) return x;\n\t\tif(n == -1) return 1/x;\n\t\tif(n < 0) return 1/myPow(x, -n);\n\t\tif(n % 2 == 0) return myPow(x*x, n/2);\n\t\treturn x*myPow(x, n-1);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2193",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order.",
    "snippets": [
        "\tstatic String order(String s){\n\t\tchar[] c = s.toCharArray();\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\ta[c[i] - '0']++;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\twhile(a[i] > 0){\n\t\t\t\tsb.append((char)(i + '0'));\n\t\t\t\ta[i]--;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic String order(String s){\n\t\tchar[] c = s.toCharArray();\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\ta[c[i]-'0']++;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < a[i]; j++){\n\t\t\t\tsb.append(i);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic String order(String s){\n\t\tchar[] c = s.toCharArray();\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\ta[c[i] - '0']++;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\twhile(a[i] > 0){\n\t\t\t\tsb.append(i);\n\t\t\t\ta[i]--;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString order(String s){\n\t\tchar[] c = s.toCharArray();\n\t\tint[] a = new int[10];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\ta[c[i] - '0']++;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\twhile(a[i] > 0){\n\t\t\t\tsb.append(i);\n\t\t\t\ta[i]--;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tstatic String sort(String s){\n\t\tchar[] chars = s.toCharArray();\n\t\tArrays.sort(chars);\n\t\treturn new String(chars);\n\t}\n}\n",
        "\tstatic String order(String s){\n\t\tchar[] c = s.toCharArray();\n\t\tint[] a = new int[c.length];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\ta[i] = c[i] - '0';\n\t\t}\n\t\tint[] b = new int[c.length];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tfor(int j = 0; j < c.length; j++){\n\t\t\t\tif(a[i] > a[j]){\n\t\t\t\t\tint temp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tString result = \"\";\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tresult += a[i];\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tString sortString(String s){\n\t\tchar[] chars = s.toCharArray();\n\t\tArrays.sort(chars);\n\t\treturn new String(chars);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2194",
    "source": "leetcode",
    "language": "java",
    "query": "A subarray of an array is a consecutive sequence of zero or more values taken out of that array. Find the maximum length of a subarray where the product of all its elements is positive.",
    "snippets": [
        "\tint maxSubArrayLen(int[] nums, int k) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tdp[i] = dp[i - 1] > 0 ? dp[i - 1] * nums[i] : nums[i];\n\t\t\tif (dp[i] == k) {\n\t\t\t\tmax = i + 1;\n\t\t\t}\n\t\t\tif (dp[i] >= k) {\n\t\t\t\tsum = dp[i];\n\t\t\t\tfor (int j = i - 1; j >= 0; j--) {\n\t\t\t\t\tif (dp[j] > 0) {\n\t\t\t\t\t\tsum = dp[j] * nums[i];\n\t\t\t\t\t\tif (sum == k) {\n\t\t\t\t\t\t\tmax = i - j + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxSubArrayLen(int[] nums, int k) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tdp[i] = dp[i - 1] > 0 ? dp[i - 1] * nums[i] : nums[i];\n\t\t\tif (dp[i] == k) {\n\t\t\t\tmax = i + 1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tsum = dp[j] - dp[i];\n\t\t\t\tif (sum == k) {\n\t\t\t\t\tmax = Math.max(max, j - i + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxLength(int[] arr){\n\t\tint max=0;\n\t\tint[] dp=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tdp[i]=1;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(arr[i]>0 && arr[j]>0){\n\t\t\t\t\tdp[i]=Math.max(dp[i],dp[j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax=Math.max(max,dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxSubArrayLen(int[] nums, int k) {\n\t\tint max = 0;\n\t\tint sum = 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tdp[i] = dp[i - 1] > 0 ? dp[i - 1] * nums[i] : nums[i];\n\t\t\tif (dp[i] == k) {\n\t\t\t\tmax = i + 1;\n\t\t\t}\n\t\t\tif (dp[i] >= k) {\n\t\t\t\tsum = dp[i];\n\t\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\t\tsum *= nums[j];\n\t\t\t\t\tif (sum == k) {\n\t\t\t\t\t\tmax = j + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxProduct(int[] nums) {\n\t\tint max = nums[0];\n\t\tint min = nums[0];\n\t\tint res = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint temp = max;\n\t\t\tmax = Math.max(Math.max(max*nums[i], min*nums[i]), nums[i]);\n\t\t\tmin = Math.min(Math.min(temp*nums[i], min*nums[i]), nums[i]);\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int maxSubArray(int[] a){\n\t\tint max=0;\n\t\tint sum=0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(sum<0)\n\t\t\t\tsum=a[i];\n\t\t\telse\n\t\t\t\tsum+=a[i];\n\t\t\tif(sum>max)\n\t\t\t\tmax=sum;\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static void main(String[] args){\n\t\tint[] a={-2,1,-3,4,-1,2,1,-5,4};\n\t\tSystem.out.println(maxSubArray(a));\n\t}\n}\n",
        "\tint maxLen(int[] arr){\n\t\tint max=0;\n\t\tint[] dp=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++){\n\t\t\tdp[i]=1;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(arr[i]>0 && arr[j]>0){\n\t\t\t\t\tdp[i]=Math.max(dp[i],dp[j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax=Math.max(max,dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic int maxSubArray(int[] a){\n\t\tint max=a[0];\n\t\tint sum=0;\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tif(sum<0)\n\t\t\t\tsum=a[i];\n\t\t\telse\n\t\t\t\tsum+=a[i];\n\t\t\tif(sum>max)\n\t\t\t\tmax=sum;\n\t\t}\n\t\treturn max;\n\t}\n\tpublic static void main(String[] args){\n\t\tint[] a={-2,1,-3,4,-1,2,1,-5,4};\n\t\tSystem.out.println(maxSubArray(a));\n\t}\n}\n",
        "\tint maxSubarrayProduct(int[] a){\n\t\tint max_so_far = 1;\n\t\tint max_ending_here = 1;\n\t\tint min_ending_here = 1;\n\t\tint n = a.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(a[i] > 0){\n\t\t\t\tmax_ending_here *= a[i];\n\t\t\t\tmin_ending_here *= a[i];\n\t\t\t}\n\t\t\telse if(a[i] == 0){\n\t\t\t\tmax_ending_here = 1;\n\t\t\t\tmin_ending_here = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint temp = max_ending_here;\n\t\t\t\tmax_ending_here = Math.max(min_ending_here * a[i], 1);\n\t\t\t\tmin_ending_here = Math.min(temp * a[i], 1);\n\t\t\t}\n\t\t\tmax_so_far = Math.max(max_so_far, max_ending_here);\n\t\t}\n\t\treturn max_so_far;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2195",
    "source": "leetcode",
    "language": "java",
    "query": "Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tNaryTree tree = new NaryTree();\n\t\ttree.add(1);\n\t\ttree.add(2);\n\t\ttree.add(3);\n\t\ttree.add(4);\n\t\ttree.add(5);\n\t\ttree.add(6);\n\t\ttree.add(7);\n\t\ttree.add(8);\n\t\ttree.add(9);\n\t\ttree.add(10);\n\t\ttree.add(11);\n\t\ttree.add(12);\n\t\ttree.add(13);\n\t\ttree.add(14);\n\t\ttree.add(15);\n\t\ttree.add(16);\n\t\ttree.add(17);\n\t\ttree.add(18);\n\t\ttree.add(19);\n\t\ttree.add(20);\n\t\ttree.add(21);\n\t\ttree.add(22);\n\t\ttree.add(23);\n\t\ttree.add(24);\n\t\ttree.add(25);\n\t\ttree.add(26);\n\t\ttree.add(27);\n\t\ttree.add(28);\n\t\ttree.add(29);\n\t\ttree.add(30);\n\t\ttree.add(31);\n\t\ttree.add(32);\n\t\ttree.add(33);\n\t\ttree.add(34);\n\t\ttree.add(35);\n\t\ttree.add(36);\n\t\ttree.add(37);\n\t\ttree.add(38);\n\t\ttree.add(39);\n\t\ttree.add(40);\n\t\ttree.add(41);\n\t\ttree.add(42);\n\t\ttree.add(43);\n\t\ttree.add(44);\n\t\ttree.add(45);\n\t\ttree.add(46);\n\t\ttree.add(47);\n\t\ttree.add(48);\n\t\ttree.add(49);\n\t\ttree.add(50);\n\t\ttree.add(51);\n\t\ttree.add(52);\n\t\ttree.add(53);\n",
        "\tstatic void main(String[] args){\n\t\tNode root = new Node(1);\n\t\troot.left = new Node(2);\n\t\troot.right = new Node(3);\n\t\troot.left.left = new Node(4);\n\t\troot.left.right = new Node(5);\n\t\troot.right.left = new Node(6);\n\t\troot.right.right = new Node(7);\n\t\troot.left.left.left = new Node(8);\n\t\troot.left.left.right = new Node(9);\n\t\troot.left.right.left = new Node(10);\n\t\troot.left.right.right = new Node(11);\n\t\troot.right.left.left = new Node(12);\n\t\troot.right.left.right = new Node(13);\n\t\troot.right.right.left = new Node(14);\n\t\troot.right.right.right = new Node(15);\n\t\troot.left.left.left.left = new Node(16);\n\t\troot.left.left.left.right = new Node(17);\n\t\troot.left.left.right.left = new Node(18);\n\t\troot.left.left.right.right = new Node(19);\n\t\troot.left.right.left.left = new Node(20);\n\t\troot.left.right.left.right = new Node(21);\n\t\troot.left.right.right.left = new Node(22);\n\t\troot.left.right.right.right = new Node(23);\n\t\troot.right.left.left.left = new Node(24);\n\t\troot.right.left.left.right = new Node(25);\n\t\troot.right.left.right.left = new Node(26);\n\t\troot.right.left.right.right = new Node(27);\n\t\troot.right.right.left.left = new Node(28);\n\t\troot.right.right.left.right = new Node(29);\n\t\troot.right.right.right.left = new Node(30);\n",
        "\tstatic void main(String[] args){\n\t\tNaryTreeNode root = new NaryTreeNode(1);\n\t\troot.addChild(new NaryTreeNode(2));\n\t\troot.addChild(new NaryTreeNode(3));\n\t\troot.addChild(new NaryTreeNode(4));\n\t\troot.addChild(new NaryTreeNode(5));\n\t\troot.addChild(new NaryTreeNode(6));\n\t\troot.addChild(new NaryTreeNode(7));\n\t\troot.addChild(new NaryTreeNode(8));\n\t\troot.addChild(new NaryTreeNode(9));\n\t\troot.addChild(new NaryTreeNode(10));\n\t\troot.addChild(new NaryTreeNode(11));\n\t\troot.addChild(new NaryTreeNode(12));\n\t\troot.addChild(new NaryTreeNode(13));\n\t\troot.addChild(new NaryTreeNode(14));\n\t\troot.addChild(new NaryTreeNode(15));\n\t\troot.addChild(new NaryTreeNode(16));\n\t\troot.addChild(new NaryTreeNode(17));\n\t\troot.addChild(new NaryTreeNode(18));\n\t\troot.addChild(new NaryTreeNode(19));\n\t\troot.addChild(new NaryTreeNode(20));\n\t\troot.addChild(new NaryTreeNode(21));\n\t\troot.addChild(new NaryTreeNode(22));\n\t\troot.addChild(new NaryTreeNode(23));\n\t\troot.addChild(new NaryTreeNode(24));\n\t\troot.addChild(new NaryTreeNode(25));\n\t\troot.addChild(new NaryTreeNode(26));\n\t\troot.addChild(new NaryTreeNode(27));\n\t\troot.addChild(new NaryTreeNode(28));\n\t\troot.addChild(new NaryTreeNode(29));\n\t\troot.addChild(new NaryTreeNode(30));\n\t\troot.addChild(new\n",
        "\tstatic void main(String[] args){\n\t\tNaryTreeNode root = new NaryTreeNode(1);\n\t\troot.addChild(2);\n\t\troot.addChild(3);\n\t\troot.addChild(4);\n\t\troot.addChild(5);\n\t\troot.addChild(6);\n\t\troot.addChild(7);\n\t\troot.addChild(8);\n\t\troot.addChild(9);\n\t\troot.addChild(10);\n\t\troot.addChild(11);\n\t\troot.addChild(12);\n\t\troot.addChild(13);\n\t\troot.addChild(14);\n\t\troot.addChild(15);\n\t\troot.addChild(16);\n\t\troot.addChild(17);\n\t\troot.addChild(18);\n\t\troot.addChild(19);\n\t\troot.addChild(20);\n\t\troot.addChild(21);\n\t\troot.addChild(22);\n\t\troot.addChild(23);\n\t\troot.addChild(24);\n\t\troot.addChild(25);\n\t\troot.addChild(26);\n\t\troot.addChild(27);\n\t\troot.addChild(28);\n\t\troot.addChild(29);\n\t\troot.addChild(30);\n\t\troot.addChild(31);\n\t\troot.addChild(32);\n\t\troot.addChild(33);\n\t\troot.addChild(34);\n\t\troot.addChild(35);\n\t\troot.addChild(36);\n\t\troot.addChild(37);\n\t\troot.addChild(38);\n\t\troot.addChild(39);\n\t\troot.addChild(40);\n\t\troot.addChild(41);\n\t\troot.addChild(42);\n\t\troot.addChild(43);\n\t\troot.addChild(44);\n\t\troot.addChild(45);\n\t\troot.addChild(46);\n\t\troot.addChild(47);\n\t\troot.addChild(48);\n",
        "\tstatic class Node{\n\t\tint data;\n\t\tNode left;\n\t\tNode right;\n\t\tNode(int data){\n\t\t\tthis.data=data;\n\t\t}\n\t}\n\tpublic static Node createNaryTree(int[] arr,int i){\n\t\tif(i>=arr.length||arr[i]==-1)\n\t\t\treturn null;\n\t\tNode root=new Node(arr[i]);\n\t\troot.left=createNaryTree(arr,2*i+1);\n\t\troot.right=createNaryTree(arr,2*i+2);\n\t\treturn root;\n\t}\n\tpublic static void printNaryTree(Node root){\n\t\tif(root==null)\n\t\t\treturn;\n\t\tSystem.out.print(root.data+\" \");\n\t\tprintNaryTree(root.left);\n\t\tprintNaryTree(root.right);\n\t}\n\tpublic static void main(String[] args){\n\t\tint[] arr={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,\n",
        "\tstatic void main(String[] args){\n\t\tNaryTree tree = new NaryTree();\n\t\ttree.root = new Node(1);\n\t\ttree.root.children.add(new Node(2));\n\t\ttree.root.children.add(new Node(3));\n\t\ttree.root.children.get(0).children.add(new Node(4));\n\t\ttree.root.children.get(0).children.add(new Node(5));\n\t\ttree.root.children.get(1).children.add(new Node(6));\n\t\ttree.root.children.get(1).children.add(new Node(7));\n\t\ttree.root.children.get(1).children.add(new Node(8));\n\t\ttree.root.children.get(1).children.add(new Node(9));\n\t\ttree.root.children.get(1).children.add(new Node(10));\n\t\ttree.root.children.get(1).children.add(new Node(11));\n\t\ttree.root.children.get(1).children.add(new Node(12));\n\t\ttree.root.children.get(1).children.add(new Node(13));\n\t\ttree.root.children.get(1).children.add(new Node(14));\n\t\ttree.root.children.get(1).children.add(new Node(15));\n\t\ttree.root.children.get(1).children.add(new Node(16));\n\t\ttree.root.children.get(1).children.add(new Node(17));\n\t\ttree.root.children.get(1).children.add(new Node(18));\n\t\ttree.root.children.get(1).children.add(new Node(19));\n\t\ttree.root.children.get(1).children.add(new Node(20));\n\t\ttree.root.children.get(1).children.add(new Node(21));\n\t\ttree.root.children.get(1).children.add(new Node(22));\n\t\ttree.root.children.get(1).children.\n",
        "\tstatic Node deserialize(String data){\n\t\tif(data == null || data.length() == 0)\n\t\t\treturn null;\n\t\tString[] nodes = data.split(\",\");\n\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\tNode root = new Node(Integer.parseInt(nodes[0]));\n\t\tqueue.add(root);\n\t\tint i = 1;\n\t\twhile(!queue.isEmpty()){\n\t\t\tNode node = queue.remove();\n\t\t\tif(nodes[i] != \"null\"){\n\t\t\t\tNode left = new Node(Integer.parseInt(nodes[i]));\n\t\t\t\tnode.left = left;\n\t\t\t\tqueue.add(left);\n\t\t\t}\n\t\t\ti++;\n\t\t\tif(nodes[i] != \"null\"){\n\t\t\t\tNode right = new Node(Integer.parseInt(nodes[i]));\n\t\t\t\tnode.right = right;\n\t\t\t\tqueue.add(right);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn root;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2196",
    "source": "leetcode",
    "language": "java",
    "query": "Remove any number of beans (possibly none) from each bag such that the number in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] bags = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] beans = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] result = removeBeans(bags,beans);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic static int[] removeBeans(int[] bags, int[] beans){\n\t\tint[] result = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tresult[i] = bags[i];\n\t\t}\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tint index = findIndex(result,beans[i]);\n\t\t\tif(index != -1){\n\t\t\t\tresult[index]--;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static int findIndex(int[] array, int value){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] == value){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] bags = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] beans = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] result = new int[bags.length];\n\t\tint[] result2 = new int[bags.length];\n\t\tint[] result3 = new int[bags.length];\n\t\tint[] result4 = new int[bags.length];\n\t\tint[] result5 = new int[bags.length];\n\t\tint[] result6 = new int[bags.length];\n\t\tint[] result7 = new int[bags.length];\n\t\tint[] result8 = new int[bags.length];\n\t\tint[] result9 = new int[bags.length];\n\t\tint[] result10 = new int[bags.length];\n\t\tint[] result11 = new int[bags.length];\n\t\tint[] result12 = new int[bags.length];\n\t\tint[] result13 = new int[bags.length];\n\t\tint[] result14 = new int[bags.length];\n\t\tint[] result15 = new int[bags.length];\n\t\tint[] result16 = new int[bags.length];\n\t\tint[] result17 = new int[bags.length];\n\t\tint[] result18 = new int[bags.length];\n\t\tint[] result19 = new int[bags.length];\n\t\tint[] result20 = new int[bags.length];\n\t\tint[] result21 = new int[bags.length];\n\t\tint[] result22 = new int[bags.length];\n\t\tint[] result23 = new int[bags.length];\n\t\tint[] result24 = new int[bags.length];\n\t\tint[] result25 = new int[bags.length];\n\t\tint[] result26 = new int[bags.length];\n\t\tint[] result27 = new int[bags.length];\n\t\tint[] result28 = new int[bags.length];\n\t\tint[] result29 = new int[bags.length];\n",
        "\tstatic void main(String[] args){\n\t\tint[] bags = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] beans = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] result = removeBeans(bags, beans);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.print(result[i] + \" \");\n\t\t}\n\t}\n\tpublic static int[] removeBeans(int[] bags, int[] beans){\n\t\tint[] result = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tresult[i] = bags[i];\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; j < beans.length; j++){\n\t\t\t\tif(beans[j] == bags[i]){\n\t\t\t\t\tcount++;\n\t\t\t\t\tbeans[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count > 0){\n\t\t\t\tfor(int j = 0; j < beans.length; j++){\n\t\t\t\t\tif(beans[j] != 0){\n\t\t\t\t\t\tresult[i] = beans[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] bags = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] beans = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] result = removeBeans(bags,beans);\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t}\n\tpublic static int[] removeBeans(int[] bags, int[] beans){\n\t\tint[] result = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tresult[i] = bags[i];\n\t\t}\n\t\tint[] temp = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\ttemp[i] = beans[i];\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tfor(int j = 0; j < beans.length; j++){\n\t\t\t\tif(result[i] == beans[j]){\n\t\t\t\t\ttemp[j] = 0;\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < temp.length; i++){\n\t\t\tif(temp[i] != 0){\n\t\t\t\tresult[i] = temp[i];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] bagCount = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbagCount[i] = bags[i];\n\t\t}\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tint bean = beans[i];\n\t\t\tint bag = findBag(bean, bagCount);\n\t\t\tif(bag != -1){\n\t\t\t\tbagCount[bag]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bagCount.length; i++){\n\t\t\tif(bagCount[i] != 0){\n\t\t\t\tSystem.out.println(\"Bag \" + i + \" has \" + bagCount[i] + \" beans\");\n\t\t\t}\n\t\t}\n\t}\n\tpublic\n\tint findBag(int bean, int[] bagCount){\n\t\tfor(int i = 0; i < bagCount.length; i++){\n\t\t\tif(bagCount[i] != 0){\n\t\t\t\tif(bagCount[i] == bean){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] bagCount = new int[bags.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbagCount[i] = beans[i];\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tint count = bags[i];\n\t\t\twhile(count > 0){\n\t\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\tint minIndex = -1;\n\t\t\t\tfor(int j = 0; j < bagCount.length; j++){\n\t\t\t\t\tif(bagCount[j] > 0 && bagCount[j] < min){\n\t\t\t\t\t\tmin = bagCount[j];\n\t\t\t\t\t\tminIndex = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbagCount[minIndex]--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bagCount.length; i++){\n\t\t\tif(bagCount[i] > 0){\n\t\t\t\tSystem.out.println(\"Bag \" + i + \" has \" + bagCount[i] + \" beans\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] bagsCopy = bags.clone();\n\t\tint[] beansCopy = beans.clone();\n\t\tint[] bagsCopy2 = bags.clone();\n\t\tint[] beansCopy2 = beans.clone();\n\t\tint[] bagsCopy3 = bags.clone();\n\t\tint[] beansCopy3 = beans.clone();\n\t\tint[] bagsCopy4 = bags.clone();\n\t\tint[] beansCopy4 = beans.clone();\n\t\tint[] bagsCopy5 = bags.clone();\n\t\tint[] beansCopy5 = beans.clone();\n\t\tint[] bagsCopy6 = bags.clone();\n\t\tint[] beansCopy6 = beans.clone();\n\t\tint[] bagsCopy7 = bags.clone();\n\t\tint[] beansCopy7 = beans.clone();\n\t\tint[] bagsCopy8 = bags.clone();\n\t\tint[] beansCopy8 = beans.clone();\n\t\tint[] bagsCopy9 = bags.clone();\n\t\tint[] beansCopy9 = beans.clone();\n\t\tint[] bagsCopy10 = bags.clone();\n\t\tint[] beansCopy10 = beans.clone();\n\t\tint[] bagsCopy11 = bags.clone();\n\t\tint[] beansCopy11 = beans.clone();\n\t\tint[] bagsCopy12 = bags.clone();\n\t\tint[] beansCopy12 = beans.clone();\n\t\tint[] bagsCopy13 = bags.clone();\n\t\tint[] beansCopy13 = beans.clone();\n\t\tint[] bagsCopy14 = bags.clone();\n\t\tint[] beansCopy14 = beans.clone();\n\t\tint[] bagsCopy15 = bags.clone();\n\t\tint[] beansCopy15 = beans.clone();\n\t\tint[] bagsCopy16 = bags.clone();\n\t\tint[] beansCopy16 = beans.clone();\n\t\tint[] bagsCopy17 = bags.clone();\n\t\tint[] beansCopy17 = beans.clone();\n\t\tint[] bagsCopy18 = bags.clone();\n\t\tint[] beansCopy18 = beans.clone();\n\t\tint[] bagsCopy19 = bags.clone();\n\t\tint[] beans\n",
        "\tvoid method(int[] bags, int[] beans){\n\t\tint[] bags2 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbags2[i] = bags[i];\n\t\t}\n\t\tint[] beans2 = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeans2[i] = beans[i];\n\t\t}\n\t\tint[] bags3 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbags3[i] = bags[i];\n\t\t}\n\t\tint[] beans3 = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeans3[i] = beans[i];\n\t\t}\n\t\tint[] bags4 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbags4[i] = bags[i];\n\t\t}\n\t\tint[] beans4 = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeans4[i] = beans[i];\n\t\t}\n\t\tint[] bags5 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbags5[i] = bags[i];\n\t\t}\n\t\tint[] beans5 = new int[beans.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbeans5[i] = beans[i];\n\t\t}\n\t\tint[] bags6 = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbags6[i] = bags[i];\n\t\t}\n\t\tint[] beans6 = new int[beans.length];\n\t\tfor\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] bagCount = new int[bags.length];\n\t\tfor(int i = 0; i < beans.length; i++){\n\t\t\tbagCount[beans[i]]++;\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(bagCount[bags[i]] > 0){\n\t\t\t\tbagCount[bags[i]]--;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(bagCount[bags[i]] > 0){\n\t\t\t\tSystem.out.println(\"Bag \" + bags[i] + \" has \" + bagCount[bags[i]] + \" beans\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid removeBeans(int[] bags, int[] beans){\n\t\tint[] beansLeft = new int[bags.length];\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tbeansLeft[i] = beans[i];\n\t\t}\n\t\tint beansToRemove = 0;\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(beansLeft[i] > 0){\n\t\t\t\tbeansToRemove = beansLeft[i] / bags[i];\n\t\t\t\tbeansLeft[i] = beansLeft[i] % bags[i];\n\t\t\t\tfor(int j = 0; j < bags.length; j++){\n\t\t\t\t\tif(i != j){\n\t\t\t\t\t\tbeansLeft[j] = beansLeft[j] - beansToRemove;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < bags.length; i++){\n\t\t\tif(beansLeft[i] > 0){\n\t\t\t\tSystem.out.println(\"No solution\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Solution\");\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2197",
    "source": "leetcode",
    "language": "java",
    "query": "Take any bag of balls and divide it into two new bags with a positive number of balls. Return the minimum possible penalty after performing the operations.",
    "snippets": [],
    "results": 0
},{
    "id": "2198",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array nums of n, return an array of all the unique quadruplets [nums] such that: a, b, c, d are distinct. You may return the answer in any order.",
    "snippets": [
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums.length < 4) return result;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\t\t\t\tint left = j + 1;\n\t\t\t\tint right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\t\t\tlist.add(nums[i]);\n\t\t\t\t\t\tlist.add(nums[j]);\n\t\t\t\t\t\tlist.add(nums[left]);\n\t\t\t\t\t\tlist.add(nums[right]);\n\t\t\t\t\t\tresult.add(list);\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(sum < target) left++;\n\t\t\t\t\telse right--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums.length < 4) return result;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\t\t\t\tint left = j + 1;\n\t\t\t\tint right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tresult.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}else if(sum < target){\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length < 4) return result;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\t\t\t\tint left = j + 1;\n\t\t\t\tint right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tresult.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}else if(sum < target){\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums.length < 4) return res;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\t\t\t\tint left = j + 1;\n\t\t\t\tint right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tres.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}else if(sum < target){\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif (nums == null || nums.length < 4) {\n\t\t\treturn result;\n\t\t}\n\t\tArrays.sort(nums);\n\t\tfor (int i = 0; i < nums.length - 3; i++) {\n\t\t\tif (i > 0 && nums[i] == nums[i - 1]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = i + 1; j < nums.length - 2; j++) {\n\t\t\t\tif (j > i + 1 && nums[j] == nums[j - 1]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left = j + 1;\n\t\t\t\tint right = nums.length - 1;\n\t\t\t\twhile (left < right) {\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif (sum == target) {\n\t\t\t\t\t\tresult.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile (left < right && nums[left] == nums[left - 1]) {\n\t\t\t\t\t\t\tleft++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (left < right && nums[right] == nums[right + 1]) {\n\t\t\t\t\t\t\tright--;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (sum < target) {\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tright--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums == null || nums.length < 4) return res;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\t\t\t\tint left = j + 1;\n\t\t\t\tint right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tres.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}else if(sum < target){\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums.length < 4) return res;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i-1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j-1]) continue;\n\t\t\t\tint left = j + 1;\n\t\t\t\tint right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tres.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left-1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right+1]) right--;\n\t\t\t\t\t}else if(sum < target) left++;\n\t\t\t\t\telse right--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(nums.length < 4) return res;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i-1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j-1]) continue;\n\t\t\t\tint left = j + 1, right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tres.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}else if(sum < target) left++;\n\t\t\t\t\telse right--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<List<Integer>> fourSum(int[] nums, int target) {\n\t\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length < 4) return res;\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 3; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tfor(int j = i + 1; j < nums.length - 2; j++){\n\t\t\t\tif(j > i + 1 && nums[j] == nums[j - 1]) continue;\n\t\t\t\tint left = j + 1, right = nums.length - 1;\n\t\t\t\twhile(left < right){\n\t\t\t\t\tint sum = nums[i] + nums[j] + nums[left] + nums[right];\n\t\t\t\t\tif(sum == target){\n\t\t\t\t\t\tres.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}else if(sum < target){\n\t\t\t\t\t\tleft++;\n\t\t\t\t\t\twhile(left < right && nums[left] == nums[left - 1]) left++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tright--;\n\t\t\t\t\t\twhile(left < right && nums[right] == nums[right + 1]) right--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2199",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer finalSum. Split it into a sum of a maximum number of unique positive even integers. If no valid split exists for finalSum, return an empty list.",
    "snippets": [
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(finalSum <= 0) return result;\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tint[] nums = new int[finalSum];\n\t\tfor(int i = 0; i < finalSum; i++){\n\t\t\tnums[i] = i + 1;\n\t\t}\n\t\tfor(int i = 0; i < finalSum; i++){\n\t\t\tif(nums[i] % 2 == 0){\n\t\t\t\tsum += nums[i];\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(sum == finalSum){\n\t\t\tresult.add(finalSum);\n\t\t\treturn result;\n\t\t}\n\t\tif(sum > finalSum) return result;\n\t\tint[] dp = new int[finalSum + 1];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i <= finalSum; i++){\n\t\t\tfor(int j = 0; j < count; j++){\n\t\t\t\tif(nums[j] <= i){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[i - nums[j]] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dp[finalSum] == 0) return result;\n\t\tint[] path = new int[finalSum];\n\t\tint index = finalSum;\n\t\twhile(index > 0){\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tif(nums[i] <= index){\n\t\t\t\t\tif(dp[index - nums[i]] == dp[index] - 1){\n\t\t\t\t\t\tpath[index - 1] = nums[i];\n\t\t\t\t\t\tindex -= nums[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(finalSum <= 0) return result;\n\t\tint[] dp = new int[finalSum + 1];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i <= finalSum; i++){\n\t\t\tfor(int j = 1; j <= i; j++){\n\t\t\t\tif(j % 2 == 0){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[i - j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = dp[finalSum];\n\t\tfor(int i = finalSum; i >= 0; i--){\n\t\t\tif(dp[i] == max){\n\t\t\t\tint j = i;\n\t\t\t\twhile(j >= 0 && dp[j] == max){\n\t\t\t\t\tresult.add(j);\n\t\t\t\t\tj -= j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tif(finalSum <= 0) return res;\n\t\tint[] dp = new int[finalSum + 1];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i <= finalSum; i++){\n\t\t\tfor(int j = i; j <= finalSum; j += i){\n\t\t\t\tdp[j] = Math.max(dp[j], dp[j - i] + 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= finalSum; i++){\n\t\t\tif(dp[i] > 1){\n\t\t\t\tres.add(i);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile(sum < finalSum){\n\t\t\tif(sum + i * 2 <= finalSum){\n\t\t\t\tsum += i * 2;\n\t\t\t\tresult.add(i * 2);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> res = new ArrayList<>();\n\t\tif(finalSum <= 0) return res;\n\t\tint[] dp = new int[finalSum + 1];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i <= finalSum; i++){\n\t\t\tfor(int j = 1; j <= i; j++){\n\t\t\t\tif(j % 2 == 0){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[i - j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = dp[finalSum];\n\t\tfor(int i = finalSum - max + 1; i <= finalSum; i++){\n\t\t\tif(i % 2 == 0) res.add(i);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\twhile(sum < finalSum){\n\t\t\tif(sum + i * 2 <= finalSum){\n\t\t\t\tresult.add(i * 2);\n\t\t\t\tsum += i * 2;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> res = new ArrayList<>();\n\t\tif(finalSum <= 0) return res;\n\t\thelper(finalSum, 0, 0, res);\n\t\treturn res;\n\t}\n\tpublic void helper(int finalSum, int curSum, int curCount, List<Integer> res){\n\t\tif(curSum > finalSum) return;\n\t\tif(curSum == finalSum){\n\t\t\tres.add(curCount);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 2; i <= finalSum; i += 2){\n\t\t\thelper(finalSum, curSum + i, curCount + 1, res);\n\t\t}\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(finalSum%2!=0) return result;\n\t\tint sum = 0;\n\t\tint i = 1;\n\t\twhile(sum<finalSum){\n\t\t\tsum+=i;\n\t\t\ti+=2;\n\t\t}\n\t\tif(sum==finalSum){\n\t\t\tresult.add(i-2);\n\t\t\tresult.add(i-2);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum){\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < finalSum; i++){\n\t\t\tif(i % 2 == 0){\n\t\t\t\tlist.add(i);\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t}\n\t\tif(sum == finalSum){\n\t\t\treturn list;\n\t\t}\n\t\telse{\n\t\t\treturn new ArrayList<Integer>();\n\t\t}\n\t}\n}\n",
        "\tList<Integer> splitIntoSubsequences(int finalSum) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tif(finalSum % 2 != 0) return result;\n\t\tint sum = 0;\n\t\tint max = finalSum / 2;\n\t\tfor(int i = 1; i <= max; i++) {\n\t\t\tif(i % 2 == 0) {\n\t\t\t\tsum += i;\n\t\t\t\tif(sum == finalSum) {\n\t\t\t\t\tresult.add(i);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif(sum > finalSum) {\n\t\t\t\t\tsum -= i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2200",
    "source": "leetcode",
    "language": "java",
    "query": "The first node is considered odd, and the second node is even, and so on. Given the head of a singly linked list, group all the nodes with odd indices together. You must solve the problem in O(1) extra space complexity.",
    "snippets": [
        "\tNode oddEvenList(Node head){\n\t\tif(head == null || head.next == null) return head;\n\t\tNode odd = head;\n\t\tNode even = head.next;\n\t\tNode evenHead = even;\n\t\twhile(even != null && even.next != null){\n\t\t\todd.next = odd.next.next;\n\t\t\teven.next = even.next.next;\n\t\t\todd = odd.next;\n\t\t\teven = even.next;\n\t\t}\n\t\todd.next = evenHead;\n\t\treturn head;\n\t}\n}\n",
        "\tNode oddEvenList(Node head){\n\t\tif(head == null || head.next == null) return head;\n\t\tNode odd = head;\n\t\tNode even = head.next;\n\t\tNode evenHead = even;\n\t\twhile(even != null && even.next != null){\n\t\t\todd.next = even.next;\n\t\t\todd = odd.next;\n\t\t\teven.next = odd.next;\n\t\t\teven = even.next;\n\t\t}\n\t\todd.next = evenHead;\n\t\treturn head;\n\t}\n}\n",
        "\tNode oddEvenList(Node head){\n\t\tif(head == null || head.next == null) return head;\n\t\tNode odd = head;\n\t\tNode even = head.next;\n\t\tNode evenHead = even;\n\t\twhile(even != null && even.next != null){\n\t\t\todd.next = odd.next.next;\n\t\t\todd = odd.next;\n\t\t\teven.next = even.next.next;\n\t\t\teven = even.next;\n\t\t}\n\t\todd.next = evenHead;\n\t\treturn head;\n\t}\n}\n",
        "\tNode oddEvenList(Node head){\n\t\tif(head == null || head.next == null){\n\t\t\treturn head;\n\t\t}\n\t\tNode odd = head;\n\t\tNode even = head.next;\n\t\tNode evenHead = even;\n\t\twhile(even != null && even.next != null){\n\t\t\todd.next = odd.next.next;\n\t\t\todd = odd.next;\n\t\t\teven.next = even.next.next;\n\t\t\teven = even.next;\n\t\t}\n\t\todd.next = evenHead;\n\t\treturn head;\n\t}\n}\n",
        "\tstatic Node oddEvenList(Node head){\n\t\tif(head == null || head.next == null){\n\t\t\treturn head;\n\t\t}\n\t\tNode odd = head;\n\t\tNode even = head.next;\n\t\tNode evenHead = even;\n\t\twhile(odd.next != null && even.next != null){\n\t\t\todd.next = odd.next.next;\n\t\t\teven.next = even.next.next;\n\t\t\todd = odd.next;\n\t\t\teven = even.next;\n\t\t}\n\t\todd.next = evenHead;\n\t\treturn head;\n\t}\n}\n",
        "\tstatic Node oddEvenList(Node head){\n\t\tif(head == null || head.next == null){\n\t\t\treturn head;\n\t\t}\n\t\tNode odd = head;\n\t\tNode even = head.next;\n\t\tNode evenHead = even;\n\t\twhile(even != null && even.next != null){\n\t\t\todd.next = odd.next.next;\n\t\t\todd = odd.next;\n\t\t\teven.next = even.next.next;\n\t\t\teven = even.next;\n\t\t}\n\t\todd.next = evenHead;\n\t\treturn head;\n\t}\n}\n",
        "\tstatic class Node{\n\t\tint data;\n\t\tNode next;\n\t\tNode(int data){\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\tpublic static void main(String[] args){\n\t\tNode head = new Node(1);\n\t\thead.next = new Node(2);\n\t\thead.next.next = new Node(3);\n\t\thead.next.next.next = new Node(4);\n\t\thead.next.next.next.next = new Node(5);\n\t\thead.next.next.next.next.next = new Node(6);\n\t\thead.next.next.next.next.next.next = new Node(7);\n\t\thead.next.next.next.next.next.next.next = new Node(8);\n\t\thead.next.next.next.next.next.next.next.next = new Node(9);\n\t\thead.next.next.next.next.next.next.next.next.next = new Node(10);\n\t\thead.next.next.next.next.next.next.next.next.next.next = new Node(11);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next = new Node(12);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next = new Node(13);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(14);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(15);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(16);\n\t\thead.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next = new Node(17);\n",
        "\tNode oddEvenList(Node head){\n\t\tif(head==null||head.next==null){\n\t\t\treturn head;\n\t\t}\n\t\tNode odd=head;\n\t\tNode even=head.next;\n\t\tNode evenHead=even;\n\t\twhile(odd!=null&&even!=null){\n\t\t\todd.next=even.next;\n\t\t\tif(odd.next!=null){\n\t\t\t\todd=odd.next;\n\t\t\t}\n\t\t\teven.next=odd.next;\n\t\t\tif(even.next!=null){\n\t\t\t\teven=even.next;\n\t\t\t}\n\t\t}\n\t\todd.next=evenHead;\n\t\treturn head;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2201",
    "source": "leetcode",
    "language": "java",
    "query": "Each node in the graph contains a value (int) and a list of its neighbors. Given a reference of a node in a connected undirected graph, return a deep copy of the graph.",
    "snippets": [
        "\tClazz(int value){\n\t\tthis.value = value;\n\t}\n\tpublic int value;\n\tpublic List<Clazz> neighbors;\n}\n",
        "\tClazz(int val){\n\t\tthis.val = val;\n\t}\n\tpublic int val;\n\tpublic List<Clazz> neighbors;\n}\n",
        "\tNode cloneGraph(Node node) {\n\t\tif(node == null) return null;\n\t\tNode newNode = new Node(node.val);\n\t\tMap<Node, Node> map = new HashMap<>();\n\t\tmap.put(node, newNode);\n\t\treturn dfs(node, map);\n\t}\n\tprivate Node dfs(Node node, Map<Node, Node> map){\n\t\tfor(Node n : node.neighbors){\n\t\t\tif(!map.containsKey(n)){\n\t\t\t\tmap.put(n, new Node(n.val));\n\t\t\t\tdfs(n, map);\n\t\t\t}\n\t\t\tmap.get(node).neighbors.add(map.get(n));\n\t\t}\n\t\treturn map.get(node);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2202",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root)",
    "snippets": [
        "\tList<List<Integer>> levelOrderBottom(TreeNode root) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(root == null) return result;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tlist.add(node.val);\n\t\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\t}\n\t\t\tresult.add(0, list);\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2203",
    "source": "leetcode",
    "language": "java",
    "query": "A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive). Given a 0-based nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i].",
    "snippets": [
        "\tint[] permute(int[] nums) {\n\t\tint[] ans = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tans[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint temp = ans[i];\n\t\t\tint j = (int)(Math.random() * (nums.length - i));\n\t\t\tans[i] = ans[j];\n\t\t\tans[j] = temp;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint[] permute(int[] nums) {\n\t\tint[] ans = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tans[i] = i;\n\t\t}\n\t\tint n = nums.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint j = (int)(Math.random() * (n - i)) + i;\n\t\t\tint temp = ans[i];\n\t\t\tans[i] = ans[j];\n\t\t\tans[j] = temp;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint[] permute(int[] nums) {\n\t\tint[] ans = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tans[i] = i;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint[] permute(int[] nums) {\n\t\tint[] ans = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tans[i] = i;\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint temp = ans[i];\n\t\t\tint j = (int)(Math.random() * (nums.length - i)) + i;\n\t\t\tans[i] = ans[j];\n\t\t\tans[j] = temp;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint[] permute(int[] nums) {\n\t\tint[] ans = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tans[i] = nums[i];\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint[] permute(int[] nums) {\n\t\tint[] ans = new int[nums.length];\n\t\tint[] visited = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tans[i] = i;\n\t\t}\n\t\tpermute(ans, visited, 0);\n\t\treturn ans;\n\t}\n\tpublic void permute(int[] ans, int[] visited, int index){\n\t\tif(index == ans.length){\n\t\t\tprint(ans);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < ans.length; i++){\n\t\t\tif(visited[i] == 0){\n\t\t\t\tans[index] = i;\n\t\t\t\tvisited[i] = 1;\n\t\t\t\tpermute(ans, visited, index + 1);\n\t\t\t\tvisited[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tpublic void print(int[] ans){\n\t\tfor(int i = 0; i < ans.length; i++){\n\t\t\tSystem.out.print(ans[i] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2204",
    "source": "leetcode",
    "language": "java",
    "query": "Each character signifies whether the student was absent, late, or present on that day. Return true if the student is eligible for an attendance award, or false otherwise.",
    "snippets": [
        "\tboolean isEligible(String s){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == 'A'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count > 1){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isEligible(String attendance){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < attendance.length(); i++){\n\t\t\tif(attendance.charAt(i) == 'A'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count > 1){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isEligible(String attendance) {\n\t\tint absent = 0;\n\t\tint late = 0;\n\t\tint present = 0;\n\t\tfor(int i = 0; i < attendance.length(); i++){\n\t\t\tif(attendance.charAt(i) == 'A'){\n\t\t\t\tabsent++;\n\t\t\t}\n\t\t\telse if(attendance.charAt(i) == 'L'){\n\t\t\t\tlate++;\n\t\t\t}\n\t\t\telse if(attendance.charAt(i) == 'P'){\n\t\t\t\tpresent++;\n\t\t\t}\n\t\t}\n\t\tif(absent >= 3 || late >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse if(absent == 2 && late == 1){\n\t\t\treturn false;\n\t\t}\n\t\telse if(absent == 1 && late == 2){\n\t\t\treturn false;\n\t\t}\n\t\telse if(absent == 0 && late == 0 && present < 5){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n",
        "\tboolean isEligible(String attendance) {\n\t\tint absent = 0;\n\t\tint late = 0;\n\t\tint present = 0;\n\t\tfor(int i = 0; i < attendance.length(); i++){\n\t\t\tif(attendance.charAt(i) == 'A'){\n\t\t\t\tabsent++;\n\t\t\t}\n\t\t\telse if(attendance.charAt(i) == 'L'){\n\t\t\t\tlate++;\n\t\t\t}\n\t\t\telse if(attendance.charAt(i) == 'P'){\n\t\t\t\tpresent++;\n\t\t\t}\n\t\t}\n\t\tif(absent >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse if(late >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse if(present >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n",
        "\tboolean checkAttendance(String[] attendance) {\n\t\tint absent = 0;\n\t\tint late = 0;\n\t\tint present = 0;\n\t\tfor(int i = 0; i < attendance.length; i++){\n\t\t\tif(attendance[i].equals(\"A\")){\n\t\t\t\tabsent++;\n\t\t\t}\n\t\t\telse if(attendance[i].equals(\"L\")){\n\t\t\t\tlate++;\n\t\t\t}\n\t\t\telse if(attendance[i].equals(\"P\")){\n\t\t\t\tpresent++;\n\t\t\t}\n\t\t}\n\t\tif(absent >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse if(late >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse if(present >= 3){\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
        "\tboolean isEligible(String attendance) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < attendance.length(); i++) {\n\t\t\tif (attendance.charAt(i) == 'A') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count >= 3) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean checkAttendance(String[] attendanceRecord){\n\t\tint count = 0;\n\t\tfor(int i = 0; i < attendanceRecord.length; i++){\n\t\t\tif(attendanceRecord[i].equals(\"A\")){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif(count >= 5){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean isEligible(String attendance){\n\t\tint absent = 0;\n\t\tint late = 0;\n\t\tint present = 0;\n\t\tfor(int i = 0; i < attendance.length(); i++){\n\t\t\tif(attendance.charAt(i) == 'A'){\n\t\t\t\tabsent++;\n\t\t\t}\n\t\t\telse if(attendance.charAt(i) == 'L'){\n\t\t\t\tlate++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpresent++;\n\t\t\t}\n\t\t}\n\t\tif(absent >= 3 || late >= 2){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n",
        "\tboolean isEligible(String attendance) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < attendance.length(); i++) {\n\t\t\tif (attendance.charAt(i) == 'A') {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tif (count >= 5) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean checkAttendance(String attendance) {\n\t\tint absent = 0;\n\t\tint late = 0;\n\t\tint present = 0;\n\t\tfor(int i = 0; i < attendance.length(); i++){\n\t\t\tif(attendance.charAt(i) == 'A'){\n\t\t\t\tabsent++;\n\t\t\t}\n\t\t\telse if(attendance.charAt(i) == 'L'){\n\t\t\t\tlate++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpresent++;\n\t\t\t}\n\t\t}\n\t\tif(absent >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse if(late >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse if(present >= 3){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2205",
    "source": "leetcode",
    "language": "java",
    "query": "There are n people, each person has a unique id between 0 and n-1. Given your id and the level of videos, return the list of videos ordered by their frequencies. For videos with the same frequency order them alphabetically from least to greatest.",
    "snippets": [
        "\tList<String> videosByFrequency(int[] ids, int[] freqs) {\n\t\tMap<Integer, List<String>> map = new HashMap<>();\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tif (!map.containsKey(freqs[i])) {\n\t\t\t\tmap.put(freqs[i], new ArrayList<>());\n\t\t\t}\n\t\t\tmap.get(freqs[i]).add(ids[i] + \"\");\n\t\t}\n\t\tList<String> res = new ArrayList<>();\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tres.addAll(map.get(freqs[i]));\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<String> videosByFrequency(int[] ids, int[] freqs) {\n\t\tMap<Integer, List<String>> map = new HashMap<>();\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tif (!map.containsKey(freqs[i])) {\n\t\t\t\tmap.put(freqs[i], new ArrayList<>());\n\t\t\t}\n\t\t\tmap.get(freqs[i]).add(String.valueOf(ids[i]));\n\t\t}\n\t\tList<String> result = new ArrayList<>();\n\t\tfor (int i = map.size() - 1; i >= 0; i--) {\n\t\t\tif (map.containsKey(i)) {\n\t\t\t\tCollections.sort(map.get(i));\n\t\t\t\tresult.addAll(map.get(i));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<String> videosByFrequency(int[] ids, String[] titles) {\n\t\tMap<String, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tmap.put(titles[i], map.getOrDefault(titles[i], 0) + ids[i]);\n\t\t}\n\t\tList<String> res = new ArrayList<>();\n\t\tfor (String key : map.keySet()) {\n\t\t\tres.add(key);\n\t\t}\n\t\tCollections.sort(res, new Comparator<String>() {\n\t\t\t@Override\n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\tint cmp = map.get(o2) - map.get(o1);\n\t\t\t\tif (cmp == 0) {\n\t\t\t\t\tcmp = o1.compareTo(o2);\n\t\t\t\t}\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t}\n}\n",
        "\tList<String> watchedVideos(int[] watchedVideos, int id, int[] videos) {\n\t\tList<String> res = new ArrayList<>();\n\t\tMap<String, Integer> map = new HashMap<>();\n\t\tfor(int i = 0; i < watchedVideos.length; i++){\n\t\t\tif(watchedVideos[i] == id){\n\t\t\t\tmap.put(videos[i], map.getOrDefault(videos[i], 0) + 1);\n\t\t\t}\n\t\t}\n\t\tList<Map.Entry<String, Integer>> list = new ArrayList<>(map.entrySet());\n\t\tCollections.sort(list, new Comparator<Map.Entry<String, Integer>>(){\n\t\t\tpublic int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2){\n\t\t\t\tif(o1.getValue() == o2.getValue()){\n\t\t\t\t\treturn o1.getKey().compareTo(o2.getKey());\n\t\t\t\t}\n\t\t\t\treturn o2.getValue() - o1.getValue();\n\t\t\t}\n\t\t});\n\t\tfor(Map.Entry<String, Integer> e : list){\n\t\t\tres.add(e.getKey());\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<String> videosByFrequency(int[] ids, int[] freqs) {\n\t\tMap<Integer, List<String>> map = new HashMap<>();\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tif (!map.containsKey(ids[i])) {\n\t\t\t\tmap.put(ids[i], new ArrayList<>());\n\t\t\t}\n\t\t\tmap.get(ids[i]).add(String.valueOf(freqs[i]));\n\t\t}\n\t\tList<String> res = new ArrayList<>();\n\t\tfor (int i = 0; i < ids.length; i++) {\n\t\t\tres.addAll(map.get(ids[i]));\n\t\t}\n\t\tCollections.sort(res);\n\t\treturn res;\n\t}\n}\n",
        "\tList<String> watchedVideos(int[] watchedVideos, int id, int[] videos) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(int i = 0; i < watchedVideos.length; i++){\n\t\t\tif(watchedVideos[i] == id){\n\t\t\t\tmap.put(videos[i], map.getOrDefault(videos[i], 0) + 1);\n\t\t\t}\n\t\t}\n\t\tList<Map.Entry<String, Integer>> list1 = new ArrayList<Map.Entry<String, Integer>>(map.entrySet());\n\t\tCollections.sort(list1, new Comparator<Map.Entry<String, Integer>>(){\n\t\t\tpublic int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2){\n\t\t\t\tif(o1.getValue() == o2.getValue()){\n\t\t\t\t\treturn o1.getKey().compareTo(o2.getKey());\n\t\t\t\t}\n\t\t\t\treturn o2.getValue() - o1.getValue();\n\t\t\t}\n\t\t});\n\t\tfor(Map.Entry<String, Integer> entry : list1){\n\t\t\tlist.add(entry.getKey());\n\t\t}\n\t\treturn list;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2206",
    "source": "leetcode",
    "language": "java",
    "query": "Since the answer may be large, return the answer modulo 10^9 + 7. Return the number of permutations of 1 to n.",
    "snippets": [
        "\tint numPermutations(int n) {\n\t\tlong res = 1;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tres = res * i;\n\t\t\tres = res % 1000000007;\n\t\t}\n\t\treturn (int)res;\n\t}\n}\n",
        "\tint numPermsDISC(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tdp[i] += dp[j - 1] * dp[i - j];\n\t\t\t}\n\t\t}\n\t\treturn dp[n] % 1000000007;\n\t}\n}\n",
        "\tint numPermutations(int n) {\n\t\tlong res = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tres = res * i % 1000000007;\n\t\t}\n\t\treturn (int) res;\n\t}\n}\n",
        "\tint numPermutations(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] * (i - 1)) % 1000000007;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tres = (res + dp[i]) % 1000000007;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint numPermsDISCUSS(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tdp[i] += dp[j - 1] * dp[i - j];\n\t\t\t}\n\t\t}\n\t\treturn dp[n] % 1000000007;\n\t}\n\tpublic\n\tint numPerms(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tdp[i] += dp[j - 1] * dp[i - j];\n\t\t\t}\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint numPermsDISCUSS(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tdp[i] += dp[j - 1] * dp[i - j];\n\t\t\t}\n\t\t}\n\t\treturn dp[n] % 1000000007;\n\t}\n}\n",
        "\tint numPermutation(int n) {\n\t\tint mod = 1000000007;\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = (dp[i - 1] * i) % mod;\n\t\t}\n\t\treturn dp[n];\n\t}\n}\n",
        "\tint numPermsDISTRIBUTED(int n) {\n\t\tint[] dp = new int[n + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= i; j++) {\n\t\t\t\tdp[i] += dp[j - 1] * dp[i - j];\n\t\t\t}\n\t\t}\n\t\treturn dp[n] % 1000000007;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2207",
    "source": "leetcode",
    "language": "java",
    "query": "If there are two middle nodes, return the second middle node. Given the head of a singly linked list, give the middle node of the linked list.",
    "snippets": [
        "\tNode middleNode(Node head){\n\t\tNode slow = head;\n\t\tNode fast = head;\n\t\twhile(fast != null && fast.next != null){\n\t\t\tslow = slow.next;\n\t\t\tfast = fast.next.next;\n\t\t}\n\t\treturn slow;\n\t}\n}\n",
        "\tNode middle(Node head){\n\t\tNode slow = head;\n\t\tNode fast = head;\n\t\twhile(fast != null && fast.next != null){\n\t\t\tslow = slow.next;\n\t\t\tfast = fast.next.next;\n\t\t}\n\t\treturn slow;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2208",
    "source": "leetcode",
    "language": "java",
    "query": "An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tSystem.out.println(isSubset(a,b));\n\t}\n\tpublic static boolean isSubset(int[] a, int[] b){\n\t\tint[] c = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tc[i] = b[a[i]];\n\t\t}\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(c[i] != a[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tSystem.out.println(isSubset(a,b));\n\t}\n\tpublic static boolean isSubset(int[] a, int[] b){\n\t\tint[] c = new int[b.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tc[a[i]-1] = 1;\n\t\t}\n\t\tfor(int i = 0; i < b.length; i++){\n\t\t\tif(c[i] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tSystem.out.println(isSubset(a,b));\n\t}\n\tpublic static boolean isSubset(int[] a, int[] b){\n\t\tint[] c = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tc[i] = b[a[i]];\n\t\t}\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(a[i] != c[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tSystem.out.println(isSubset(a,b));\n\t}\n\tpublic static boolean isSubset(int[] a, int[] b){\n\t\tif(a.length > b.length) return false;\n\t\tint[] c = new int[b.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tc[a[i]] = 1;\n\t\t}\n\t\tfor(int i = 0; i < b.length; i++){\n\t\t\tif(c[b[i]] == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tSystem.out.println(isSubset(a,b));\n\t}\n\tpublic static boolean isSubset(int[] a, int[] b){\n\t\tint[] c = new int[b.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tc[a[i]] = 1;\n\t\t}\n\t\tfor(int i = 0; i < b.length; i++){\n\t\t\tif(c[b[i]] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] c = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};\n\t\tint[] d = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3};\n\t\tint[] b = {1,2,3,4,5};\n\t\tSystem.out.println(isSubset(a,b));\n\t}\n\tpublic static boolean isSubset(int[] a, int[] b){\n\t\tif(a.length > b.length) return false;\n\t\tint[] temp = new int[b.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\ttemp[a[i]] = 1;\n\t\t}\n\t\tfor(int i = 0; i < b.length; i++){\n\t\t\tif(temp[i] == 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5};\n\t\tint[] b = {1,2,3,4,5,6};\n\t\tSystem.out.println(isSubset(a,b));\n\t}\n\tpublic static boolean isSubset(int[] a, int[] b){\n\t\tif(a.length>b.length) return false;\n\t\tint[] c = new int[b.length];\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tc[a[i]-1] = 1;\n\t\t}\n\t\tfor(int i=0;i<b.length;i++){\n\t\t\tif(c[i]==0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2209",
    "source": "leetcode",
    "language": "java",
    "query": "Answers within 10-5 of the actual answer will be considered accepted. Return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.",
    "snippets": [
        "\tstatic double mean(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint min = b[0];\n\t\tint max = b[0];\n\t\tfor(int i = 0; i < b.length; i++){\n\t\t\tif(b[i] < min){\n\t\t\t\tmin = b[i];\n\t\t\t}\n\t\t\tif(b[i] > max){\n\t\t\t\tmax = b[i];\n\t\t\t}\n\t\t}\n\t\tint min_index = 0;\n\t\tint max_index = 0;\n\t\tfor(int i = 0; i < b.length; i++){\n\t\t\tif(b[i] == min){\n\t\t\t\tmin_index = i;\n\t\t\t}\n\t\t\tif(b[i] == max){\n\t\t\t\tmax_index = i;\n\t\t\t}\n\t\t}\n\t\tint[] c = new int[b.length - 2];\n\t\tint j = 0;\n\t\tfor(int i = 0; i < b.length; i++){\n\t\t\tif(i != min_index && i != max_index){\n\t\t\t\tc[j] = b[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tsum += c[i];\n\t\t}\n\t\treturn sum / c.length;\n\t}\n}\n",
        "\tstatic double mean(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\tint[] c = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tc[i] = a[i];\n\t\t}\n\t\tArrays.sort(c);\n\t\tint[] d = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\td[i] = a[i];\n\t\t}\n\t\tArrays.sort(d);\n\t\tint[] e = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\te[i] = a[i];\n\t\t}\n\t\tArrays.sort(e);\n\t\tint[] f = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tf[i] = a[i];\n\t\t}\n\t\tArrays.sort(f);\n\t\tint[] g = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tg[i] = a[i];\n\t\t}\n\t\tArrays.sort(g);\n\t\tint[] h = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\th[i] = a[i];\n\t\t}\n\t\tArrays.sort(h);\n\t\tint[] i = new int[a.length];\n\t\tfor(int j = 0; j < a.length; j++){\n\t\t\ti[j] = a[j];\n\t\t}\n\t\tArrays.sort(i);\n\t\tint[] j = new int[\n",
        "\tstatic double mean(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tArrays.sort(b);\n\t\tint[] c = new int[a.length];\n\t\tint[] d = new int[a.length];\n\t\tint e = (int)Math.floor(a.length * 0.05);\n\t\tint f = (int)Math.floor(a.length * 0.95);\n\t\tfor(int i = 0; i < e; i++){\n\t\t\tc[i] = b[i];\n\t\t}\n\t\tfor(int i = f; i < a.length; i++){\n\t\t\td[i] = b[i];\n\t\t}\n\t\tint g = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(!(i < e || i > f)){\n\t\t\t\tg += a[i];\n\t\t\t}\n\t\t}\n\t\treturn g / (a.length - (2 * e));\n\t}\n}\n",
        "\tstatic double mean(int[] a){\n\t\tint[] b = new int[a.length];\n\t\tint[] c = new int[a.length];\n\t\tint[] d = new int[a.length];\n\t\tint[] e = new int[a.length];\n\t\tint[] f = new int[a.length];\n\t\tint[] g = new int[a.length];\n\t\tint[] h = new int[a.length];\n\t\tint[] i = new int[a.length];\n\t\tint[] j = new int[a.length];\n\t\tint[] k = new int[a.length];\n\t\tint[] l = new int[a.length];\n\t\tint[] m = new int[a.length];\n\t\tint[] n = new int[a.length];\n\t\tint[] o = new int[a.length];\n\t\tint[] p = new int[a.length];\n\t\tint[] q = new int[a.length];\n\t\tint[] r = new int[a.length];\n\t\tint[] s = new int[a.length];\n\t\tint[] t = new int[a.length];\n\t\tint[] u = new int[a.length];\n\t\tint[] v = new int[a.length];\n\t\tint[] w = new int[a.length];\n\t\tint[] x = new int[a.length];\n\t\tint[] y = new int[a.length];\n\t\tint[] z = new int[a.length];\n\t\tint[] aa = new int[a.length];\n\t\tint[] bb = new int[a.length];\n\t\tint[] cc = new int[a.length];\n\t\tint[] dd = new int[a.length];\n\t\tint[] ee = new int[a.length];\n\t\tint[] ff = new int[a.length];\n\t\tint[] gg = new int[a.length];\n\t\tint[] hh = new int[a.length];\n\t\tint[] ii = new int[a.length];\n\t\tint[] jj = new\n",
        "\tdouble mean(int[] arr){\n\t\tint[] newArr = new int[arr.length];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tnewArr[i] = arr[i];\n\t\t}\n\t\tArrays.sort(newArr);\n\t\tint remove = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove2 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove3 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove4 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove5 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove6 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove7 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove8 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove9 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove10 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove11 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove12 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove13 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove14 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove15 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove16 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove17 = (int)Math.floor(newArr.length * 0.05);\n\t\tint remove18 = (int)Math.floor(newArr.\n",
        "\tstatic double mean(int[] arr){\n\t\tint[] copy = arr.clone();\n\t\tArrays.sort(copy);\n\t\tint size = copy.length;\n\t\tint remove = (int) Math.floor(size * 0.05);\n\t\tint remove2 = (int) Math.floor(size * 0.05);\n\t\tdouble sum = 0;\n\t\tfor(int i = remove; i < size - remove2; i++){\n\t\t\tsum += copy[i];\n\t\t}\n\t\treturn sum / (size - remove - remove2);\n\t}\n}\n",
        "\tstatic double getAverage(int[] array){\n\t\tint[] copy = array.clone();\n\t\tArrays.sort(copy);\n\t\tint size = copy.length;\n\t\tint remove = (int)Math.floor(size*0.05);\n\t\tint remove2 = (int)Math.floor(size*0.05);\n\t\tint remove3 = (int)Math.floor(size*0.05);\n\t\tint remove4 = (int)Math.floor(size*0.05);\n\t\tint remove5 = (int)Math.floor(size*0.05);\n\t\tint remove6 = (int)Math.floor(size*0.05);\n\t\tint remove7 = (int)Math.floor(size*0.05);\n\t\tint remove8 = (int)Math.floor(size*0.05);\n\t\tint remove9 = (int)Math.floor(size*0.05);\n\t\tint remove10 = (int)Math.floor(size*0.05);\n\t\tint remove11 = (int)Math.floor(size*0.05);\n\t\tint remove12 = (int)Math.floor(size*0.05);\n\t\tint remove13 = (int)Math.floor(size*0.05);\n\t\tint remove14 = (int)Math.floor(size*0.05);\n\t\tint remove15 = (int)Math.floor(size*0.05);\n\t\tint remove16 = (int)Math.floor(size*0.05);\n\t\tint remove17 = (int)Math.floor(size*0.05);\n\t\tint remove18 = (int)Math.floor(size*0.05);\n\t\tint remove19 = (int)Math.floor(size*0.05);\n\t\tint remove20 = (int)Math.floor(size*0.05);\n\t\tint remove21 = (int)Math.floor(size*0.05);\n\t\tint remove22 = (int)Math.floor(size*0.05);\n\t\tint remove23 = (int)Math.floor(size*0.05\n",
        "\tdouble mean(int[] numbers){\n\t\tint[] copy = numbers.clone();\n\t\tArrays.sort(copy);\n\t\tint size = copy.length;\n\t\tint remove = (int) Math.floor(size * 0.05);\n\t\tint remove2 = (int) Math.floor(size * 0.05);\n\t\tint remove3 = (int) Math.floor(size * 0.05);\n\t\tint remove4 = (int) Math.floor(size * 0.05);\n\t\tint remove5 = (int) Math.floor(size * 0.05);\n\t\tint remove6 = (int) Math.floor(size * 0.05);\n\t\tint remove7 = (int) Math.floor(size * 0.05);\n\t\tint remove8 = (int) Math.floor(size * 0.05);\n\t\tint remove9 = (int) Math.floor(size * 0.05);\n\t\tint remove10 = (int) Math.floor(size * 0.05);\n\t\tint remove11 = (int) Math.floor(size * 0.05);\n\t\tint remove12 = (int) Math.floor(size * 0.05);\n\t\tint remove13 = (int) Math.floor(size * 0.05);\n\t\tint remove14 = (int) Math.floor(size * 0.05);\n\t\tint remove15 = (int) Math.floor(size * 0.05);\n\t\tint remove16 = (int) Math.floor(size * 0.05);\n\t\tint remove17 = (int) Math.floor(size * 0.05);\n\t\tint remove18 = (int) Math.floor(size * 0.05);\n\t\tint remove19 = (int) Math.floor(size * 0.05);\n\t\tint remove20 = (int) Math.floor(size * 0.05);\n\t\tint remove21 = (int) Math.floor(size * 0.05);\n\t\tint remove22 = (int) Math.floor(size * 0.05);\n\t\tint remove23 = (int) Math.floor(size * 0.05);\n",
        "\tdouble mean(int[] a){\n\t\tint[] b = a.clone();\n\t\tArrays.sort(b);\n\t\tint n = b.length;\n\t\tint k = (int)Math.floor(n*0.05);\n\t\tint sum = 0;\n\t\tfor(int i = k; i < n-k; i++){\n\t\t\tsum += b[i];\n\t\t}\n\t\treturn (double)sum/(n-2*k);\n\t}\n}\n",
        "\tstatic int[] remove5(int[] arr){\n\t\tint[] newArr = new int[arr.length];\n\t\tint[] sortedArr = new int[arr.length];\n\t\tint[] sortedArr2 = new int[arr.length];\n\t\tint[] sortedArr3 = new int[arr.length];\n\t\tint[] sortedArr4 = new int[arr.length];\n\t\tint[] sortedArr5 = new int[arr.length];\n\t\tint[] sortedArr6 = new int[arr.length];\n\t\tint[] sortedArr7 = new int[arr.length];\n\t\tint[] sortedArr8 = new int[arr.length];\n\t\tint[] sortedArr9 = new int[arr.length];\n\t\tint[] sortedArr10 = new int[arr.length];\n\t\tint[] sortedArr11 = new int[arr.length];\n\t\tint[] sortedArr12 = new int[arr.length];\n\t\tint[] sortedArr13 = new int[arr.length];\n\t\tint[] sortedArr14 = new int[arr.length];\n\t\tint[] sortedArr15 = new int[arr.length];\n\t\tint[] sortedArr16 = new int[arr.length];\n\t\tint[] sortedArr17 = new int[arr.length];\n\t\tint[] sortedArr18 = new int[arr.length];\n\t\tint[] sortedArr19 = new int[arr.length];\n\t\tint[] sortedArr20 = new int[arr.length];\n\t\tint[] sortedArr21 = new int[arr.length];\n\t\tint[] sortedArr22 = new int[arr.length];\n\t\tint[] sortedArr23 = new int[arr.length];\n\t\tint[] sortedArr24 = new int[arr.length];\n\t\tint[] sortedArr25 = new int[arr.length];\n\t\tint[] sortedArr26 = new int[arr.length];\n\t\tint[] sortedArr27 = new int[arr.length];\n\t\tint[] sortedArr28 = new int[arr\n"
    ],
    "results": 10
},{
    "id": "2210",
    "source": "leetcode",
    "language": "java",
    "query": "A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born. The kingdom has a well-defined order of inheritance.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tSystem.out.println(solve(a));\n\t}\n\tpublic static int solve(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint j = i;\n\t\t\twhile(j < n && b[j] > 0){\n\t\t\t\tb[j]--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tans += j - i;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tSystem.out.println(solve(a));\n\t}\n\tpublic static int solve(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint j = i;\n\t\t\twhile(j < n && b[j] > 0){\n\t\t\t\tb[j]--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tans = Math.max(ans, j-i);\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] a = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] b = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] c = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] d = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] e = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] f = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] g = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] h = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] i = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] j = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] k = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] l = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] m = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] n = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] o = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] p = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] q = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] r = {1,2,3,\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tSystem.out.println(solve(a));\n\t}\n\tpublic static int solve(int[] a){\n\t\tint n = a.length;\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = a[i];\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = a[i];\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = a[i];\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = a[i];\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = a[i];\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = a[i];\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int j = 0; j < n; j++){\n\t\t\ti[j] = a[j];\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[][] family = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfamily[i][0] = i;\n\t\t\tfamily[i][1] = i + 1;\n\t\t}\n\t\tint[][] relations = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\trelations[i][0] = family[i][0];\n\t\t\trelations[i][1] = family[i][1];\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(relations[i][0] + \" \" + relations[i][1]);\n\t\t}\n\t}\n}\n",
        "\tvoid main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+1]);\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = a[i];\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = a[i];\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = a[i];\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = a[i];\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = a[i];\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = a[i];\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ti[i] = a[i];\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tj[i] = a[i];\n\t\t}\n\t\tint[] k = new int\n",
        "\tstatic void main(String[] args){\n\t\tint n = Integer.parseInt(args[0]);\n\t\tint k = Integer.parseInt(args[1]);\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i] = Integer.parseInt(args[i+2]);\n\t\t}\n\t\tint[] b = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tb[i] = a[i];\n\t\t}\n\t\tint[] c = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tc[i] = a[i];\n\t\t}\n\t\tint[] d = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\td[i] = a[i];\n\t\t}\n\t\tint[] e = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\te[i] = a[i];\n\t\t}\n\t\tint[] f = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tf[i] = a[i];\n\t\t}\n\t\tint[] g = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tg[i] = a[i];\n\t\t}\n\t\tint[] h = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\th[i] = a[i];\n\t\t}\n\t\tint[] i = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ti[i] = a[i];\n\t\t}\n\t\tint[] j = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tj[i] = a\n",
        "\tClazz(){\n\t\t\n\t}\n\tpublic void method(){\n\t\t\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2211",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, break it into the sum of k positive integers, where k >= 2. Return the maximum product you can get.",
    "snippets": [
        "\tint breakInteger(int n, int k){\n\t\tint[] nums = new int[k];\n\t\tint i = 0;\n\t\twhile(n > 0){\n\t\t\tnums[i] = n % 10;\n\t\t\tn /= 10;\n\t\t\ti++;\n\t\t}\n\t\tint max = 1;\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tmax *= nums[j];\n\t\t}\n\t\tint min = max;\n\t\tfor(int j = k - 1; j >= 0; j--){\n\t\t\tmax *= nums[j];\n\t\t\tmin *= nums[j];\n\t\t}\n\t\treturn max > min ? max : min;\n\t}\n}\n",
        "\tint splitIntoFives(int n) {\n\t\tint count = 0;\n\t\tint product = 1;\n\t\twhile (n > 0) {\n\t\t\tn -= 5;\n\t\t\tcount++;\n\t\t\tproduct *= 5;\n\t\t}\n\t\treturn count * product;\n\t}\n}\n",
        "\tint maxProduct(int n) {\n\t\tint max = n;\n\t\tint min = n;\n\t\tint res = n;\n\t\tfor(int i = 2; i <= n; i++){\n\t\t\tint tmp = max;\n\t\t\tmax = Math.max(max * i, min * i);\n\t\t\tmin = Math.min(tmp * i, min * i);\n\t\t\tres = Math.max(res, max);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint splitIntoFives(int n){\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\twhile(n > 0){\n\t\t\tsum += n % 5;\n\t\t\tn /= 5;\n\t\t\tcount++;\n\t\t}\n\t\tif(sum % 5 != 0){\n\t\t\treturn 0;\n\t\t}\n\t\tint[] dp = new int[count + 1];\n\t\tdp[0] = 1;\n\t\tdp[1] = 1;\n\t\tfor(int i = 2; i <= count; i++){\n\t\t\tdp[i] = Math.max(dp[i - 1], dp[i - 2] + sum / 5);\n\t\t}\n\t\treturn dp[count];\n\t}\n}\n",
        "\tint breakInteger(int n, int k){\n\t\tint result = 0;\n\t\tint[] arr = new int[k];\n\t\tint i = 0;\n\t\twhile(n > 0){\n\t\t\tarr[i] = n % 10;\n\t\t\tn = n / 10;\n\t\t\ti++;\n\t\t}\n\t\tint max = 0;\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tmax = Math.max(max, arr[j]);\n\t\t}\n\t\tint min = 0;\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tmin = Math.min(min, arr[j]);\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tsum += arr[j];\n\t\t}\n\t\tif(sum == max){\n\t\t\tresult = max;\n\t\t}\n\t\telse if(sum == min){\n\t\t\tresult = min;\n\t\t}\n\t\telse{\n\t\t\tresult = sum;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint splitIntoFives(int n){\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\tint product = 1;\n\t\twhile(n > 0){\n\t\t\tsum += n % 5;\n\t\t\tn /= 5;\n\t\t\tcount++;\n\t\t}\n\t\twhile(sum > 0){\n\t\t\tproduct *= sum;\n\t\t\tsum -= 5;\n\t\t}\n\t\treturn product;\n\t}\n}\n",
        "\tint splitIntoFives(int n){\n\t\tif(n<=0) return 0;\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\twhile(n>0){\n\t\t\tsum += n%5;\n\t\t\tn /= 5;\n\t\t\tcount++;\n\t\t}\n\t\tif(sum%5!=0) return 0;\n\t\treturn (int)Math.pow(5, count)*(sum/5);\n\t}\n}\n"
    ],
    "results": 9
},{
    "id": "2212",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[ i] == 0 instead.",
    "snippets": [
        "\tint[] dailyTemperatures(int[] temperatures) {\n\t\tint[] res = new int[temperatures.length];\n\t\tfor(int i = 0; i < temperatures.length; i++){\n\t\t\tint j = i + 1;\n\t\t\twhile(j < temperatures.length && temperatures[j] <= temperatures[i]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(j < temperatures.length){\n\t\t\t\tres[i] = j - i;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] dailyTemperatures(int[] temperatures) {\n\t\tint[] result = new int[temperatures.length];\n\t\tfor(int i = 0; i < temperatures.length; i++){\n\t\t\tint j = i + 1;\n\t\t\twhile(j < temperatures.length){\n\t\t\t\tif(temperatures[j] > temperatures[i]){\n\t\t\t\t\tresult[i] = j - i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif(j == temperatures.length){\n\t\t\t\tresult[i] = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] dailyTemperatures(int[] temperatures) {\n\t\tint[] res = new int[temperatures.length];\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor(int i = 0; i < temperatures.length; i++){\n\t\t\twhile(!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]){\n\t\t\t\tint index = stack.pop();\n\t\t\t\tres[index] = i - index;\n\t\t\t}\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] dailyTemperatures(int[] temperatures) {\n\t\tint[] res = new int[temperatures.length];\n\t\tStack<Integer> stack = new Stack<Integer>();\n\t\tfor(int i = 0; i < temperatures.length; i++){\n\t\t\twhile(!stack.isEmpty() && temperatures[stack.peek()] < temperatures[i]){\n\t\t\t\tint index = stack.pop();\n\t\t\t\tres[index] = i - index;\n\t\t\t}\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2213",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array nums of integers, a move consists of choosing any element and decreasing it by 1. An array A is a zigzag array if either:Every even-indexed element is greater than adjacent elements, ie. A[0] > A[1] < A[2] > a[3] < a[4] > ....",
    "snippets": [
        "\tboolean isZigZag(int[] nums){\n\t\tif(nums.length<2) return true;\n\t\tboolean flag = false;\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tif(flag){\n\t\t\t\tif(nums[i]<nums[i-1]) return false;\n\t\t\t}else{\n\t\t\t\tif(nums[i]>nums[i-1]) return false;\n\t\t\t}\n\t\t\tflag = !flag;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isZigZag(int[] nums){\n\t\tif(nums == null || nums.length == 0)\n\t\t\treturn false;\n\t\tboolean isZigZag = true;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tif(i % 2 == 0){\n\t\t\t\tif(nums[i] < nums[i-1])\n\t\t\t\t\tisZigZag = false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(nums[i] > nums[i-1])\n\t\t\t\t\tisZigZag = false;\n\t\t\t}\n\t\t}\n\t\treturn isZigZag;\n\t}\n}\n",
        "\tboolean isZigZag(int[] nums){\n\t\tif(nums == null || nums.length == 0)\n\t\t\treturn false;\n\t\tint i = 0;\n\t\twhile(i < nums.length - 1){\n\t\t\tif(nums[i] > nums[i + 1]){\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nums[i] < nums[i + 1]){\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isZigZag(int[] nums){\n\t\tif(nums.length<2) return true;\n\t\tboolean isZigZag = true;\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tif(i%2==1){\n\t\t\t\tif(nums[i]<nums[i-1]){\n\t\t\t\t\tisZigZag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(nums[i]>nums[i-1]){\n\t\t\t\t\tisZigZag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn isZigZag;\n\t}\n}\n",
        "\tboolean isZigzag(int[] nums){\n\t\tif(nums.length<2) return true;\n\t\tint i=0;\n\t\tint j=1;\n\t\twhile(j<nums.length){\n\t\t\tif(nums[i]>nums[j]){\n\t\t\t\ti=j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(i==0) return true;\n\t\telse return false;\n\t}\n}\n",
        "\tboolean isZigzag(int[] nums){\n\t\tif(nums.length<=1) return true;\n\t\tint i=0;\n\t\tint j=1;\n\t\twhile(j<nums.length){\n\t\t\tif(nums[i]>nums[j]){\n\t\t\t\ti=j;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isZigZag(int[] nums){\n\t\tif(nums.length<2) return true;\n\t\tboolean flag = false;\n\t\tfor(int i=0;i<nums.length-1;i++){\n\t\t\tif(flag){\n\t\t\t\tif(nums[i]>nums[i+1]) return false;\n\t\t\t}else{\n\t\t\t\tif(nums[i]<nums[i+1]) return false;\n\t\t\t}\n\t\t\tflag = !flag;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isZigzag(int[] nums){\n\t\tif(nums.length<=1) return true;\n\t\tboolean isZigZag = true;\n\t\tfor(int i=0;i<nums.length-1;i++){\n\t\t\tif(i%2==0){\n\t\t\t\tif(nums[i]>nums[i+1]){\n\t\t\t\t\tisZigZag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(nums[i]<nums[i+1]){\n\t\t\t\t\tisZigZag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn isZigZag;\n\t}\n}\n",
        "\tboolean isZigzag(int[] nums){\n\t\tif(nums.length<=1) return true;\n\t\tboolean flag = true;\n\t\tfor(int i=0;i<nums.length-1;i++){\n\t\t\tif(flag){\n\t\t\t\tif(nums[i]>nums[i+1]) return false;\n\t\t\t}else{\n\t\t\t\tif(nums[i]<nums[i+1]) return false;\n\t\t\t}\n\t\t\tflag = !flag;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isZigzag(int[] nums){\n\t\tif(nums.length<2) return true;\n\t\tboolean flag=true;\n\t\tfor(int i=0;i<nums.length-1;i++){\n\t\t\tif(flag){\n\t\t\t\tif(nums[i]>nums[i+1]) return false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(nums[i]<nums[i+1]) return false;\n\t\t\t}\n\t\t\tflag=!flag;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2214",
    "source": "leetcode",
    "language": "java",
    "query": "For each person i, preferences[i] contains a list of friends sorted in the order of preference. Friends in each list are denoted by integers from 0 to n-1. A friend x is unhappy if x is paired with y and there exists a friend u who is paired. with v but: X prefers u over y, and u prefers x over v.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[][] preferences = new int[n][n];\n\t\tpreferences[0] = new int[]{1, 2, 3, 4, 0};\n\t\tpreferences[1] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[2] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[3] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[4] = new int[]{0, 1, 2, 3, 4};\n\t\tint[][] pairs = match(preferences);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(pairs[i][0] + \" \" + pairs[i][1]);\n\t\t}\n\t}\n\tpublic static int[][] match(int[][] preferences){\n\t\tint n = preferences.length;\n\t\tint[][] pairs = new int[n][2];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tpairs[i][0] = i;\n\t\t\tpairs[i][1] = -1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pairs[i][1] == -1 && preferences[i][j] == i){\n\t\t\t\t\tpairs[i][1] = j;\n\t\t\t\t\tpairs[j][1] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(pairs[i][1] == -1){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(pairs[j][1] == -1\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[][] preferences = new int[n][n];\n\t\tpreferences[0] = new int[]{1, 2, 3, 4, 0};\n\t\tpreferences[1] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[2] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[3] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[4] = new int[]{0, 1, 2, 3, 4};\n\t\tint[][] pairs = new int[n][2];\n\t\tint[] result = new int[n];\n\t\tint[] result2 = new int[n];\n\t\tresult = match(preferences, pairs);\n\t\tresult2 = match2(preferences, pairs);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(result2[i]);\n\t\t}\n\t}\n\tpublic static int[] match(int[][] preferences, int[][] pairs){\n\t\tint n = preferences.length;\n\t\tint[] result = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tresult[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(result[preferences[i][j]] == -1){\n\t\t\t\t\tresult[preferences[i][j]] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static int[] match2(int[][] preferences, int[][] pairs){\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[][] preferences = new int[n][n];\n\t\tpreferences[0] = new int[]{1, 2, 3, 4, 0};\n\t\tpreferences[1] = new int[]{2, 3, 4, 0, 1};\n\t\tpreferences[2] = new int[]{3, 4, 0, 1, 2};\n\t\tpreferences[3] = new int[]{4, 0, 1, 2, 3};\n\t\tpreferences[4] = new int[]{0, 1, 2, 3, 4};\n\t\tSystem.out.println(Arrays.toString(preferences));\n\t\tint[] result = new int[n];\n\t\tresult = stableMatching(preferences);\n\t\tSystem.out.println(Arrays.toString(result));\n\t}\n\tpublic static int[] stableMatching(int[][] preferences){\n\t\tint n = preferences.length;\n\t\tint[] result = new int[n];\n\t\tint[] match = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmatch[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(match[i] == -1){\n\t\t\t\tresult[i] = match[preferences[i][0]];\n\t\t\t\tmatch[preferences[i][0]] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(result[i] == -1){\n\t\t\t\tint j = 0;\n\t\t\t\twhile(match[preferences[i][j]] != -1){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tresult[i] = match[preferences[i][j]];\n\t\t\t\tmatch[preferences[i][j]] = i;\n\t\t\t}\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[][] preferences = new int[n][n];\n\t\tpreferences[0] = new int[]{1, 2, 3, 4};\n\t\tpreferences[1] = new int[]{0, 2, 3, 4};\n\t\tpreferences[2] = new int[]{0, 1, 3, 4};\n\t\tpreferences[3] = new int[]{0, 1, 2, 4};\n\t\tpreferences[4] = new int[]{0, 1, 2, 3};\n\t\tint[][] pairs = new int[n][2];\n\t\tint[] result = new int[n];\n\t\tint[] result2 = new int[n];\n\t\tint[] result3 = new int[n];\n\t\tint[] result4 = new int[n];\n\t\tint[] result5 = new int[n];\n\t\tint[] result6 = new int[n];\n\t\tint[] result7 = new int[n];\n\t\tint[] result8 = new int[n];\n\t\tint[] result9 = new int[n];\n\t\tint[] result10 = new int[n];\n\t\tint[] result11 = new int[n];\n\t\tint[] result12 = new int[n];\n\t\tint[] result13 = new int[n];\n\t\tint[] result14 = new int[n];\n\t\tint[] result15 = new int[n];\n\t\tint[] result16 = new int[n];\n\t\tint[] result17 = new int[n];\n\t\tint[] result18 = new int[n];\n\t\tint[] result19 = new int[n];\n\t\tint[] result20 = new int[n];\n\t\tint[] result21 = new int[n];\n\t\tint[] result22 = new int[n];\n\t\tint[] result23 = new int[n];\n\t\tint[] result24 = new int[n];\n\t\tint[] result25 = new int[n];\n\t\tint[] result26 = new int[n];\n",
        "\tstatic void main(String[] args){\n\t\tint n = 5;\n\t\tint[][] preferences = new int[n][n];\n\t\tpreferences[0] = new int[]{1, 2, 3, 4, 0};\n\t\tpreferences[1] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[2] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[3] = new int[]{0, 1, 2, 3, 4};\n\t\tpreferences[4] = new int[]{0, 1, 2, 3, 4};\n\t\tint[][] pairs = new int[n][2];\n\t\tint[] result = new int[n];\n\t\tint[] result2 = new int[n];\n\t\tresult = solution(n, preferences);\n\t\tresult2 = solution2(n, preferences);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(result[i]);\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tSystem.out.println(result2[i]);\n\t\t}\n\t}\n\tpublic static int[] solution(int n, int[][] preferences){\n\t\tint[] result = new int[n];\n\t\tint[] count = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tresult[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(result[preferences[i][j]] == -1){\n\t\t\t\t\tresult[preferences[i][j]] = i;\n\t\t\t\t\tcount[preferences[i][j]] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if(result[preferences[i][j]] == i){\n",
        "\tvoid solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tint[][] preferences = new int[n][];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpreferences[i] = in.nextIntArray(m);\n\t\t}\n\t\tint[] result = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tresult[i] = i;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tint x = preferences[i][j];\n\t\t\t\tint y = result[x];\n\t\t\t\tif (x != y) {\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tint u = preferences[x][j - 1];\n\t\t\t\t\t\tint v = preferences[y][j - 1];\n\t\t\t\t\t\tif (u == x) {\n\t\t\t\t\t\t\tresult[x] = y;\n\t\t\t\t\t\t\tresult[y] = x;\n\t\t\t\t\t\t} else if (v == y) {\n\t\t\t\t\t\t\tresult[x] = y;\n\t\t\t\t\t\t\tresult[y] = x;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[x] = y;\n\t\t\t\t\t\tresult[y] = x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print(result[i] + \" \");\n\t\t}\n\t\tout.println();\n\t}\n}\n",
        "\tstatic int unhappyFriends(int n, int[][] preferences){\n\t\tint unhappy = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tif(preferences[i][j] < preferences[i][preferences[i].length - 1] && preferences[i][j] < preferences[j][preferences[j].length - 1]){\n\t\t\t\t\t\tunhappy++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn unhappy;\n\t}\n}\n",
        "\tstatic int unhappyFriends(int n, int[][] preferences) {\n\t\tint unhappy = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(preferences[i][j] == i){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(preferences[i][j] == j){\n\t\t\t\t\tunhappy++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn unhappy;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2215",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, return any array containing n unique integers such that they add up to 0.",
    "snippets": [
        "\tArrayList<Integer> sumZero(int n) {\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tif(n == 1){\n\t\t\tlist.add(0);\n\t\t\treturn list;\n\t\t}\n\t\tint i = 1;\n\t\twhile(i <= n/2){\n\t\t\tlist.add(i);\n\t\t\tlist.add(-i);\n\t\t\ti++;\n\t\t}\n\t\tif(n%2 == 1){\n\t\t\tlist.add(0);\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<List<Integer>> sumZero(int n) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(n == 0){\n\t\t\tresult.add(new ArrayList<Integer>());\n\t\t\treturn result;\n\t\t}\n\t\tif(n == 1){\n\t\t\tresult.add(Arrays.asList(-1));\n\t\t\tresult.add(Arrays.asList(1));\n\t\t\treturn result;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tList<List<Integer>> temp = sumZero(n - 1);\n\t\t\tfor(List<Integer> list : temp){\n\t\t\t\tlist.add(i);\n\t\t\t\tresult.add(list);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> sumZero(int n) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(n == 0){\n\t\t\tresult.add(new ArrayList<Integer>());\n\t\t\treturn result;\n\t\t}\n\t\tint[] nums = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnums[i] = i * 2 - n;\n\t\t}\n\t\thelper(nums, 0, new ArrayList<Integer>(), result);\n\t\treturn result;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> result){\n\t\tif(index == nums.length){\n\t\t\tif(list.get(0) == 0){\n\t\t\t\tresult.add(new ArrayList<Integer>(list));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlist.add(nums[index]);\n\t\thelper(nums, index + 1, list, result);\n\t\tlist.remove(list.size() - 1);\n\t\thelper(nums, index + 1, list, result);\n\t}\n}\n",
        "\tList<List<Integer>> sumZero(int n) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(n == 1){\n\t\t\tresult.add(Arrays.asList(-1));\n\t\t\treturn result;\n\t\t}\n\t\tint[] nums = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnums[i] = i + 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\tint target = sum / 2;\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile(i < j){\n\t\t\tif(nums[i] + nums[j] == target){\n\t\t\t\tList<Integer> temp = new ArrayList<Integer>();\n\t\t\t\ttemp.add(nums[i]);\n\t\t\t\ttemp.add(nums[j]);\n\t\t\t\tresult.add(temp);\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\telse if(nums[i] + nums[j] < target){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] sumZero(int n) {\n\t\tint[] result = new int[n];\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile (i < j) {\n\t\t\tresult[i] = i + 1;\n\t\t\tresult[j] = -(i + 1);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\tif (i == j) {\n\t\t\tresult[i] = 0;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<List<Integer>> sumZero(int n) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(n == 0){\n\t\t\tres.add(new ArrayList<Integer>());\n\t\t\treturn res;\n\t\t}\n\t\tint[] nums = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnums[i] = i + 1;\n\t\t}\n\t\thelper(nums, 0, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int start, List<Integer> list, List<List<Integer>> res){\n\t\tif(start == nums.length){\n\t\t\tif(list.get(0) == 0){\n\t\t\t\tres.add(new ArrayList<Integer>(list));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, i + 1, list, res);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> sumZero(int n) {\n\t\tList<List<Integer>> res = new ArrayList<>();\n\t\tif(n == 0) return res;\n\t\tif(n == 1){\n\t\t\tres.add(Arrays.asList(0));\n\t\t\treturn res;\n\t\t}\n\t\tif(n == 2){\n\t\t\tres.add(Arrays.asList(-1,1));\n\t\t\tres.add(Arrays.asList(1,-1));\n\t\t\treturn res;\n\t\t}\n\t\tint[] nums = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tnums[i] = i * 2 - n + 1;\n\t\t}\n\t\thelper(res, nums, 0, 0);\n\t\treturn res;\n\t}\n\tpublic void helper(List<List<Integer>> res, int[] nums, int start, int sum){\n\t\tif(sum == 0){\n\t\t\tList<Integer> list = new ArrayList<>();\n\t\t\tfor(int i = start; i < nums.length; i++){\n\t\t\t\tlist.add(nums[i]);\n\t\t\t}\n\t\t\tres.add(list);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tif(i > start && nums[i] == nums[i-1]) continue;\n\t\t\thelper(res, nums, i+1, sum - nums[i]);\n\t\t}\n\t}\n}\n",
        "\tstatic int[] sumZero(int n) {\n\t\tint[] result = new int[n];\n\t\tint i = 0;\n\t\twhile(i < n){\n\t\t\tresult[i] = i+1;\n\t\t\ti++;\n\t\t}\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tresult[j] = -result[j];\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2216",
    "source": "leetcode",
    "language": "java",
    "query": "The deletion can be divided into two stages:Search for a node to remove. If the node is found, delete the node. Return the root node reference (possibly updated) of the BST.",
    "snippets": [
        "\tNode deleteNode(Node root, int key) {\n\t\tif(root == null) return root;\n\t\tif(key < root.val) root.left = deleteNode(root.left, key);\n\t\telse if(key > root.val) root.right = deleteNode(root.right, key);\n\t\telse{\n\t\t\tif(root.left == null) return root.right;\n\t\t\telse if(root.right == null) return root.left;\n\t\t\telse{\n\t\t\t\tNode temp = root.right;\n\t\t\t\twhile(temp.left != null) temp = temp.left;\n\t\t\t\troot.val = temp.val;\n\t\t\t\troot.right = deleteNode(root.right, temp.val);\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tNode delete(Node root, int data){\n\t\tif(root == null){\n\t\t\treturn root;\n\t\t}\n\t\tif(data < root.data){\n\t\t\troot.left = delete(root.left, data);\n\t\t}else if(data > root.data){\n\t\t\troot.right = delete(root.right, data);\n\t\t}else{\n\t\t\tif(root.left == null){\n\t\t\t\treturn root.right;\n\t\t\t}else if(root.right == null){\n\t\t\t\treturn root.left;\n\t\t\t}\n\t\t\troot.data = minValue(root.right);\n\t\t\troot.right = delete(root.right, root.data);\n\t\t}\n\t\treturn root;\n\t}\n\tpublic int minValue(Node root){\n\t\tint minval = root.data;\n\t\twhile(root.left != null){\n\t\t\tminval = root.left.data;\n\t\t\troot = root.left;\n\t\t}\n\t\treturn minval;\n\t}\n}\n",
        "\tTreeNode deleteNode(TreeNode root, int key) {\n\t\tif(root == null) return null;\n\t\tif(root.val == key){\n\t\t\tif(root.left == null) return root.right;\n\t\t\tif(root.right == null) return root.left;\n\t\t\tTreeNode min = findMin(root.right);\n\t\t\troot.val = min.val;\n\t\t\troot.right = deleteNode(root.right, min.val);\n\t\t\treturn root;\n\t\t}\n\t\tif(root.val > key) root.left = deleteNode(root.left, key);\n\t\telse root.right = deleteNode(root.right, key);\n\t\treturn root;\n\t}\n\tpublic TreeNode findMin(TreeNode root){\n\t\tif(root.left == null) return root;\n\t\treturn findMin(root.left);\n\t}\n}\n",
        "\tNode delete(Node root, int data){\n\t\tif(root == null)\n\t\t\treturn root;\n\t\tif(data < root.data)\n\t\t\troot.left = delete(root.left, data);\n\t\telse if(data > root.data)\n\t\t\troot.right = delete(root.right, data);\n\t\telse{\n\t\t\tif(root.left == null)\n\t\t\t\treturn root.right;\n\t\t\telse if(root.right == null)\n\t\t\t\treturn root.left;\n\t\t\troot.data = minValue(root.right);\n\t\t\troot.right = delete(root.right, root.data);\n\t\t}\n\t\treturn root;\n\t}\n\tpublic int minValue(Node root){\n\t\tint minval = root.data;\n\t\twhile(root.left != null){\n\t\t\tminval = root.left.data;\n\t\t\troot = root.left;\n\t\t}\n\t\treturn minval;\n\t}\n}\n",
        "\tNode deleteNode(Node root, int key) {\n\t\tif (root == null) return root;\n\t\tif (key < root.key) root.left = deleteNode(root.left, key);\n\t\telse if (key > root.key) root.right = deleteNode(root.right, key);\n\t\telse {\n\t\t\tif (root.left == null) return root.right;\n\t\t\tif (root.right == null) return root.left;\n\t\t\troot.key = minValue(root.right);\n\t\t\troot.right = deleteNode(root.right, root.key);\n\t\t}\n\t\treturn root;\n\t}\n\tpublic int minValue(Node root) {\n\t\tint minval = root.key;\n\t\twhile (root.left != null) {\n\t\t\tminval = root.left.key;\n\t\t\troot = root.left;\n\t\t}\n\t\treturn minval;\n\t}\n}\n",
        "\tNode delete(Node root, int data){\n\t\tif(root == null) return root;\n\t\tif(data < root.data) root.left = delete(root.left, data);\n\t\telse if(data > root.data) root.right = delete(root.right, data);\n\t\telse{\n\t\t\tif(root.left == null) return root.right;\n\t\t\telse if(root.right == null) return root.left;\n\t\t\telse{\n\t\t\t\tNode temp = root.right;\n\t\t\t\twhile(temp.left != null) temp = temp.left;\n\t\t\t\troot.data = temp.data;\n\t\t\t\troot.right = delete(root.right, temp.data);\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n}\n",
        "\tNode delete(Node root, int key) {\n\t\tif (root == null) return root;\n\t\tif (key < root.key) root.left = delete(root.left, key);\n\t\telse if (key > root.key) root.right = delete(root.right, key);\n\t\telse {\n\t\t\tif (root.left == null) return root.right;\n\t\t\telse if (root.right == null) return root.left;\n\t\t\troot.key = minValue(root.right);\n\t\t\troot.right = delete(root.right, root.key);\n\t\t}\n\t\treturn root;\n\t}\n\tpublic int minValue(Node root) {\n\t\tint minval = root.key;\n\t\twhile (root.left != null) {\n\t\t\tminval = root.left.key;\n\t\t\troot = root.left;\n\t\t}\n\t\treturn minval;\n\t}\n}\n",
        "\tBinaryTreeNode<Integer> deleteNode(BinaryTreeNode<Integer> root, int key) {\n\t\tif(root == null) return null;\n\t\tif(root.data == key){\n\t\t\tif(root.left == null && root.right == null) return null;\n\t\t\tif(root.left == null) return root.right;\n\t\t\tif(root.right == null) return root.left;\n\t\t\troot.data = findMin(root.right);\n\t\t}\n\t\troot.left = deleteNode(root.left, key);\n\t\troot.right = deleteNode(root.right, key);\n\t\treturn root;\n\t}\n\tpublic int findMin(BinaryTreeNode<Integer> root){\n\t\tif(root.left == null) return root.data;\n\t\treturn findMin(root.left);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2217",
    "source": "leetcode",
    "language": "java",
    "query": "A segment is defined to be a contiguous sequence of non-space characters. Given a string s, return the number of segments in the string.",
    "snippets": [
        "\tint countSegments(String s) {\n\t\tint count = 0;\n\t\tboolean flag = false;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) != ' '){\n\t\t\t\tif(flag == false){\n\t\t\t\t\tcount++;\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSegments(String s) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) != ' '){\n\t\t\t\tcount++;\n\t\t\t\twhile(i < s.length() && s.charAt(i) != ' '){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSegments(String s) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == ' '){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t\twhile(i < s.length() && s.charAt(i) != ' '){\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSegments(String s) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) != ' '){\n\t\t\t\tcount++;\n\t\t\t\twhile(i < s.length() && s.charAt(i) != ' ')\n\t\t\t\t\ti++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2218",
    "source": "leetcode",
    "language": "java",
    "query": "Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that: a < b < c < d.",
    "snippets": [
        "\tint fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n\t\tint count = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int a : A) {\n\t\t\tfor (int b : B) {\n\t\t\t\tmap.put(a + b, map.getOrDefault(a + b, 0) + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int c : C) {\n\t\t\tfor (int d : D) {\n\t\t\t\tcount += map.getOrDefault(-(c + d), 0);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n\t\tint res = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int a : A) {\n\t\t\tfor (int b : B) {\n\t\t\t\tmap.put(a + b, map.getOrDefault(a + b, 0) + 1);\n\t\t\t}\n\t\t}\n\t\tfor (int c : C) {\n\t\t\tfor (int d : D) {\n\t\t\t\tres += map.getOrDefault(-(c + d), 0);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countQuadruplets(int[] nums) {\n\t\tint count = 0;\n\t\tint n = nums.length;\n\t\tArrays.sort(nums);\n\t\tfor (int i = 0; i < n - 3; i++) {\n\t\t\tfor (int j = i + 1; j < n - 2; j++) {\n\t\t\t\tint k = j + 1;\n\t\t\t\tint l = n - 1;\n\t\t\t\twhile (k < l) {\n\t\t\t\t\tif (nums[i] + nums[j] + nums[k] + nums[l] == 0) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t\tl--;\n\t\t\t\t\t} else if (nums[i] + nums[j] + nums[k] + nums[l] < 0) {\n\t\t\t\t\t\tk++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tl--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint count(int[] nums) {\n\t\tint n = nums.length;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tfor (int k = j + 1; k < n; k++) {\n\t\t\t\t\tfor (int l = k + 1; l < n; l++) {\n\t\t\t\t\t\tif (nums[i] < nums[j] && nums[j] < nums[k] && nums[k] < nums[l]) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint count(int[] nums) {\n\t\tint n = nums.length;\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n - 3; i++) {\n\t\t\tfor (int j = i + 1; j < n - 2; j++) {\n\t\t\t\tfor (int k = j + 1; k < n - 1; k++) {\n\t\t\t\t\tfor (int l = k + 1; l < n; l++) {\n\t\t\t\t\t\tif (nums[i] < nums[j] && nums[j] < nums[k] && nums[k] < nums[l]) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countQuadruplets(int[] nums) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tfor (int k = j + 1; k < nums.length; k++) {\n\t\t\t\t\tfor (int l = k + 1; l < nums.length; l++) {\n\t\t\t\t\t\tif (nums[i] + nums[j] + nums[k] + nums[l] == 0) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint count(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] count = new int[n];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (nums[i] > nums[j]) {\n\t\t\t\t\tcount[i] += count[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tfor (int k = 0; k < j; k++) {\n\t\t\t\t\tif (nums[i] > nums[j] && nums[j] > nums[k]) {\n\t\t\t\t\t\tres += count[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2219",
    "source": "leetcode",
    "language": "java",
    "query": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
    "snippets": [
        "\tstatic boolean isPalindrome(String s){\n\t\tString s1 = s.toLowerCase();\n\t\tString s2 = \"\";\n\t\tfor(int i = 0; i < s1.length(); i++){\n\t\t\tif(s1.charAt(i) >= 'a' && s1.charAt(i) <= 'z'){\n\t\t\t\ts2 += s1.charAt(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < s2.length() / 2; i++){\n\t\t\tif(s2.charAt(i) != s2.charAt(s2.length() - i - 1)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPalindrome(String s){\n\t\tString str = s.toLowerCase();\n\t\tstr = str.replaceAll(\"[^a-zA-Z0-9]\", \"\");\n\t\tint i = 0;\n\t\tint j = str.length()-1;\n\t\twhile(i<j){\n\t\t\tif(str.charAt(i)!=str.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPalindrome(String s){\n\t\tString str = s.toLowerCase();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\tif(str.charAt(i) >= 'a' && str.charAt(i) <= 'z'){\n\t\t\t\tsb.append(str.charAt(i));\n\t\t\t}\n\t\t}\n\t\tstr = sb.toString();\n\t\tfor(int i = 0; i < str.length()/2; i++){\n\t\t\tif(str.charAt(i) != str.charAt(str.length()-1-i)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPalindrome(String s){\n\t\tString str = s.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\t\tint i = 0;\n\t\tint j = str.length() - 1;\n\t\twhile(i < j){\n\t\t\tif(str.charAt(i) != str.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPalindrome(String phrase){\n\t\tString clean = phrase.replaceAll(\"[^a-zA-Z0-9]\", \"\").toLowerCase();\n\t\treturn clean.equals(new StringBuilder(clean).reverse().toString());\n\t}\n}\n",
        "\tstatic boolean isPalindrome(String s){\n\t\tString str = s.toLowerCase().replaceAll(\"[^a-zA-Z0-9]\", \"\");\n\t\tint i = 0;\n\t\tint j = str.length() - 1;\n\t\twhile(i < j){\n\t\t\tif(str.charAt(i) != str.charAt(j)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPalindrome(String phrase){\n\t\tString lower = phrase.toLowerCase();\n\t\tString alpha = lower.replaceAll(\"[^a-zA-Z0-9]\", \"\");\n\t\treturn alpha.equals(new StringBuilder(alpha).reverse().toString());\n\t}\n}\n",
        "\tstatic boolean isPalindrome(String s){\n\t\tif(s.length()==0) return true;\n\t\tString str=s.toLowerCase();\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0;i<str.length();i++){\n\t\t\tif(str.charAt(i)>='a'&&str.charAt(i)<='z'){\n\t\t\t\tsb.append(str.charAt(i));\n\t\t\t}\n\t\t}\n\t\tstr=sb.toString();\n\t\tfor(int i=0;i<str.length()/2;i++){\n\t\t\tif(str.charAt(i)!=str.charAt(str.length()-1-i)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2220",
    "source": "leetcode",
    "language": "java",
    "query": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, \"()\", \"(())()\", and \"(()(()))\" are all valid parenthesesstrings.",
    "snippets": [
        "\tboolean isValid(String s){\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{'){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')') return false;\n\t\t\t\tif(c=='['&&s.charAt(i)!=']') return false;\n\t\t\t\tif(c=='{'&&s.charAt(i)!='}') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s){\n\t\tif(s.length()==0) return true;\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{'){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')'||c=='['&&s.charAt(i)!=']'||c=='{'&&s.charAt(i)!='}') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s == null || s.length() == 0) return true;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{'){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}else{\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c == '(' && s.charAt(i) != ')'){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(c == '[' && s.charAt(i) != ']'){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(c == '{' && s.charAt(i) != '}'){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s) {\n\t\tif(s == null || s.length() == 0) return true;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{'){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}else{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c == '(' && s.charAt(i) != ')') return false;\n\t\t\t\tif(c == '[' && s.charAt(i) != ']') return false;\n\t\t\t\tif(c == '{' && s.charAt(i) != '}') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s){\n\t\tif(s == null || s.length() == 0){\n\t\t\treturn true;\n\t\t}\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(c == '(' || c == '[' || c == '{'){\n\t\t\t\tstack.push(c);\n\t\t\t}else{\n\t\t\t\tif(stack.isEmpty()){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tchar top = stack.pop();\n\t\t\t\tif(c == ')' && top != '('){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(c == ']' && top != '['){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif(c == '}' && top != '{'){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s){\n\t\tif(s==null||s.length()==0)\n\t\t\treturn true;\n\t\tStack<Character> stack=new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tif(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{')\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty())\n\t\t\t\t\treturn false;\n\t\t\t\tchar c=stack.pop();\n\t\t\t\tif(c=='('&&s.charAt(i)!=')'||c=='['&&s.charAt(i)!=']'||c=='{'&&s.charAt(i)!='}')\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s){\n\t\tif(s.length() == 0) return true;\n\t\tif(s.length() % 2 != 0) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{'){\n\t\t\t\tstack.push(s.charAt(i));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar c = stack.pop();\n\t\t\t\tif(c == '(' && s.charAt(i) != ')') return false;\n\t\t\t\tif(c == '[' && s.charAt(i) != ']') return false;\n\t\t\t\tif(c == '{' && s.charAt(i) != '}') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n",
        "\tboolean isValid(String s){\n\t\tif(s.length()%2==1) return false;\n\t\tStack<Character> stack = new Stack<Character>();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(c=='('||c=='['||c=='{'){\n\t\t\t\tstack.push(c);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(stack.isEmpty()) return false;\n\t\t\t\tchar top = stack.pop();\n\t\t\t\tif(c==')'&&top!='(') return false;\n\t\t\t\tif(c==']'&&top!='[') return false;\n\t\t\t\tif(c=='}'&&top!='{') return false;\n\t\t\t}\n\t\t}\n\t\treturn stack.isEmpty();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2221",
    "source": "leetcode",
    "language": "java",
    "query": "There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character.",
    "snippets": [
        "\tvoid method(String s){\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n}\n",
        "\tvoid method(String s){\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid method(String s){\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == 'a'){\n\t\t\t\tSystem.out.println(\"a\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'b'){\n\t\t\t\tSystem.out.println(\"b\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'c'){\n\t\t\t\tSystem.out.println(\"c\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'd'){\n\t\t\t\tSystem.out.println(\"d\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'e'){\n\t\t\t\tSystem.out.println(\"e\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'f'){\n\t\t\t\tSystem.out.println(\"f\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'g'){\n\t\t\t\tSystem.out.println(\"g\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'h'){\n\t\t\t\tSystem.out.println(\"h\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'i'){\n\t\t\t\tSystem.out.println(\"i\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'j'){\n\t\t\t\tSystem.out.println(\"j\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(s.charAt(i) == 'k'){\n\t\t\t\tSystem.out.println(\"k\");\n",
        "\tvoid print(char[] str){\n\t\tint i = 0;\n\t\twhile(i < str.length){\n\t\t\tif(str[i] == 'a'){\n\t\t\t\tSystem.out.println(str[i]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid method(char c){\n\t\tif(c=='a'){\n\t\t\tSystem.out.println(\"a\");\n\t\t}\n\t\tif(c=='b'){\n\t\t\tSystem.out.println(\"b\");\n\t\t}\n\t\tif(c=='c'){\n\t\t\tSystem.out.println(\"c\");\n\t\t}\n\t\tif(c=='d'){\n\t\t\tSystem.out.println(\"d\");\n\t\t}\n\t\tif(c=='e'){\n\t\t\tSystem.out.println(\"e\");\n\t\t}\n\t\tif(c=='f'){\n\t\t\tSystem.out.println(\"f\");\n\t\t}\n\t\tif(c=='g'){\n\t\t\tSystem.out.println(\"g\");\n\t\t}\n\t\tif(c=='h'){\n\t\t\tSystem.out.println(\"h\");\n\t\t}\n\t\tif(c=='i'){\n\t\t\tSystem.out.println(\"i\");\n\t\t}\n\t\tif(c=='j'){\n\t\t\tSystem.out.println(\"j\");\n\t\t}\n\t\tif(c=='k'){\n\t\t\tSystem.out.println(\"k\");\n\t\t}\n\t\tif(c=='l'){\n\t\t\tSystem.out.println(\"l\");\n\t\t}\n\t\tif(c=='m'){\n\t\t\tSystem.out.println(\"m\");\n\t\t}\n\t\tif(c=='n'){\n\t\t\tSystem.out.println(\"n\");\n\t\t}\n\t\tif(c=='o'){\n\t\t\tSystem.out.println(\"o\");\n\t\t}\n\t\tif(c=='p'){\n\t\t\tSystem.out.println(\"p\");\n\t\t}\n\t\tif(c=='q'){\n\t\t\tSystem.out.println(\"q\");\n\t\t}\n\t\tif(c=='r'){\n\t\t\tSystem.out.println(\"r\");\n\t\t}\n\t\tif(c\n",
        "\tvoid print(char[] str){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < str.length){\n\t\t\tif(str[i] == ' '){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(j < str.length){\n\t\t\t\t\tif(str[j] == str[i]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j == str.length){\n\t\t\t\t\tSystem.out.print(str[i]);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid method(String s){\n\t\tchar[] c = s.toCharArray();\n\t\tint i = 0;\n\t\twhile(i < c.length){\n\t\t\tif(c[i] == 'a'){\n\t\t\t\tSystem.out.print(\"a\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'b'){\n\t\t\t\tSystem.out.print(\"ab\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'c'){\n\t\t\t\tSystem.out.print(\"abc\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'd'){\n\t\t\t\tSystem.out.print(\"abcd\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'e'){\n\t\t\t\tSystem.out.print(\"abcde\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'f'){\n\t\t\t\tSystem.out.print(\"abcdef\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'g'){\n\t\t\t\tSystem.out.print(\"abcdefg\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'h'){\n\t\t\t\tSystem.out.print(\"abcdefgh\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'i'){\n\t\t\t\tSystem.out.print(\"abcdefghi\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'j'){\n\t\t\t\tSystem.out.print(\"abcdefghij\");\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if(c[i] == 'k'){\n\t\t\t\tSystem.out.print(\"abcdefghijk\");\n\t\t\t\ti\n",
        "\tvoid print(char[] str){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < str.length){\n\t\t\tif(str[i] == ' '){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(j < str.length){\n\t\t\t\t\tif(str[j] == str[i]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j == str.length){\n\t\t\t\t\tSystem.out.print(str[i]);\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid method(char[] str){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint c = 0;\n\t\tint d = 0;\n\t\tint e = 0;\n\t\tint f = 0;\n\t\tint g = 0;\n\t\tint h = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n\t\tint r = 0;\n\t\tint s = 0;\n\t\tint t = 0;\n\t\tint u = 0;\n\t\tint v = 0;\n\t\tint w = 0;\n\t\tint x = 0;\n\t\tint y = 0;\n\t\tint z = 0;\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint c = 0;\n\t\tint d = 0;\n\t\tint e = 0;\n\t\tint f = 0;\n\t\tint g = 0;\n\t\tint h = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\tint m = 0;\n\t\tint n = 0;\n\t\tint o = 0;\n\t\tint p = 0;\n\t\tint q = 0;\n"
    ],
    "results": 10
},{
    "id": "2222",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array nums and an integer k. Append k unique positive integers that do not appear in nums to nums such that the resulting total sum is minimum. Return the sum of the k integers appended tonums.",
    "snippets": [
        "\tint appendK(int[] nums, int k){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\tint target = sum + k * (k + 1) / 2;\n\t\tint[] nums2 = new int[target];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tnums2[nums[i]] = 1;\n\t\t}\n\t\tfor(int i = 1; i <= k; i++){\n\t\t\tif(nums2[i] == 0){\n\t\t\t\tnums2[i] = 1;\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums2.length; i++){\n\t\t\tif(nums2[i] == 1){\n\t\t\t\tnums[i] = i;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint appendK(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tmin = Math.min(min, sum + i + 1);\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint appendK(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t}\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i <= k; i++) {\n\t\t\tif (sum + i <= min) {\n\t\t\t\tmin = sum + i;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint appendK(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\tint min = sum;\n\t\tfor(int i = 1; i <= k; i++){\n\t\t\tif(sum + i > min){\n\t\t\t\tmin = sum + i;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minSum(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] nums2 = new int[nums.length + k];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tnums2[i] = nums[i];\n\t\t\tsum += nums[i];\n\t\t}\n\t\tArrays.sort(nums2);\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tmin = Math.min(min, nums2[i]);\n\t\t}\n\t\treturn sum + min * k;\n\t}\n}\n",
        "\tint appendK(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint[] temp = new int[nums.length + k];\n\t\twhile(i < nums.length && j < k){\n\t\t\tif(nums[i] > 0){\n\t\t\t\ttemp[j] = nums[i];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\twhile(j < k){\n\t\t\ttemp[j] = j + 1;\n\t\t\tj++;\n\t\t}\n\t\tfor(int x = 0; x < temp.length; x++){\n\t\t\tsum += temp[x];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint minSum(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] nums2 = new int[nums.length + k];\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tnums2[i] = nums[i];\n\t\t}\n\t\tfor (int i = nums.length; i < nums2.length; i++) {\n\t\t\tnums2[i] = i + 1;\n\t\t}\n\t\tArrays.sort(nums2);\n\t\tfor (int i = 0; i < nums2.length; i++) {\n\t\t\tsum += nums2[i];\n\t\t\tif (sum > min) {\n\t\t\t\tsum -= nums2[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin = Math.min(min, sum);\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint minsum(int[] nums, int k){\n\t\tint sum = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] temp = new int[nums.length + k];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\ttemp[i] = nums[i];\n\t\t}\n\t\tfor(int i = nums.length; i < temp.length; i++){\n\t\t\ttemp[i] = i + 1;\n\t\t}\n\t\tArrays.sort(temp);\n\t\tfor(int i = 0; i < temp.length; i++){\n\t\t\tif(temp[i] > 0){\n\t\t\t\tsum += temp[i];\n\t\t\t}\n\t\t\tif(sum > min){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmin = sum;\n\t\t}\n\t\treturn min;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2223",
    "source": "leetcode",
    "language": "java",
    "query": "A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Given the root of a binary tree, return its maximum depth.",
    "snippets": [
        "\tint maxDepth(TreeNode root) {\n\t\tif(root == null) return 0;\n\t\tint left = maxDepth(root.left);\n\t\tint right = maxDepth(root.right);\n\t\treturn Math.max(left, right) + 1;\n\t}\n}\n",
        "\tint maxDepth(TreeNode root) {\n\t\tif(root == null) return 0;\n\t\treturn Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2224",
    "source": "leetcode",
    "language": "java",
    "query": "There are n points on a road you are driving your taxi on. You want to drive from point 1 to point n to make money by picking up passengers. The passengers are represented by a 0-indexed 2D integer array rides.",
    "snippets": [
        "\tint maxProfit(int[] prices) {\n\t\tint max = 0;\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tmin = Math.min(min, prices[i]);\n\t\t\tmax = Math.max(max, prices[i] - min);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tfor(int j = i + 1; j < prices.length; j++){\n\t\t\t\tint profit = prices[j] - prices[i];\n\t\t\t\tif(profit > max){\n\t\t\t\t\tmax = profit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tfor(int j = i + 1; j < prices.length; j++){\n\t\t\t\tif(prices[j] - prices[i] > max){\n\t\t\t\t\tmax = prices[j] - prices[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint maxProfit = 0;\n\t\tint minPrice = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < prices.length; i++){\n\t\t\tminPrice = Math.min(minPrice, prices[i]);\n\t\t\tmaxProfit = Math.max(maxProfit, prices[i] - minPrice);\n\t\t}\n\t\treturn maxProfit;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint n = prices.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] - prices[i]);\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i; j < n; j++) {\n\t\t\t\tres = Math.max(res, dp[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint maxProfit(int[] prices) {\n\t\tint n = prices.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor(int len = 1; len < n; len++){\n\t\t\tfor(int i = 0; i < n - len; i++){\n\t\t\t\tint j = i + len;\n\t\t\t\tdp[i][j] = Integer.MIN_VALUE;\n\t\t\t\tfor(int k = i; k < j; k++){\n\t\t\t\t\tdp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[k + 1][j] + prices[i] * prices[k + 1] * prices[j + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2225",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
    "snippets": [
        "\tint rangeBitwiseAnd(int m, int n) {\n\t\tint i = 0;\n\t\twhile(m != n){\n\t\t\tm >>= 1;\n\t\t\tn >>= 1;\n\t\t\ti++;\n\t\t}\n\t\treturn m << i;\n\t}\n}\n",
        "\tstatic int rangeBitwiseAnd(int m, int n) {\n\t\tint i = 0;\n\t\twhile(m != n){\n\t\t\tm >>= 1;\n\t\t\tn >>= 1;\n\t\t\ti++;\n\t\t}\n\t\treturn m << i;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2226",
    "source": "leetcode",
    "language": "java",
    "query": "An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x. Given an integer n, return the smallest numericallybalanced number strictly greater than n.",
    "snippets": [
        "\tstatic int next(int n){\n\t\tint x = n+1;\n\t\twhile(!isBalanced(x)){\n\t\t\tx++;\n\t\t}\n\t\treturn x;\n\t}\n\tpublic static boolean isBalanced(int n){\n\t\tint[] digits = new int[10];\n\t\twhile(n>0){\n\t\t\tdigits[n%10]++;\n\t\t\tn/=10;\n\t\t}\n\t\tfor(int i=0;i<digits.length;i++){\n\t\t\tif(digits[i]==0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic int next(int n){\n\t\tint x = n+1;\n\t\twhile(!isBalanced(x)){\n\t\t\tx++;\n\t\t}\n\t\treturn x;\n\t}\n\tpublic static boolean isBalanced(int x){\n\t\tint[] digits = new int[10];\n\t\twhile(x>0){\n\t\t\tdigits[x%10]++;\n\t\t\tx/=10;\n\t\t}\n\t\tfor(int i=0;i<digits.length;i++){\n\t\t\tif(digits[i]!=0 && digits[i]!=1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic int next(int n){\n\t\tint x = n+1;\n\t\twhile(!isBalanced(x)){\n\t\t\tx++;\n\t\t}\n\t\treturn x;\n\t}\n\tpublic static boolean isBalanced(int x){\n\t\tint[] count = new int[10];\n\t\twhile(x>0){\n\t\t\tcount[x%10]++;\n\t\t\tx/=10;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]%2!=0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic int next(int n){\n\t\tint i=n+1;\n\t\twhile(true){\n\t\t\tif(isBalanced(i)){\n\t\t\t\treturn i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n\tpublic static boolean isBalanced(int n){\n\t\tint[] count=new int[10];\n\t\twhile(n>0){\n\t\t\tcount[n%10]++;\n\t\t\tn/=10;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]!=1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic int next(int n){\n\t\tint i=n+1;\n\t\twhile(!isBalanced(i)){\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}\n\tpublic static boolean isBalanced(int n){\n\t\tint[] count=new int[10];\n\t\twhile(n>0){\n\t\t\tcount[n%10]++;\n\t\t\tn/=10;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]%2!=0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic int next(int n){\n\t\tint x=n+1;\n\t\twhile(!isBalanced(x)){\n\t\t\tx++;\n\t\t}\n\t\treturn x;\n\t}\n\tpublic static boolean isBalanced(int n){\n\t\tint[] count=new int[10];\n\t\twhile(n>0){\n\t\t\tcount[n%10]++;\n\t\t\tn/=10;\n\t\t}\n\t\tfor(int i=0;i<count.length;i++){\n\t\t\tif(count[i]%2!=0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic int balancedNum(int n){\n\t\tint num = n+1;\n\t\twhile(!isBalanced(num)){\n\t\t\tnum++;\n\t\t}\n\t\treturn num;\n\t}\n\tpublic static boolean isBalanced(int num){\n\t\tint[] digits = new int[10];\n\t\twhile(num>0){\n\t\t\tdigits[num%10]++;\n\t\t\tnum/=10;\n\t\t}\n\t\tfor(int i=0;i<digits.length;i++){\n\t\t\tif(digits[i]%2!=0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic int next(int n) {\n\t\tint[] digits = new int[10];\n\t\tint num = n;\n\t\twhile(num > 0){\n\t\t\tdigits[num%10]++;\n\t\t\tnum /= 10;\n\t\t}\n\t\tint i = 0;\n\t\twhile(i < 10 && digits[i] == 0) i++;\n\t\tif(i == 10) return -1;\n\t\tint res = i;\n\t\tfor(int j = i+1; j < 10; j++){\n\t\t\tif(digits[j] > 0){\n\t\t\t\tres = res * 10 + j;\n\t\t\t\tdigits[j]--;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int next(int n){\n\t\tint i = n;\n\t\tint j = n;\n\t\tint count = 0;\n\t\tint count1 = 0;\n\t\tint count2 = 0;\n\t\tint count3 = 0;\n\t\tint count4 = 0;\n\t\tint count5 = 0;\n\t\tint count6 = 0;\n\t\tint count7 = 0;\n\t\tint count8 = 0;\n\t\tint count9 = 0;\n\t\twhile(i>0){\n\t\t\tint rem = i%10;\n\t\t\tif(rem==0){\n\t\t\t\tcount0++;\n\t\t\t}\n\t\t\tif(rem==1){\n\t\t\t\tcount1++;\n\t\t\t}\n\t\t\tif(rem==2){\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t\tif(rem==3){\n\t\t\t\tcount3++;\n\t\t\t}\n\t\t\tif(rem==4){\n\t\t\t\tcount4++;\n\t\t\t}\n\t\t\tif(rem==5){\n\t\t\t\tcount5++;\n\t\t\t}\n\t\t\tif(rem==6){\n\t\t\t\tcount6++;\n\t\t\t}\n\t\t\tif(rem==7){\n\t\t\t\tcount7++;\n\t\t\t}\n\t\t\tif(rem==8){\n\t\t\t\tcount8++;\n\t\t\t}\n\t\t\tif(rem==9){\n\t\t\t\tcount9++;\n\t\t\t}\n\t\t\ti=i/10;\n\t\t}\n\t\twhile(j>0){\n\t\t\tint rem = j%10;\n\t\t\tif(rem==0){\n\t\t\t\tcount0--;\n\t\t\t}\n\t\t\tif(rem==1){\n\t\t\t\tcount1--;\n\t\t\t}\n\t\t\tif(rem==2){\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t\tif(rem==3){\n\t\t\t\tcount3--;\n\t\t\t}\n\t\t\tif(\n"
    ],
    "results": 10
},{
    "id": "2227",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer total indicating the amount of money you have. You are also given two integers cost1 and cost2 indicating the price of a pen and pencil respectively. You can spend part or all of your money to buy multiple quantities of each kind of writing utensil.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint total = 10;\n\t\tint cost1 = 3;\n\t\tint cost2 = 5;\n\t\tint total1 = total/cost1;\n\t\tint total2 = total/cost2;\n\t\tint total3 = total%cost1;\n\t\tint total4 = total%cost2;\n\t\tSystem.out.println(\"You can buy \"+total1+\" pencils and \"+total2+\" pens.\");\n\t\tSystem.out.println(\"You can buy \"+total3+\" pencils and \"+total4+\" pens.\");\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint total = 10;\n\t\tint cost1 = 2;\n\t\tint cost2 = 3;\n\t\tint total1 = total/cost1;\n\t\tint total2 = total/cost2;\n\t\tint total3 = total%cost1;\n\t\tint total4 = total%cost2;\n\t\tSystem.out.println(\"You can buy \"+total1+\" pencils and \"+total2+\" pens.\");\n\t\tSystem.out.println(\"You can buy \"+total3+\" pencils and \"+total4+\" pens.\");\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint total = 10;\n\t\tint cost1 = 3;\n\t\tint cost2 = 5;\n\t\tint cost3 = 7;\n\t\tint cost4 = 9;\n\t\tint cost5 = 11;\n\t\tint cost6 = 13;\n\t\tint cost7 = 15;\n\t\tint cost8 = 17;\n\t\tint cost9 = 19;\n\t\tint cost10 = 21;\n\t\tint cost11 = 23;\n\t\tint cost12 = 25;\n\t\tint cost13 = 27;\n\t\tint cost14 = 29;\n\t\tint cost15 = 31;\n\t\tint cost16 = 33;\n\t\tint cost17 = 35;\n\t\tint cost18 = 37;\n\t\tint cost19 = 39;\n\t\tint cost20 = 41;\n\t\tint cost21 = 43;\n\t\tint cost22 = 45;\n\t\tint cost23 = 47;\n\t\tint cost24 = 49;\n\t\tint cost25 = 51;\n\t\tint cost26 = 53;\n\t\tint cost27 = 55;\n\t\tint cost28 = 57;\n\t\tint cost29 = 59;\n\t\tint cost30 = 61;\n\t\tint cost31 = 63;\n\t\tint cost32 = 65;\n\t\tint cost33 = 67;\n\t\tint cost34 = 69;\n\t\tint cost35 = 71;\n\t\tint cost36 = 73;\n\t\tint cost37 = 75;\n\t\tint cost38 = 77;\n\t\tint cost39 = 79;\n\t\tint cost40 = 81;\n\t\tint cost41 = 83;\n\t\tint cost42 = 85;\n\t\tint cost43 = 87;\n\t\tint cost44 = 89;\n\t\tint cost45 = 91;\n\t\tint cost46 = 93;\n\t\tint cost47 = 95;\n\t\tint cost48 = 97;\n\t\tint cost49 = 99;\n\t\tint cost50 = 101;\n\t\tint cost51 = 103;\n\t\tint cost52 = 105;\n\t\tint cost53 = 107;\n\t\tint cost\n",
        "\tstatic void main(String[] args){\n\t\tint total = 100;\n\t\tint cost1 = 10;\n\t\tint cost2 = 20;\n\t\tint total1 = total/cost1;\n\t\tint total2 = total/cost2;\n\t\tint total3 = total%cost1;\n\t\tint total4 = total%cost2;\n\t\tSystem.out.println(\"total1 = \" + total1);\n\t\tSystem.out.println(\"total2 = \" + total2);\n\t\tSystem.out.println(\"total3 = \" + total3);\n\t\tSystem.out.println(\"total4 = \" + total4);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint total = 100;\n\t\tint cost1 = 10;\n\t\tint cost2 = 20;\n\t\tint total1 = total/cost1;\n\t\tint total2 = total/cost2;\n\t\tint total3 = total%cost1;\n\t\tint total4 = total%cost2;\n\t\tSystem.out.println(\"You can buy \"+total1+\" pencils and \"+total2+\" pens.\");\n\t\tSystem.out.println(\"You can buy \"+total3+\" pencils and \"+total4+\" pens.\");\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint total = 10;\n\t\tint cost1 = 2;\n\t\tint cost2 = 3;\n\t\tint count1 = total/cost1;\n\t\tint count2 = total/cost2;\n\t\tint count3 = total%cost1;\n\t\tint count4 = total%cost2;\n\t\tSystem.out.println(\"You can buy \"+count1+\" pencils and \"+count2+\" pencils.\");\n\t\tSystem.out.println(\"You can buy \"+count3+\" pencils and \"+count4+\" pencils.\");\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint total = 10;\n\t\tint cost1 = 3;\n\t\tint cost2 = 5;\n\t\tint pencils = total/cost1;\n\t\tint pens = total/cost2;\n\t\tint remainder = total%(cost1+cost2);\n\t\tSystem.out.println(\"You can buy \"+pencils+\" pencils and \"+pens+\" pens. You have \"+remainder+\" dollars left.\");\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2228",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array coins of length n which represents the n coins that you own. You can make some value x if you can choose some of your n coins such that their values sum up to x.",
    "snippets": [
        "\tint makeChange(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < coins.length; i++) {\n\t\t\tfor (int j = coins[i]; j <= amount; j++) {\n\t\t\t\tdp[j] += dp[j - coins[i]];\n\t\t\t}\n\t\t}\n\t\treturn dp[amount];\n\t}\n}\n",
        "\tstatic int[] coins = {1,2,5,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000,200000,500000,1000000,2000000,5000000,10000000,20000000,50000000,100000000,200000000,500000000,1000000000,2000000000,5000000000,10000000000,20000000000,50000000000,100000000000,200000000000,500000000000,1000000000000,2000000000000,5000000000000,10000000000000,20000000000000,50000000000000,100000000000000,200000000000000,500000000000000,1000000000000000,2000000000000000,5000000000000000,10000000000000000,20000000000000000,5000000000000000,1000000000000000000,200000000000000000,5000000000000000000,10000000000000000000,2000000000000000000,50000000000000000000,100000000000000000000,200000000000000000000,500000000000000000000,1000000000000000000000,2000000000000000000000,5000000000000000000000,10000000000000000000000,20000000000000000000000,50000000000000000000000,100000000000000000000000,200000000000000000000000,500000000000000000000000,1000000000000000000000000,2000000000000000000000000,50000000000000000000000000,10000000000000000000000000,20000000000000000000000000,500000000000000000000000,10000000000000000000000000,200000000000000000000000000,5000000000000000000000000,100000000000000000000000000,2000000000000000000000000000,50000000000000000000000000,10000000000000000000000000,20000000000000000000000000000,500000000000000000000000000,1000000000000000000000000000,200000000000000000000000000000,5000000000000000000000000000,10000000000000000000000000000,2000000000000000000000000000000,50000000000000000000000000000,100000000000000000000000000000,20000000000000000000000000000000,500000000000000000000000000000,1000000000000000000000000000000,200000000000000000000000000000000,5000000000000000000000000000000,10000000000000000000000000000000,2000000000000000000000000000000000,50000000000000000000000000000000,100000000000000000000000000000000,2000000000000000000000000000000000,500000000000000000000000000000000,10000000000000000000000000000000000,2000000000000000000000000000000000,50000000000000000000000000000000000,100000000000000000000000000000000000,2000000000000000000000000000000000,500000000000000000000000000000000000,1000000000000000000000000000000000000,2000000000000000000000000000000000,5000000000000000000000000000000000000,10000000000000000000000000000000000000,2000000000000000000000000000000000,50000000000000000000000000000000000000,100000000000000000000000000000000000000,2000000000000000000000000000000000,500000000000000000000000000000000000000,1000000000000000000000000000000000000000,2000000000000000000000000000000000,5000000000000000000000000000000000000000,10000000000000000000000000000000000000000,2000000000000000000000000000000000,50000000000000000000000000000000000000000\n",
        "\tstatic int makeChange(int[] coins, int amount) {\n\t\tint[] dp = new int[amount + 1];\n\t\tdp[0] = 1;\n\t\tfor (int i = 0; i < coins.length; i++) {\n\t\t\tfor (int j = coins[i]; j <= amount; j++) {\n\t\t\t\tdp[j] += dp[j - coins[i]];\n\t\t\t}\n\t\t}\n\t\treturn dp[amount];\n\t}\n}\n",
        "\tstatic int[] coins = {1,2,5,10,20,50,100,200,500,1000,2000,5000,10000,20000,50000,100000,200000,500000,1000000,2000000,5000000,10000000,20000000,50000000,100000000,200000000,500000000,1000000000,2000000000,5000000000,10000000000,20000000000,50000000000,100000000000,200000000000,500000000000,1000000000000,2000000000000,5000000000000,10000000000000,20000000000000,50000000000000,100000000000000,200000000000000,500000000000000,1000000000000000,2000000000000000,5000000000000000,10000000000000000,20000000000000000,50000000000000000,100000000000000000,200000000000000000,500000000000000000,1000000000000000000,200000000000000000,5000000000000000000,10000000000000000000,2000000000000000000,50000000000000000000,100000000000000000000,200000000000000000000,500000000000000000000,1000000000000000000000,2000000000000000000000,5000000000000000000000,10000000000000000000000,20000000000000000000000,50000000000000000000000,100000000000000000000000,200000000000000000000000,500000000000000000000000,1000000000000000000000000,2000000000000000000000000,5000000000000000000000000,10000000000000000000000000,2000000000000000000000000,50000000000000000000000000,100000000000000000000000000,2000000000000000000000000,500000000000000000000000000,1000000000000000000000000000,2000000000000000000000000,5000000000000000000000000000,10000000000000000000000000000,2000000000000000000000000,50000000000000000000000000000,100000000000000000000000000000,2000000000000000000000000,500000000000000000000000000000,1000000000000000000000000000000,2000000000000000000000000,5000000000000000000000000000000,10000000000000000000000000000000,2000000000000000000000000,50000000000000000000000000000000,1000000000000000000000000000000000,2000000000000000000000000,5000000000000000000000000000000000,100000000000000000000000000000000,2000000000000000000000000,500000000000000000000000000000000,1000000000000000000000000000000000,2000000000000000000000000,5000000000000000000000000000000000,10000000000000000000000000000000000,2000000000000000000000000,50000000000000000000000000000000000,100000000000000000000000000000000000,2000000000000000000000000,500000000000000000000000000000000000,1000000000000000000000000000000000000,2000000000000000000000000,5000000000000000000000000000000000000,10000000000000000000000000000000000000,2000000000000000000000000,50000000000000000000000000000000000000,100000000000000000000000000000000000000,2000000000000000000000000,500000000000000000000000000000000000000,1000000000000000000000000000000000000000,2000000000000000000000000,5000000000000000000000000000000000000000,10000000000000000000000000000000000000000,2000000000000000000000000,5\n",
        "\tstatic int find(int[] coins, int x){\n\t\tint n = coins.length;\n\t\tint[][] dp = new int[n+1][x+1];\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tdp[i][0] = 1;\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=x;j++){\n\t\t\t\tif(j>=coins[i-1]){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n][x];\n\t}\n}\n",
        "\tstatic int makeChange(int[] coins, int amount){\n\t\tint[] dp = new int[amount+1];\n\t\tdp[0] = 1;\n\t\tfor(int i=0; i<coins.length; i++){\n\t\t\tfor(int j=1; j<=amount; j++){\n\t\t\t\tif(j>=coins[i]){\n\t\t\t\t\tdp[j] += dp[j-coins[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount];\n\t}\n}\n",
        "\tstatic int[] coins;\n\tpublic\n\tstatic int[] memo;\n\tpublic\n\tstatic int makeChange(int n){\n\t\tif(n<0) return 0;\n\t\tif(n==0) return 1;\n\t\tif(memo[n]!=0) return memo[n];\n\t\tint count=0;\n\t\tfor(int i=0;i<coins.length;i++){\n\t\t\tcount+=makeChange(n-coins[i]);\n\t\t}\n\t\tmemo[n]=count;\n\t\treturn count;\n\t}\n\tpublic\n\tstatic void main(String[] args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tcoins=new int[n];\n\t\tmemo=new int[n+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcoins[i]=sc.nextInt();\n\t\t}\n\t\tSystem.out.println(makeChange(n));\n\t}\n}\n",
        "\tstatic int[] coins;\n\tpublic\n\tstatic int[] memo;\n\tpublic\n\tstatic int makeChange(int amount){\n\t\tif(amount == 0) return 0;\n\t\tif(memo[amount] != -1) return memo[amount];\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < coins.length; i++){\n\t\t\tif(coins[i] <= amount){\n\t\t\t\tint res = makeChange(amount - coins[i]);\n\t\t\t\tif(res != -1 && res < min) min = res;\n\t\t\t}\n\t\t}\n\t\treturn memo[amount] = (min == Integer.MAX_VALUE) ? -1 : min + 1;\n\t}\n\tpublic\n\tstatic void main(String[] args){\n\t\tcoins = new int[]{1,2,5,10,20,50,100,200,500,1000};\n\t\tmemo = new int[2001];\n\t\tfor(int i = 0; i < memo.length; i++) memo[i] = -1;\n\t\tSystem.out.println(makeChange(2000));\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2229",
    "source": "leetcode",
    "language": "java",
    "query": "Given the head of a linked list, rotate the list to the right by k places.",
    "snippets": [
        "\tclass ListNode{\n\t\tint val;\n\t\tListNode next;\n\t\tListNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic ListNode rotateRight(ListNode head, int k) {\n\t\tif(head == null || head.next == null) return head;\n\t\tListNode dummy = new ListNode(0);\n\t\tdummy.next = head;\n\t\tListNode fast = dummy;\n\t\tListNode slow = dummy;\n\t\tint count = 0;\n\t\twhile(fast != null){\n\t\t\tfast = fast.next;\n\t\t\tcount++;\n\t\t\tif(fast == null) break;\n\t\t\tfast = fast.next;\n\t\t\tslow = slow.next;\n\t\t}\n\t\tint n = count - k % count;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tslow = slow.next;\n\t\t}\n\t\tListNode newHead = slow.next;\n\t\tslow.next = null;\n\t\tfast.next = dummy.next;\n\t\treturn newHead;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || k == 0) return head;\n\t\tNode cur = head;\n\t\tint len = 0;\n\t\twhile(cur != null){\n\t\t\tlen++;\n\t\t\tcur = cur.next;\n\t\t}\n\t\tk = k % len;\n\t\tif(k == 0) return head;\n\t\tcur = head;\n\t\tfor(int i = 0; i < len - k - 1; i++){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tNode newHead = cur.next;\n\t\tcur.next = null;\n\t\tcur = newHead;\n\t\twhile(cur.next != null){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tcur.next = head;\n\t\treturn newHead;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || k == 0) return head;\n\t\tNode p = head;\n\t\tint len = 0;\n\t\twhile(p != null){\n\t\t\tlen++;\n\t\t\tp = p.next;\n\t\t}\n\t\tk = k % len;\n\t\tif(k == 0) return head;\n\t\tp = head;\n\t\twhile(k-- > 0){\n\t\t\tp = p.next;\n\t\t}\n\t\tNode q = p;\n\t\twhile(p.next != null){\n\t\t\tp = p.next;\n\t\t}\n\t\tp.next = head;\n\t\thead = q.next;\n\t\tq.next = null;\n\t\treturn head;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || head.next == null) return head;\n\t\tNode p = head;\n\t\tint len = 0;\n\t\twhile(p != null){\n\t\t\tlen++;\n\t\t\tp = p.next;\n\t\t}\n\t\tk = k % len;\n\t\tif(k == 0) return head;\n\t\tp = head;\n\t\twhile(k > 1){\n\t\t\tp = p.next;\n\t\t\tk--;\n\t\t}\n\t\tNode q = p.next;\n\t\twhile(q.next != null){\n\t\t\tq = q.next;\n\t\t\tp = p.next;\n\t\t}\n\t\tq.next = head;\n\t\tp.next = null;\n\t\treturn q;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || head.next == null) return head;\n\t\tNode p = head;\n\t\tint len = 0;\n\t\twhile(p != null){\n\t\t\tlen++;\n\t\t\tp = p.next;\n\t\t}\n\t\tk = k % len;\n\t\tif(k == 0) return head;\n\t\tp = head;\n\t\twhile(k-- > 0){\n\t\t\tp = p.next;\n\t\t}\n\t\tNode q = p.next;\n\t\tp.next = null;\n\t\twhile(q.next != null){\n\t\t\tq = q.next;\n\t\t}\n\t\tq.next = head;\n\t\treturn q;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || k == 0) return head;\n\t\tNode cur = head;\n\t\tint len = 1;\n\t\twhile(cur.next != null){\n\t\t\tcur = cur.next;\n\t\t\tlen++;\n\t\t}\n\t\tcur.next = head;\n\t\tk = k % len;\n\t\tfor(int i = 0; i < len - k; i++){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tNode newHead = cur.next;\n\t\tcur.next = null;\n\t\treturn newHead;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || head.next == null) return head;\n\t\tNode cur = head;\n\t\tint len = 0;\n\t\twhile(cur != null){\n\t\t\tlen++;\n\t\t\tcur = cur.next;\n\t\t}\n\t\tk = k % len;\n\t\tif(k == 0) return head;\n\t\tcur = head;\n\t\tfor(int i = 0; i < len - k - 1; i++){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tNode newHead = cur.next;\n\t\tcur.next = null;\n\t\tcur = newHead;\n\t\twhile(cur.next != null){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tcur.next = head;\n\t\treturn newHead;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || head.next == null || k == 0) return head;\n\t\tNode cur = head;\n\t\tint len = 1;\n\t\twhile(cur.next != null){\n\t\t\tcur = cur.next;\n\t\t\tlen++;\n\t\t}\n\t\tcur.next = head;\n\t\tk = k % len;\n\t\tfor(int i = 0; i < len - k; i++){\n\t\t\tcur = cur.next;\n\t\t}\n\t\tNode newHead = cur.next;\n\t\tcur.next = null;\n\t\treturn newHead;\n\t}\n}\n",
        "\tNode rotateRight(Node head, int k) {\n\t\tif(head == null || head.next == null) return head;\n\t\tNode tail = head;\n\t\tint len = 1;\n\t\twhile(tail.next != null){\n\t\t\ttail = tail.next;\n\t\t\tlen++;\n\t\t}\n\t\ttail.next = head;\n\t\tk = k % len;\n\t\tfor(int i = 0; i < len - k; i++){\n\t\t\ttail = tail.next;\n\t\t}\n\t\tNode newHead = tail.next;\n\t\ttail.next = null;\n\t\treturn newHead;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2230",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer num, return three consecutive integers (as a sorted array) that sum to num. If num cannot be expressed as the sum of three consecutive integer, return an empty array.",
    "snippets": [
        "\tint[] threeSum(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint[] result = new int[3];\n\t\tfor(int i = 0; i < nums.length - 2; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tint left = i + 1;\n\t\t\tint right = nums.length - 1;\n\t\t\twhile(left < right){\n\t\t\t\tint sum = nums[i] + nums[left] + nums[right];\n\t\t\t\tif(sum == 0){\n\t\t\t\t\tresult[0] = nums[i];\n\t\t\t\t\tresult[1] = nums[left];\n\t\t\t\t\tresult[2] = nums[right];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse if(sum < 0){\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] threeSum(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint[] result = new int[3];\n\t\tfor(int i = 0; i < nums.length - 2; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i - 1]) continue;\n\t\t\tint left = i + 1, right = nums.length - 1;\n\t\t\twhile(left < right){\n\t\t\t\tint sum = nums[i] + nums[left] + nums[right];\n\t\t\t\tif(sum == 0){\n\t\t\t\t\tresult[0] = nums[i];\n\t\t\t\t\tresult[1] = nums[left];\n\t\t\t\t\tresult[2] = nums[right];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse if(sum < 0){\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] threeSum(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint[] result = new int[3];\n\t\tfor(int i = 0; i < nums.length - 2; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i-1]) continue;\n\t\t\tint left = i + 1;\n\t\t\tint right = nums.length - 1;\n\t\t\twhile(left < right){\n\t\t\t\tint sum = nums[i] + nums[left] + nums[right];\n\t\t\t\tif(sum == 0){\n\t\t\t\t\tresult[0] = nums[i];\n\t\t\t\t\tresult[1] = nums[left];\n\t\t\t\t\tresult[2] = nums[right];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tif(sum < 0){\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tright--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tArrayList<Integer> threeSum(int num) {\n\t\tArrayList<Integer> result = new ArrayList<Integer>();\n\t\tif(num < 3) return result;\n\t\tint[] nums = new int[num];\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tnums[i] = i+1;\n\t\t}\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < num-2; i++){\n\t\t\tif(i > 0 && nums[i] == nums[i-1]) continue;\n\t\t\tint j = i+1;\n\t\t\tint k = num-1;\n\t\t\twhile(j < k){\n\t\t\t\tint sum = nums[i] + nums[j] + nums[k];\n\t\t\t\tif(sum == num){\n\t\t\t\t\tresult.add(nums[i]);\n\t\t\t\t\tresult.add(nums[j]);\n\t\t\t\t\tresult.add(nums[k]);\n\t\t\t\t\tj++;\n\t\t\t\t\tk--;\n\t\t\t\t\twhile(j < k && nums[j] == nums[j-1]) j++;\n\t\t\t\t\twhile(j < k && nums[k] == nums[k+1]) k--;\n\t\t\t\t}\n\t\t\t\telse if(sum < num){\n\t\t\t\t\tj++;\n\t\t\t\t\twhile(j < k && nums[j] == nums[j-1]) j++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tk--;\n\t\t\t\t\twhile(j < k && nums[k] == nums[k+1]) k--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] consecutiveSum(int num){\n\t\tint[] result = new int[3];\n\t\tint i = 1;\n\t\twhile(i<=num){\n\t\t\tif(num-i==i+i+i){\n\t\t\t\tresult[0] = i;\n\t\t\t\tresult[1] = i+i;\n\t\t\t\tresult[2] = i+i+i;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] consecutiveSum(int num){\n\t\tint[] result = new int[3];\n\t\tint i = 1;\n\t\twhile(i<=num){\n\t\t\tif(num-i==i+1){\n\t\t\t\tresult[0] = i;\n\t\t\t\tresult[1] = i+1;\n\t\t\t\tresult[2] = num-i;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] threeSum(int[] nums) {\n\t\tint[] result = new int[3];\n\t\tArrays.sort(nums);\n\t\tfor(int i = 0; i < nums.length - 2; i++){\n\t\t\tint j = i + 1;\n\t\t\tint k = nums.length - 1;\n\t\t\twhile(j < k){\n\t\t\t\tif(nums[i] + nums[j] + nums[k] == 0){\n\t\t\t\t\tresult[0] = nums[i];\n\t\t\t\t\tresult[1] = nums[j];\n\t\t\t\t\tresult[2] = nums[k];\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse if(nums[i] + nums[j] + nums[k] > 0){\n\t\t\t\t\tk--;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] consecutive(int num){\n\t\tint[] result = new int[3];\n\t\tint i = 1;\n\t\twhile(i<=num){\n\t\t\tif(num-i==i+i+i){\n\t\t\t\tresult[0] = i;\n\t\t\t\tresult[1] = i+i;\n\t\t\t\tresult[2] = i+i+i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] consecutiveSum(int num){\n\t\tint[] result = new int[3];\n\t\tint i = 0;\n\t\twhile(num > 0){\n\t\t\tresult[i] = num;\n\t\t\tnum -= result[i];\n\t\t\ti++;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] consecutiveSum(int num){\n\t\tint[] res = new int[3];\n\t\tint i = 0;\n\t\tfor(int j = 1; j < num; j++){\n\t\t\tif(num - j == j){\n\t\t\t\tres[i++] = j;\n\t\t\t\tres[i++] = j;\n\t\t\t\tres[i++] = num - j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(num - j > j){\n\t\t\t\tres[i++] = j;\n\t\t\t\tres[i++] = num - j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2231",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed integer array nums and an integer k. You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array.",
    "snippets": [
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (j + nums[j] >= i) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint min = n;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (j + nums[j] >= i) {\n\t\t\t\t\tmin = Math.min(min, dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = min;\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint max = 0;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (j + nums[j] >= i) {\n\t\t\t\t\tmax = Math.max(max, dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = max;\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint jump(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (j + nums[j] >= i) {\n\t\t\t\t\tmin = Math.min(min, dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = min;\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2232",
    "source": "leetcode",
    "language": "java",
    "query": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append additional letters onto the end of the merged string.",
    "snippets": [
        "\tString mergeStrings(String word1, String word2){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0, j = 0;\n\t\twhile(i < word1.length() && j < word2.length()){\n\t\t\tsb.append(word1.charAt(i));\n\t\t\tsb.append(word2.charAt(j));\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tif(i < word1.length()){\n\t\t\tsb.append(word1.substring(i));\n\t\t}\n\t\tif(j < word2.length()){\n\t\t\tsb.append(word2.substring(j));\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString mergeStrings(String word1, String word2){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0, j = 0;\n\t\twhile(i < word1.length() && j < word2.length()){\n\t\t\tsb.append(word1.charAt(i));\n\t\t\tsb.append(word2.charAt(j));\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\twhile(i < word1.length()){\n\t\t\tsb.append(word1.charAt(i));\n\t\t\ti++;\n\t\t}\n\t\twhile(j < word2.length()){\n\t\t\tsb.append(word2.charAt(j));\n\t\t\tj++;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString mergeStrings(String word1, String word2){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < word1.length() && j < word2.length()){\n\t\t\tsb.append(word1.charAt(i));\n\t\t\tsb.append(word2.charAt(j));\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tif(i < word1.length()){\n\t\t\tsb.append(word1.substring(i));\n\t\t}\n\t\tif(j < word2.length()){\n\t\t\tsb.append(word2.substring(j));\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString merge(String word1, String word2){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0, j = 0;\n\t\twhile(i < word1.length() && j < word2.length()){\n\t\t\tsb.append(word1.charAt(i));\n\t\t\tsb.append(word2.charAt(j));\n\t\t\ti++;\n\t\t\tj++;\n\t\t}\n\t\tif(i < word1.length()){\n\t\t\tsb.append(word1.substring(i));\n\t\t}\n\t\tif(j < word2.length()){\n\t\t\tsb.append(word2.substring(j));\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2233",
    "source": "leetcode",
    "language": "java",
    "query": "Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums.",
    "snippets": [
        "\tint startValue(int[] nums, int startValue){\n\t\tint sum = startValue;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint arrayProduct(int[] nums) {\n\t\tint product = 1;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tproduct *= nums[i];\n\t\t}\n\t\treturn product;\n\t}\n}\n",
        "\tint startValue = 1;\n\tpublic\n\tint[] nums = {1,2,3,4,5};\n\tpublic\n\tint[] nums2 = {1,2,3,4,5,6,7,8,9,10};\n\tpublic\n\tint[] nums3 = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20};\n\tpublic\n\tint[] nums4 = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188\n",
        "\tint startValue = 1;\n\tpublic\n\tint[] nums;\n\tpublic\n\tint startIndex = 0;\n\tpublic\n\tint endIndex = 0;\n\tpublic\n\tint sum = 0;\n\tpublic\n\tint step = 0;\n\tpublic\n\tint[] result;\n\tpublic\n\tint resultIndex = 0;\n\tpublic\n\tint resultSum = 0;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultEndIndex = 0;\n\tpublic\n\tint resultEndValue = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n\tpublic\n\tint resultStartValue = 1;\n\tpublic\n\tint resultStep = 0;\n\tpublic\n\tint resultStartIndex = 0;\n",
        "\tint startValue = 1;\n\tpublic\n\tint[] nums = {1,2,3};\n\tpublic\n\tint startValue(int[] nums){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2234",
    "source": "leetcode",
    "language": "java",
    "query": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums [j] and (i * j) is divisible by k.",
    "snippets": [
        "\tint numPairsDivisibleBy60(int[] nums) {\n\t\tint[] count = new int[60];\n\t\tfor (int num : nums) {\n\t\t\tcount[(num % 60 + 60) % 60]++;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tres += count[i] * count[60 - i - 1];\n\t\t}\n\t\tres += count[30] * (count[30] - 1) / 2;\n\t\treturn res;\n\t}\n}\n",
        "\tint numPairsDivisibleBy60(int[] nums) {\n\t\tint[] count = new int[60];\n\t\tfor (int num : nums) {\n\t\t\tcount[(num % 60 + 60) % 60]++;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tres += count[i] * count[60 - i];\n\t\t}\n\t\tres += count[0] * (count[0] - 1) / 2;\n\t\treturn res;\n\t}\n}\n",
        "\tint count(int[] nums, int k) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tif ((nums[i] + nums[j]) % k == 0) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numPairsDivisibleBy60(int[] nums) {\n\t\tint[] count = new int[60];\n\t\tfor (int num : nums) {\n\t\t\tcount[(num % 60 + 60) % 60]++;\n\t\t}\n\t\tint res = 0;\n\t\tfor (int i = 1; i < 30; i++) {\n\t\t\tres += count[i] * count[60 - i];\n\t\t}\n\t\tres += count[0] * (count[0] - 1) / 2;\n\t\treturn res;\n\t}\n}\n",
        "\tint kSimilarity(int[] A, int k) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tfor (int j = i + 1; j < A.length; j++) {\n\t\t\t\tif (A[i] == A[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint[] B = A.clone();\n\t\t\t\tint[] C = A.clone();\n\t\t\t\tint count1 = 0;\n\t\t\t\tint count2 = 0;\n\t\t\t\tfor (int m = 0; m < A.length; m++) {\n\t\t\t\t\tif (B[m] == A[i]) {\n\t\t\t\t\t\tB[m] = A[j];\n\t\t\t\t\t\tcount1++;\n\t\t\t\t\t}\n\t\t\t\t\tif (C[m] == A[j]) {\n\t\t\t\t\t\tC[m] = A[i];\n\t\t\t\t\t\tcount2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (count1 == count2) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2235",
    "source": "leetcode",
    "language": "java",
    "query": "In one move, you can increment or decrement an element of the array by 1. Test cases are designed so that the answer will fit in a 32-bit integer.",
    "snippets": [
        "\tint[] movesToMakeZigZag(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\tint count = 0;\n\t\twhile (i < j) {\n\t\t\tif (nums[i] < nums[j]) {\n\t\t\t\tres[count] = nums[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[count] = nums[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tif (i == j) {\n\t\t\tres[count] = nums[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] movesToMakeZigZag(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\tint count = 0;\n\t\twhile (i < j) {\n\t\t\tif (nums[i] < nums[j]) {\n\t\t\t\tres[count++] = i;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[count++] = j;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif (i == j) {\n\t\t\tres[count++] = i;\n\t\t}\n\t\treturn Arrays.copyOf(res, count);\n\t}\n}\n",
        "\tint[] movesToMakeZigZag(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\tint k = 0;\n\t\twhile (i < j) {\n\t\t\tif (nums[i] < nums[j]) {\n\t\t\t\tres[k++] = i;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[k++] = j;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif (i == j) {\n\t\t\tres[k++] = i;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] move(int[] nums){\n\t\tint[] result = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tresult[i] = nums[i];\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 0){\n\t\t\t\tresult[i] = 1;\n\t\t\t}\n\t\t\telse if(nums[i] == 1){\n\t\t\t\tresult[i] = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] movesToMakeZigZag(int[] a) {\n\t\tint[] res = new int[a.length];\n\t\tint i = 0;\n\t\tint j = a.length - 1;\n\t\tint k = 0;\n\t\twhile (i < j) {\n\t\t\tif (a[i] < a[j]) {\n\t\t\t\tres[k++] = i;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[k++] = j;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif (i == j) {\n\t\t\tres[k++] = i;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] movesToMakeZigZag(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] res = new int[n];\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile (i < j) {\n\t\t\tif (nums[i] < nums[j]) {\n\t\t\t\tres[i] = j - i + 1;\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[j] = j - i + 1;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif (i == j) {\n\t\t\tres[i] = 1;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] movesToMakeZigzag(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\tint l = 0;\n\t\twhile (i < nums.length) {\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tif (nums[i] >= nums[j]) {\n\t\t\t\t\tres[k] = nums[i] - nums[j] + 1;\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\tres[k] = nums[j] - nums[i] + 1;\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nums[i] >= nums[l]) {\n\t\t\t\t\tres[k] = nums[i] - nums[l] + 1;\n\t\t\t\t\ti++;\n\t\t\t\t\tl++;\n\t\t\t\t} else {\n\t\t\t\t\tres[k] = nums[l] - nums[i] + 1;\n\t\t\t\t\ti++;\n\t\t\t\t\tl++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tk++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] array;\n\tpublic\n\tClazz(int[] array){\n\t\tthis.array = array;\n\t}\n\tpublic\n\tint[] increment(int index){\n\t\tarray[index]++;\n\t\treturn array;\n\t}\n\tpublic\n\tint[] decrement(int index){\n\t\tarray[index]--;\n\t\treturn array;\n\t}\n}\n",
        "\tint[] array = new int[100];\n\tpublic\n\tvoid setArray(int[] array){\n\t\tthis.array = array;\n\t}\n\tpublic\n\tint[] getArray(){\n\t\treturn array;\n\t}\n\tpublic\n\tint maxArraySum(int[] array){\n\t\tint max = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tfor(int j = 0; j < array.length; j++){\n\t\t\t\tint sum = 0;\n\t\t\t\tfor(int k = i; k <= j; k++){\n\t\t\t\t\tsum += array[k];\n\t\t\t\t}\n\t\t\t\tif(sum > max){\n\t\t\t\t\tmax = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2236",
    "source": "leetcode",
    "language": "java",
    "query": "An English letter b is greater than another letter a if b appears after a in the English alphabet. Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase in s.",
    "snippets": [
        "\tstatic char max(String s){\n\t\tchar max = 'a';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) > max){\n\t\t\t\tmax = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tstatic char min(String s){\n\t\tchar min = 'z';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) < min){\n\t\t\t\tmin = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tpublic\n\tstatic char max2(String s){\n\t\tchar max = 'a';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) > max){\n\t\t\t\tmax = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tstatic char min2(String s){\n\t\tchar min = 'z';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) < min){\n\t\t\t\tmin = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tpublic\n\tstatic char max3(String s){\n\t\tchar max = 'a';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) > max){\n\t\t\t\tmax = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tstatic char min3(String s){\n\t\tchar min = 'z';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) < min){\n",
        "\tstatic char max(String s){\n\t\tchar max = 'a';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) > max){\n\t\t\t\tmax = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tstatic char min(String s){\n\t\tchar min = 'z';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) < min){\n\t\t\t\tmin = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tpublic\n\tstatic char max(String s, char c){\n\t\tchar max = 'a';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) > max && s.charAt(i) != c){\n\t\t\t\tmax = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tstatic char min(String s, char c){\n\t\tchar min = 'z';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) < min && s.charAt(i) != c){\n\t\t\t\tmin = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n\tpublic\n\tstatic char max(String s, char c1, char c2){\n\t\tchar max = 'a';\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) > max && s.charAt(i) != c1 && s.charAt(i) != c2){\n\t\t\t\tmax = s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\tpublic\n\tstatic char\n",
        "\tstatic char findGreatest(String s){\n\t\tchar[] arr = s.toCharArray();\n\t\tchar max = arr[0];\n\t\tfor(int i = 1; i < arr.length; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic char find(String s){\n\t\tchar[] arr = s.toCharArray();\n\t\tchar max = 'a';\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic char getGreatest(String s){\n\t\tchar[] arr = s.toCharArray();\n\t\tchar max = arr[0];\n\t\tfor(int i = 1; i < arr.length; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic char findGreatest(String s){\n\t\tchar[] arr = s.toCharArray();\n\t\tchar max = arr[0];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic char find(String s){\n\t\tchar[] arr = s.toCharArray();\n\t\tchar max = arr[0];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic char findGreatest(String s){\n\t\tchar[] c = s.toCharArray();\n\t\tchar max = c[0];\n\t\tfor(int i = 0; i < c.length; i++){\n\t\t\tif(c[i] > max){\n\t\t\t\tmax = c[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tstatic char findGreatestLetter(String s){\n\t\tchar[] arr = s.toCharArray();\n\t\tchar max = arr[0];\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] > max){\n\t\t\t\tmax = arr[i];\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2237",
    "source": "leetcode",
    "language": "java",
    "query": "The next greater number of a number x is the first greater number to its traversing-order next in the array. If it doesn't exist, return -1 for this number. Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums [0]), return the next greater numbers for every element.",
    "snippets": [
        "\tint[] nextGreaterElements(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = 0; i < nums.length * 2; i++) {\n\t\t\twhile (!stack.isEmpty() && nums[stack.peek()] < nums[i % nums.length]) {\n\t\t\t\tres[stack.pop()] = nums[i % nums.length];\n\t\t\t}\n\t\t\tif (i < nums.length) {\n\t\t\t\tstack.push(i);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] nextGreaterElements(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = 0; i < nums.length * 2; i++) {\n\t\t\tint num = nums[i % nums.length];\n\t\t\twhile (!stack.isEmpty() && nums[stack.peek()] < num) {\n\t\t\t\tres[stack.pop()] = num;\n\t\t\t}\n\t\t\tif (i < nums.length) {\n\t\t\t\tstack.push(i);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] nextGreaterElements(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = 0; i < nums.length * 2; i++) {\n\t\t\twhile (!stack.isEmpty() && nums[stack.peek()] < nums[i % nums.length]) {\n\t\t\t\tres[stack.pop()] = nums[i % nums.length];\n\t\t\t}\n\t\t\tstack.push(i % nums.length);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] nextGreaterElements(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = 2 * nums.length - 1; i >= 0; i--) {\n\t\t\twhile (!stack.isEmpty() && nums[stack.peek()] <= nums[i % nums.length]) {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tres[i % nums.length] = stack.isEmpty() ? -1 : nums[stack.peek()];\n\t\t\tstack.push(i % nums.length);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] nextGreaterElements(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = nums.length - 1; i >= 0; i--) {\n\t\t\twhile (!stack.isEmpty() && nums[stack.peek()] <= nums[i]) {\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\tres[i] = stack.isEmpty() ? -1 : nums[stack.peek()];\n\t\t\tstack.push(i);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2238",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.",
    "snippets": [
        "\tList<Integer> majorityElement(int[] nums) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tint count1 = 0, count2 = 0, num1 = 0, num2 = 0;\n\t\tfor(int num : nums){\n\t\t\tif(num == num1) count1++;\n\t\t\telse if(num == num2) count2++;\n\t\t\telse if(count1 == 0){\n\t\t\t\tnum1 = num;\n\t\t\t\tcount1 = 1;\n\t\t\t}\n\t\t\telse if(count2 == 0){\n\t\t\t\tnum2 = num;\n\t\t\t\tcount2 = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t}\n\t\tcount1 = 0; count2 = 0;\n\t\tfor(int num : nums){\n\t\t\tif(num == num1) count1++;\n\t\t\telse if(num == num2) count2++;\n\t\t}\n\t\tif(count1 > nums.length/3) res.add(num1);\n\t\tif(count2 > nums.length/3) res.add(num2);\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> majorityElement(int[] nums) {\n\t\tList<Integer> res = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tint count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1;\n\t\tfor(int num : nums){\n\t\t\tif(num == candidate1) count1++;\n\t\t\telse if(num == candidate2) count2++;\n\t\t\telse if(count1 == 0){\n\t\t\t\tcandidate1 = num;\n\t\t\t\tcount1 = 1;\n\t\t\t}\n\t\t\telse if(count2 == 0){\n\t\t\t\tcandidate2 = num;\n\t\t\t\tcount2 = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t}\n\t\tcount1 = 0;\n\t\tcount2 = 0;\n\t\tfor(int num : nums){\n\t\t\tif(num == candidate1) count1++;\n\t\t\telse if(num == candidate2) count2++;\n\t\t}\n\t\tif(count1 > nums.length/3) res.add(candidate1);\n\t\tif(count2 > nums.length/3) res.add(candidate2);\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> majorityElement(int[] nums) {\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0){\n\t\t\treturn result;\n\t\t}\n\t\tint count1 = 0;\n\t\tint count2 = 0;\n\t\tint candidate1 = 0;\n\t\tint candidate2 = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == candidate1){\n\t\t\t\tcount1++;\n\t\t\t}else if(nums[i] == candidate2){\n\t\t\t\tcount2++;\n\t\t\t}else if(count1 == 0){\n\t\t\t\tcandidate1 = nums[i];\n\t\t\t\tcount1 = 1;\n\t\t\t}else if(count2 == 0){\n\t\t\t\tcandidate2 = nums[i];\n\t\t\t\tcount2 = 1;\n\t\t\t}else{\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t}\n\t\tcount1 = 0;\n\t\tcount2 = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == candidate1){\n\t\t\t\tcount1++;\n\t\t\t}else if(nums[i] == candidate2){\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t}\n\t\tif(count1 > nums.length/3){\n\t\t\tresult.add(candidate1);\n\t\t}\n\t\tif(count2 > nums.length/3){\n\t\t\tresult.add(candidate2);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> majorityElement(int[] nums) {\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0){\n\t\t\treturn result;\n\t\t}\n\t\tint n = nums.length;\n\t\tint count1 = 0;\n\t\tint count2 = 0;\n\t\tint candidate1 = 0;\n\t\tint candidate2 = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] == candidate1){\n\t\t\t\tcount1++;\n\t\t\t}else if(nums[i] == candidate2){\n\t\t\t\tcount2++;\n\t\t\t}else if(count1 == 0){\n\t\t\t\tcandidate1 = nums[i];\n\t\t\t\tcount1 = 1;\n\t\t\t}else if(count2 == 0){\n\t\t\t\tcandidate2 = nums[i];\n\t\t\t\tcount2 = 1;\n\t\t\t}else{\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t}\n\t\tcount1 = 0;\n\t\tcount2 = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(nums[i] == candidate1){\n\t\t\t\tcount1++;\n\t\t\t}else if(nums[i] == candidate2){\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t}\n\t\tif(count1 > n/3){\n\t\t\tresult.add(candidate1);\n\t\t}\n\t\tif(count2 > n/3){\n\t\t\tresult.add(candidate2);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> majorityElement(int[] nums) {\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0)\n\t\t\treturn result;\n\t\tint count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == candidate1)\n\t\t\t\tcount1++;\n\t\t\telse if(nums[i] == candidate2)\n\t\t\t\tcount2++;\n\t\t\telse if(count1 == 0){\n\t\t\t\tcandidate1 = nums[i];\n\t\t\t\tcount1 = 1;\n\t\t\t}\n\t\t\telse if(count2 == 0){\n\t\t\t\tcandidate2 = nums[i];\n\t\t\t\tcount2 = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t}\n\t\tcount1 = 0;\n\t\tcount2 = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == candidate1)\n\t\t\t\tcount1++;\n\t\t\telse if(nums[i] == candidate2)\n\t\t\t\tcount2++;\n\t\t}\n\t\tif(count1 > nums.length/3)\n\t\t\tresult.add(candidate1);\n\t\tif(count2 > nums.length/3)\n\t\t\tresult.add(candidate2);\n\t\treturn result;\n\t}\n}\n",
        "\tList<Integer> majorityElement(int[] nums) {\n\t\tList<Integer> result = new ArrayList<Integer>();\n\t\tif(nums == null || nums.length == 0) return result;\n\t\tint count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1;\n\t\tfor(int num : nums){\n\t\t\tif(num == candidate1) count1++;\n\t\t\telse if(num == candidate2) count2++;\n\t\t\telse if(count1 == 0){\n\t\t\t\tcandidate1 = num;\n\t\t\t\tcount1 = 1;\n\t\t\t}\n\t\t\telse if(count2 == 0){\n\t\t\t\tcandidate2 = num;\n\t\t\t\tcount2 = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n\t\t}\n\t\tcount1 = 0;\n\t\tcount2 = 0;\n\t\tfor(int num : nums){\n\t\t\tif(num == candidate1) count1++;\n\t\t\telse if(num == candidate2) count2++;\n\t\t}\n\t\tif(count1 > nums.length/3) result.add(candidate1);\n\t\tif(count2 > nums.length/3) result.add(candidate2);\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2239",
    "source": "leetcode",
    "language": "java",
    "query": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.",
    "snippets": [
        "\tint count(String[] words1, String[] words2) {\n\t\tint count = 0;\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor(String word : words1){\n\t\t\tif(map.containsKey(word)){\n\t\t\t\tmap.put(word, map.get(word)+1);\n\t\t\t}else{\n\t\t\t\tmap.put(word, 1);\n\t\t\t}\n\t\t}\n\t\tfor(String word : words2){\n\t\t\tif(map.containsKey(word) && map.get(word) == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countWords(String[] words1, String[] words2) {\n\t\tint count = 0;\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor (String word : words1) {\n\t\t\tif (map.containsKey(word)) {\n\t\t\t\tmap.put(word, map.get(word) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(word, 1);\n\t\t\t}\n\t\t}\n\t\tfor (String word : words2) {\n\t\t\tif (map.containsKey(word) && map.get(word) == 1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint count(String[] words1, String[] words2) {\n\t\tint count = 0;\n\t\tfor(String word1 : words1){\n\t\t\tfor(String word2 : words2){\n\t\t\t\tif(word1.equals(word2)){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint count(String[] words1, String[] words2) {\n\t\tint count = 0;\n\t\tfor(String word1:words1){\n\t\t\tfor(String word2:words2){\n\t\t\t\tif(word1.equals(word2)){\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2240",
    "source": "leetcode",
    "language": "java",
    "query": "Given two strings first and second, consider occurrences in some text of the form \"first second third\" Return an array of all the words third for each occurrence of \" first second third\".",
    "snippets": [
        "\tString[] third(String[] first, String[] second){\n\t\tString[] third = new String[first.length];\n\t\tfor(int i = 0; i < first.length; i++){\n\t\t\tthird[i] = first[i] + \" \" + second[i];\n\t\t}\n\t\treturn third;\n\t}\n}\n",
        "\tString[] findThird(String first, String second, String third){\n\t\tString[] result = new String[0];\n\t\tint index = 0;\n\t\tint firstIndex = 0;\n\t\tint secondIndex = 0;\n\t\tint thirdIndex = 0;\n\t\twhile(true){\n\t\t\tfirstIndex = first.indexOf(first, index);\n\t\t\tsecondIndex = second.indexOf(second, index);\n\t\t\tthirdIndex = third.indexOf(third, index);\n\t\t\tif(firstIndex == -1 || secondIndex == -1 || thirdIndex == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(firstIndex < secondIndex && secondIndex < thirdIndex){\n\t\t\t\tindex = thirdIndex + third.length();\n\t\t\t\tresult = add(result, third);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tindex = secondIndex + second.length();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic String[] add(String[] result, String s){\n\t\tString[] newResult = new String[result.length + 1];\n\t\tfor(int i = 0; i < result.length; i++){\n\t\t\tnewResult[i] = result[i];\n\t\t}\n\t\tnewResult[result.length] = s;\n\t\treturn newResult;\n\t}\n}\n",
        "\tString[] findThird(String first, String second, String third){\n\t\tString[] result = new String[0];\n\t\tint firstIndex = 0;\n\t\tint secondIndex = 0;\n\t\tint thirdIndex = 0;\n\t\twhile(thirdIndex < third.length()){\n\t\t\tif(third.charAt(thirdIndex) == ' '){\n\t\t\t\tif(third.substring(thirdIndex, thirdIndex + first.length() + second.length() + 3).equals(first + \" \" + second + \" \" + third)){\n\t\t\t\t\tresult = add(result, third.substring(thirdIndex + first.length() + second.length() + 3));\n\t\t\t\t}\n\t\t\t\tthirdIndex += first.length() + second.length() + 3;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthirdIndex++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic String[] add(String[] array, String element){\n\t\tString[] result = new String[array.length + 1];\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tresult[i] = array[i];\n\t\t}\n\t\tresult[array.length] = element;\n\t\treturn result;\n\t}\n}\n",
        "\tString[] findThird(String first, String second, String third){\n\t\tString[] result = new String[0];\n\t\tif(first == null || second == null || third == null){\n\t\t\treturn result;\n\t\t}\n\t\tint firstLen = first.length();\n\t\tint secondLen = second.length();\n\t\tint thirdLen = third.length();\n\t\tint len = firstLen + secondLen + thirdLen;\n\t\tint index = 0;\n\t\twhile(index < len){\n\t\t\tint firstIndex = first.indexOf(first, index);\n\t\t\tint secondIndex = second.indexOf(second, index);\n\t\t\tint thirdIndex = third.indexOf(third, index);\n\t\t\tif(firstIndex == -1 && secondIndex == -1 && thirdIndex == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(firstIndex == -1){\n\t\t\t\tindex = secondIndex + secondLen;\n\t\t\t}else if(secondIndex == -1){\n\t\t\t\tindex = firstIndex + firstLen;\n\t\t\t}else if(thirdIndex == -1){\n\t\t\t\tindex = secondIndex + secondLen;\n\t\t\t}else{\n\t\t\t\tindex = thirdIndex + thirdLen;\n\t\t\t}\n\t\t\tint start = index - thirdLen;\n\t\t\tint end = index;\n\t\t\tString temp = text.substring(start, end);\n\t\t\tif(temp.equals(third)){\n\t\t\t\tresult.add(temp);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tString[] findThird(String first, String second){\n\t\tString[] result = new String[0];\n\t\tString[] words = first.split(\" \");\n\t\tfor(int i = 0; i < words.length; i++){\n\t\t\tif(words[i].equals(second)){\n\t\t\t\tString[] temp = new String[result.length + 1];\n\t\t\t\tfor(int j = 0; j < result.length; j++){\n\t\t\t\t\ttemp[j] = result[j];\n\t\t\t\t}\n\t\t\t\ttemp[temp.length - 1] = words[i + 1];\n\t\t\t\tresult = temp;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tString[] findThird(String first, String second){\n\t\tString[] third = new String[first.length()];\n\t\tint i = 0;\n\t\twhile(i < first.length()){\n\t\t\tint j = first.indexOf(second, i);\n\t\t\tif(j == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthird[i] = first.substring(j + second.length(), j + second.length() + 3);\n\t\t\ti = j + second.length() + 3;\n\t\t}\n\t\treturn third;\n\t}\n}\n",
        "\tString[] findThird(String first, String second, String third){\n\t\tString[] result = new String[0];\n\t\tString[] firsts = first.split(\" \");\n\t\tString[] seconds = second.split(\" \");\n\t\tString[] thirds = third.split(\" \");\n\t\tfor(int i = 0; i < firsts.length; i++){\n\t\t\tfor(int j = 0; j < seconds.length; j++){\n\t\t\t\tfor(int k = 0; k < thirds.length; k++){\n\t\t\t\t\tif(firsts[i].equals(seconds[j]) && seconds[j].equals(thirds[k])){\n\t\t\t\t\t\tString[] temp = new String[result.length + 1];\n\t\t\t\t\t\tfor(int l = 0; l < result.length; l++){\n\t\t\t\t\t\t\ttemp[l] = result[l];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttemp[temp.length - 1] = thirds[k];\n\t\t\t\t\t\tresult = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2241",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array of even length arr, return true if it is possible to reorder arr such that arr[2 * i + 1] = 2 * arr[ 2 * i] for every 0 <= i < len(arr) / 2.",
    "snippets": [
        "\tboolean checkPossibility(int[] arr) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] > arr[i+1]){\n\t\t\t\tcount++;\n\t\t\t\tif(i == 0 || arr[i-1] <= arr[i+1]){\n\t\t\t\t\tarr[i] = arr[i+1];\n\t\t\t\t}else{\n\t\t\t\t\tarr[i+1] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] arr) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(i + 1 < arr.length && arr[i] > arr[i + 1]){\n\t\t\t\tcount++;\n\t\t\t\tif(i - 1 >= 0 && arr[i - 1] > arr[i]){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] arr) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(i == 0){\n\t\t\t\tif(arr[i] > arr[i+1]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i == arr.length-1){\n\t\t\t\tif(arr[i] > arr[i-1]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(arr[i] > arr[i+1] && arr[i] > arr[i-1]){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(count > 1){\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2242",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.",
    "snippets": [
        "\tString reverseWords(String s){\n\t\tString[] words = s.split(\" \");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String word:words){\n\t\t\tsb.append(new StringBuilder(word).reverse());\n\t\t\tsb.append(\" \");\n\t\t}\n\t\treturn sb.toString().trim();\n\t}\n}\n",
        "\tString reverseWords(String s){\n\t\tString[] words = s.split(\" \");\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(String word:words){\n\t\t\tsb.append(new StringBuilder(word).reverse().toString()+\" \");\n\t\t}\n\t\treturn sb.toString().trim();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2243",
    "source": "leetcode",
    "language": "java",
    "query": "For example, 21 written in binary is 10101, which has 3 set bits. Given two integers left and right, return the count of numbers in the inclusive range.",
    "snippets": [
        "\tint countBits(int num) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i <= num; i++){\n\t\t\tcount += Integer.bitCount(i);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countBits(int n) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tcount += Integer.bitCount(i);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countBits(int num) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i <= num; i++){\n\t\t\tcount += countBits(i);\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tint countBits(int num){\n\t\tint count = 0;\n\t\twhile(num > 0){\n\t\t\tcount += num & 1;\n\t\t\tnum = num >> 1;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countBits(int num) {\n\t\tint count = 0;\n\t\twhile(num > 0){\n\t\t\tcount += num & 1;\n\t\t\tnum >>= 1;\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2244",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition.",
    "snippets": [
        "\tint[] sortArrayByParity(int[] A) {\n\t\tint[] res = new int[A.length];\n\t\tint i = 0, j = 0;\n\t\tfor (int k = 0; k < A.length; k++) {\n\t\t\tif (A[k] % 2 == 0) {\n\t\t\t\tres[i] = A[k];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[A.length - 1 - j] = A[k];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArrayByParity(int[] A) {\n\t\tint[] res = new int[A.length];\n\t\tint i = 0, j = 0;\n\t\tfor (int k = 0; k < A.length; k++) {\n\t\t\tif (A[k] % 2 == 0) {\n\t\t\t\tres[i++] = A[k];\n\t\t\t} else {\n\t\t\t\tres[A.length - 1 - j++] = A[k];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArrayByParity(int[] A) {\n\t\tint[] res = new int[A.length];\n\t\tint i = 0, j = A.length - 1;\n\t\tfor (int k = 0; k < A.length; k++) {\n\t\t\tif (A[k] % 2 == 0) {\n\t\t\t\tres[i++] = A[k];\n\t\t\t} else {\n\t\t\t\tres[j--] = A[k];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArray(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = 0;\n\t\tfor (int k = 0; k < nums.length; k++) {\n\t\t\tif (nums[k] % 2 == 0) {\n\t\t\t\tres[i] = nums[k];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tres[nums.length - 1 - j] = nums[k];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArrayByParity(int[] A) {\n\t\tint[] result = new int[A.length];\n\t\tint even = 0;\n\t\tint odd = A.length - 1;\n\t\tfor (int i = 0; i < A.length; i++) {\n\t\t\tif (A[i] % 2 == 0) {\n\t\t\t\tresult[even] = A[i];\n\t\t\t\teven++;\n\t\t\t} else {\n\t\t\t\tresult[odd] = A[i];\n\t\t\t\todd--;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sortArray(int[] nums){\n\t\tint[] res = new int[nums.length];\n\t\tint i = 0, j = 0;\n\t\tfor(int k = 0; k < nums.length; k++){\n\t\t\tif(nums[k] % 2 == 0){\n\t\t\t\tres[i++] = nums[k];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres[nums.length - 1 - j++] = nums[k];\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] sortArrayByParity(int[] nums) {\n\t\tint[] result = new int[nums.length];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] % 2 == 0){\n\t\t\t\tresult[index] = nums[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] % 2 != 0){\n\t\t\t\tresult[index] = nums[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] sortArray(int[] nums) {\n\t\tint[] result = new int[nums.length];\n\t\tint even = 0;\n\t\tint odd = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] % 2 == 0){\n\t\t\t\tresult[even] = nums[i];\n\t\t\t\teven++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tresult[nums.length - 1 - odd] = nums[i];\n\t\t\t\todd++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2245",
    "source": "leetcode",
    "language": "java",
    "query": "A subarray is a contiguous subsequence of the array. Given an integer array arr, remove a subarray from arr such that the remaining elements in arr are non-decreasing.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint[] arr = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr2 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr3 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr4 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr5 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr6 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr7 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr8 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr9 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr10 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr11 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr12 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr13 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr14 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr15 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr16 = {1,2,3,4,5,6,7,8,9,10};\n\t\tint[] arr17 = {1,2,3,4,5,6,7,8,9,\n",
        "\tvoid removeSubarray(int[] arr){\n\t\tint n = arr.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(j < n){\n\t\t\tif(arr[j] < arr[i]){\n\t\t\t\ti = j + 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif(i == 0){\n\t\t\treturn;\n\t\t}\n\t\tint[] newArr = new int[n - i];\n\t\tfor(int k = i; k < n; k++){\n\t\t\tnewArr[k - i] = arr[k];\n\t\t}\n\t\tfor(int k = 0; k < n - i; k++){\n\t\t\tarr[k] = newArr[k];\n\t\t}\n\t}\n}\n",
        "\tvoid removeSubarray(int[] arr){\n\t\tint n = arr.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n && j < n){\n\t\t\tif(arr[j] < arr[i]){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(i == n){\n\t\t\treturn;\n\t\t}\n\t\tint k = i;\n\t\twhile(k < n && arr[k] <= arr[i]){\n\t\t\tk++;\n\t\t}\n\t\tint m = k;\n\t\twhile(m < n && arr[m] >= arr[i]){\n\t\t\tm++;\n\t\t}\n\t\tint l = m;\n\t\twhile(l < n && arr[l] <= arr[i]){\n\t\t\tl++;\n\t\t}\n\t\tint p = l;\n\t\twhile(p < n && arr[p] >= arr[i]){\n\t\t\tp++;\n\t\t}\n\t\tint q = p;\n\t\twhile(q < n && arr[q] <= arr[i]){\n\t\t\tq++;\n\t\t}\n\t\tint r = q;\n\t\twhile(r < n && arr[r] >= arr[i]){\n\t\t\tr++;\n\t\t}\n\t\tint s = r;\n\t\twhile(s < n && arr[s] <= arr[i]){\n\t\t\ts++;\n\t\t}\n\t\tint t = s;\n\t\twhile(t < n && arr[t] >= arr[i]){\n\t\t\tt++;\n\t\t}\n\t\tint u = t;\n\t\twhile(u < n && arr[u] <= arr[i]){\n\t\t\tu++;\n\t\t}\n\t\tint v = u;\n\t\twhile(v < n && arr[v] >= arr[i]){\n\t\t\tv++;\n\t\t}\n\t\tint w = v;\n\t\twhile(w <\n",
        "\tvoid removeSubarray(int[] arr){\n\t\tint n = arr.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tleft[0] = 0;\n\t\tright[n-1] = n-1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint j = i-1;\n\t\t\twhile(j >= 0 && arr[j] > arr[i]){\n\t\t\t\tj = left[j];\n\t\t\t}\n\t\t\tleft[i] = j;\n\t\t}\n\t\tfor(int i = n-2; i >= 0; i--){\n\t\t\tint j = i+1;\n\t\t\twhile(j < n && arr[j] > arr[i]){\n\t\t\t\tj = right[j];\n\t\t\t}\n\t\t\tright[i] = j;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(left[i] != 0 && right[i] != n-1){\n\t\t\t\tint j = left[i];\n\t\t\t\tint k = right[i];\n\t\t\t\twhile(j <= k){\n\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid remove(int[] arr){\n\t\tint n = arr.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(j < n){\n\t\t\tif(arr[i] <= arr[j]){\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint temp = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = temp;\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tvoid removeSubarray(int[] arr){\n\t\tint n = arr.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = 1;\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tdp[i] = dp[i-1] + 1;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(arr[i] > arr[j]){\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\tint[] ans = new int[max];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < dp[i]; j++){\n\t\t\t\tans[j] = arr[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < max; i++){\n\t\t\tSystem.out.print(ans[i] + \" \");\n\t\t}\n\t}\n}\n",
        "\tstatic void removeSubarray(int[] arr){\n\t\tint n = arr.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n && j < n){\n\t\t\tif(arr[j] < arr[i]){\n\t\t\t\ti++;\n\t\t\t}else{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tif(i == n){\n\t\t\treturn;\n\t\t}\n\t\tint k = i;\n\t\twhile(k < n && arr[k] <= arr[i]){\n\t\t\tk++;\n\t\t}\n\t\tint m = k;\n\t\twhile(m < n && arr[m] >= arr[i]){\n\t\t\tm++;\n\t\t}\n\t\tint l = m;\n\t\twhile(l < n && arr[l] <= arr[i]){\n\t\t\tl++;\n\t\t}\n\t\tint r = l;\n\t\twhile(r < n && arr[r] >= arr[i]){\n\t\t\tr++;\n\t\t}\n\t\tint p = r;\n\t\twhile(p < n && arr[p] <= arr[i]){\n\t\t\tp++;\n\t\t}\n\t\tint q = p;\n\t\twhile(q < n && arr[q] >= arr[i]){\n\t\t\tq++;\n\t\t}\n\t\tint s = q;\n\t\twhile(s < n && arr[s] <= arr[i]){\n\t\t\ts++;\n\t\t}\n\t\tint t = s;\n\t\twhile(t < n && arr[t] >= arr[i]){\n\t\t\tt++;\n\t\t}\n\t\tint u = t;\n\t\twhile(u < n && arr[u] <= arr[i]){\n\t\t\tu++;\n\t\t}\n\t\tint v = u;\n\t\twhile(v < n && arr[v] >= arr[i]){\n\t\t\tv++;\n\t\t}\n\t\tint w = v;\n\t\twhile(w\n",
        "\tvoid removeSubarray(int[] arr){\n\t\tint n = arr.length;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i < n && arr[i] <= arr[i+1]){\n\t\t\ti++;\n\t\t}\n\t\twhile(j < n && arr[j] <= arr[j+1]){\n\t\t\tj++;\n\t\t}\n\t\tif(i == n || j == n){\n\t\t\treturn;\n\t\t}\n\t\tint k = i;\n\t\tint l = j;\n\t\twhile(k < l){\n\t\t\tarr[k] = arr[l];\n\t\t\tk++;\n\t\t\tl--;\n\t\t}\n\t\tint m = i;\n\t\tint n = j;\n\t\twhile(m < n){\n\t\t\tarr[m] = arr[n];\n\t\t\tm++;\n\t\t\tn--;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2246",
    "source": "leetcode",
    "language": "java",
    "query": "There may be duplicates in the original array. Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.",
    "snippets": [
        "\tboolean checkPossibility(int[] nums) {\n\t\tint count = 0;\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif (nums[i] < nums[i - 1]) {\n\t\t\t\tcount++;\n\t\t\t\tif (i == 1 || nums[i - 2] <= nums[i]) {\n\t\t\t\t\tnums[i - 1] = nums[i];\n\t\t\t\t} else {\n\t\t\t\t\tnums[i] = nums[i - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] nums) {\n\t\tint count = 0;\n\t\tfor (int i = 1; i < nums.length; i++) {\n\t\t\tif (nums[i] < nums[i - 1]) {\n\t\t\t\tcount++;\n\t\t\t\tif (i > 1 && nums[i] < nums[i - 2]) {\n\t\t\t\t\tnums[i] = nums[i - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] nums) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length - 1; i++){\n\t\t\tif(nums[i] > nums[i + 1]){\n\t\t\t\tcount++;\n\t\t\t\tif(i == 0 || nums[i - 1] <= nums[i + 1]){\n\t\t\t\t\tnums[i] = nums[i + 1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnums[i + 1] = nums[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] nums) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < nums.length - 1; i++) {\n\t\t\tif (nums[i] > nums[i + 1]) {\n\t\t\t\tcount++;\n\t\t\t\tif (i > 0 && nums[i - 1] > nums[i + 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n",
        "\tboolean checkPossibility(int[] nums) {\n\t\tint n = nums.length;\n\t\tint count = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tif (nums[i] < nums[i - 1]) {\n\t\t\t\tcount++;\n\t\t\t\tif (i > 1 && nums[i] < nums[i - 2]) {\n\t\t\t\t\tnums[i] = nums[i - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count <= 1;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2247",
    "source": "leetcode",
    "language": "java",
    "query": "Given a binary string s, return true if s contains at most one contiguous segment of ones. Otherwise, return false.",
    "snippets": [
        "\tboolean binaryGap(int n) {\n\t\tString s = Integer.toBinaryString(n);\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn max <= 1;\n\t}\n}\n",
        "\tboolean binaryGap(int N) {\n\t\tString s = Integer.toBinaryString(N);\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\tif(count > max){\n\t\t\tmax = count;\n\t\t}\n\t\treturn max <= 1;\n\t}\n}\n",
        "\tboolean binaryGap(int N) {\n\t\tString s = Integer.toBinaryString(N);\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn max <= 1;\n\t}\n}\n",
        "\tboolean binaryGap(int n) {\n\t\tString s = Integer.toBinaryString(n);\n\t\tint count = 0;\n\t\tint max = 0;\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '1'){\n\t\t\t\tcount++;\n\t\t\t}else{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn max <= 1;\n\t}\n}\n",
        "\tboolean binaryGap(int N) {\n\t\tint count = 0;\n\t\tint max = 0;\n\t\tint i = 0;\n\t\twhile(N > 0){\n\t\t\tif(N % 2 == 1){\n\t\t\t\tif(count > 0){\n\t\t\t\t\tif(max < count){\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tN /= 2;\n\t\t}\n\t\treturn max <= 1;\n\t}\n}\n",
        "\tboolean binaryGap(int N) {\n\t\tint max = 0;\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile(N > 0){\n\t\t\tif(N % 2 == 1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(count > max){\n\t\t\t\t\tmax = count;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\tN /= 2;\n\t\t}\n\t\treturn max <= 1;\n\t}\n}\n",
        "\tboolean binaryGap(int N) {\n\t\tint count = 0;\n\t\tint max = 0;\n\t\tboolean isOne = false;\n\t\tfor(int i = 0; i < 32; i++){\n\t\t\tif((N & (1 << i)) != 0){\n\t\t\t\tif(isOne){\n\t\t\t\t\tcount++;\n\t\t\t\t}else{\n\t\t\t\t\tisOne = true;\n\t\t\t\t\tcount = 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(isOne){\n\t\t\t\t\tif(count > max){\n\t\t\t\t\t\tmax = count;\n\t\t\t\t\t}\n\t\t\t\t\tisOne = false;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max <= 1;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2248",
    "source": "leetcode",
    "language": "java",
    "query": "A square triple (a,b,c) is a triple where a, b, and c are integers. A2 + b2 = c2.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tint a = 1;\n\t\tint b = 1;\n\t\tint c = 1;\n\t\twhile(a<=1000){\n\t\t\twhile(b<=1000){\n\t\t\t\twhile(c<=1000){\n\t\t\t\t\tif(a*a+b*b==c*c){\n\t\t\t\t\t\tSystem.out.println(a+\" \"+b+\" \"+c);\n\t\t\t\t\t}\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t\tc=b+1;\n\t\t\t}\n\t\t\ta++;\n\t\t\tb=a+1;\n\t\t\tc=b+1;\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint a, b, c;\n\t\tfor(a = 1; a < 1000; a++){\n\t\t\tfor(b = 1; b < 1000; b++){\n\t\t\t\tc = 1000 - a - b;\n\t\t\t\tif(a*a + b*b == c*c){\n\t\t\t\t\tSystem.out.println(a + \" \" + b + \" \" + c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint a, b, c;\n\t\tfor(a = 1; a <= 1000; a++){\n\t\t\tfor(b = 1; b <= 1000; b++){\n\t\t\t\tc = (int)Math.sqrt(a*a + b*b);\n\t\t\t\tif(a + b + c == 1000){\n\t\t\t\t\tSystem.out.println(a*b*c);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint a, b, c;\n\t\tfor(a = 1; a < 1000; a++){\n\t\t\tfor(b = a; b < 1000; b++){\n\t\t\t\tc = 1000 - a - b;\n\t\t\t\tif(a*a + b*b == c*c){\n\t\t\t\t\tSystem.out.println(a*b*c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint a = 0;\n\t\tint b = 0;\n\t\tint c = 0;\n\t\tfor(int i = 1; i < 1000; i++){\n\t\t\tfor(int j = 1; j < 1000; j++){\n\t\t\t\tfor(int k = 1; k < 1000; k++){\n\t\t\t\t\tif(i + j + k == 1000 && i*i + j*j == k*k){\n\t\t\t\t\t\ta = i;\n\t\t\t\t\t\tb = j;\n\t\t\t\t\t\tc = k;\n\t\t\t\t\t\tSystem.out.println(a + \" \" + b + \" \" + c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint a = 1;\n\t\tint b = 2;\n\t\tint c = 3;\n\t\tint a2 = a*a;\n\t\tint b2 = b*b;\n\t\tint c2 = c*c;\n\t\tif(a2 + b2 == c2){\n\t\t\tSystem.out.println(\"a,b,c are a square triple\");\n\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"a,b,c are not a square triple\");\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2249",
    "source": "leetcode",
    "language": "java",
    "query": "An integer is a palindrome when it reads the same backward as forward. Given an integer x, return true if x is palindromic integer.",
    "snippets": [
        "\tboolean isPalindrome(int x) {\n\t\tif(x<0) return false;\n\t\tint y=x;\n\t\tint z=0;\n\t\twhile(y>0){\n\t\t\tz=z*10+y%10;\n\t\t\ty=y/10;\n\t\t}\n\t\treturn z==x;\n\t}\n}\n",
        "\tboolean isPalindrome(int x) {\n\t\tif(x<0) return false;\n\t\tint temp = x;\n\t\tint sum = 0;\n\t\twhile(temp>0){\n\t\t\tsum = sum*10 + temp%10;\n\t\t\ttemp/=10;\n\t\t}\n\t\treturn sum==x;\n\t}\n}\n",
        "\tboolean isPalindrome(int x) {\n\t\tif(x<0){\n\t\t\treturn false;\n\t\t}\n\t\tint temp=x;\n\t\tint reverse=0;\n\t\twhile(temp!=0){\n\t\t\treverse=reverse*10+temp%10;\n\t\t\ttemp=temp/10;\n\t\t}\n\t\treturn reverse==x;\n\t}\n}\n",
        "\tboolean isPalindrome(int x) {\n\t\tif(x<0) return false;\n\t\tint temp=x;\n\t\tint sum=0;\n\t\twhile(temp!=0){\n\t\t\tsum=sum*10+temp%10;\n\t\t\ttemp/=10;\n\t\t}\n\t\treturn sum==x;\n\t}\n}\n",
        "\tboolean isPalindrome(int x) {\n\t\tif(x<0) return false;\n\t\tint temp = x;\n\t\tint rev = 0;\n\t\twhile(temp>0){\n\t\t\trev = rev*10 + temp%10;\n\t\t\ttemp = temp/10;\n\t\t}\n\t\treturn rev==x;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2250",
    "source": "leetcode",
    "language": "java",
    "query": "An Anagram is a word or phrase formed by rearranging the letters of a different word. Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "snippets": [
        "\tboolean anagram(String s, String t) {\n\t\tif(s.length() != t.length()) return false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean anagram(String s, String t) {\n\t\tif(s.length() != t.length()) return false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < t.length(); i++){\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean anagram(String s, String t) {\n\t\tif(s.length() != t.length())\n\t\t\treturn false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++)\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\tfor(int i = 0; i < t.length(); i++)\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\tfor(int i = 0; i < 26; i++)\n\t\t\tif(count[i] != 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isAnagram(String s, String t) {\n\t\tif(s.length()!=t.length()) return false;\n\t\tint[] count = new int[26];\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tcount[s.charAt(i)-'a']++;\n\t\t}\n\t\tfor(int i=0;i<t.length();i++){\n\t\t\tcount[t.charAt(i)-'a']--;\n\t\t}\n\t\tfor(int i=0;i<26;i++){\n\t\t\tif(count[i]!=0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean anagram(String s, String t) {\n\t\tif(s.length() != t.length())\n\t\t\treturn false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++)\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\tfor(int i = 0; i < t.length(); i++)\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\tfor(int i = 0; i < 26; i++)\n\t\t\tif(count[i] != 0)\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean anagram(String s, String t){\n\t\tif(s.length() != t.length()) return false;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t\tcount[t.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2251",
    "source": "leetcode",
    "language": "java",
    "query": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound. You may return the answer in any order.",
    "snippets": [
        "\tList<Integer> powerfulIntegers(int x, int y, int bound) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint k = 0;\n\t\twhile(i <= bound){\n\t\t\twhile(j <= bound){\n\t\t\t\twhile(k <= bound){\n\t\t\t\t\tint sum = i + j + k;\n\t\t\t\t\tif(sum <= bound){\n\t\t\t\t\t\tlist.add(sum);\n\t\t\t\t\t}\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t\tk = 0;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj = 0;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> powerfulIntegers(int x, int y, int bound) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 1;\n\t\tint j = 1;\n\t\twhile(i <= bound){\n\t\t\twhile(j <= bound){\n\t\t\t\tint sum = i + j;\n\t\t\t\tif(sum <= bound){\n\t\t\t\t\tlist.add(sum);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj = 1;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> powerfulIntegers(int x, int y, int bound) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile(i*x+j*y<=bound){\n\t\t\tlist.add(i*x+j*y);\n\t\t\tif(i*x+j*y<=bound){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(i*x+j*y<=bound){\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> powerfulIntegers(int x, int y, int bound) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tint i = 1;\n\t\twhile(i*x <= bound){\n\t\t\tint j = 1;\n\t\t\twhile(j*y <= bound){\n\t\t\t\tint sum = i*x + j*y;\n\t\t\t\tif(sum <= bound)\n\t\t\t\t\tlist.add(sum);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> powerfulIntegers(int x, int y, int bound) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tint i = 1;\n\t\tint j = 1;\n\t\twhile(i <= bound){\n\t\t\twhile(j <= bound){\n\t\t\t\tint sum = i + j;\n\t\t\t\tif(sum <= bound){\n\t\t\t\t\tlist.add(sum);\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj = 1;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> powerfulIntegers(int x, int y, int bound) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tint i = 1;\n\t\twhile(i*x <= bound){\n\t\t\tint j = 1;\n\t\t\twhile(i*x + j*y <= bound){\n\t\t\t\tlist.add(i*x + j*y);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn list;\n\t}\n}\n",
        "\tList<Integer> powerfulIntegers(int x, int y, int bound) {\n\t\tList<Integer> list = new ArrayList<>();\n\t\tif(x == 1) list.add(1);\n\t\tif(y == 1) list.add(1);\n\t\tint i = 1;\n\t\tint j = 1;\n\t\twhile(i <= bound){\n\t\t\twhile(j <= bound){\n\t\t\t\tint sum = i + j;\n\t\t\t\tif(sum <= bound) list.add(sum);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t\tj = 1;\n\t\t}\n\t\treturn list;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2252",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array nums. In one move, you can choose one element of nums and change it by any value. Return the minimum difference between the largest and smallest value after performing at most three moves.",
    "snippets": [
        "\tint minDifference(int[] nums) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\t\tdiff = Math.min(diff, max - min);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint minDifference(int[] nums) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\t\tdiff = Math.min(diff, max - min);\n\t\t\t\t\ttemp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint minDifference(int[] nums) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t}\n\t\t\tif(nums[i] < min){\n\t\t\t\tmin = nums[i];\n\t\t\t}\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t\tint newMin = Integer.MAX_VALUE;\n\t\t\t\t\tint newMax = Integer.MIN_VALUE;\n\t\t\t\t\tfor(int k = 0; k < nums.length; k++){\n\t\t\t\t\t\tif(nums[k] > newMax){\n\t\t\t\t\t\t\tnewMax = nums[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nums[k] < newMin){\n\t\t\t\t\t\t\tnewMin = nums[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint newDiff = newMax - newMin;\n\t\t\t\t\tif(newDiff < diff){\n\t\t\t\t\t\tdiff = newDiff;\n\t\t\t\t\t}\n\t\t\t\t\ttemp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint minDiff(int[] nums) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\t\tdiff = Math.min(diff, max - min);\n\t\t\t\t\ttemp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint minDiff(int[] nums) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\t\tdiff = Math.min(diff, max - min);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint minDiff(int[] nums){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = 0; j < nums.length; j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tint temp = nums[i];\n\t\t\t\t\tnums[i] = nums[j];\n\t\t\t\t\tnums[j] = temp;\n\t\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\t\tdiff = Math.min(diff, max - min);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint minDiff(int[] nums) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tmin = Math.min(min, nums[i]);\n\t\t\tmax = Math.max(max, nums[i]);\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint temp = nums[i];\n\t\t\tnums[i] = max;\n\t\t\tmin = Math.min(min, max - temp);\n\t\t\tmax = Math.max(max, temp);\n\t\t}\n\t\treturn Math.min(diff, min);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2253",
    "source": "leetcode",
    "language": "java",
    "query": "The test cases are generated so that the answer will fit in a 32-bit integer. Given an integer array nums and two integers left and right, return the number of contiguous non-empty subarrays.",
    "snippets": [
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\twhile (end < nums.length) {\n\t\t\tif (nums[end] <= R) {\n\t\t\t\tend++;\n\t\t\t} else {\n\t\t\t\tcount += (end - start);\n\t\t\t\twhile (start < end && nums[start] <= L) {\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t\tcount += (end - start);\n\t\t\t\tend = start;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i < nums.length) {\n\t\t\twhile (j < nums.length && nums[j] <= R) {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tcount += j - i;\n\t\t\twhile (i < nums.length && nums[i] <= L) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (j < nums.length) {\n\t\t\tif (nums[j] <= R) {\n\t\t\t\tj++;\n\t\t\t} else {\n\t\t\t\tcount += j - i;\n\t\t\t\ti = j + 1;\n\t\t\t\tj = i;\n\t\t\t}\n\t\t}\n\t\tcount += j - i;\n\t\treturn count;\n\t}\n}\n",
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\twhile(end < nums.length){\n\t\t\tif(nums[end] <= R){\n\t\t\t\tend++;\n\t\t\t}else{\n\t\t\t\tcount += (end - start);\n\t\t\t\twhile(nums[start] <= L){\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t\tend = start + 1;\n\t\t\t}\n\t\t}\n\t\tcount += (end - start);\n\t\treturn count;\n\t}\n}\n",
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint start = 0;\n\t\tint end = 0;\n\t\twhile (end < nums.length) {\n\t\t\tif (nums[end] <= R) {\n\t\t\t\tend++;\n\t\t\t} else {\n\t\t\t\tcount += (end - start) * (end - start + 1) / 2;\n\t\t\t\twhile (start < end && nums[start] <= L) {\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t\tcount += (end - start) * (end - start + 1) / 2;\n\t\t\t\tend = start;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint left = 0;\n\t\tint right = 0;\n\t\twhile(right < nums.length){\n\t\t\twhile(right < nums.length && nums[right] <= R){\n\t\t\t\tright++;\n\t\t\t}\n\t\t\twhile(left < nums.length && nums[left] <= L){\n\t\t\t\tleft++;\n\t\t\t}\n\t\t\tcount += right - left;\n\t\t\tright++;\n\t\t\tleft++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint start = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (nums[i] < L) {\n\t\t\t\tstart = i + 1;\n\t\t\t} else if (nums[i] <= R) {\n\t\t\t\tcount += i - start + 1;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint numSubarrayBoundedMax(int[] nums, int L, int R) {\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tfor (int j = 0; j < nums.length; j++) {\n\t\t\tif (nums[j] > R) {\n\t\t\t\ti = j + 1;\n\t\t\t} else if (nums[j] < L) {\n\t\t\t\ti = j + 1;\n\t\t\t} else {\n\t\t\t\tcount += j - i + 1;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2254",
    "source": "leetcode",
    "language": "java",
    "query": "A subsequence is a sequence that can be derived from another sequence by deleting some or no elements. Given a string s, find the longest palindromic subsequence's length in s.",
    "snippets": [
        "\tint longestPalindromicSubsequence(String s){\n\t\tint[][] dp = new int[s.length()][s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tdp[i][i] = 1;\n\t\t}\n\t\tfor(int i = s.length() - 1; i >= 0; i--){\n\t\t\tfor(int j = i + 1; j < s.length(); j++){\n\t\t\t\tif(s.charAt(i) == s.charAt(j)){\n\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][s.length() - 1];\n\t}\n}\n",
        "\tint longestPalindromeSubseq(String s) {\n\t\tint n = s.length();\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tdp[i][i] = 1;\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (s.charAt(i) == s.charAt(j)) {\n\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][n - 1];\n\t}\n}\n",
        "\tint longestPalindromeSubseq(String s) {\n\t\tint[][] dp = new int[s.length()][s.length()];\n\t\tfor(int i = s.length()-1; i >= 0; i--){\n\t\t\tdp[i][i] = 1;\n\t\t\tfor(int j = i+1; j < s.length(); j++){\n\t\t\t\tif(s.charAt(i) == s.charAt(j)){\n\t\t\t\t\tdp[i][j] = dp[i+1][j-1] + 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][s.length()-1];\n\t}\n}\n",
        "\tint longestPalindromicSubsequence(String s) {\n\t\tint[][] dp = new int[s.length()][s.length()];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tdp[i][i] = 1;\n\t\t}\n\t\tfor(int i = s.length() - 2; i >= 0; i--){\n\t\t\tfor(int j = i + 1; j < s.length(); j++){\n\t\t\t\tif(s.charAt(i) == s.charAt(j)){\n\t\t\t\t\tdp[i][j] = dp[i + 1][j - 1] + 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][s.length() - 1];\n\t}\n}\n",
        "\tstatic int longestPalindromeSubseq(String s) {\n\t\tint[][] dp = new int[s.length()][s.length()];\n\t\tfor(int i = s.length()-1; i >= 0; i--){\n\t\t\tdp[i][i] = 1;\n\t\t\tfor(int j = i+1; j < s.length(); j++){\n\t\t\t\tif(s.charAt(i) == s.charAt(j)){\n\t\t\t\t\tdp[i][j] = dp[i+1][j-1] + 2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[0][s.length()-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2255",
    "source": "leetcode",
    "language": "java",
    "query": "We are given a list nums of integers representing a list compressed with run-length encoding. For each adjacent pair of elements [freq, val] there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.",
    "snippets": [
        "\tList<Integer> decompressRLElist(List<int[]> nums) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int[] arr : nums){\n\t\t\tfor(int i = 0; i < arr[0]; i++){\n\t\t\t\tres.add(arr[1]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> decompressRLElist(List<int[]> nums) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int[] pair : nums){\n\t\t\tfor(int i = 0; i < pair[0]; i++){\n\t\t\t\tres.add(pair[1]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tList<Integer> decompressRLElist(List<int[]> nums) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor (int[] pair : nums) {\n\t\t\tfor (int i = 0; i < pair[0]; i++) {\n\t\t\t\tresult.add(pair[1]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic List<Integer> decompressRLElist(List<int[]> nums) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int[] arr : nums){\n\t\t\tfor(int i = 0; i < arr[0]; i++){\n\t\t\t\tres.add(arr[1]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2256",
    "source": "leetcode",
    "language": "java",
    "query": "It is guaranteed that the node to be deleted is not a tail node in the list. Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given Access to the node.",
    "snippets": [
        "\tvoid deleteNode(Node node){\n\t\tnode.val = node.next.val;\n\t\tnode.next = node.next.next;\n\t}\n}\n",
        "\tclass Node{\n\t\tint data;\n\t\tNode next;\n\t\tpublic Node(int data){\n\t\t\tthis.data = data;\n\t\t}\n\t}\n\tpublic void deleteNode(Node node){\n\t\tnode.data = node.next.data;\n\t\tnode.next = node.next.next;\n\t}\n}\n",
        "\tclass Node{\n\t\tpublic int val;\n\t\tpublic Node next;\n\t\tpublic Node(int val){\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\tpublic void deleteNode(Node node){\n\t\tnode.val = node.next.val;\n\t\tnode.next = node.next.next;\n\t}\n}\n",
        "\tstatic void deleteNode(Node node){\n\t\tnode.val = node.next.val;\n\t\tnode.next = node.next.next;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2257",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. Return the minimum number of operations to reduce the sum of nums by at least half.",
    "snippets": [
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint half = sum / 2;\n\t\tint count = 0;\n\t\tint cur = 0;\n\t\tfor (int num : nums) {\n\t\t\tcur += num;\n\t\t\tif (cur > half) {\n\t\t\t\tcur = num;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint target = sum / 2;\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile (i < nums.length) {\n\t\t\tif (nums[i] <= target) {\n\t\t\t\ttarget -= nums[i];\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t\ttarget += nums[i] / 2;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint target = sum / 2;\n\t\tint count = 0;\n\t\tint cur = 0;\n\t\tfor (int num : nums) {\n\t\t\tif (cur < num) {\n\t\t\t\tcur += num;\n\t\t\t} else {\n\t\t\t\tcur -= num;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint target = sum / 2;\n\t\tint count = 0;\n\t\tint cur = 0;\n\t\tfor (int num : nums) {\n\t\t\tcur += num;\n\t\t\tif (cur == target) {\n\t\t\t\tcount++;\n\t\t\t\tcur = 0;\n\t\t\t} else if (cur > target) {\n\t\t\t\tcount += 2;\n\t\t\t\tcur = num;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint target = sum / 2;\n\t\tint[] dp = new int[target + 1];\n\t\tfor (int i = 1; i <= target; i++) {\n\t\t\tdp[i] = Integer.MAX_VALUE;\n\t\t}\n\t\tdp[0] = 0;\n\t\tfor (int i = 1; i <= target; i++) {\n\t\t\tfor (int num : nums) {\n\t\t\t\tif (i >= num) {\n\t\t\t\t\tdp[i] = Math.min(dp[i], dp[i - num] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[target];\n\t}\n}\n",
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint target = sum / 2;\n\t\tint count = 0;\n\t\tint cur = 0;\n\t\tfor (int num : nums) {\n\t\t\tif (cur < num) {\n\t\t\t\tcur += num;\n\t\t\t} else {\n\t\t\t\tcur -= num;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (cur == target) {\n\t\t\t\treturn count;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tif (sum % 2 == 1) {\n\t\t\treturn -1;\n\t\t}\n\t\tint half = sum / 2;\n\t\tint count = 0;\n\t\tint cur = 0;\n\t\tfor (int num : nums) {\n\t\t\tif (cur < num) {\n\t\t\t\tcount++;\n\t\t\t\tcur = num;\n\t\t\t}\n\t\t\tcur -= num / 2;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint minOperations(int[] nums) {\n\t\tint sum = 0;\n\t\tfor (int num : nums) {\n\t\t\tsum += num;\n\t\t}\n\t\tint target = sum / 2;\n\t\tint count = 0;\n\t\tint i = 0;\n\t\twhile (i < nums.length && nums[i] <= target) {\n\t\t\ttarget -= nums[i];\n\t\t\ti++;\n\t\t\tcount++;\n\t\t}\n\t\treturn count + (target == 0 ? 0 : 1);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2258",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses.",
    "snippets": [
        "\tString fractionToDecimal(int numerator, int denominator) {\n\t\tif(numerator == 0) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif((numerator < 0) ^ (denominator < 0)) sb.append(\"-\");\n\t\tlong num = Math.abs((long)numerator);\n\t\tlong den = Math.abs((long)denominator);\n\t\tsb.append(num / den);\n\t\tnum %= den;\n\t\tif(num == 0) return sb.toString();\n\t\tsb.append(\".\");\n\t\tMap<Long, Integer> map = new HashMap<>();\n\t\tmap.put(num, sb.length());\n\t\twhile(num != 0){\n\t\t\tnum *= 10;\n\t\t\tsb.append(num / den);\n\t\t\tnum %= den;\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tsb.insert(map.get(num), \"(\");\n\t\t\t\tsb.append(\")\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse map.put(num, sb.length());\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString fractionToDecimal(int numerator, int denominator) {\n\t\tif(numerator == 0) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif((numerator < 0) ^ (denominator < 0)) sb.append(\"-\");\n\t\tlong num = Math.abs((long)numerator);\n\t\tlong den = Math.abs((long)denominator);\n\t\tsb.append(num / den);\n\t\tnum %= den;\n\t\tif(num == 0) return sb.toString();\n\t\tsb.append(\".\");\n\t\tMap<Long, Integer> map = new HashMap<>();\n\t\tmap.put(num, sb.length());\n\t\twhile(num != 0){\n\t\t\tnum *= 10;\n\t\t\tsb.append(num / den);\n\t\t\tnum %= den;\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tsb.insert(map.get(num), \"(\");\n\t\t\t\tsb.append(\")\");\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tmap.put(num, sb.length());\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString fractionToDecimal(int numerator, int denominator) {\n\t\tif(numerator == 0) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif((numerator < 0) ^ (denominator < 0)) sb.append(\"-\");\n\t\tlong num = Math.abs((long)numerator);\n\t\tlong den = Math.abs((long)denominator);\n\t\tsb.append(num / den);\n\t\tnum %= den;\n\t\tif(num == 0) return sb.toString();\n\t\tsb.append(\".\");\n\t\tMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\tmap.put(num, sb.length());\n\t\twhile(num != 0){\n\t\t\tnum *= 10;\n\t\t\tsb.append(num / den);\n\t\t\tnum %= den;\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tsb.insert(map.get(num), \"(\");\n\t\t\t\tsb.append(\")\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse map.put(num, sb.length());\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString fractionToDecimal(int numerator, int denominator) {\n\t\tif(numerator == 0) return \"0\";\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif((numerator < 0) ^ (denominator < 0)) sb.append(\"-\");\n\t\tlong num = Math.abs((long)numerator);\n\t\tlong den = Math.abs((long)denominator);\n\t\tsb.append(num / den);\n\t\tnum %= den;\n\t\tif(num == 0) return sb.toString();\n\t\tsb.append(\".\");\n\t\tMap<Long, Integer> map = new HashMap<Long, Integer>();\n\t\tmap.put(num, sb.length());\n\t\twhile(num != 0){\n\t\t\tnum *= 10;\n\t\t\tsb.append(num / den);\n\t\t\tnum %= den;\n\t\t\tif(map.containsKey(num)){\n\t\t\t\tsb.insert(map.get(num), \"(\");\n\t\t\t\tsb.append(\")\");\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tmap.put(num, sb.length());\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2259",
    "source": "leetcode",
    "language": "java",
    "query": "The array-form of an integer num is an array representing its digits in left to right order. For example, for num = 1321, the array form is [1,3,2,1].",
    "snippets": [
        "\tstatic int[] arrayForm(int num){\n\t\tint[] arr = new int[(int)Math.log10(num) + 1];\n\t\tint i = 0;\n\t\twhile(num > 0){\n\t\t\tarr[i++] = num % 10;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn arr;\n\t}\n}\n",
        "\tstatic int[] arrayForm(int num){\n\t\tint[] arr = new int[(int)Math.log10(num) + 1];\n\t\tint i = 0;\n\t\twhile(num > 0){\n\t\t\tarr[i] = num % 10;\n\t\t\tnum /= 10;\n\t\t\ti++;\n\t\t}\n\t\treturn arr;\n\t}\n}\n",
        "\tint[] arrayForm(int num){\n\t\tint[] arr = new int[(int)Math.log10(num) + 1];\n\t\tint i = 0;\n\t\twhile(num > 0){\n\t\t\tarr[i] = num % 10;\n\t\t\tnum /= 10;\n\t\t\ti++;\n\t\t}\n\t\treturn arr;\n\t}\n}\n",
        "\tstatic int[] arrayForm(int num){\n\t\tint[] array = new int[(int)Math.log10(num)+1];\n\t\tint i = 0;\n\t\twhile(num > 0){\n\t\t\tarray[i] = num % 10;\n\t\t\tnum /= 10;\n\t\t\ti++;\n\t\t}\n\t\treturn array;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2260",
    "source": "leetcode",
    "language": "java",
    "query": "Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned.",
    "snippets": [
        "\tint mySqrt(int x) {\n\t\tif(x == 0) return 0;\n\t\tint left = 1;\n\t\tint right = x;\n\t\twhile(left < right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(mid <= x / mid)\n\t\t\t\tleft = mid + 1;\n\t\t\telse\n\t\t\t\tright = mid;\n\t\t}\n\t\treturn left - 1;\n\t}\n}\n",
        "\tint mySqrt(int x) {\n\t\tif(x == 0) return 0;\n\t\tint left = 1;\n\t\tint right = x;\n\t\twhile(left < right){\n\t\t\tint mid = left + (right - left) / 2;\n\t\t\tif(mid <= x / mid){\n\t\t\t\tleft = mid + 1;\n\t\t\t}else{\n\t\t\t\tright = mid;\n\t\t\t}\n\t\t}\n\t\treturn right;\n\t}\n}\n",
        "\tint mySqrt(int x) {\n\t\tif(x==0) return 0;\n\t\tint low=1,high=x;\n\t\twhile(low<=high){\n\t\t\tint mid=(low+high)/2;\n\t\t\tif(mid*mid==x) return mid;\n\t\t\telse if(mid*mid<x) low=mid+1;\n\t\t\telse high=mid-1;\n\t\t}\n\t\treturn high;\n\t}\n}\n",
        "\tint mySqrt(int x) {\n\t\tif(x<0) return -1;\n\t\tint left=0,right=x;\n\t\twhile(left<=right){\n\t\t\tint mid=(left+right)/2;\n\t\t\tif(mid*mid==x) return mid;\n\t\t\telse if(mid*mid<x) left=mid+1;\n\t\t\telse right=mid-1;\n\t\t}\n\t\treturn right;\n\t}\n}\n",
        "\tint mySqrt(int x) {\n\t\tif(x<0) return -1;\n\t\tint low=0,high=x;\n\t\twhile(low<=high){\n\t\t\tint mid=(low+high)/2;\n\t\t\tif(mid*mid==x) return mid;\n\t\t\telse if(mid*mid<x) low=mid+1;\n\t\t\telse high=mid-1;\n\t\t}\n\t\treturn high;\n\t}\n}\n",
        "\tint mySqrt(int x){\n\t\tif(x<0) return -1;\n\t\tif(x==0) return 0;\n\t\tint left=1,right=x;\n\t\twhile(left<right){\n\t\t\tint mid=(left+right)/2;\n\t\t\tif(mid*mid>x) right=mid;\n\t\t\telse left=mid+1;\n\t\t}\n\t\treturn left-1;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2261",
    "source": "leetcode",
    "language": "java",
    "query": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.",
    "snippets": [
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic double[] averageOfLevels(TreeNode root){\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> q = new LinkedList<TreeNode>();\n\t\tq.offer(root);\n\t\tint size = q.size();\n\t\tdouble[] res = new double[size];\n\t\tint i = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tTreeNode cur = q.poll();\n\t\t\tres[i] += cur.val;\n\t\t\tif(cur.left != null) q.offer(cur.left);\n\t\t\tif(cur.right != null) q.offer(cur.right);\n\t\t\tif(q.size() == size) i++;\n\t\t}\n\t\tfor(int j = 0; j < size; j++) res[j] /= size;\n\t\treturn res;\n\t}\n}\n",
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic double[] averageOfLevels(TreeNode root){\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tint size = queue.size();\n\t\tdouble[] res = new double[size];\n\t\tint i = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tTreeNode node = queue.poll();\n\t\t\tres[i] += node.val;\n\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\tif(queue.size() == 0){\n\t\t\t\ti++;\n\t\t\t\tsize = queue.size();\n\t\t\t\tres[i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < res.length; j++) res[j] /= size;\n\t\treturn res;\n\t}\n}\n",
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic double[] averageOfLevels(TreeNode root){\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> q = new LinkedList<TreeNode>();\n\t\tq.offer(root);\n\t\tint size = q.size();\n\t\tdouble[] res = new double[size];\n\t\tint i = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tTreeNode cur = q.poll();\n\t\t\tres[i] += cur.val;\n\t\t\tif(cur.left != null) q.offer(cur.left);\n\t\t\tif(cur.right != null) q.offer(cur.right);\n\t\t\tif(q.size() == size) i++;\n\t\t}\n\t\tfor(int j = 0; j < res.length; j++) res[j] /= size;\n\t\treturn res;\n\t}\n}\n",
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic double[] averageOfLevels(TreeNode root){\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tint size = queue.size();\n\t\tdouble[] res = new double[size];\n\t\tint i = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tTreeNode node = queue.poll();\n\t\t\tres[i] += node.val;\n\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\tif(queue.size() == size) i++;\n\t\t\tsize = queue.size();\n\t\t}\n\t\tfor(int j = 0; j < res.length; j++) res[j] /= size;\n\t\treturn res;\n\t}\n}\n",
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic double[] averageOfLevels(TreeNode root){\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> q = new LinkedList<TreeNode>();\n\t\tq.offer(root);\n\t\tint size = q.size();\n\t\tdouble[] res = new double[size];\n\t\tint i = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tTreeNode node = q.poll();\n\t\t\tres[i] += node.val;\n\t\t\tif(node.left != null) q.offer(node.left);\n\t\t\tif(node.right != null) q.offer(node.right);\n\t\t\tif(q.size() == 0){\n\t\t\t\ti++;\n\t\t\t\tsize = q.size();\n\t\t\t\tres[i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < res.length; j++) res[j] /= size;\n\t\treturn res;\n\t}\n}\n",
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int val){\n\t\t\tthis.val = val;\n\t\t}\n\t}\n\tpublic double[] averageOfLevels(TreeNode root){\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> q = new LinkedList<TreeNode>();\n\t\tq.offer(root);\n\t\tint size = q.size();\n\t\tdouble[] res = new double[size];\n\t\tint i = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tTreeNode cur = q.poll();\n\t\t\tres[i] += cur.val;\n\t\t\tif(cur.left != null) q.offer(cur.left);\n\t\t\tif(cur.right != null) q.offer(cur.right);\n\t\t\tif(q.size() == size) i++;\n\t\t}\n\t\tfor(int j = 0; j < size; j++) res[j] /= size;\n\t\treturn res;\n\t}\n}\n",
        "\tdouble[] averageOfLevels(TreeNode root) {\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tdouble[] res = new double[queue.size()];\n\t\tint i = 0;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tdouble sum = 0;\n\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tsum += node.val;\n\t\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\t}\n\t\t\tres[i++] = sum / size;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic double[] averageOfLevels(TreeNode root){\n\t\tif(root == null) return new double[0];\n\t\tQueue<TreeNode> q = new LinkedList<TreeNode>();\n\t\tq.add(root);\n\t\tdouble[] res = new double[q.size()];\n\t\tint i = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tint size = q.size();\n\t\t\tdouble sum = 0;\n\t\t\twhile(size-- > 0){\n\t\t\t\tTreeNode cur = q.poll();\n\t\t\t\tsum += cur.val;\n\t\t\t\tif(cur.left != null) q.add(cur.left);\n\t\t\t\tif(cur.right != null) q.add(cur.right);\n\t\t\t}\n\t\t\tres[i++] = sum / q.size();\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic double[] averageOfLevels(TreeNode root){\n\t\tdouble[] result = new double[getLevel(root)];\n\t\tgetAverage(root, result, 0);\n\t\treturn result;\n\t}\n\tpublic static int getLevel(TreeNode root){\n\t\tif(root == null) return 0;\n\t\treturn 1 + Math.max(getLevel(root.left), getLevel(root.right));\n\t}\n\tpublic static void getAverage(TreeNode root, double[] result, int level){\n\t\tif(root == null) return;\n\t\tif(result[level] == 0) result[level] = root.val;\n\t\telse result[level] = (result[level] + root.val) / 2;\n\t\tgetAverage(root.left, result, level + 1);\n\t\tgetAverage(root.right, result, level + 1);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2262",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same. Return any possible rearrangement of s or return \"\" if not possible.",
    "snippets": [
        "\tString rearrangeString(String s){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t}\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> b[1] - a[1]);\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] > 0){\n\t\t\t\tpq.add(new int[]{i, count[i]});\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!pq.isEmpty()){\n\t\t\tint[] cur = pq.poll();\n\t\t\tsb.append((char)(cur[0] + 'a'));\n\t\t\tif(--cur[1] > 0){\n\t\t\t\tpq.add(cur);\n\t\t\t}\n\t\t}\n\t\treturn sb.length() == s.length() ? sb.toString() : \"\";\n\t}\n}\n",
        "\tString rearrangeString(String s){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t}\n\t\tPriorityQueue<Character> pq = new PriorityQueue<Character>();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] > 0){\n\t\t\t\tpq.add((char)(i + 'a'));\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!pq.isEmpty()){\n\t\t\tchar c = pq.poll();\n\t\t\tsb.append(c);\n\t\t\tcount[c - 'a']--;\n\t\t\tif(count[c - 'a'] > 0){\n\t\t\t\tpq.add(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.length() == s.length() ? sb.toString() : \"\";\n\t}\n}\n",
        "\tString rearrangeString(String s){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t}\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> b[1] - a[1]);\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] > 0){\n\t\t\t\tpq.offer(new int[]{i, count[i]});\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!pq.isEmpty()){\n\t\t\tint[] cur = pq.poll();\n\t\t\tsb.append((char)(cur[0] + 'a'));\n\t\t\tif(--cur[1] > 0){\n\t\t\t\tpq.offer(cur);\n\t\t\t}\n\t\t}\n\t\treturn sb.length() == s.length() ? sb.toString() : \"\";\n\t}\n}\n",
        "\tString rearrangeString(String s) {\n\t\tint[] count = new int[26];\n\t\tfor (char c : s.toCharArray()) {\n\t\t\tcount[c - 'a']++;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\twhile (count[i]-- > 0) {\n\t\t\t\tsb.append((char) ('a' + i));\n\t\t\t}\n\t\t}\n\t\tif (sb.length() != s.length()) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString rearrangeString(String s) {\n\t\tint[] count = new int[26];\n\t\tfor (char c : s.toCharArray()) {\n\t\t\tcount[c - 'a']++;\n\t\t}\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> b[1] - a[1]);\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (count[i] > 0) {\n\t\t\t\tpq.offer(new int[] { i, count[i] });\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!pq.isEmpty()) {\n\t\t\tint[] pair = pq.poll();\n\t\t\tsb.append((char) (pair[0] + 'a'));\n\t\t\tif (--pair[1] > 0) {\n\t\t\t\tpq.offer(pair);\n\t\t\t}\n\t\t}\n\t\treturn sb.length() == s.length() ? sb.toString() : \"\";\n\t}\n}\n",
        "\tString rearrangeString(String s) {\n\t\tint[] count = new int[26];\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif (count[c - 'a'] > 0) {\n\t\t\t\tsb.append(c);\n\t\t\t\tcount[c - 'a']--;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 26; i++) {\n\t\t\tif (count[i] > 0) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString rearrange(String s){\n\t\tif(s == null || s.length() == 0) return s;\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tcount[s.charAt(i) - 'a']++;\n\t\t}\n\t\tPriorityQueue<Character> pq = new PriorityQueue<Character>();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] > 0){\n\t\t\t\tpq.add((char)('a' + i));\n\t\t\t}\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!pq.isEmpty()){\n\t\t\tchar c = pq.poll();\n\t\t\tsb.append(c);\n\t\t\tcount[c - 'a']--;\n\t\t\tif(count[c - 'a'] > 0){\n\t\t\t\tpq.add(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.length() == s.length() ? sb.toString() : \"\";\n\t}\n}\n",
        "\tString rearrange(String s){\n\t\tif(s.length()<2) return s;\n\t\tint[] count = new int[26];\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tcount[s.charAt(i)-'a']++;\n\t\t}\n\t\tint[] index = new int[26];\n\t\tfor(int i=0;i<26;i++){\n\t\t\tindex[i]=count[i];\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0;i<s.length();i++){\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tint minIndex = -1;\n\t\t\tfor(int j=0;j<26;j++){\n\t\t\t\tif(index[j]>0 && index[j]<min){\n\t\t\t\t\tmin = index[j];\n\t\t\t\t\tminIndex = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minIndex==-1) return \"\";\n\t\t\tsb.append((char)(minIndex+'a'));\n\t\t\tindex[minIndex]--;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString rearrangeString(String s) {\n\t\tint[] count = new int[26];\n\t\tfor(char c : s.toCharArray())\n\t\t\tcount[c-'a']++;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\twhile(count[i]-- > 0)\n\t\t\t\tsb.append((char)('a'+i));\n\t\t}\n\t\tif(sb.length() != s.length())\n\t\t\treturn \"\";\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString rearrangeString(String s) {\n\t\tint[] count = new int[26];\n\t\tfor(char c : s.toCharArray())\n\t\t\tcount[c-'a']++;\n\t\tPriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b)->b[1]-a[1]);\n\t\tfor(int i = 0; i < 26; i++)\n\t\t\tif(count[i] > 0)\n\t\t\t\tpq.offer(new int[]{i, count[i]});\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!pq.isEmpty()){\n\t\t\tint[] cur = pq.poll();\n\t\t\tsb.append((char)(cur[0]+'a'));\n\t\t\tif(--cur[1] > 0)\n\t\t\t\tpq.offer(cur);\n\t\t}\n\t\treturn sb.length() == s.length() ? sb.toString() : \"\";\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2263",
    "source": "leetcode",
    "language": "java",
    "query": "An integer n is a power of two, if there exists an integer x such that n == 2x. Given an integer n, return true if it is a powers of two. Otherwise, return false.",
    "snippets": [
        "\tboolean isPowerOfTwo(int n){\n\t\tif(n==0) return false;\n\t\tif(n==1) return true;\n\t\tif(n%2==0) return isPowerOfTwo(n/2);\n\t\treturn false;\n\t}\n}\n",
        "\tboolean isPowerOfTwo(int n){\n\t\tif(n==0) return false;\n\t\tif(n==1) return true;\n\t\tif(n%2==1) return false;\n\t\treturn isPowerOfTwo(n/2);\n\t}\n}\n",
        "\tboolean isPowerOfTwo(int n){\n\t\tif(n == 0) return false;\n\t\twhile(n != 1){\n\t\t\tif(n % 2 != 0) return false;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isPowerOfTwo(int n){\n\t\tif(n == 0) return false;\n\t\tif(n == 1) return true;\n\t\tif(n % 2 == 0){\n\t\t\treturn isPowerOfTwo(n/2);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tstatic boolean isPowerOfTwo(int n){\n\t\tif(n == 0) return false;\n\t\twhile(n != 1){\n\t\t\tif(n % 2 != 0) return false;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPowerOfTwo(int n){\n\t\tif(n == 0) return false;\n\t\tif(n == 1) return true;\n\t\tif(n % 2 == 0){\n\t\t\treturn isPowerOfTwo(n/2);\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2264",
    "source": "leetcode",
    "language": "java",
    "query": "A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangrams.",
    "snippets": [
        "\tboolean isPangram(String sentence){\n\t\tboolean[] alphabet = new boolean[26];\n\t\tfor(int i = 0; i < sentence.length(); i++){\n\t\t\tchar c = sentence.charAt(i);\n\t\t\tif(c >= 'a' && c <= 'z'){\n\t\t\t\talphabet[c - 'a'] = true;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < alphabet.length; i++){\n\t\t\tif(!alphabet[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isPangram(String sentence){\n\t\tint[] alphabet = new int[26];\n\t\tfor(int i = 0; i < sentence.length(); i++){\n\t\t\tchar c = sentence.charAt(i);\n\t\t\tif(c >= 'a' && c <= 'z'){\n\t\t\t\talphabet[c - 'a']++;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < alphabet.length; i++){\n\t\t\tif(alphabet[i] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPangram(String sentence){\n\t\tboolean[] alphabet = new boolean[26];\n\t\tfor(int i = 0; i < sentence.length(); i++){\n\t\t\tchar c = sentence.charAt(i);\n\t\t\tif(c >= 'a' && c <= 'z'){\n\t\t\t\talphabet[c - 'a'] = true;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < alphabet.length; i++){\n\t\t\tif(!alphabet[i]){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean isPangram(String sentence){\n\t\tint[] alphabet = new int[26];\n\t\tfor(int i = 0; i < sentence.length(); i++){\n\t\t\talphabet[sentence.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < alphabet.length; i++){\n\t\t\tif(alphabet[i] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean isPangram(String sentence){\n\t\tint[] alphabet = new int[26];\n\t\tfor(int i = 0; i < sentence.length(); i++){\n\t\t\talphabet[sentence.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(alphabet[i] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2265",
    "source": "leetcode",
    "language": "java",
    "query": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays.",
    "snippets": [
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tArrays.sort(nums1);\n\t\tArrays.sort(nums2);\n\t\tint i = 0, j = 0;\n\t\tint[] res = new int[nums1.length + nums2.length];\n\t\tint k = 0;\n\t\twhile(i < nums1.length && j < nums2.length){\n\t\t\tif(nums1[i] == nums2[j]){\n\t\t\t\tres[k++] = nums1[i];\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(nums1[i] < nums2[j]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOfRange(res, 0, k);\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tArrays.sort(nums1);\n\t\tArrays.sort(nums2);\n\t\tint i = 0, j = 0;\n\t\tint[] res = new int[nums1.length + nums2.length];\n\t\tint k = 0;\n\t\twhile (i < nums1.length && j < nums2.length) {\n\t\t\tif (nums1[i] == nums2[j]) {\n\t\t\t\tres[k++] = nums1[i];\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t} else if (nums1[i] < nums2[j]) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(res, k);\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tArrays.sort(nums1);\n\t\tArrays.sort(nums2);\n\t\tint i = 0, j = 0;\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\twhile(i < nums1.length && j < nums2.length){\n\t\t\tif(nums1[i] == nums2[j]){\n\t\t\t\tlist.add(nums1[i]);\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(nums1[i] < nums2[j]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor(int k = 0; k < list.size(); k++){\n\t\t\tres[k] = list.get(k);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int num : nums1) {\n\t\t\tmap.put(num, map.getOrDefault(num, 0) + 1);\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor (int num : nums2) {\n\t\t\tif (map.containsKey(num)) {\n\t\t\t\tlist.add(num);\n\t\t\t\tmap.put(num, map.get(num) - 1);\n\t\t\t\tif (map.get(num) == 0) {\n\t\t\t\t\tmap.remove(num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tres[i] = list.get(i);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tint[] result = new int[nums1.length + nums2.length];\n\t\tint index = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < nums1.length; i++) {\n\t\t\tmap.put(nums1[i], map.getOrDefault(nums1[i], 0) + 1);\n\t\t}\n\t\tfor (int i = 0; i < nums2.length; i++) {\n\t\t\tif (map.containsKey(nums2[i])) {\n\t\t\t\tresult[index++] = nums2[i];\n\t\t\t\tmap.put(nums2[i], map.get(nums2[i]) - 1);\n\t\t\t\tif (map.get(nums2[i]) == 0) {\n\t\t\t\t\tmap.remove(nums2[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOfRange(result, 0, index);\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tint[] result = new int[nums1.length];\n\t\tint index = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < nums1.length; i++) {\n\t\t\tif (map.containsKey(nums1[i])) {\n\t\t\t\tmap.put(nums1[i], map.get(nums1[i]) + 1);\n\t\t\t} else {\n\t\t\t\tmap.put(nums1[i], 1);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < nums2.length; i++) {\n\t\t\tif (map.containsKey(nums2[i]) && map.get(nums2[i]) > 0) {\n\t\t\t\tresult[index++] = nums2[i];\n\t\t\t\tmap.put(nums2[i], map.get(nums2[i]) - 1);\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[index];\n\t\tfor (int i = 0; i < index; i++) {\n\t\t\tres[i] = result[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tint[] result = new int[nums1.length];\n\t\tint index = 0;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < nums1.length; i++){\n\t\t\tif(map.containsKey(nums1[i])){\n\t\t\t\tmap.put(nums1[i], map.get(nums1[i]) + 1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tmap.put(nums1[i], 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums2.length; i++){\n\t\t\tif(map.containsKey(nums2[i])){\n\t\t\t\tif(map.get(nums2[i]) > 0){\n\t\t\t\t\tresult[index] = nums2[i];\n\t\t\t\t\tindex++;\n\t\t\t\t\tmap.put(nums2[i], map.get(nums2[i]) - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[index];\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tres[i] = result[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tint[] result = new int[nums1.length];\n\t\tint index = 0;\n\t\tArrays.sort(nums1);\n\t\tArrays.sort(nums2);\n\t\tint i = 0, j = 0;\n\t\twhile(i < nums1.length && j < nums2.length){\n\t\t\tif(nums1[i] == nums2[j]){\n\t\t\t\tresult[index++] = nums1[i];\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(nums1[i] < nums2[j]){\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(result, index);\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < nums1.length; i++) {\n\t\t\tmap.put(nums1[i], map.getOrDefault(nums1[i], 0) + 1);\n\t\t}\n\t\tList<Integer> list = new ArrayList<>();\n\t\tfor (int i = 0; i < nums2.length; i++) {\n\t\t\tif (map.containsKey(nums2[i]) && map.get(nums2[i]) > 0) {\n\t\t\t\tlist.add(nums2[i]);\n\t\t\t\tmap.put(nums2[i], map.get(nums2[i]) - 1);\n\t\t\t}\n\t\t}\n\t\tint[] res = new int[list.size()];\n\t\tfor (int i = 0; i < res.length; i++) {\n\t\t\tres[i] = list.get(i);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] intersect(int[] nums1, int[] nums2) {\n\t\tint[] res = new int[nums1.length];\n\t\tint i = 0;\n\t\tfor(int j = 0; j < nums1.length; j++){\n\t\t\tif(contains(nums2, nums1[j])){\n\t\t\t\tres[i++] = nums1[j];\n\t\t\t}\n\t\t}\n\t\treturn Arrays.copyOf(res, i);\n\t}\n\tpublic boolean contains(int[] nums, int target){\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == target){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2266",
    "source": "leetcode",
    "language": "java",
    "query": "You are given two positive integer arrays spells and potions, of length n and m respectively. A spell and potion pair is considered successful if the product of their strengths is at least success.",
    "snippets": [
        "\tstatic int[] spell(int[] spells, int[] potions, int success){\n\t\tint[] result = new int[spells.length];\n\t\tfor(int i = 0; i < spells.length; i++){\n\t\t\tfor(int j = 0; j < potions.length; j++){\n\t\t\t\tif(spells[i] * potions[j] >= success){\n\t\t\t\t\tresult[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] spellPotion(int[] spells, int[] potions, int success){\n\t\tint[] result = new int[spells.length];\n\t\tfor(int i = 0; i < spells.length; i++){\n\t\t\tfor(int j = 0; j < potions.length; j++){\n\t\t\t\tif(spells[i] * potions[j] >= success){\n\t\t\t\t\tresult[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] spell(int[] spells, int[] potions, int success){\n\t\tint[] result = new int[spells.length];\n\t\tfor(int i = 0; i < spells.length; i++){\n\t\t\tfor(int j = 0; j < potions.length; j++){\n\t\t\t\tif(spells[i] * potions[j] >= success){\n\t\t\t\t\tresult[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tstatic int[] spellPotion(int[] spells, int[] potions, int success){\n\t\tint[] result = new int[2];\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint count = 0;\n\t\twhile(i < spells.length && j < potions.length){\n\t\t\tif(spells[i] * potions[j] >= success){\n\t\t\t\tcount++;\n\t\t\t\ti++;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(spells[i] > potions[j]){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[0] = count;\n\t\tresult[1] = spells.length + potions.length - count * 2;\n\t\treturn result;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2267",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used. All the letters in the answer string should be lowercase characters.",
    "snippets": [
        "\tString toHex(int num){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num == 0){\n\t\t\treturn \"0\";\n\t\t}\n\t\tif(num < 0){\n\t\t\tnum = ~num + 1;\n\t\t}\n\t\twhile(num != 0){\n\t\t\tint temp = num % 16;\n\t\t\tif(temp < 10){\n\t\t\t\tsb.append(temp);\n\t\t\t}else{\n\t\t\t\tsb.append((char)(temp - 10 + 'a'));\n\t\t\t}\n\t\t\tnum = num / 16;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString toHex(int num){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num == 0){\n\t\t\treturn \"0\";\n\t\t}\n\t\tif(num < 0){\n\t\t\tnum = ~num + 1;\n\t\t}\n\t\twhile(num != 0){\n\t\t\tint temp = num & 15;\n\t\t\tif(temp < 10){\n\t\t\t\tsb.append((char)(temp + '0'));\n\t\t\t}else{\n\t\t\t\tsb.append((char)(temp - 10 + 'a'));\n\t\t\t}\n\t\t\tnum = num >>> 4;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString toHex(int num){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num == 0){\n\t\t\treturn \"0\";\n\t\t}\n\t\tif(num < 0){\n\t\t\tnum = ~num + 1;\n\t\t}\n\t\twhile(num != 0){\n\t\t\tint temp = num & 15;\n\t\t\tif(temp < 10){\n\t\t\t\tsb.append(temp);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append((char)(temp + 87));\n\t\t\t}\n\t\t\tnum = num >>> 4;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString toHex(int num){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num == 0) return \"0\";\n\t\tif(num < 0){\n\t\t\tnum = ~num + 1;\n\t\t}\n\t\twhile(num != 0){\n\t\t\tint temp = num & 15;\n\t\t\tif(temp < 10) sb.append((char)(temp + '0'));\n\t\t\telse sb.append((char)(temp - 10 + 'a'));\n\t\t\tnum = num >>> 4;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString toHex(int num){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num == 0) return \"0\";\n\t\tif(num < 0){\n\t\t\tnum = ~num + 1;\n\t\t}\n\t\twhile(num != 0){\n\t\t\tint digit = num & 15;\n\t\t\tif(digit < 10) sb.append((char)(digit + '0'));\n\t\t\telse sb.append((char)(digit - 10 + 'a'));\n\t\t\tnum = num >>> 4;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString toHex(int num){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num == 0) return \"0\";\n\t\tif(num < 0){\n\t\t\tnum = ~num + 1;\n\t\t\tsb.append(\"-\");\n\t\t}\n\t\twhile(num != 0){\n\t\t\tint temp = num & 15;\n\t\t\tif(temp < 10) sb.append((char)(temp + '0'));\n\t\t\telse sb.append((char)(temp - 10 + 'a'));\n\t\t\tnum = num >>> 4;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString toHex(int num) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num == 0){\n\t\t\treturn \"0\";\n\t\t}\n\t\tif(num < 0){\n\t\t\tnum = Integer.MAX_VALUE + num + 1;\n\t\t}\n\t\twhile(num != 0){\n\t\t\tint temp = num % 16;\n\t\t\tif(temp < 10){\n\t\t\t\tsb.append(temp);\n\t\t\t}else{\n\t\t\t\tsb.append((char)(temp - 10 + 'a'));\n\t\t\t}\n\t\t\tnum = num / 16;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n",
        "\tString toHex(int num){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(num==0){\n\t\t\treturn \"0\";\n\t\t}\n\t\tif(num<0){\n\t\t\tnum = Integer.MAX_VALUE + num + 1;\n\t\t}\n\t\twhile(num!=0){\n\t\t\tint temp = num&15;\n\t\t\tif(temp<10){\n\t\t\t\tsb.append((char)(temp+'0'));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append((char)(temp-10+'a'));\n\t\t\t}\n\t\t\tnum = num>>>4;\n\t\t}\n\t\treturn sb.reverse().toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2268",
    "source": "leetcode",
    "language": "java",
    "query": "Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\" You want to know how many of the stones you have are also jewels.",
    "snippets": [
        "\tint numJewelsInStones(String J, String S) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < S.length(); i++){\n\t\t\tif(J.indexOf(S.charAt(i)) != -1){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int numJewelsInStones(String J, String S) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < S.length(); i++) {\n\t\t\tif (J.indexOf(S.charAt(i)) != -1) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] jewels = {\"a\",\"b\",\"c\"};\n\t\tString[] stones = {\"a\",\"b\",\"c\"};\n\t\tint count = 0;\n\t\tfor(int i = 0; i < jewels.length; i++){\n\t\t\tfor(int j = 0; j < stones.length; j++){\n\t\t\t\tif(jewels[i].equals(stones[j])){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString[] J = {\"aA\", \"bB\", \"cC\"};\n\t\tString[] S = {\"aAAbbbb\", \"zZ\", \"cC\"};\n\t\tint count = 0;\n\t\tfor(int i = 0; i < J.length; i++){\n\t\t\tfor(int j = 0; j < S.length; j++){\n\t\t\t\tif(J[i].equals(S[j])){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2269",
    "source": "leetcode",
    "language": "java",
    "query": "A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. Given the roots of two binary trees root and subRoot, return true if there is a subtree with the same structure and node values of subRoot.",
    "snippets": [
        "\tboolean isSubtree(TreeNode root, TreeNode subRoot) {\n\t\tif(root == null) return false;\n\t\tif(isSame(root, subRoot)) return true;\n\t\treturn isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n\t}\n\tpublic boolean isSame(TreeNode root, TreeNode subRoot){\n\t\tif(root == null && subRoot == null) return true;\n\t\tif(root == null || subRoot == null) return false;\n\t\tif(root.val != subRoot.val) return false;\n\t\treturn isSame(root.left, subRoot.left) && isSame(root.right, subRoot.right);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2270",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k. Pick the scores of any k students from the array so that the difference between the highest and lowest of the k scores is minimized.",
    "snippets": [
        "\tint pick(int[] nums, int k){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i < k){\n\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t}else{\n\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\tmin = Math.min(min, nums[i - k]);\n\t\t\t\tmax = Math.max(max, nums[i - k]);\n\t\t\t}\n\t\t}\n\t\treturn max - min;\n\t}\n}\n",
        "\tint pick(int[] nums, int k){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] < min){\n\t\t\t\tmin = nums[i];\n\t\t\t}\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t}\n\t\t}\n\t\tint diff = max - min;\n\t\tint minDiff = diff;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(j - i == k){\n\t\t\t\t\tint temp = nums[i] + nums[j];\n\t\t\t\t\tif(temp < minDiff){\n\t\t\t\t\t\tminDiff = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn minDiff;\n\t}\n}\n",
        "\tint pick(int[] nums, int k){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] < min){\n\t\t\t\tmin = nums[i];\n\t\t\t}\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t}\n\t\t}\n\t\tint diff = max - min;\n\t\tint minDiff = diff;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tif(j - i == k){\n\t\t\t\t\tint temp = nums[i] - nums[j];\n\t\t\t\t\tif(temp < minDiff){\n\t\t\t\t\t\tminDiff = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn minDiff;\n\t}\n}\n",
        "\tint pick(int[] nums, int k){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] < min){\n\t\t\t\tmin = nums[i];\n\t\t\t}\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t}\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tint temp = nums[i];\n\t\t\tnums[i] = max;\n\t\t\tmax = min;\n\t\t\tmin = temp;\n\t\t\tint tempDiff = max - min;\n\t\t\tif(tempDiff < diff){\n\t\t\t\tdiff = tempDiff;\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint pick(int[] nums, int k){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] < min){\n\t\t\t\tmin = nums[i];\n\t\t\t}\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t}\n\t\t}\n\t\tint diff = max - min;\n\t\tint[] temp = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\ttemp[i] = nums[i] - min;\n\t\t}\n\t\tArrays.sort(temp);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < k; i++){\n\t\t\tsum += temp[i];\n\t\t}\n\t\treturn sum + min;\n\t}\n}\n",
        "\tint pick(int[] nums, int k){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i < k){\n\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t}else{\n\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\tnums[i - k] = nums[i - k] - min + max;\n\t\t\t\tmin = Integer.MAX_VALUE;\n\t\t\t\tmax = Integer.MIN_VALUE;\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tres = Math.min(res, nums[i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint pick(int[] nums, int k){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] < min) min = nums[i];\n\t\t\tif(nums[i] > max) max = nums[i];\n\t\t}\n\t\tint diff = max - min;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] - min > diff) continue;\n\t\t\tint[] newNums = new int[nums.length - 1];\n\t\t\tint j = 0;\n\t\t\tfor(int k = 0; k < nums.length; k++){\n\t\t\t\tif(k == i) continue;\n\t\t\t\tnewNums[j] = nums[k];\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tint newDiff = pick(newNums, k - 1);\n\t\t\tif(newDiff < diff){\n\t\t\t\tdiff = newDiff;\n\t\t\t}\n\t\t}\n\t\treturn diff;\n\t}\n}\n",
        "\tint pick(int[] nums, int k) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint max = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i < k){\n\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t}else{\n\t\t\t\tif(nums[i] < min){\n\t\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\t}else if(nums[i] > max){\n\t\t\t\t\tmin = Math.min(min, nums[i]);\n\t\t\t\t\tmax = Math.max(max, nums[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max - min;\n\t}\n}\n",
        "\tint kthSmallest(int[] nums, int k) {\n\t\tint n = nums.length;\n\t\tint[] sorted = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tsorted[i] = nums[i];\n\t\t}\n\t\tArrays.sort(sorted);\n\t\treturn sorted[k-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2271",
    "source": "leetcode",
    "language": "java",
    "query": "The two dates are given as strings, their format is YYYY-MM-DD. Write a program to count the number of days between two dates.",
    "snippets": [
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString date1 = sc.nextLine();\n\t\tString date2 = sc.nextLine();\n\t\tint[] date1Array = new int[3];\n\t\tint[] date2Array = new int[3];\n\t\tString[] date1Split = date1.split(\"-\");\n\t\tString[] date2Split = date2.split(\"-\");\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdate1Array[i] = Integer.parseInt(date1Split[i]);\n\t\t\tdate2Array[i] = Integer.parseInt(date2Split[i]);\n\t\t}\n\t\tint days = 0;\n\t\tif(date1Array[0] == date2Array[0]){\n\t\t\tif(date1Array[1] == date2Array[1]){\n\t\t\t\tdays = date2Array[2] - date1Array[2];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays = (date2Array[1] - date1Array[1]) * 30 - date1Array[2] + date2Array[2];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdays = (date2Array[0] - date1Array[0]) * 365 - date1Array[1] * 30 + date2Array[2];\n\t\t}\n\t\tSystem.out.println(days);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString date1 = sc.nextLine();\n\t\tString date2 = sc.nextLine();\n\t\tint days = 0;\n\t\tString[] date1_arr = date1.split(\"-\");\n\t\tString[] date2_arr = date2.split(\"-\");\n\t\tint year1 = Integer.parseInt(date1_arr[0]);\n\t\tint year2 = Integer.parseInt(date2_arr[0]);\n\t\tint month1 = Integer.parseInt(date1_arr[1]);\n\t\tint month2 = Integer.parseInt(date2_arr[1]);\n\t\tint day1 = Integer.parseInt(date1_arr[2]);\n\t\tint day2 = Integer.parseInt(date2_arr[2]);\n\t\tif(year1 == year2){\n\t\t\tif(month1 == month2){\n\t\t\t\tdays = day2 - day1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays = (month2 - month1) * 30 - day1 + day2;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdays = (year2 - year1) * 365 - day1 + day2;\n\t\t}\n\t\tSystem.out.println(days);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString date1 = sc.nextLine();\n\t\tString date2 = sc.nextLine();\n\t\tsc.close();\n\t\tint[] date1_arr = new int[3];\n\t\tint[] date2_arr = new int[3];\n\t\tString[] date1_str = date1.split(\"-\");\n\t\tString[] date2_str = date2.split(\"-\");\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tdate1_arr[i] = Integer.parseInt(date1_str[i]);\n\t\t\tdate2_arr[i] = Integer.parseInt(date2_str[i]);\n\t\t}\n\t\tint days = 0;\n\t\tif(date1_arr[0] == date2_arr[0]){\n\t\t\tif(date1_arr[1] == date2_arr[1]){\n\t\t\t\tdays = date2_arr[2] - date1_arr[2];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays = (date2_arr[1] - date1_arr[1]) * 30 + (date2_arr[2] - date1_arr[2]);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdays = (date2_arr[0] - date1_arr[0]) * 365 + (date2_arr[1] - date1_arr[1]) * 30 + (date2_arr[2] - date1_arr[2]);\n\t\t}\n\t\tSystem.out.println(days);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString date1 = sc.nextLine();\n\t\tString date2 = sc.nextLine();\n\t\tString[] date1_split = date1.split(\"-\");\n\t\tString[] date2_split = date2.split(\"-\");\n\t\tint year1 = Integer.parseInt(date1_split[0]);\n\t\tint year2 = Integer.parseInt(date2_split[0]);\n\t\tint month1 = Integer.parseInt(date1_split[1]);\n\t\tint month2 = Integer.parseInt(date2_split[1]);\n\t\tint day1 = Integer.parseInt(date1_split[2]);\n\t\tint day2 = Integer.parseInt(date2_split[2]);\n\t\tint days = 0;\n\t\tif(year1 == year2){\n\t\t\tif(month1 == month2){\n\t\t\t\tdays = day2 - day1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays = (month2 - month1) * 30 - day1 + day2;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdays = (year2 - year1) * 365 - (month1 - 1) * 30 - day1 + (month2 - 1) * 30 + day2;\n\t\t}\n\t\tSystem.out.println(days);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tString date1 = sc.next();\n\t\tString date2 = sc.next();\n\t\tint[] d1 = new int[3];\n\t\tint[] d2 = new int[3];\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\td1[i] = Integer.parseInt(date1.split(\"-\")[i]);\n\t\t\td2[i] = Integer.parseInt(date2.split(\"-\")[i]);\n\t\t}\n\t\tint days = 0;\n\t\tfor(int i = 0; i < 3; i++){\n\t\t\tif(d1[i] > d2[i]){\n\t\t\t\tdays += (d1[i] - d2[i]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays += (d2[i] - d1[i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(days);\n\t}\n}\n",
        "\tstatic int daysBetweenDates(String date1, String date2) {\n\t\tint days = 0;\n\t\tint year1 = Integer.parseInt(date1.substring(0, 4));\n\t\tint year2 = Integer.parseInt(date2.substring(0, 4));\n\t\tint month1 = Integer.parseInt(date1.substring(5, 7));\n\t\tint month2 = Integer.parseInt(date2.substring(5, 7));\n\t\tint day1 = Integer.parseInt(date1.substring(8, 10));\n\t\tint day2 = Integer.parseInt(date2.substring(8, 10));\n\t\tif (year1 == year2) {\n\t\t\tif (month1 == month2) {\n\t\t\t\tdays = day2 - day1;\n\t\t\t} else {\n\t\t\t\tdays = (month2 - month1) * 30 + day2 - day1;\n\t\t\t}\n\t\t} else {\n\t\t\tdays = (year2 - year1) * 365 + (month2 - month1) * 30 + day2 - day1;\n\t\t}\n\t\treturn days;\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString date1 = \"2014-06-30\";\n\t\tString date2 = \"2014-07-01\";\n\t\tint days = 0;\n\t\tString[] date1Array = date1.split(\"-\");\n\t\tString[] date2Array = date2.split(\"-\");\n\t\tint year1 = Integer.parseInt(date1Array[0]);\n\t\tint year2 = Integer.parseInt(date2Array[0]);\n\t\tint month1 = Integer.parseInt(date1Array[1]);\n\t\tint month2 = Integer.parseInt(date2Array[1]);\n\t\tint day1 = Integer.parseInt(date1Array[2]);\n\t\tint day2 = Integer.parseInt(date2Array[2]);\n\t\tif(year1 == year2){\n\t\t\tif(month1 == month2){\n\t\t\t\tdays = day2 - day1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays = (month2 - month1) * 30 + day2 - day1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdays = (year2 - year1) * 365 + (month2 - month1) * 30 + day2 - day1;\n\t\t}\n\t\tSystem.out.println(days);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString date1 = \"2014-06-01\";\n\t\tString date2 = \"2014-06-02\";\n\t\tint days = daysBetweenDates(date1, date2);\n\t\tSystem.out.println(days);\n\t}\n\tpublic static int daysBetweenDates(String date1, String date2){\n\t\tSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tDate d1 = null;\n\t\tDate d2 = null;\n\t\ttry{\n\t\t\td1 = sdf.parse(date1);\n\t\t\td2 = sdf.parse(date2);\n\t\t}catch(ParseException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\tlong diff = d2.getTime() - d1.getTime();\n\t\treturn (int)(diff / (1000 * 60 * 60 * 24));\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString date1 = \"2014-06-01\";\n\t\tString date2 = \"2014-06-02\";\n\t\tint days = 0;\n\t\tString[] date1Array = date1.split(\"-\");\n\t\tString[] date2Array = date2.split(\"-\");\n\t\tint year1 = Integer.parseInt(date1Array[0]);\n\t\tint year2 = Integer.parseInt(date2Array[0]);\n\t\tint month1 = Integer.parseInt(date1Array[1]);\n\t\tint month2 = Integer.parseInt(date2Array[1]);\n\t\tint day1 = Integer.parseInt(date1Array[2]);\n\t\tint day2 = Integer.parseInt(date2Array[2]);\n\t\tif(year1 == year2){\n\t\t\tif(month1 == month2){\n\t\t\t\tdays = day2 - day1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays = (month2 - month1) * 30 - day1 + day2;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdays = (year2 - year1) * 365 - (month1 - 1) * 30 - day1 + (month2 - 1) * 30 + day2;\n\t\t}\n\t\tSystem.out.println(days);\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tString date1 = \"2014-01-01\";\n\t\tString date2 = \"2014-01-02\";\n\t\tint days = daysBetweenDates(date1, date2);\n\t\tSystem.out.println(days);\n\t}\n\tpublic static int daysBetweenDates(String date1, String date2){\n\t\tint days = 0;\n\t\tString[] date1Array = date1.split(\"-\");\n\t\tString[] date2Array = date2.split(\"-\");\n\t\tint year1 = Integer.parseInt(date1Array[0]);\n\t\tint year2 = Integer.parseInt(date2Array[0]);\n\t\tint month1 = Integer.parseInt(date1Array[1]);\n\t\tint month2 = Integer.parseInt(date2Array[1]);\n\t\tint day1 = Integer.parseInt(date1Array[2]);\n\t\tint day2 = Integer.parseInt(date2Array[2]);\n\t\tif(year1 == year2){\n\t\t\tif(month1 == month2){\n\t\t\t\tdays = day2 - day1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdays = (month2 - month1) * 30 + (day2 - day1);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tdays = (year2 - year1) * 365 + (month2 - month1) * 30 + (day2 - day1);\n\t\t}\n\t\treturn days;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2272",
    "source": "leetcode",
    "language": "java",
    "query": "A professional robber plans to rob houses along a street. Each house has a certain amount of money stashed. The only constraint stopping you from robbing each of them is that adjacent houses have security systems connected.",
    "snippets": [
        "\tint rob(int[] nums) {\n\t\tint len = nums.length;\n\t\tif(len == 0) return 0;\n\t\tif(len == 1) return nums[0];\n\t\tif(len == 2) return Math.max(nums[0], nums[1]);\n\t\tint[] dp = new int[len];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(nums[0], nums[1]);\n\t\tfor(int i = 2; i < len; i++){\n\t\t\tdp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n\t\t}\n\t\treturn dp[len-1];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {1,2,3,1};\n\t\tSystem.out.println(rob(nums));\n\t}\n\tpublic static int rob(int[] nums){\n\t\tif(nums.length == 0) return 0;\n\t\tif(nums.length == 1) return nums[0];\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(nums[0],nums[1]);\n\t\tfor(int i = 2; i < nums.length; i++){\n\t\t\tdp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);\n\t\t}\n\t\treturn dp[nums.length-1];\n\t}\n}\n",
        "\tint rob(int[] nums) {\n\t\tif(nums.length == 0) return 0;\n\t\tif(nums.length == 1) return nums[0];\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(nums[0], nums[1]);\n\t\tfor(int i = 2; i < nums.length; i++){\n\t\t\tdp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n\t\t}\n\t\treturn dp[nums.length-1];\n\t}\n}\n",
        "\tint rob(int[] nums) {\n\t\tint n = nums.length;\n\t\tif(n == 0) return 0;\n\t\tif(n == 1) return nums[0];\n\t\tif(n == 2) return Math.max(nums[0], nums[1]);\n\t\tint[] dp = new int[n];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(nums[0], nums[1]);\n\t\tfor(int i = 2; i < n; i++){\n\t\t\tdp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n\t\t}\n\t\treturn dp[n-1];\n\t}\n}\n",
        "\tstatic int rob(int[] nums) {\n\t\tif(nums.length == 0) return 0;\n\t\tif(nums.length == 1) return nums[0];\n\t\tif(nums.length == 2) return Math.max(nums[0], nums[1]);\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(nums[0], nums[1]);\n\t\tfor(int i = 2; i < nums.length; i++){\n\t\t\tdp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n\t\t}\n\t\treturn dp[nums.length-1];\n\t}\n}\n",
        "\tstatic void main(String[] args){\n\t\tint[] nums = {2,7,9,3,1};\n\t\tSystem.out.println(rob(nums));\n\t}\n\tpublic static int rob(int[] nums){\n\t\tif(nums.length == 0) return 0;\n\t\tif(nums.length == 1) return nums[0];\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(nums[0], nums[1]);\n\t\tfor(int i = 2; i < nums.length; i++){\n\t\t\tdp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n\t\t}\n\t\treturn dp[nums.length-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2273",
    "source": "leetcode",
    "language": "java",
    "query": "A super ugly number is a positive integer whose prime factors are in the array primes. It is guaranteed to fit in a 32-bit signed integer.",
    "snippets": [
        "\tint nthSuperUglyNumber(int n, int[] primes) {\n\t\tint[] res = new int[n];\n\t\tres[0] = 1;\n\t\tint[] index = new int[primes.length];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tres[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tres[i] = Math.min(res[i], primes[j] * res[index[j]]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tif (res[i] == primes[j] * res[index[j]]) {\n\t\t\t\t\tindex[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res[n - 1];\n\t}\n}\n",
        "\tint nthSuperUglyNumber(int n, int[] primes) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint[] index = new int[primes.length];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tugly[i] = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tugly[i] = Math.min(ugly[i], primes[j] * ugly[index[j]]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tif (ugly[i] == primes[j] * ugly[index[j]]) {\n\t\t\t\t\tindex[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n",
        "\tint nthSuperUglyNumber(int n, int[] primes) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint[] index = new int[primes.length];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tmin = Math.min(min, primes[j] * ugly[index[j]]);\n\t\t\t}\n\t\t\tugly[i] = min;\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tif (min == primes[j] * ugly[index[j]]) {\n\t\t\t\t\tindex[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n",
        "\tstatic int nthSuperUglyNumber(int n, int[] primes) {\n\t\tint[] ugly = new int[n];\n\t\tugly[0] = 1;\n\t\tint[] index = new int[primes.length];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tmin = Math.min(min, primes[j] * ugly[index[j]]);\n\t\t\t}\n\t\t\tugly[i] = min;\n\t\t\tfor (int j = 0; j < primes.length; j++) {\n\t\t\t\tif (ugly[i] == primes[j] * ugly[index[j]]) {\n\t\t\t\t\tindex[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ugly[n - 1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2274",
    "source": "leetcode",
    "language": "java",
    "query": "Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.",
    "snippets": [
        "\tint maximalSquare(char[][] matrix) {\n\t\tint m = matrix.length;\n\t\tif(m == 0) return 0;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(matrix[i][j] == '1'){\n\t\t\t\t\tif(i == 0 || j == 0) dp[i][j] = 1;\n\t\t\t\t\telse dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n\t\t\t\t\tmax = Math.max(max, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max * max;\n\t}\n}\n",
        "\tint maximalSquare(char[][] matrix) {\n\t\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\n\t\tint m = matrix.length, n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(matrix[i][j] == '1'){\n\t\t\t\t\tif(i == 0 || j == 0) dp[i][j] = 1;\n\t\t\t\t\telse dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n\t\t\t\t\tmax = Math.max(max, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max * max;\n\t}\n}\n",
        "\tint maximalSquare(char[][] matrix) {\n\t\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\n\t\tint m = matrix.length, n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(matrix[i][j] == '1'){\n\t\t\t\t\tif(i == 0 || j == 0) dp[i][j] = 1;\n\t\t\t\t\telse dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;\n\t\t\t\t\tmax = Math.max(max, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max * max;\n\t}\n}\n",
        "\tint maximalSquare(char[][] matrix) {\n\t\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0)\n\t\t\treturn 0;\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(matrix[i][j] == '1'){\n\t\t\t\t\tif(i == 0 || j == 0)\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;\n\t\t\t\t\tmax = Math.max(max, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max * max;\n\t}\n}\n",
        "\tint maximalSquare(char[][] matrix) {\n\t\tif(matrix.length == 0) return 0;\n\t\tint m = matrix.length;\n\t\tint n = matrix[0].length;\n\t\tint[][] dp = new int[m][n];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(matrix[i][j] == '1'){\n\t\t\t\t\tif(i == 0 || j == 0) dp[i][j] = 1;\n\t\t\t\t\telse dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;\n\t\t\t\t\tmax = Math.max(max, dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max * max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2275",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums, return the maximum result of nums[i] XOR nums [j], where 0 <= i <= j < n.",
    "snippets": [
        "\tint findMaximumXOR(int[] nums) {\n\t\tint max = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tfor (int j = i + 1; j < nums.length; j++) {\n\t\t\t\tint xor = nums[i] ^ nums[j];\n\t\t\t\tif (xor > max) {\n\t\t\t\t\tmax = xor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaximumXOR(int[] nums) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tmax = Math.max(max, nums[i] ^ nums[j]);\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint findMaximumXOR(int[] nums) {\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tfor(int j = i + 1; j < nums.length; j++){\n\t\t\t\tint temp = nums[i] ^ nums[j];\n\t\t\t\tif(temp > max) max = temp;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2276",
    "source": "leetcode",
    "language": "java",
    "query": "A subarray is a contiguous part of an array. Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum.",
    "snippets": [
        "\tint maxSubArray(int[] nums) {\n\t\tint max = nums[0];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tif(sum > max)\n\t\t\t\tmax = sum;\n\t\t\tif(sum < 0)\n\t\t\t\tsum = 0;\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint maxSubArray(int[] nums) {\n\t\tint max = nums[0];\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\tif (sum > max) {\n\t\t\t\tmax = sum;\n\t\t\t}\n\t\t\tif (sum < 0) {\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2277",
    "source": "leetcode",
    "language": "java",
    "query": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffle.",
    "snippets": [
        "\tString restoreString(String s, int[] indices) {\n\t\tchar[] arr = s.toCharArray();\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tchar temp = arr[i];\n\t\t\tarr[i] = arr[indices[i]];\n\t\t\tarr[indices[i]] = temp;\n\t\t}\n\t\treturn new String(arr);\n\t}\n}\n",
        "\tString restoreString(String s, int[] indices) {\n\t\tchar[] ch = s.toCharArray();\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tchar temp = ch[i];\n\t\t\tch[i] = ch[indices[i]];\n\t\t\tch[indices[i]] = temp;\n\t\t}\n\t\treturn new String(ch);\n\t}\n}\n",
        "\tString restoreString(String s, int[] indices) {\n\t\tchar[] chars = s.toCharArray();\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tchar temp = chars[i];\n\t\t\tchars[i] = chars[indices[i]];\n\t\t\tchars[indices[i]] = temp;\n\t\t}\n\t\treturn new String(chars);\n\t}\n}\n",
        "\tString restoreString(String s, int[] indices) {\n\t\tchar[] ch = s.toCharArray();\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tch[indices[i]] = s.charAt(i);\n\t\t}\n\t\treturn new String(ch);\n\t}\n}\n",
        "\tString shuffleString(String s, int[] indices) {\n\t\tchar[] chars = s.toCharArray();\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tchar temp = chars[i];\n\t\t\tchars[i] = chars[indices[i]];\n\t\t\tchars[indices[i]] = temp;\n\t\t}\n\t\treturn new String(chars);\n\t}\n}\n",
        "\tString shuffleString(String s, int[] indices) {\n\t\tchar[] arr = s.toCharArray();\n\t\tfor(int i = 0; i < indices.length; i++){\n\t\t\tchar temp = arr[i];\n\t\t\tarr[i] = arr[indices[i]];\n\t\t\tarr[indices[i]] = temp;\n\t\t}\n\t\treturn new String(arr);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2278",
    "source": "leetcode",
    "language": "java",
    "query": "Reverse the strings in each pair of matching parentheses, starting from the innermost one. Your result should not contain any brackets.",
    "snippets": [
        "\tString reverseParentheses(String s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < s.length() && s.charAt(j) != ')'){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tsb.append(new StringBuilder(s.substring(i + 1, j)).reverse());\n\t\t\t\ti = j;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsb.append(s.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString reverseParentheses(String s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < s.length() && s.charAt(j) != ')'){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tString temp = s.substring(i + 1, j);\n\t\t\t\tStringBuilder sb2 = new StringBuilder();\n\t\t\t\tfor(int k = temp.length() - 1; k >= 0; k--){\n\t\t\t\t\tsb2.append(temp.charAt(k));\n\t\t\t\t}\n\t\t\t\tsb.append(sb2.toString());\n\t\t\t\ti = j;\n\t\t\t}else{\n\t\t\t\tsb.append(s.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString reverseInParentheses(String s) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < s.length() && s.charAt(j) != ')'){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tString temp = s.substring(i + 1, j);\n\t\t\t\tString reverse = new StringBuilder(temp).reverse().toString();\n\t\t\t\tsb.append(reverse);\n\t\t\t\ti = j;\n\t\t\t}else{\n\t\t\t\tsb.append(s.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString reverseInParentheses(String s){\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tleft = i;\n\t\t\t}\n\t\t\tif(s.charAt(i) == ')'){\n\t\t\t\tright = i;\n\t\t\t}\n\t\t}\n\t\tString temp = s.substring(left + 1, right);\n\t\tString reverse = new StringBuilder(temp).reverse().toString();\n\t\tsb.append(s.substring(0, left));\n\t\tsb.append(reverse);\n\t\tsb.append(s.substring(right + 1));\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString reverseInParentheses(String s) {\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < s.length() && s.charAt(j) != ')'){\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tString temp = s.substring(i + 1, j);\n\t\t\t\tStringBuilder sb = new StringBuilder(temp);\n\t\t\t\tsb.reverse();\n\t\t\t\ts = s.substring(0, i + 1) + sb.toString() + s.substring(j);\n\t\t\t\ti = j;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn s;\n\t}\n}\n",
        "\tString reverseInParentheses(String s){\n\t\tint start = 0;\n\t\tint end = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tstart = i;\n\t\t\t}\n\t\t\tif(s.charAt(i) == ')'){\n\t\t\t\tend = i;\n\t\t\t\tString temp = s.substring(start + 1, end);\n\t\t\t\tStringBuilder sb2 = new StringBuilder();\n\t\t\t\tfor(int j = temp.length() - 1; j >= 0; j--){\n\t\t\t\t\tsb2.append(temp.charAt(j));\n\t\t\t\t}\n\t\t\t\tsb.append(sb2.toString());\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString reverseInParentheses(String s) {\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) == '('){\n\t\t\t\tleft = i;\n\t\t\t}\n\t\t\tif(s.charAt(i) == ')'){\n\t\t\t\tright = i;\n\t\t\t}\n\t\t}\n\t\tString temp = s.substring(left+1, right);\n\t\tString temp2 = new StringBuilder(temp).reverse().toString();\n\t\tsb.append(s.substring(0, left));\n\t\tsb.append(temp2);\n\t\tsb.append(s.substring(right+1));\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString reverseInParentheses(String s) {\n\t\tint left = 0;\n\t\tint right = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif (s.charAt(i) == '(') {\n\t\t\t\tleft = i;\n\t\t\t}\n\t\t\tif (s.charAt(i) == ')') {\n\t\t\t\tright = i;\n\t\t\t\tsb.append(s.substring(left + 1, right));\n\t\t\t\tsb.reverse();\n\t\t\t\tsb.append(s.substring(left + 1, right));\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2279",
    "source": "leetcode",
    "language": "java",
    "query": "A falling path starts at any element in the first row and chooses the next element that is either directly below or diagonally left/right. Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.",
    "snippets": [
        "\tint minFallingPathSum(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][0] = matrix[i][0];\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j], Math.min(dp[i - 1][j - 1], dp[i - 1][j + 1]));\n\t\t\t}\n\t\t}\n\t\tint res = dp[n - 1][0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tres = Math.min(res, dp[n - 1][i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minFallingPathSum(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][0] = matrix[i][0];\n\t\t}\n\t\tfor (int j = 1; j < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdp[i][j] = matrix[i][j] + Math.min(dp[i][j - 1], Math.min(dp[i - 1][j - 1], dp[i + 1][j - 1]));\n\t\t\t}\n\t\t}\n\t\tint res = dp[0][n - 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = Math.min(res, dp[i][n - 1]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minFallingPathSum(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][0] = matrix[i][0];\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j], Math.min(dp[i - 1][j - 1], dp[i - 1][j + 1]));\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = Math.min(res, dp[n - 1][i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minFallingPathSum(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = matrix[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] += Math.min(dp[i - 1][j], Math.min(dp[i - 1][j + 1], dp[i - 1][j - 1]));\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = Math.min(res, dp[n - 1][i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minFallingPathSum(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][0] = matrix[i][0];\n\t\t}\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = matrix[i][j] + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i - 1][j + 1]));\n\t\t\t}\n\t\t}\n\t\tint res = dp[n - 1][0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tres = Math.min(res, dp[n - 1][i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint minFallingPathSum(int[][] matrix) {\n\t\tint n = matrix.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tdp[i][0] = matrix[i][0];\n\t\t}\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdp[i][j] = matrix[i][j] + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i-1][j+1]));\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tres = Math.min(res, dp[n-1][i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2280",
    "source": "leetcode",
    "language": "java",
    "query": "Given an binary array nums and an integer k, return true if all 1's are at least k places away from each other. Otherwise return false.",
    "snippets": [
        "\tboolean kLengthApart(int[] nums, int k) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 1){\n\t\t\t\tif(count < k) return false;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean kLengthApart(int[] nums, int k) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 1){\n\t\t\t\tif(count == 0){\n\t\t\t\t\tcount = i;\n\t\t\t\t}else{\n\t\t\t\t\tif(i - count <= k){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tcount = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean kLengthApart(int[] nums, int k) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 1){\n\t\t\t\tif(count < k){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean kLengthApart(int[] nums, int k) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] == 1){\n\t\t\t\tif(count == 0){\n\t\t\t\t\tcount = i;\n\t\t\t\t}else{\n\t\t\t\t\tif(i - count < k)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcount = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2281",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti. A chain of pairs can be formed in this fashion.",
    "snippets": [
        "\tint chain(int[][] pairs) {\n\t\tint n = pairs.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = pairs[i][0];\n\t\t\tright[i] = pairs[i][1];\n\t\t}\n\t\tArrays.sort(left);\n\t\tArrays.sort(right);\n\t\tint res = 0;\n\t\tint i = 0, j = 0;\n\t\twhile (i < n && j < n) {\n\t\t\tif (left[i] < right[j]) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int chain(int[][] pairs) {\n\t\tint n = pairs.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = pairs[i][0];\n\t\t\tright[i] = pairs[i][1];\n\t\t}\n\t\tArrays.sort(left);\n\t\tArrays.sort(right);\n\t\tint count = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (left[i] == right[i]) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int chain(int[][] pairs) {\n\t\tint n = pairs.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = pairs[i][0];\n\t\t\tright[i] = pairs[i][1];\n\t\t}\n\t\tArrays.sort(left);\n\t\tArrays.sort(right);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (left[i] == right[i]) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\tif (left[i] == right[j]) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tstatic int chain(int[][] pairs) {\n\t\tint n = pairs.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tleft[i] = pairs[i][0];\n\t\t\tright[i] = pairs[i][1];\n\t\t}\n\t\tArrays.sort(left);\n\t\tArrays.sort(right);\n\t\tint count = 0;\n\t\tint i = 0;\n\t\tint j = 0;\n\t\twhile (i < n && j < n) {\n\t\t\tif (left[i] < right[j]) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint chain(int[] pairs){\n\t\tint n = pairs.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tleft[i] = pairs[i][0];\n\t\t\tright[i] = pairs[i][1];\n\t\t}\n\t\tArrays.sort(left);\n\t\tArrays.sort(right);\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(left[i] == right[i]){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int chain(int[][] pairs) {\n\t\tint n = pairs.length;\n\t\tint[][] dp = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tdp[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][i] + dp[i + 1][j]);\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i][i] + dp[i + 1][j + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = Integer.MAX_VALUE;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres = Math.min(res, dp[0][i]);\n\t\t}\n\t\treturn res == Integer.MAX_VALUE ? -1 : res;\n\t}\n}\n",
        "\tstatic int chain(int[][] pairs) {\n\t\tif(pairs == null || pairs.length == 0) return 0;\n\t\tint n = pairs.length;\n\t\tint[] left = new int[n];\n\t\tint[] right = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tleft[i] = pairs[i][0];\n\t\t\tright[i] = pairs[i][1];\n\t\t}\n\t\tArrays.sort(left);\n\t\tArrays.sort(right);\n\t\tint count = 0;\n\t\tint i = 0, j = 0;\n\t\twhile(i < n && j < n){\n\t\t\tif(left[i] < right[j]){\n\t\t\t\ti++;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tstatic int chain(int[][] pairs) {\n\t\tif(pairs.length == 0) return 0;\n\t\tint n = pairs.length;\n\t\tint[] dp = new int[n];\n\t\tArrays.fill(dp, 1);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(pairs[i][0] > pairs[j][1]){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Arrays.stream(dp).max().getAsInt();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2282",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums of 2n, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.",
    "snippets": [
        "\tint maxSum(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] dp = new int[n];\n\t\tdp[0] = nums[0];\n\t\tdp[1] = Math.max(nums[0], nums[1]);\n\t\tfor (int i = 2; i < n; i++) {\n\t\t\tdp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\n\t\t}\n\t\treturn dp[n - 1];\n\t}\n}\n",
        "\tint arrayPairSum(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < nums.length; i += 2) {\n\t\t\tsum += Math.min(nums[i], nums[i + 1]);\n\t\t}\n\t\treturn sum;\n\t}\n}\n",
        "\tint arrayPairSum(int[] nums) {\n\t\tArrays.sort(nums);\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i += 2){\n\t\t\tsum += nums[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2283",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array.",
    "snippets": [
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(set.contains(nums[i])){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tset.add(nums[i]);\n\t\t\tif(set.size() > k){\n\t\t\t\tset.remove(nums[i-k]);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tSet<Integer> set = new HashSet<Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i > k) set.remove(nums[i-k-1]);\n\t\t\tif(!set.add(nums[i])) return true;\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tif (map.containsKey(nums[i])) {\n\t\t\t\tif (i - map.get(nums[i]) <= k) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap.put(nums[i], i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tif(nums == null || nums.length == 0) return false;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(nums[i])){\n\t\t\t\tif(i - map.get(nums[i]) <= k) return true;\n\t\t\t}\n\t\t\tmap.put(nums[i], i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tif(nums == null || nums.length == 0)\n\t\t\treturn false;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(nums[i])){\n\t\t\t\tif(i - map.get(nums[i]) <= k)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tmap.put(nums[i], i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(nums[i])){\n\t\t\t\tif(i - map.get(nums[i]) <= k) return true;\n\t\t\t}\n\t\t\tmap.put(nums[i], i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tif(nums.length<=1) return false;\n\t\tMap<Integer,Integer> map = new HashMap<Integer,Integer>();\n\t\tfor(int i=0;i<nums.length;i++){\n\t\t\tif(map.containsKey(nums[i])){\n\t\t\t\tif(i-map.get(nums[i])<=k) return true;\n\t\t\t}\n\t\t\tmap.put(nums[i],i);\n\t\t}\n\t\treturn false;\n\t}\n}\n",
        "\tboolean containsNearbyDuplicate(int[] nums, int k) {\n\t\tif(nums == null || nums.length == 0 || k <= 0) return false;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(map.containsKey(nums[i])){\n\t\t\t\tif(i - map.get(nums[i]) <= k) return true;\n\t\t\t}\n\t\t\tmap.put(nums[i], i);\n\t\t}\n\t\treturn false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2284",
    "source": "leetcode",
    "language": "java",
    "query": "Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.",
    "snippets": [
        "\tboolean rotate(int[][] mat, int[][] target) {\n\t\tint n = mat.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] != target[j][n - 1 - i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean rotate(int[][] mat, int[][] target) {\n\t\tint n = mat.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] != target[j][n - i - 1]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean rotate(int[][] mat, int[][] target) {\n\t\tint n = mat.length;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] != target[j][n - 1 - i])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean rotate(int[][] mat, int[][] target) {\n\t\tif(mat.length != target.length) return false;\n\t\tint n = mat.length;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(mat[i][j] != target[j][n-i-1]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2285",
    "source": "leetcode",
    "language": "java",
    "query": "Given an m x n binary matrix mat, return the number of submatrices that have all ones.",
    "snippets": [
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tcount += dfs(mat, i, j, m, n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic\n\tint dfs(int[][] mat, int i, int j, int m, int n) {\n\t\tint count = 0;\n\t\tfor (int k = i; k < m; k++) {\n\t\t\tfor (int l = j; l < n; l++) {\n\t\t\t\tif (mat[k][l] == 1) {\n\t\t\t\t\tcount++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint[][] dp = new int[m][n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tdp[i][j] = (i == 0 || j == 0) ? 1 : dp[i - 1][j] + dp[i][j - 1];\n\t\t\t\t\tans += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint[][] dp = new int[m][n];\n\t\tint res = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tdp[i][j] = (i == 0 || j == 0) ? 1 : dp[i - 1][j] + dp[i][j - 1];\n\t\t\t\t\tres += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint[][] dp = new int[m][n];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tdp[i][j] += dp[i][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && j > 0) {\n\t\t\t\t\t\tdp[i][j] -= dp[i - 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tans += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tcount += dfs(mat, i, j, m, n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tprivate int dfs(int[][] mat, int i, int j, int m, int n) {\n\t\tint count = 0;\n\t\tfor (int x = i; x < m; x++) {\n\t\t\tfor (int y = j; y < n; y++) {\n\t\t\t\tif (mat[x][y] == 1) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint[][] dp = new int[m][n];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tdp[i][j] = (i == 0 || j == 0) ? 1 : dp[i - 1][j] + dp[i][j - 1];\n\t\t\t\t\tcount += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tres += dfs(mat, i, j, m, n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tprivate int dfs(int[][] mat, int i, int j, int m, int n) {\n\t\tint res = 0;\n\t\tfor (int k = i; k < m; k++) {\n\t\t\tfor (int l = j; l < n; l++) {\n\t\t\t\tif (mat[k][l] == 1) {\n\t\t\t\t\tres++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint countSubmatrices(int[][] mat, int m, int n) {\n\t\tint[][] dp = new int[m][n];\n\t\tint count = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (mat[i][j] == 1) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tdp[i][j] += dp[i][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && j > 0) {\n\t\t\t\t\t\tdp[i][j] -= dp[i - 1][j - 1];\n\t\t\t\t\t}\n\t\t\t\t\tcount += dp[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2286",
    "source": "leetcode",
    "language": "java",
    "query": "A path in a binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.",
    "snippets": [
        "\tstatic boolean isPseudoPalindrome(TreeNode root){\n\t\tif(root==null) return true;\n\t\tif(root.left==null && root.right==null) return true;\n\t\tif(root.left==null){\n\t\t\tif(isPseudoPalindrome(root.right)) return true;\n\t\t\telse return false;\n\t\t}\n\t\tif(root.right==null){\n\t\t\tif(isPseudoPalindrome(root.left)) return true;\n\t\t\telse return false;\n\t\t}\n\t\tif(isPseudoPalindrome(root.left) && isPseudoPalindrome(root.right)) return true;\n\t\telse return false;\n\t}\n}\n",
        "\tboolean isPseudoPalindrome(TreeNode root){\n\t\tif(root==null)\n\t\t\treturn true;\n\t\tif(root.left==null&&root.right==null)\n\t\t\treturn true;\n\t\tif(root.left==null){\n\t\t\tif(isPseudoPalindrome(root.right))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tif(root.right==null){\n\t\t\tif(isPseudoPalindrome(root.left))\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n\t\t}\n\t\tif(isPseudoPalindrome(root.left)&&isPseudoPalindrome(root.right))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n}\n",
        "\tboolean isPseudoPalindrome(TreeNode root) {\n\t\tif(root==null) return true;\n\t\tif(root.left==null && root.right==null) return true;\n\t\tif(root.left==null) return isPseudoPalindrome(root.right);\n\t\tif(root.right==null) return isPseudoPalindrome(root.left);\n\t\treturn isPseudoPalindrome(root.left) && isPseudoPalindrome(root.right);\n\t}\n}\n",
        "\tstatic boolean isPseudoPalindrome(TreeNode root){\n\t\tif(root==null)\n\t\t\treturn true;\n\t\treturn isPseudoPalindrome(root.left,root.right);\n\t}\n\tpublic\n\tstatic boolean isPseudoPalindrome(TreeNode left,TreeNode right){\n\t\tif(left==null&&right==null)\n\t\t\treturn true;\n\t\tif(left==null||right==null)\n\t\t\treturn false;\n\t\tif(left.val==right.val)\n\t\t\treturn isPseudoPalindrome(left.left,right.right)&&isPseudoPalindrome(left.right,right.left);\n\t\telse\n\t\t\treturn isPseudoPalindrome(left.left,right.right)||isPseudoPalindrome(left.right,right.left);\n\t}\n}\n",
        "\tboolean isPseudoPalindrome(TreeNode root) {\n\t\tif(root==null) return true;\n\t\treturn isPseudoPalindrome(root.left)&&isPseudoPalindrome(root.right);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2287",
    "source": "leetcode",
    "language": "java",
    "query": "A binary tree is uni-valued if every node in the tree has the same value. Given the root of a binary tree, return true if the given tree isUnivalued.",
    "snippets": [
        "\tboolean isUnivalued(TreeNode root) {\n\t\tif(root == null) return true;\n\t\treturn isUnivalued(root.left, root.val) && isUnivalued(root.right, root.val);\n\t}\n\tprivate\n\tboolean isUnivalued(TreeNode root, int val){\n\t\tif(root == null) return true;\n\t\tif(root.val != val) return false;\n\t\treturn isUnivalued(root.left, val) && isUnivalued(root.right, val);\n\t}\n}\n",
        "\tboolean isUnivalued(TreeNode root) {\n\t\tif(root == null) return true;\n\t\treturn isUnivalued(root.left, root.val) && isUnivalued(root.right, root.val);\n\t}\n\tprivate boolean isUnivalued(TreeNode root, int val) {\n\t\tif(root == null) return true;\n\t\treturn root.val == val && isUnivalued(root.left, val) && isUnivalued(root.right, val);\n\t}\n}\n",
        "\tboolean isUnivalued(TreeNode root) {\n\t\tif(root == null) return true;\n\t\tif(root.left != null && root.left.val != root.val) return false;\n\t\tif(root.right != null && root.right.val != root.val) return false;\n\t\treturn isUnivalued(root.left) && isUnivalued(root.right);\n\t}\n}\n",
        "\tboolean isUnivalued(TreeNode root) {\n\t\tif(root == null) return true;\n\t\tif(root.left == null && root.right == null) return true;\n\t\tif(root.left == null) return root.val == isUnivalued(root.right);\n\t\tif(root.right == null) return root.val == isUnivalued(root.left);\n\t\treturn root.val == isUnivalued(root.left) && root.val == isUnivalued(root.right);\n\t}\n}\n",
        "\tboolean isUnivalued(TreeNode root) {\n\t\tif(root==null) return true;\n\t\treturn isUnivalued(root.left,root.val)&&isUnivalued(root.right,root.val);\n\t}\n\tpublic\n\tboolean isUnivalued(TreeNode root,int val){\n\t\tif(root==null) return true;\n\t\tif(root.val!=val) return false;\n\t\treturn isUnivalued(root.left,val)&&isUnivalued(root.right,val);\n\t}\n}\n",
        "\tboolean isUnivalued(TreeNode root){\n\t\tif(root==null) return true;\n\t\tif(root.left==null && root.right==null) return true;\n\t\tif(root.left==null){\n\t\t\tif(root.right.val==root.val) return isUnivalued(root.right);\n\t\t\telse return false;\n\t\t}\n\t\tif(root.right==null){\n\t\t\tif(root.left.val==root.val) return isUnivalued(root.left);\n\t\t\telse return false;\n\t\t}\n\t\tif(root.left.val==root.val && root.right.val==root.val) return isUnivalued(root.left) && isUnivalued(root.right);\n\t\telse return false;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2288",
    "source": "leetcode",
    "language": "java",
    "query": "You can arrange for the planet to collide with the asteroids in any arbitrary order. If the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass. Otherwise, return false.",
    "snippets": [
        "\tstatic boolean asteroidCollision(int[] asteroids) {\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = 0; i < asteroids.length; i++) {\n\t\t\tif (asteroids[i] > 0) {\n\t\t\t\tstack.push(asteroids[i]);\n\t\t\t} else {\n\t\t\t\twhile (!stack.isEmpty() && stack.peek() > 0 && stack.peek() < -asteroids[i]) {\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t\tif (!stack.isEmpty() && stack.peek() > 0 && stack.peek() == -asteroids[i]) {\n\t\t\t\t\tstack.pop();\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean asteroidCollision(int[] asteroids) {\n\t\tStack<Integer> stack = new Stack<>();\n\t\tfor (int i = 0; i < asteroids.length; i++) {\n\t\t\tif (asteroids[i] > 0) {\n\t\t\t\tstack.push(asteroids[i]);\n\t\t\t} else {\n\t\t\t\twhile (!stack.isEmpty() && stack.peek() > 0 && stack.peek() < -asteroids[i]) {\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t\tif (!stack.isEmpty() && stack.peek() == -asteroids[i]) {\n\t\t\t\t\tstack.pop();\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean asteroidCollision(int[] asteroids) {\n\t\tint len = asteroids.length;\n\t\tif(len == 0) return true;\n\t\tif(len == 1) return asteroids[0] == 0;\n\t\tint[] arr = new int[len];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tarr[i] = asteroids[i];\n\t\t}\n\t\tint i = 0;\n\t\twhile(i < len){\n\t\t\tif(arr[i] < 0){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < len){\n\t\t\t\t\tif(arr[j] > 0){\n\t\t\t\t\t\tif(arr[i] + arr[j] == 0){\n\t\t\t\t\t\t\tarr[i] = 0;\n\t\t\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(arr[i] + arr[j] > 0){\n\t\t\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor(int k = 0; k < len; k++){\n\t\t\tif(arr[k] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean asteroidCollision(int[] asteroids) {\n\t\tint len = asteroids.length;\n\t\tif(len == 0) return true;\n\t\tif(len == 1) return asteroids[0] == 0;\n\t\tint[] arr = new int[len];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tarr[i] = asteroids[i];\n\t\t}\n\t\tint i = 0;\n\t\twhile(i < len){\n\t\t\tif(arr[i] < 0){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < len){\n\t\t\t\t\tif(arr[j] > 0){\n\t\t\t\t\t\tif(arr[i] + arr[j] == 0){\n\t\t\t\t\t\t\tarr[i] = 0;\n\t\t\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else if(arr[i] + arr[j] > 0){\n\t\t\t\t\t\t\tarr[j] = -arr[j];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j == len){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor(int k = 0; k < len; k++){\n\t\t\tif(arr[k] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean asteroidCollision(int[] asteroids) {\n\t\tint size = asteroids.length;\n\t\tif(size == 0) return true;\n\t\tif(size == 1) return asteroids[0] == 0;\n\t\tint[] arr = new int[size];\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tarr[i] = asteroids[i];\n\t\t}\n\t\tint i = 0;\n\t\twhile(i < size){\n\t\t\tif(arr[i] < 0){\n\t\t\t\tint j = i + 1;\n\t\t\t\twhile(j < size && arr[j] > 0){\n\t\t\t\t\tif(arr[i] + arr[j] == 0){\n\t\t\t\t\t\tarr[i] = 0;\n\t\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(arr[i] + arr[j] > 0){\n\t\t\t\t\t\tarr[j] = -arr[j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tif(j == size) return false;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor(int k = 0; k < size; k++){\n\t\t\tif(arr[k] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tstatic boolean asteroidCollision(int[] asteroids) {\n\t\tint i = 0;\n\t\twhile (i < asteroids.length) {\n\t\t\tif (asteroids[i] < 0) {\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = i + 1;\n\t\t\twhile (j < asteroids.length) {\n\t\t\t\tif (asteroids[j] < 0) {\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (asteroids[i] + asteroids[j] == 0) {\n\t\t\t\t\tasteroids[i] = -1;\n\t\t\t\t\tasteroids[j] = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (asteroids[i] + asteroids[j] > 0) {\n\t\t\t\t\tasteroids[j] = -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j == asteroids.length) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean asteroidCollision(int[] asteroids) {\n\t\tint size = asteroids.length;\n\t\tif(size == 0) return true;\n\t\tif(size == 1) return asteroids[0] == 0;\n\t\tint[] arr = new int[size];\n\t\tfor(int i = 0; i < size; i++){\n\t\t\tarr[i] = asteroids[i];\n\t\t}\n\t\tint i = 0;\n\t\tint j = 1;\n\t\twhile(j < size){\n\t\t\tif(arr[i] < 0 && arr[j] < 0){\n\t\t\t\tif(arr[i] + arr[j] == 0){\n\t\t\t\t\tarr[i] = 0;\n\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\ti = j;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(arr[i] + arr[j] > 0){\n\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(arr[i] < 0 && arr[j] > 0){\n\t\t\t\tif(arr[i] + arr[j] == 0){\n\t\t\t\t\tarr[i] = 0;\n\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\ti = j;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if(arr[i] + arr[j] > 0){\n\t\t\t\t\tarr[j] = 0;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(arr[i] > 0 && arr[j] < 0){\n\t\t\t\tif(arr[i] + arr[j] == 0){\n\t\t\t\t\tarr[i]\n",
        "\tstatic boolean asteroidCollision(int[] asteroids) {\n\t\tif(asteroids.length == 0) return true;\n\t\tint i = 0;\n\t\twhile(i < asteroids.length){\n\t\t\tif(asteroids[i] < 0){\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint j = i+1;\n\t\t\twhile(j < asteroids.length){\n\t\t\t\tif(asteroids[j] > 0){\n\t\t\t\t\tif(asteroids[i] > asteroids[j]){\n\t\t\t\t\t\tasteroids[i] += asteroids[j];\n\t\t\t\t\t\tasteroids[j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tasteroids[j] += asteroids[i];\n\t\t\t\t\t\tasteroids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tfor(int k = 0; k < asteroids.length; k++){\n\t\t\tif(asteroids[k] != 0) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tboolean asteroidCollision(int[] asteroids) {\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tint size = asteroids.length;\n\t\twhile(i < size && j < size){\n\t\t\tif(asteroids[i] > 0){\n\t\t\t\tif(asteroids[j] < 0){\n\t\t\t\t\tif(asteroids[i] > -asteroids[j]){\n\t\t\t\t\t\tasteroids[i] += asteroids[j];\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tasteroids[j] += asteroids[i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < size; k++){\n\t\t\tif(asteroids[k] < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2289",
    "source": "leetcode",
    "language": "java",
    "query": "The solution set must not contain duplicate subsets. Return the solution in any order. Given an integer array nums that may contain duplicates, return all possible subsets (the power set)",
    "snippets": [
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0){\n\t\t\treturn result;\n\t\t}\n\t\tArrays.sort(nums);\n\t\thelper(nums, 0, new ArrayList<Integer>(), result);\n\t\treturn result;\n\t}\n\tpublic void helper(int[] nums, int index, List<Integer> list, List<List<Integer>> result){\n\t\tif(index == nums.length){\n\t\t\tresult.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\thelper(nums, index + 1, list, result);\n\t\tlist.add(nums[index]);\n\t\thelper(nums, index + 1, list, result);\n\t\tlist.remove(list.size() - 1);\n\t}\n}\n",
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0) return result;\n\t\tArrays.sort(nums);\n\t\thelper(nums, 0, new ArrayList<Integer>(), result);\n\t\treturn result;\n\t}\n\tpublic void helper(int[] nums, int start, List<Integer> list, List<List<Integer>> result){\n\t\tif(start == nums.length){\n\t\t\tresult.add(new ArrayList<Integer>(list));\n\t\t\treturn;\n\t\t}\n\t\thelper(nums, start + 1, list, result);\n\t\tlist.add(nums[start]);\n\t\thelper(nums, start + 1, list, result);\n\t\tlist.remove(list.size() - 1);\n\t}\n}\n",
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0){\n\t\t\treturn result;\n\t\t}\n\t\tArrays.sort(nums);\n\t\thelper(nums, 0, new ArrayList<Integer>(), result);\n\t\treturn result;\n\t}\n\tpublic void helper(int[] nums, int start, List<Integer> list, List<List<Integer>> result){\n\t\tresult.add(new ArrayList<Integer>(list));\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tif(i > start && nums[i] == nums[i-1]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, i+1, list, result);\n\t\t\tlist.remove(list.size()-1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0){\n\t\t\treturn result;\n\t\t}\n\t\tArrays.sort(nums);\n\t\thelper(nums, 0, new ArrayList<Integer>(), result);\n\t\treturn result;\n\t}\n\t\n\tpublic void helper(int[] nums, int start, List<Integer> list, List<List<Integer>> result){\n\t\tresult.add(new ArrayList<Integer>(list));\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tif(i != start && nums[i] == nums[i-1]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, i+1, list, result);\n\t\t\tlist.remove(list.size()-1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0){\n\t\t\tresult.add(new ArrayList<Integer>());\n\t\t\treturn result;\n\t\t}\n\t\tArrays.sort(nums);\n\t\thelper(result, new ArrayList<Integer>(), nums, 0);\n\t\treturn result;\n\t}\n\tpublic void helper(List<List<Integer>> result, List<Integer> list, int[] nums, int start){\n\t\tresult.add(new ArrayList<Integer>(list));\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tif(i > start && nums[i] == nums[i-1]) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(result, list, nums, i+1);\n\t\t\tlist.remove(list.size()-1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0)\n\t\t\treturn result;\n\t\tArrays.sort(nums);\n\t\thelper(result, new ArrayList<Integer>(), nums, 0);\n\t\treturn result;\n\t}\n\tpublic void helper(List<List<Integer>> result, List<Integer> list, int[] nums, int start){\n\t\tresult.add(new ArrayList<Integer>(list));\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tif(i > start && nums[i] == nums[i-1])\n\t\t\t\tcontinue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(result, list, nums, i+1);\n\t\t\tlist.remove(list.size()-1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> result = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0){\n\t\t\tresult.add(new ArrayList<Integer>());\n\t\t\treturn result;\n\t\t}\n\t\tArrays.sort(nums);\n\t\thelper(result, new ArrayList<Integer>(), nums, 0);\n\t\treturn result;\n\t}\n\tpublic void helper(List<List<Integer>> result, List<Integer> list, int[] nums, int index){\n\t\tresult.add(new ArrayList<Integer>(list));\n\t\tfor(int i = index; i < nums.length; i++){\n\t\t\tif(i > index && nums[i] == nums[i - 1]) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(result, list, nums, i + 1);\n\t\t\tlist.remove(list.size() - 1);\n\t\t}\n\t}\n}\n",
        "\tList<List<Integer>> subsetsWithDup(int[] nums) {\n\t\tList<List<Integer>> res = new ArrayList<List<Integer>>();\n\t\tif(nums == null || nums.length == 0) return res;\n\t\tArrays.sort(nums);\n\t\thelper(nums, 0, new ArrayList<Integer>(), res);\n\t\treturn res;\n\t}\n\tpublic void helper(int[] nums, int start, List<Integer> list, List<List<Integer>> res){\n\t\tres.add(new ArrayList<Integer>(list));\n\t\tfor(int i = start; i < nums.length; i++){\n\t\t\tif(i != start && nums[i] == nums[i-1]) continue;\n\t\t\tlist.add(nums[i]);\n\t\t\thelper(nums, i+1, list, res);\n\t\t\tlist.remove(list.size()-1);\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2290",
    "source": "leetcode",
    "language": "java",
    "query": "A string is good if it can be formed by characters from chars (each character can only be used once) Return the sum of lengths of all good strings in words.",
    "snippets": [
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint count = 0;\n\t\tfor(String word : words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\tcount[word.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < chars.length(); i++){\n\t\t\tcount[chars.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(count[i] < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint count = 0;\n\t\tfor(String word : words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tcount += word.length();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\tcount[word.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < chars.length(); i++){\n\t\t\tif(count[chars.charAt(i) - 'a'] == 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint sum = 0;\n\t\tfor(String word : words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tsum += word.length();\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] charCount = new int[26];\n\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\tcharCount[word.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < chars.length(); i++){\n\t\t\tcharCount[chars.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(charCount[i] < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint count = 0;\n\t\tfor(String word : words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] charCount = new int[26];\n\t\tfor(char c : word.toCharArray()){\n\t\t\tcharCount[c - 'a']++;\n\t\t}\n\t\tfor(char c : chars.toCharArray()){\n\t\t\tcharCount[c - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(charCount[i] < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint count = 0;\n\t\tfor(String word : words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tcount += word.length();\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] charCount = new int[26];\n\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\tcharCount[word.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < chars.length(); i++){\n\t\t\tcharCount[chars.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(charCount[i] < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint count = 0;\n\t\tfor(String word : words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\t\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] charCount = new int[26];\n\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\tcharCount[word.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < chars.length(); i++){\n\t\t\tcharCount[chars.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tif(charCount[i] < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint sum = 0;\n\t\tfor(String word : words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tsum += word.length();\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] count = new int[26];\n\t\tfor(int i = 0; i < word.length(); i++){\n\t\t\tcount[word.charAt(i) - 'a']++;\n\t\t}\n\t\tfor(int i = 0; i < chars.length(); i++){\n\t\t\tcount[chars.charAt(i) - 'a']--;\n\t\t}\n\t\tfor(int i = 0; i < count.length; i++){\n\t\t\tif(count[i] < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tint countGoodStrings(String[] words, String chars) {\n\t\tint res = 0;\n\t\tfor(String word: words){\n\t\t\tif(isGood(word, chars)){\n\t\t\t\tres += word.length();\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic boolean isGood(String word, String chars){\n\t\tint[] cnt = new int[26];\n\t\tfor(char c: word.toCharArray()){\n\t\t\tcnt[c-'a']++;\n\t\t}\n\t\tfor(char c: chars.toCharArray()){\n\t\t\tcnt[c-'a']--;\n\t\t}\n\t\tfor(int i: cnt){\n\t\t\tif(i>0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2291",
    "source": "leetcode",
    "language": "java",
    "query": "A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "snippets": [
        "\tint lengthOfLIS(int[] nums) {\n\t\tint[] dp = new int[nums.length];\n\t\tint max = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(nums[j] < nums[i]){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint lengthOfLIS(int[] nums) {\n\t\tif(nums.length==0) return 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = 1;\n\t\tint max = 1;\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(nums[i]>nums[j]){\n\t\t\t\t\tdp[i] = Math.max(dp[i],dp[j]+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max,dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint lengthOfLIS(int[] nums) {\n\t\tif(nums.length==0) return 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = 1;\n\t\tint max = 1;\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tint max_ = 0;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(nums[i]>nums[j]){\n\t\t\t\t\tmax_ = Math.max(max_, dp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = max_+1;\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint lengthOfLIS(int[] nums) {\n\t\tif(nums.length==0) return 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = 1;\n\t\tint max = 1;\n\t\tfor(int i=1;i<nums.length;i++){\n\t\t\tint max_tmp = 0;\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(nums[j]<nums[i]){\n\t\t\t\t\tmax_tmp = Math.max(max_tmp,dp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = max_tmp+1;\n\t\t\tmax = Math.max(max,dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint lengthOfLis(int[] nums) {\n\t\tint[] dp = new int[nums.length];\n\t\tint max = 0;\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tdp[i] = 1;\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tif (nums[i] > nums[j]) {\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint lengthOfLIS(int[] nums) {\n\t\tif(nums.length == 0) return 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = 1;\n\t\tint max = 1;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tint max_ = 0;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(nums[j] < nums[i]){\n\t\t\t\t\tmax_ = Math.max(max_, dp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = max_ + 1;\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint lengthOfLIS(int[] nums) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = 1;\n\t\tint max = 1;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(nums[i] > nums[j]){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n",
        "\tint lengthOfLIS(int[] nums) {\n\t\tif(nums == null || nums.length == 0) return 0;\n\t\tint[] dp = new int[nums.length];\n\t\tdp[0] = 1;\n\t\tint max = 1;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tdp[i] = 1;\n\t\t\tfor(int j = 0; j < i; j++){\n\t\t\t\tif(nums[j] < nums[i]){\n\t\t\t\t\tdp[i] = Math.max(dp[i], dp[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, dp[i]);\n\t\t}\n\t\treturn max;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2292",
    "source": "leetcode",
    "language": "java",
    "query": "A subarray is a contiguous part of an array. Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.",
    "snippets": [
        "\tint subarraySum(int[] nums, int k) {\n\t\tint sum = 0, count = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tmap.put(0, 1);\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\tcount += map.getOrDefault(sum - k, 0);\n\t\t\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint subarraySum(int[] nums, int k) {\n\t\tint sum = 0, count = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tmap.put(0, 1);\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\tif (map.containsKey(sum - k))\n\t\t\t\tcount += map.get(sum - k);\n\t\t\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint subarraySum(int[] nums, int k) {\n\t\tint count = 0;\n\t\tint sum = 0;\n\t\tMap<Integer, Integer> map = new HashMap<>();\n\t\tmap.put(0, 1);\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\tif (map.containsKey(sum - k)) {\n\t\t\t\tcount += map.get(sum - k);\n\t\t\t}\n\t\t\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\n\t\t}\n\t\treturn count;\n\t}\n}\n",
        "\tint subarraySum(int[] nums, int k) {\n\t\tint sum = 0;\n\t\tint count = 0;\n\t\tMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tmap.put(0, 1);\n\t\tfor (int i = 0; i < nums.length; i++) {\n\t\t\tsum += nums[i];\n\t\t\tif (map.containsKey(sum - k)) {\n\t\t\t\tcount += map.get(sum - k);\n\t\t\t}\n\t\t\tmap.put(sum, map.getOrDefault(sum, 0) + 1);\n\t\t}\n\t\treturn count;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2293",
    "source": "leetcode",
    "language": "java",
    "query": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.",
    "snippets": [
        "\tint getMinimumDifference(TreeNode root) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint prev = Integer.MIN_VALUE;\n\t\tTreeNode cur = root;\n\t\twhile(cur != null){\n\t\t\tif(cur.left != null){\n\t\t\t\tcur = cur.left;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(prev != Integer.MIN_VALUE){\n\t\t\t\t\tmin = Math.min(min, cur.val - prev);\n\t\t\t\t}\n\t\t\t\tprev = cur.val;\n\t\t\t\tif(cur.right != null){\n\t\t\t\t\tcur = cur.right;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcur = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint getMinimumDifference(TreeNode root) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint prev = Integer.MIN_VALUE;\n\t\tTreeNode cur = root;\n\t\twhile(cur != null){\n\t\t\tif(cur.left != null){\n\t\t\t\tcur = cur.left;\n\t\t\t}else{\n\t\t\t\tif(prev != Integer.MIN_VALUE){\n\t\t\t\t\tmin = Math.min(min, cur.val - prev);\n\t\t\t\t}\n\t\t\t\tprev = cur.val;\n\t\t\t\tcur = cur.right;\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint getMinimumDifference(TreeNode root){\n\t\tint min = Integer.MAX_VALUE;\n\t\tint prev = Integer.MIN_VALUE;\n\t\tTreeNode cur = root;\n\t\twhile(cur != null){\n\t\t\tif(cur.left != null){\n\t\t\t\tmin = Math.min(min, cur.left.val - prev);\n\t\t\t\tprev = cur.left.val;\n\t\t\t}\n\t\t\tif(cur.right != null){\n\t\t\t\tmin = Math.min(min, cur.right.val - prev);\n\t\t\t\tprev = cur.right.val;\n\t\t\t}\n\t\t\tcur = cur.left == null ? cur.right : cur.left;\n\t\t}\n\t\treturn min;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2294",
    "source": "leetcode",
    "language": "java",
    "query": "Determine whether the largest element in an array is at least twice as much as every other number in the array. If it is, return the index of the largest elements, or return -1 otherwise.",
    "snippets": [
        "\tint findLargest(int[] nums){\n\t\tint max = nums[0];\n\t\tint maxIndex = 0;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(nums[i] * 2 < max){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn maxIndex;\n\t}\n}\n",
        "\tint findLargest(int[] nums){\n\t\tint max = nums[0];\n\t\tint maxIndex = 0;\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tif(nums[i] > max){\n\t\t\t\tmax = nums[i];\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tif(i != maxIndex && nums[i] * 2 < max){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn maxIndex;\n\t}\n}\n",
        "\tstatic int findLargest(int[] a){\n\t\tint max = a[0];\n\t\tint maxIndex = 0;\n\t\tfor(int i = 1; i < a.length; i++){\n\t\t\tif(a[i] > max){\n\t\t\t\tmax = a[i];\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(a[i] * 2 < max){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn maxIndex;\n\t}\n}\n",
        "\tstatic int findLargest(int[] a){\n\t\tint largest = a[0];\n\t\tint largestIndex = 0;\n\t\tfor(int i = 1; i < a.length; i++){\n\t\t\tif(a[i] > largest){\n\t\t\t\tlargest = a[i];\n\t\t\t\tlargestIndex = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(a[i] * 2 < largest){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn largestIndex;\n\t}\n}\n",
        "\tstatic int findLargest(int[] array){\n\t\tint largest = array[0];\n\t\tint index = 0;\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] > largest){\n\t\t\t\tlargest = array[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tif(array[i] * 2 < largest){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n}\n",
        "\tstatic int findLargest(int[] arr){\n\t\tint largest = arr[0];\n\t\tint index = 0;\n\t\tfor(int i = 1; i < arr.length; i++){\n\t\t\tif(arr[i] > largest){\n\t\t\t\tlargest = arr[i];\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif(arr[i] * 2 < largest){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n}\n",
        "\tint indexLargestTwice(int[] a){\n\t\tint max = a[0];\n\t\tint maxIndex = 0;\n\t\tfor(int i = 1; i < a.length; i++){\n\t\t\tif(a[i] > max){\n\t\t\t\tmax = a[i];\n\t\t\t\tmaxIndex = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tif(a[i] * 2 < max){\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn maxIndex;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2295",
    "source": "leetcode",
    "language": "java",
    "query": "Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.",
    "snippets": [
        "\tString toLowerCase(String s){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(c >= 'A' && c <= 'Z'){\n\t\t\t\tc += 32;\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString toLowerCase(String s){\n\t\tString res = \"\";\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(s.charAt(i) >= 'A' && s.charAt(i) <= 'Z'){\n\t\t\t\tres += (char)(s.charAt(i) + 32);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres += s.charAt(i);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2296",
    "source": "leetcode",
    "language": "java",
    "query": "RunningSum[i] is the running sum of an array. Given an array nums. We define a running sum as sum(nums[0]…nums(i)).",
    "snippets": [
        "\tint[] runningSum(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tres[i] = sum;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] runningSum(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tres[0] = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tres[i] = res[i-1] + nums[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] runningSum(int[] nums) {\n\t\tint[] result = new int[nums.length];\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tsum += nums[i];\n\t\t\tresult[i] = sum;\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint[] RunningSum(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tres[0] = nums[0];\n\t\tfor(int i = 1; i < nums.length; i++){\n\t\t\tres[i] = res[i-1] + nums[i];\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint[] RunningSum(int[] nums) {\n\t\tint[] res = new int[nums.length];\n\t\tfor(int i = 0; i < nums.length; i++){\n\t\t\tres[i] = nums[i];\n\t\t\tif(i > 0) res[i] += res[i-1];\n\t\t}\n\t\treturn res;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2297",
    "source": "leetcode",
    "language": "java",
    "query": "Given an integer n, add a dot (\".\") as the thousands separator and return it in string format.",
    "snippets": [
        "\tString addDot(int n){\n\t\tString s = String.valueOf(n);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(i % 3 == 0 && i != 0){\n\t\t\t\tsb.append(\".\");\n\t\t\t}\n\t\t\tsb.append(s.charAt(i));\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = Integer.toString(n);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < s.length(); i++){\n\t\t\tif(i % 3 == 0 && i != 0){\n\t\t\t\tsb.append(\".\");\n\t\t\t}\n\t\t\tsb.append(s.charAt(i));\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = String.valueOf(n);\n\t\tint len = s.length();\n\t\tif(len <= 3){\n\t\t\treturn s;\n\t\t}\n\t\tint i = len - 3;\n\t\twhile(i > 0){\n\t\t\ts = s.substring(0, i) + \".\" + s.substring(i);\n\t\t\ti -= 3;\n\t\t}\n\t\treturn s;\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = String.valueOf(n);\n\t\tint len = s.length();\n\t\tif(len<4){\n\t\t\treturn s;\n\t\t}\n\t\tint i = len%3;\n\t\tif(i==0){\n\t\t\ti=3;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(s.substring(0,i));\n\t\tsb.append(\".\");\n\t\tfor(int j=i;j<len;j+=3){\n\t\t\tsb.append(s.substring(j,j+3));\n\t\t\tsb.append(\".\");\n\t\t}\n\t\treturn sb.toString().substring(0,sb.length()-1);\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = String.valueOf(n);\n\t\tint len = s.length();\n\t\tif(len<4){\n\t\t\treturn s;\n\t\t}\n\t\tint i = len%3;\n\t\tif(i==0){\n\t\t\ti=3;\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int j=0;j<i;j++){\n\t\t\tsb.append(s.charAt(j));\n\t\t}\n\t\tsb.append(\".\");\n\t\tfor(int j=i;j<len;j+=3){\n\t\t\tfor(int k=j;k<j+3;k++){\n\t\t\t\tsb.append(s.charAt(k));\n\t\t\t}\n\t\t\tsb.append(\".\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = String.valueOf(n);\n\t\tint len = s.length();\n\t\tif(len <= 3) return s;\n\t\tint i = len % 3;\n\t\tif(i == 0) i = 3;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(s.substring(0, i));\n\t\tsb.append('.');\n\t\tfor(; i < len; i += 3){\n\t\t\tsb.append(s.substring(i, i + 3));\n\t\t\tsb.append('.');\n\t\t}\n\t\tsb.deleteCharAt(sb.length() - 1);\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = Integer.toString(n);\n\t\tint len = s.length();\n\t\tif(len<4) return s;\n\t\tint i = len-3;\n\t\twhile(i>0){\n\t\t\ts = s.substring(0,i)+\".\"+s.substring(i);\n\t\t\ti-=3;\n\t\t}\n\t\treturn s;\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = Integer.toString(n);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint i = 0;\n\t\twhile(i < s.length()){\n\t\t\tsb.append(s.charAt(i));\n\t\t\tif(i % 3 == 2 && i != s.length() - 1){\n\t\t\t\tsb.append(\".\");\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n",
        "\tString addDot(int n){\n\t\tString s = Integer.toString(n);\n\t\tint len = s.length();\n\t\tint i = 0;\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(i<len){\n\t\t\tif(i%3==0 && i!=0){\n\t\t\t\tsb.append(\".\");\n\t\t\t}\n\t\t\tsb.append(s.charAt(i));\n\t\t\ti++;\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2298",
    "source": "leetcode",
    "language": "java",
    "query": "Consider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors. A factor of an integer n is defined as an integer i where n % i == 0.",
    "snippets": [
        "\tint kthFactor(int n, int k) {\n\t\tint i = 1;\n\t\tint count = 0;\n\t\twhile(i <= n){\n\t\t\tif(n % i == 0){\n\t\t\t\tcount++;\n\t\t\t\tif(count == k){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint kthFactor(int n, int k) {\n\t\tint i = 1;\n\t\tint count = 0;\n\t\twhile(i <= n){\n\t\t\tif(n % i == 0){\n\t\t\t\tcount++;\n\t\t\t\tif(count == k) return i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint kthFactor(int n, int k) {\n\t\tint count = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(n % i == 0){\n\t\t\t\tcount++;\n\t\t\t\tif(count == k)\n\t\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint kthFactor(int n, int k) {\n\t\tint count = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(n % i == 0){\n\t\t\t\tcount++;\n\t\t\t\tif(count == k){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint kthFactor(int n, int k){\n\t\tint i = 1;\n\t\tint count = 0;\n\t\twhile(n > i){\n\t\t\tif(n % i == 0){\n\t\t\t\tcount++;\n\t\t\t\tif(count == k){\n\t\t\t\t\treturn i;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn -1;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2299",
    "source": "leetcode",
    "language": "java",
    "query": "A leaf is a node with no children. Given the root of a binary tree, return all root-to-leaf paths in any order.",
    "snippets": [
        "\tList<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(root == null) return res;\n\t\tdfs(root, res, \"\");\n\t\treturn res;\n\t}\n\tpublic void dfs(TreeNode root, List<String> res, String path){\n\t\tif(root.left == null && root.right == null){\n\t\t\tres.add(path + root.val);\n\t\t\treturn;\n\t\t}\n\t\tif(root.left != null) dfs(root.left, res, path + root.val + \"->\");\n\t\tif(root.right != null) dfs(root.right, res, path + root.val + \"->\");\n\t}\n}\n",
        "\tList<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> res = new ArrayList<>();\n\t\tif(root == null) return res;\n\t\tdfs(root, res, \"\");\n\t\treturn res;\n\t}\n\tpublic void dfs(TreeNode root, List<String> res, String path){\n\t\tif(root.left == null && root.right == null){\n\t\t\tres.add(path + root.val);\n\t\t\treturn;\n\t\t}\n\t\tif(root.left != null) dfs(root.left, res, path + root.val + \"->\");\n\t\tif(root.right != null) dfs(root.right, res, path + root.val + \"->\");\n\t}\n}\n",
        "\tList<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> res = new ArrayList<String>();\n\t\tif(root == null) return res;\n\t\thelper(root, res, new StringBuilder());\n\t\treturn res;\n\t}\n\tpublic void helper(TreeNode root, List<String> res, StringBuilder sb){\n\t\tif(root.left == null && root.right == null){\n\t\t\tsb.append(root.val);\n\t\t\tres.add(sb.toString());\n\t\t\tsb.deleteCharAt(sb.length() - 1);\n\t\t\treturn;\n\t\t}\n\t\tsb.append(root.val);\n\t\tsb.append(\"->\");\n\t\tif(root.left != null) helper(root.left, res, sb);\n\t\tif(root.right != null) helper(root.right, res, sb);\n\t\tsb.deleteCharAt(sb.length() - 1);\n\t\tsb.deleteCharAt(sb.length() - 1);\n\t}\n}\n",
        "\tList<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tif(root == null) return result;\n\t\tif(root.left == null && root.right == null) {\n\t\t\tresult.add(root.val + \"\");\n\t\t\treturn result;\n\t\t}\n\t\tList<String> left = binaryTreePaths(root.left);\n\t\tList<String> right = binaryTreePaths(root.right);\n\t\tfor(String str : left) {\n\t\t\tresult.add(root.val + \"->\" + str);\n\t\t}\n\t\tfor(String str : right) {\n\t\t\tresult.add(root.val + \"->\" + str);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tif(root == null) return result;\n\t\tif(root.left == null && root.right == null) {\n\t\t\tresult.add(root.val + \"\");\n\t\t\treturn result;\n\t\t}\n\t\tList<String> left = binaryTreePaths(root.left);\n\t\tList<String> right = binaryTreePaths(root.right);\n\t\tfor(String s : left) {\n\t\t\tresult.add(root.val + \"->\" + s);\n\t\t}\n\t\tfor(String s : right) {\n\t\t\tresult.add(root.val + \"->\" + s);\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tList<String> binaryTreePaths(TreeNode root) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tif(root == null)\n\t\t\treturn list;\n\t\tif(root.left == null && root.right == null)\n\t\t\tlist.add(root.val + \"\");\n\t\telse{\n\t\t\tList<String> left = binaryTreePaths(root.left);\n\t\t\tList<String> right = binaryTreePaths(root.right);\n\t\t\tfor(String s : left){\n\t\t\t\tlist.add(root.val + \"->\" + s);\n\t\t\t}\n\t\t\tfor(String s : right){\n\t\t\t\tlist.add(root.val + \"->\" + s);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2300",
    "source": "leetcode",
    "language": "java",
    "query": "An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
    "snippets": [
        "\tint numIslands(char[][] grid) {\n\t\tint count = 0;\n\t\tfor(int i = 0; i < grid.length; i++){\n\t\t\tfor(int j = 0; j < grid[0].length; j++){\n\t\t\t\tif(grid[i][j] == '1'){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(char[][] grid, int i, int j){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0'){\n\t\t\treturn;\n\t\t}\n\t\tgrid[i][j] = '0';\n\t\tdfs(grid, i + 1, j);\n\t\tdfs(grid, i - 1, j);\n\t\tdfs(grid, i, j + 1);\n\t\tdfs(grid, i, j - 1);\n\t}\n}\n",
        "\tint numIslands(char[][] grid) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < grid.length; i++) {\n\t\t\tfor (int j = 0; j < grid[0].length; j++) {\n\t\t\t\tif (grid[i][j] == '1') {\n\t\t\t\t\tcount++;\n\t\t\t\t\tdfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic void dfs(char[][] grid, int i, int j) {\n\t\tif (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1') {\n\t\t\treturn;\n\t\t}\n\t\tgrid[i][j] = '0';\n\t\tdfs(grid, i + 1, j);\n\t\tdfs(grid, i - 1, j);\n\t\tdfs(grid, i, j + 1);\n\t\tdfs(grid, i, j - 1);\n\t}\n}\n",
        "\tint numIslands(char[][] grid) {\n\t\tif(grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n\t\tint m = grid.length;\n\t\tint n = grid[0].length;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(grid[i][j] == '1'){\n\t\t\t\t\tcount++;\n\t\t\t\t\tdfs(grid, i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tpublic void dfs(char[][] grid, int i, int j){\n\t\tif(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') return;\n\t\tgrid[i][j] = '0';\n\t\tdfs(grid, i + 1, j);\n\t\tdfs(grid, i - 1, j);\n\t\tdfs(grid, i, j + 1);\n\t\tdfs(grid, i, j - 1);\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2301",
    "source": "leetcode",
    "language": "java",
    "query": "An integer has sequential digits if and only if each digit in the number is one more than the previous digit. Return a sorted list of all the integers that have sequential digits.",
    "snippets": [
        "\tList<Integer> sequentialDigits(int low, int high) {\n\t\tList<Integer> list = new ArrayList<Integer>();\n\t\tfor(int i = low; i <= high; i++){\n\t\t\tif(isSequential(i)){\n\t\t\t\tlist.add(i);\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tpublic boolean isSequential(int num){\n\t\tString str = String.valueOf(num);\n\t\tfor(int i = 0; i < str.length() - 1; i++){\n\t\t\tif(str.charAt(i + 1) - str.charAt(i) != 1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tList<Integer> sequentialDigits(int low, int high) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int i = low; i <= high; i++){\n\t\t\tif(isSequential(i)) res.add(i);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tboolean isSequential(int num){\n\t\tint prev = 0;\n\t\twhile(num > 0){\n\t\t\tint cur = num % 10;\n\t\t\tif(cur != prev + 1) return false;\n\t\t\tprev = cur;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tList<Integer> sequentialDigits(int low, int high) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int i = low; i <= high; i++){\n\t\t\tif(isSequential(i)) res.add(i);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate boolean isSequential(int num){\n\t\tString s = String.valueOf(num);\n\t\tfor(int i = 0; i < s.length() - 1; i++){\n\t\t\tif(s.charAt(i + 1) - s.charAt(i) != 1) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tList<Integer> sequentialDigits(int low, int high) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int i = low; i <= high; i++){\n\t\t\tif(isSequential(i)) res.add(i);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isSequential(int num){\n\t\tint prev = -1;\n\t\tint cur = 0;\n\t\twhile(num > 0){\n\t\t\tcur = num % 10;\n\t\t\tif(prev != -1 && cur != prev + 1) return false;\n\t\t\tprev = cur;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tList<Integer> sequentialDigits(int low, int high) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int i = low; i <= high; i++){\n\t\t\tif(isSequential(i)) res.add(i);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate boolean isSequential(int num){\n\t\tint prev = 0;\n\t\tint cur = 0;\n\t\twhile(num > 0){\n\t\t\tcur = num % 10;\n\t\t\tif(cur != prev + 1) return false;\n\t\t\tprev = cur;\n\t\t\tnum /= 10;\n\t\t}\n\t\treturn true;\n\t}\n}\n",
        "\tList<Integer> sequentialDigits(int low, int high) {\n\t\tList<Integer> res = new ArrayList<>();\n\t\tfor(int i = low; i <= high; i++){\n\t\t\tif(isSequential(i)) res.add(i);\n\t\t}\n\t\treturn res;\n\t}\n\tpublic boolean isSequential(int num){\n\t\tString s = String.valueOf(num);\n\t\tfor(int i = 0; i < s.length() - 1; i++){\n\t\t\tif(s.charAt(i + 1) - s.charAt(i) != 1) return false;\n\t\t}\n\t\treturn true;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2302",
    "source": "leetcode",
    "language": "java",
    "query": "Length of the path between two nodes is represented by the number of edges between them. Given the root of a binary tree, return the length of the longest path. This path may or may not pass through the root.",
    "snippets": [
        "\tint longestPath(TreeNode root){\n\t\tif(root==null) return 0;\n\t\tint[] max = new int[1];\n\t\tmax[0] = 0;\n\t\thelper(root,0,max);\n\t\treturn max[0];\n\t}\n\tpublic\n\tvoid helper(TreeNode root,int cur,int[] max){\n\t\tif(root==null) return;\n\t\tint left = cur+1;\n\t\tint right = cur+1;\n\t\tif(root.left!=null) helper(root.left,left,max);\n\t\tif(root.right!=null) helper(root.right,right,max);\n\t\tmax[0] = Math.max(max[0],left+right);\n\t}\n}\n",
        "\tint longestPath(TreeNode root){\n\t\tif(root==null) return 0;\n\t\tint[] max = new int[1];\n\t\tmax[0] = 0;\n\t\thelper(root,max);\n\t\treturn max[0];\n\t}\n\tpublic\n\tint helper(TreeNode root,int[] max){\n\t\tif(root==null) return 0;\n\t\tint left = helper(root.left,max);\n\t\tint right = helper(root.right,max);\n\t\tint cur = left+right+1;\n\t\tmax[0] = Math.max(max[0],cur);\n\t\treturn Math.max(left,right)+1;\n\t}\n}\n",
        "\tint longestPath(TreeNode root){\n\t\tif(root==null) return 0;\n\t\tint[] max = new int[1];\n\t\tmax[0] = 0;\n\t\thelper(root,max);\n\t\treturn max[0];\n\t}\n\tpublic\n\tint helper(TreeNode root,int[] max){\n\t\tif(root==null) return 0;\n\t\tint left = helper(root.left,max);\n\t\tint right = helper(root.right,max);\n\t\tint cur = Math.max(left,right)+1;\n\t\tmax[0] = Math.max(max[0],cur+Math.max(left,right));\n\t\treturn cur;\n\t}\n}\n",
        "\tint longestPath(TreeNode root){\n\t\tif(root==null) return 0;\n\t\tint[] res=new int[1];\n\t\tres[0]=0;\n\t\thelper(root,res);\n\t\treturn res[0];\n\t}\n\tpublic\n\tint helper(TreeNode root,int[] res){\n\t\tif(root==null) return 0;\n\t\tint left=helper(root.left,res);\n\t\tint right=helper(root.right,res);\n\t\tint cur=Math.max(left,right)+1;\n\t\tres[0]=Math.max(res[0],cur+Math.max(left,right));\n\t\treturn cur;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2303",
    "source": "leetcode",
    "language": "java",
    "query": "You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array. Note that this modifies the array for future operations.",
    "snippets": [
        "\tint removeElement(int[] nums, int val) {\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (nums[i] == val) {\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n}\n",
        "\tint removeElement(int[] nums, int val) {\n\t\tint i = 0;\n\t\tint j = nums.length - 1;\n\t\twhile (i <= j) {\n\t\t\tif (nums[i] == val) {\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn j + 1;\n\t}\n}\n",
        "\tvoid removeLeftmost(int[] nums){\n\t\tint n = nums.length;\n\t\tif(n == 0) return;\n\t\tint i = 0;\n\t\twhile(i < n && nums[i] == 0) i++;\n\t\tif(i == n) return;\n\t\tint j = i;\n\t\twhile(j < n && nums[j] != 0) j++;\n\t\tif(j == n) return;\n\t\tfor(int k = i; k < j; k++) nums[k] = nums[k+1];\n\t}\n\tpublic\n\tvoid removeRightmost(int[] nums){\n\t\tint n = nums.length;\n\t\tif(n == 0) return;\n\t\tint i = n - 1;\n\t\twhile(i >= 0 && nums[i] == 0) i--;\n\t\tif(i == -1) return;\n\t\tint j = i;\n\t\twhile(j >= 0 && nums[j] != 0) j--;\n\t\tif(j == -1) return;\n\t\tfor(int k = j; k > i; k--) nums[k] = nums[k-1];\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2304",
    "source": "leetcode",
    "language": "java",
    "query": "Return the shortest such subarray and output its length. Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted.",
    "snippets": [
        "\tint findUnsortedSubarray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] copy = Arrays.copyOf(nums, n);\n\t\tArrays.sort(copy);\n\t\tint left = 0, right = n - 1;\n\t\twhile (left < n && nums[left] == copy[left]) left++;\n\t\twhile (right >= 0 && nums[right] == copy[right]) right--;\n\t\treturn right - left + 1;\n\t}\n}\n",
        "\tint findUnsortedSubarray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] copy = new int[n];\n\t\tSystem.arraycopy(nums, 0, copy, 0, n);\n\t\tArrays.sort(copy);\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile (i < n && nums[i] == copy[i]) {\n\t\t\ti++;\n\t\t}\n\t\twhile (j >= 0 && nums[j] == copy[j]) {\n\t\t\tj--;\n\t\t}\n\t\treturn j - i + 1;\n\t}\n}\n",
        "\tint findUnsortedSubarray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] copy = new int[n];\n\t\tSystem.arraycopy(nums, 0, copy, 0, n);\n\t\tArrays.sort(copy);\n\t\tint left = 0, right = n - 1;\n\t\twhile (left < n && nums[left] == copy[left]) left++;\n\t\twhile (right >= 0 && nums[right] == copy[right]) right--;\n\t\treturn right - left + 1;\n\t}\n}\n",
        "\tint findUnsortedSubarray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] copy = Arrays.copyOf(nums, n);\n\t\tArrays.sort(copy);\n\t\tint i = 0;\n\t\tint j = n - 1;\n\t\twhile (i < n && nums[i] == copy[i]) i++;\n\t\twhile (j >= 0 && nums[j] == copy[j]) j--;\n\t\treturn j - i + 1;\n\t}\n}\n",
        "\tint findUnsortedSubarray(int[] nums) {\n\t\tint n = nums.length;\n\t\tint[] copy = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcopy[i] = nums[i];\n\t\t}\n\t\tArrays.sort(copy);\n\t\tint left = 0;\n\t\tint right = n - 1;\n\t\twhile (left < n && nums[left] == copy[left]) {\n\t\t\tleft++;\n\t\t}\n\t\twhile (right >= 0 && nums[right] == copy[right]) {\n\t\t\tright--;\n\t\t}\n\t\treturn right - left + 1;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2305",
    "source": "leetcode",
    "language": "java",
    "query": "Write a function that reverses a string. The input string is given as an array of characters s. modify the input array in-place with O(1) extra memory.",
    "snippets": [
        "\tvoid reverseString(char[] s) {\n\t\tint i = 0;\n\t\tint j = s.length - 1;\n\t\twhile (i < j) {\n\t\t\tchar temp = s[i];\n\t\t\ts[i] = s[j];\n\t\t\ts[j] = temp;\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2306",
    "source": "leetcode",
    "language": "java",
    "query": "Given the root of a binary tree, return the leftmost value in the last row of the tree.",
    "snippets": [
        "\tclass TreeNode{\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\t\tTreeNode(int x){\n\t\t\tval = x;\n\t\t}\n\t}\n\tpublic int findBottomLeftValue(TreeNode root){\n\t\tif(root == null) return -1;\n\t\tint level = 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tTreeNode node = null;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tnode = queue.poll();\n\t\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\t}\n\t\t\tlevel++;\n\t\t}\n\t\treturn node.val;\n\t}\n}\n",
        "\tint findBottomLeftValue(TreeNode root) {\n\t\tif(root == null) return 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tint count = 1;\n\t\tint res = root.val;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode cur = queue.poll();\n\t\t\t\tif(cur.left != null) queue.offer(cur.left);\n\t\t\t\tif(cur.right != null) queue.offer(cur.right);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif(count == size){\n\t\t\t\tres = queue.peek().val;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint findBottomLeftValue(TreeNode root) {\n\t\tif(root == null) return 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tint count = 1;\n\t\tint res = root.val;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode cur = queue.poll();\n\t\t\t\tif(cur.left != null) queue.offer(cur.left);\n\t\t\t\tif(cur.right != null) queue.offer(cur.right);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif(count == queue.size()){\n\t\t\t\tres = queue.peek().val;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint findBottomLeftValue(TreeNode root) {\n\t\tif(root == null) return 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tint count = 1;\n\t\tint res = root.val;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode cur = queue.poll();\n\t\t\t\tif(cur.left != null) queue.offer(cur.left);\n\t\t\t\tif(cur.right != null) queue.offer(cur.right);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif(count == Math.pow(2, count - 1)) res = queue.peek().val;\n\t\t}\n\t\treturn res;\n\t}\n}\n",
        "\tint findBottomLeftValue(TreeNode root) {\n\t\tif(root == null) return -1;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tint last = -1;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\t}\n\t\t\tlast = queue.peek().val;\n\t\t}\n\t\treturn last;\n\t}\n}\n",
        "\tint findBottomLeftValue(TreeNode root) {\n\t\tif(root == null) return -1;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.offer(root);\n\t\tint count = 1;\n\t\tint result = root.val;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tif(node.left != null) queue.offer(node.left);\n\t\t\t\tif(node.right != null) queue.offer(node.right);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif(count == size){\n\t\t\t\tresult = queue.peek().val;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint findBottomLeftValue(TreeNode root) {\n\t\tif(root == null) return 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.add(root);\n\t\tint count = 1;\n\t\tint result = root.val;\n\t\twhile(!queue.isEmpty()){\n\t\t\tint size = queue.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = queue.poll();\n\t\t\t\tif(node.left != null) queue.add(node.left);\n\t\t\t\tif(node.right != null) queue.add(node.right);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif(count == size){\n\t\t\t\tresult = queue.peek().val;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n",
        "\tint leftMost(TreeNode root){\n\t\tif(root == null) return -1;\n\t\tQueue<TreeNode> q = new LinkedList<TreeNode>();\n\t\tq.offer(root);\n\t\tint count = 1;\n\t\tint last = -1;\n\t\twhile(!q.isEmpty()){\n\t\t\tint size = q.size();\n\t\t\tfor(int i = 0; i < size; i++){\n\t\t\t\tTreeNode node = q.poll();\n\t\t\t\tif(node.left != null) q.offer(node.left);\n\t\t\t\tif(node.right != null) q.offer(node.right);\n\t\t\t}\n\t\t\tcount += size;\n\t\t\tif(count == last){\n\t\t\t\treturn node.val;\n\t\t\t}\n\t\t\tlast = count;\n\t\t}\n\t\treturn -1;\n\t}\n}\n",
        "\tint leftmost(Node root){\n\t\tif(root==null) return -1;\n\t\tQueue<Node> q=new LinkedList<Node>();\n\t\tq.offer(root);\n\t\tint count=1;\n\t\tint last=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tNode cur=q.poll();\n\t\t\tif(cur.left!=null) q.offer(cur.left);\n\t\t\tif(cur.right!=null) q.offer(cur.right);\n\t\t\tcount--;\n\t\t\tif(count==0){\n\t\t\t\tlast=cur.val;\n\t\t\t\tcount=q.size();\n\t\t\t}\n\t\t}\n\t\treturn last;\n\t}\n}\n",
        "\tint leftmost(Node root){\n\t\tif(root==null)\n\t\t\treturn -1;\n\t\tQueue<Node> q=new LinkedList<Node>();\n\t\tq.add(root);\n\t\tint count=1;\n\t\tint last=0;\n\t\twhile(!q.isEmpty()){\n\t\t\tNode temp=q.remove();\n\t\t\tcount--;\n\t\t\tif(temp.left!=null)\n\t\t\t\tq.add(temp.left);\n\t\t\tif(temp.right!=null)\n\t\t\t\tq.add(temp.right);\n\t\t\tif(count==0){\n\t\t\t\tlast=temp.val;\n\t\t\t\tcount=q.size();\n\t\t\t}\n\t\t}\n\t\treturn last;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2307",
    "source": "leetcode",
    "language": "java",
    "query": "Given a list of 24-hour clock time points in \"HH:MM\" format, return the minimum minutes difference between any two time-points in the list.",
    "snippets": [
        "\tint findMinDifference(String[] timePoints) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] time = new int[timePoints.length];\n\t\tfor(int i = 0; i < timePoints.length; i++){\n\t\t\tString[] timePoint = timePoints[i].split(\":\");\n\t\t\ttime[i] = Integer.parseInt(timePoint[0]) * 60 + Integer.parseInt(timePoint[1]);\n\t\t}\n\t\tArrays.sort(time);\n\t\tfor(int i = 0; i < time.length - 1; i++){\n\t\t\tmin = Math.min(min, time[i + 1] - time[i]);\n\t\t}\n\t\tmin = Math.min(min, 24 * 60 - time[0] + time[time.length - 1]);\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDifference(String[] timePoints) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] time = new int[timePoints.length];\n\t\tfor(int i = 0; i < timePoints.length; i++){\n\t\t\tString[] t = timePoints[i].split(\":\");\n\t\t\ttime[i] = Integer.parseInt(t[0]) * 60 + Integer.parseInt(t[1]);\n\t\t}\n\t\tArrays.sort(time);\n\t\tfor(int i = 0; i < time.length - 1; i++){\n\t\t\tmin = Math.min(min, time[i + 1] - time[i]);\n\t\t}\n\t\tmin = Math.min(min, time[0] + 1440 - time[time.length - 1]);\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDifference(String[] timePoints) {\n\t\tint[] time = new int[timePoints.length];\n\t\tfor(int i = 0; i < timePoints.length; i++){\n\t\t\tString[] t = timePoints[i].split(\":\");\n\t\t\ttime[i] = Integer.parseInt(t[0]) * 60 + Integer.parseInt(t[1]);\n\t\t}\n\t\tArrays.sort(time);\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < time.length - 1; i++){\n\t\t\tint diff = time[i + 1] - time[i];\n\t\t\tif(diff < min) min = diff;\n\t\t}\n\t\tint diff = time[0] + 1440 - time[time.length - 1];\n\t\tif(diff < min) min = diff;\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDifference(List<String> timePoints) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] time = new int[timePoints.size()];\n\t\tfor(int i = 0; i < timePoints.size(); i++){\n\t\t\tString[] t = timePoints.get(i).split(\":\");\n\t\t\ttime[i] = Integer.parseInt(t[0]) * 60 + Integer.parseInt(t[1]);\n\t\t}\n\t\tArrays.sort(time);\n\t\tfor(int i = 0; i < time.length - 1; i++){\n\t\t\tmin = Math.min(min, time[i+1] - time[i]);\n\t\t}\n\t\tmin = Math.min(min, time[0] + 1440 - time[time.length - 1]);\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDifference(List<String> timePoints) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] times = new int[timePoints.size()];\n\t\tfor(int i = 0; i < timePoints.size(); i++){\n\t\t\tString[] time = timePoints.get(i).split(\":\");\n\t\t\ttimes[i] = Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]);\n\t\t}\n\t\tArrays.sort(times);\n\t\tfor(int i = 0; i < times.length - 1; i++){\n\t\t\tmin = Math.min(min, times[i + 1] - times[i]);\n\t\t}\n\t\tmin = Math.min(min, 24 * 60 - times[times.length - 1] + times[0]);\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDiff(String[] timePoints) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] time = new int[timePoints.length];\n\t\tfor(int i = 0; i < timePoints.length; i++){\n\t\t\tString[] t = timePoints[i].split(\":\");\n\t\t\ttime[i] = Integer.parseInt(t[0]) * 60 + Integer.parseInt(t[1]);\n\t\t}\n\t\tfor(int i = 0; i < time.length; i++){\n\t\t\tfor(int j = i + 1; j < time.length; j++){\n\t\t\t\tmin = Math.min(min, Math.abs(time[i] - time[j]));\n\t\t\t}\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDifference(List<String> timePoints) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint len = timePoints.size();\n\t\tint[] time = new int[len];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tString[] t = timePoints.get(i).split(\":\");\n\t\t\ttime[i] = Integer.parseInt(t[0]) * 60 + Integer.parseInt(t[1]);\n\t\t}\n\t\tArrays.sort(time);\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tint diff = Math.abs(time[i] - time[(i + 1) % len]);\n\t\t\tif(diff < min)\n\t\t\t\tmin = diff;\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDiff(String[] timePoints) {\n\t\tint min = Integer.MAX_VALUE;\n\t\tint[] times = new int[timePoints.length];\n\t\tfor (int i = 0; i < timePoints.length; i++) {\n\t\t\tString[] t = timePoints[i].split(\":\");\n\t\t\ttimes[i] = Integer.parseInt(t[0]) * 60 + Integer.parseInt(t[1]);\n\t\t}\n\t\tArrays.sort(times);\n\t\tfor (int i = 0; i < times.length - 1; i++) {\n\t\t\tmin = Math.min(min, times[i + 1] - times[i]);\n\t\t}\n\t\treturn min;\n\t}\n}\n",
        "\tint findMinDiff(String[] timePoints){\n\t\tint[] times = new int[timePoints.length];\n\t\tfor(int i = 0; i < timePoints.length; i++){\n\t\t\tString[] time = timePoints[i].split(\":\");\n\t\t\ttimes[i] = Integer.parseInt(time[0]) * 60 + Integer.parseInt(time[1]);\n\t\t}\n\t\tArrays.sort(times);\n\t\tint min = Integer.MAX_VALUE;\n\t\tfor(int i = 0; i < times.length - 1; i++){\n\t\t\tmin = Math.min(min, times[i + 1] - times[i]);\n\t\t}\n\t\treturn min;\n\t}\n}\n"
    ],
    "results": 10
},{
    "id": "2308",
    "source": "humanEval",
    "language": "python",
    "query": "Check if in given list of numbers, are any two numbers closer to each other than a given threshold. Has_close_elements() returns true or false.",
    "snippets": [
        "def has_close_elements(list, threshold):\n    for i in range(len(list)):\n        for j in range(i+1, len(list)):\n            if abs(list[i] - list[j]) <= threshold:\n                return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "2309",
    "source": "humanEval",
    "language": "python",
    "query": "Separate groups are balanced (each open brace is properly closed) and not nested within each other. Ignore any spaces in the input string.",
    "snippets": [
        "def balanced(string):\n    stack = []\n    for char in string:\n        if char == '{':\n            stack.append(char)\n        elif char == '}':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def balance(string):\n    stack = []\n    for char in string:\n        if char == '{':\n            stack.append(char)\n        elif char == '}':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def balance(s):\n    stack = []\n    for c in s:\n        if c == '{':\n            stack.append(c)\n        elif c == '}':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def balanced(s):\n    stack = []\n    for c in s:\n        if c == '{':\n            stack.append(c)\n        elif c == '}':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def isBalanced(s):\n    stack = []\n    for c in s:\n        if c == '{':\n            stack.append(c)\n        elif c == '}':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n"
    ],
    "results": 10
},{
    "id": "2310",
    "source": "humanEval",
    "language": "python",
    "query": "Given a positive floating point number, it can be decomposed into an integer part (largest integer smaller than given number) and decimals (leftover part always smaller than 1)",
    "snippets": [
        "def decompose(number):\n    if number == 0:\n        return 0, 0\n    else:\n        integer = int(number)\n        decimals = number - integer\n        return integer, decimals\n",
        "def decompose(number):\n    integer = int(number)\n    decimals = number - integer\n    return integer, decimals\n",
        "def decompose(number):\n    if number == 0:\n        return 0, 0\n    else:\n        integer = int(number)\n        decimal = number - integer\n        return integer, decimal\n",
        "def decompose(number):\n    if number < 1:\n        return 0, number\n    else:\n        integer = int(number)\n        decimals = number - integer\n        return integer, decimals\n",
        "def decompose(number):\n    if number < 1:\n        return None\n    else:\n        integer = int(number)\n        decimals = number - integer\n        return integer, decimals\n",
        "def decompose(number):\n    if number == 0:\n        return 0\n    else:\n        return int(number) + decompose(number - int(number))\n",
        "def decompose(number):\n    if number < 1:\n        return 0, number\n    else:\n        integer = int(number)\n        decimal = number - integer\n        return integer, decimal\n",
        "def decompose(num):\n    if num == 0:\n        return 0, 0\n    elif num < 1:\n        return 0, num\n    else:\n        return int(num), num - int(num)\n",
        "def decompose(number):\n    if number < 1:\n        return 0\n    else:\n        return int(number) + decompose(number - int(number))\n"
    ],
    "results": 10
},{
    "id": "2311",
    "source": "humanEval",
    "language": "python",
    "query": "You're given a list of deposit and withdrawal operations on a bank account that starts with a zero balance. Your task is to detect if at any point the balance of account fallls below zero. At that point function should return True. Otherwise it should return False.",
    "snippets": [
        "def detect_negative_balance(operations):\n    balance = 0\n    for operation in operations:\n        if operation[0] == 'D':\n            balance += operation[1]\n        else:\n            balance -= operation[1]\n        if balance < 0:\n            return True\n    return False\n",
        "def detect_negative_balance(operations):\n    balance = 0\n    for operation in operations:\n        if operation[0] == 'D':\n            balance += int(operation[1:])\n        else:\n            balance -= int(operation[1:])\n        if balance < 0:\n            return True\n    return False\n",
        "def detect_negative_cycle(operations):\n    balance = 0\n    for operation in operations:\n        if operation[0] == 'D':\n            balance += operation[1]\n        else:\n            balance -= operation[1]\n        if balance < 0:\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "2312",
    "source": "humanEval",
    "language": "python",
    "query": "Mean Absolute Deviation is the average absolute difference between each element and a centerpoint. For a given list of input numbers, calculate Mean Absolute Deviated around the mean of this dataset.",
    "snippets": [
        "def mean_absolute_deviation(numbers):\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n",
        "def mean(numbers):\n    return float(sum(numbers)) / max(len(numbers), 1)\n",
        "def mean(numbers):\n    return sum(numbers) / float(len(numbers))\n",
        "def mean(numbers):\n    return sum(numbers) / len(numbers)\n"
    ],
    "results": 10
},{
    "id": "2313",
    "source": "humanEval",
    "language": "python",
    "query": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers' Insert a 'number' between each of the first two elements of the input list.",
    "snippets": [
        "def insert_delimiter(numbers, delimiter):\n    return [delimiter] + numbers + [delimiter]\n",
        "def insert_delimeter(numbers, delimeter):\n    return [delimeter] + numbers + [delimeter]\n",
        "def insert_number(numbers, number):\n    return [number] + numbers + [number]\n",
        "def insert_delimeter(numbers, delimeter):\n    return [delimeter] + numbers[:2] + numbers[2:]\n"
    ],
    "results": 10
},{
    "id": "2314",
    "source": "humanEval",
    "language": "python",
    "query": "parse_nested_parens is a function that parses multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses. E.g. (()()) has maximum two levels of nesting while ((())) has three.",
    "snippets": [
        "def parse_nested_parens(s):\n    if s == '':\n        return 0\n    if s[0] == '(':\n        return 1 + parse_nested_parens(s[1:])\n    else:\n        return parse_nested_parens(s[1:])\n",
        "def parse_nested_parens(s):\n    if s == '':\n        return 0\n    if s[0] == '(' and s[-1] == ')':\n        return 1 + parse_nested_parens(s[1:-1])\n    else:\n        return 0\n",
        "def parse_nested_parens(s):\n    if len(s) == 0:\n        return 0\n    if s[0] == '(':\n        return 1 + parse_nested_parens(s[1:])\n    else:\n        return parse_nested_parens(s[1:])\n",
        "def parse_nested_parens(string):\n    if string == '':\n        return 0\n    if string[0] == '(':\n        return 1 + parse_nested_parens(string[1:])\n    else:\n        return parse_nested_parens(string[1:])\n",
        "def parse_nested_parens(s):\n    if s == '':\n        return 0\n    else:\n        if s[0] == '(':\n            return 1 + parse_nested_parens(s[1:])\n        else:\n            return parse_nested_parens(s[1:])\n"
    ],
    "results": 10
},{
    "id": "2315",
    "source": "humanEval",
    "language": "python",
    "query": ". Filter an input list of strings only for ones that contain given substring. filter_by_substring('a', 'bacd', 'cde', 'array'], 'a')",
    "snippets": [
        "def filter_by_substring(substring, *args):\n    return [arg for arg in args if substring in arg]\n",
        "def filter_by_substring(substring, *args):\n    return [x for x in args if substring in x]\n"
    ],
    "results": 10
},{
    "id": "2316",
    "source": "humanEval",
    "language": "python",
    "query": "For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list. Empty sum should be equal to 0 and empty product should beequal to 1.",
    "snippets": [
        "def sum_and_product(lst):\n    sum = 0\n    product = 1\n    for i in lst:\n        sum += i\n        product *= i\n    return (sum, product)\n",
        "def sum_product(lst):\n    sum = 0\n    product = 1\n    for i in lst:\n        sum += i\n        product *= i\n    return (sum, product)\n",
        "def sum_and_product(lst):\n    if lst == []:\n        return (0, 1)\n    else:\n        return (sum(lst), reduce(lambda x, y: x * y, lst))\n",
        "def sum_and_product(lst):\n    if not lst:\n        return (0, 1)\n    else:\n        return (sum(lst), reduce(lambda x, y: x * y, lst))\n",
        "def sum_and_product(lst):\n    sum = 0\n    product = 1\n    for i in lst:\n        sum += i\n        product *= i\n    return sum, product\n"
    ],
    "results": 10
},{
    "id": "2317",
    "source": "humanEval",
    "language": "python",
    "query": "From a given list of integers, generate a list of rolling maximum element found until given moment in the sequence.",
    "snippets": [
        "def max_list(lst):\n    max_list = []\n    for i in range(len(lst)):\n        max_list.append(max(lst[:i+1]))\n    return max_list\n",
        "def max_list(l):\n    max_list = []\n    for i in range(len(l)):\n        max_list.append(max(l[:i+1]))\n    return max_list\n",
        "def max_list(lst):\n    max_lst = []\n    for i in range(len(lst)):\n        max_lst.append(max(lst[:i+1]))\n    return max_lst\n",
        "def max_list(lst):\n    if len(lst) == 0:\n        return []\n    else:\n        max_lst = [lst[0]]\n        for i in range(1, len(lst)):\n            if lst[i] > max_lst[-1]:\n                max_lst.append(lst[i])\n            else:\n                max_lst.append(max_lst[-1])\n        return max_lst\n",
        "def max_list_iter(int_list):\n    \"\"\"\n    Assumes int_list is a list of integers\n    Returns a list of rolling maxes, same length as int_list\n    \"\"\"\n    max_list = []\n    if len(int_list) == 0:\n        return max_list\n    else:\n        max_list.append(int_list[0])\n        for i in range(1, len(int_list)):\n            if int_list[i] > max_list[i-1]:\n                max_list.append(int_list[i])\n            else:\n                max_list.append(max_list[i-1])\n        return max_list\n",
        "def max_list_iter(int_list):\n    \"\"\"\n"
    ],
    "results": 10
},{
    "id": "2318",
    "source": "humanEval",
    "language": "python",
    "query": "Find the shortest palindrome that begins with a supplied string. Test if given string is a Palindrome. Algorithm idea is simple.",
    "snippets": [
        "def is_palindrome(string):\n    if string == string[::-1]:\n        return True\n    else:\n        return False\n",
        "def is_palindrome(s):\n    return s == s[::-1]\n",
        "def is_palindrome(string):\n    return string == string[::-1]\n"
    ],
    "results": 10
},{
    "id": "2319",
    "source": "humanEval",
    "language": "python",
    "query": "Perform binary XOR on two strings a and b consisting only of 1s and 0s. Return result as a string.",
    "snippets": [
        "def xor(a, b):\n    return ''.join(str(int(x) ^ int(y)) for x, y in zip(a, b))\n",
        "def xor(a, b):\n    return ''.join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n",
        "def xor(a, b):\n    return ''.join(map(lambda x, y: str(int(x) ^ int(y)), a, b))\n",
        "def xor(a, b):\n    return \"\".join(map(lambda x, y: str(int(x) ^ int(y)), a, b))\n",
        "def xor(a, b):\n    if len(a) != len(b):\n        raise ValueError(\"Strings must be of equal length\")\n    return ''.join(map(lambda x: str(int(x[0]) ^ int(x[1])), zip(a, b)))\n"
    ],
    "results": 10
},{
    "id": "2320",
    "source": "humanEval",
    "language": "python",
    "query": "Out of list of strings, return the longest one. Return the first one in case of multiple strings of the same length. Return None in case the input list is empty.",
    "snippets": [
        "def longest_string(list_of_strings):\n    if list_of_strings == []:\n        return None\n    else:\n        longest = list_of_strings[0]\n        for i in list_of_strings:\n            if len(i) > len(longest):\n                longest = i\n        return longest\n",
        "def longest_string(list_of_strings):\n    if list_of_strings == []:\n        return None\n    else:\n        longest = list_of_strings[0]\n        for string in list_of_strings:\n            if len(string) > len(longest):\n                longest = string\n        return longest\n",
        "def longest(lst):\n    if lst == []:\n        return None\n    else:\n        longest = lst[0]\n        for i in lst:\n            if len(i) > len(longest):\n                longest = i\n        return longest\n",
        "def longest_string(list_of_strings):\n    if len(list_of_strings) == 0:\n        return None\n    else:\n        longest = list_of_strings[0]\n        for string in list_of_strings:\n            if len(string) > len(longest):\n                longest = string\n        return longest\n",
        "def longest(list_of_strings):\n    if len(list_of_strings) == 0:\n        return None\n    else:\n        longest_string = list_of_strings[0]\n        for string in list_of_strings:\n            if len(string) > len(longest_string):\n                longest_string = string\n        return longest_string\n",
        "def longest(list_of_strings):\n    if list_of_strings == []:\n        return None\n    else:\n        longest = list_of_strings[0]\n        for string in list_of_strings:\n            if len(string) > len(longest):\n                longest = string\n        return longest\n"
    ],
    "results": 10
},{
    "id": "2321",
    "source": "humanEval",
    "language": "python",
    "query": "greatest_common_divisor(3, 5) is a greatest common divisor of two integers a and b.",
    "snippets": [
        "def greatest_common_divisor(a, b):\n    if b == 0:\n        return a\n    else:\n        return greatest_common_divisor(b, a % b)\n",
        "def greatest_common_divisor(a, b):\n    if a == b:\n        return a\n    elif a > b:\n        return greatest_common_divisor(a - b, b)\n    else:\n        return greatest_common_divisor(a, b - a)\n",
        "def greatest_common_divisor(a, b):\n    if a == 0:\n        return b\n    if b == 0:\n        return a\n    if a > b:\n        return greatest_common_divisor(a % b, b)\n    else:\n        return greatest_common_divisor(a, b % a)\n"
    ],
    "results": 10
},{
    "id": "2322",
    "source": "humanEval",
    "language": "python",
    "query": "All_ prefixes() returns list of all prefixes from shortest to longest of the input string. For example, all_prefixes('ab') returns ['a', 'ab', 'abc']",
    "snippets": [
        "def all_prefixes(s):\n    if s == '':\n        return ['']\n    else:\n        return [s] + all_prefixes(s[:-1])\n",
        "def all_prefixes(s):\n    if s == '':\n        return ['']\n    else:\n        return [s[:i] + p for i in range(len(s) + 1) for p in all_prefixes(s[i:])]\n",
        "def all_prefixes(s):\n    if s == '':\n        return ['']\n    else:\n        return [s[:i] + prefix for i in range(len(s) + 1) for prefix in all_prefixes(s[i:])]\n",
        "def all_prefixes(s):\n    if len(s) == 0:\n        return ['']\n    else:\n        return [s[:i] + p for i in range(len(s) + 1) for p in all_prefixes(s[i:])]\n",
        "def all_prefixes(s):\n    if s == '':\n        return ['']\n    else:\n        return [s[:i] + prefix for i in range(1, len(s) + 1) for prefix in all_prefixes(s[i:])]\n",
        "def all_prefixes(s):\n    if s == '':\n        return ['']\n    else:\n        return [s[:i] + p for i in range(len(s)) for p in all_prefixes(s[i:])]\n"
    ],
    "results": 10
},{
    "id": "2323",
    "source": "humanEval",
    "language": "python",
    "query": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.",
    "snippets": [
        "def stringy(n):\n    return ' '.join(str(i % 2) for i in range(n))\n",
        "def stringy(n):\n    return ' '.join(str(i) for i in range(n+1))\n"
    ],
    "results": 10
},{
    "id": "2324",
    "source": "humanEval",
    "language": "python",
    "query": "Given a string, find out how many distinct characters (regardless of case) does it consist of.",
    "snippets": [
        "def distinct_characters(string):\n    return len(set(string.lower()))\n",
        "def count_unique_characters(string):\n    return len(set(string.lower()))\n",
        "def count_distinct_chars(s):\n    return len(set(s.lower()))\n",
        "def count_distinct_characters(string):\n    return len(set(string.lower()))\n"
    ],
    "results": 10
},{
    "id": "2325",
    "source": "humanEval",
    "language": "python",
    "query": "The function parses a string representing musical notes in a special ASCII format. Your task is to parse this string and return list of integers corresponding to how many beats each note lasts.",
    "snippets": [
        "def parse_notes(s):\n    notes = s.split(' ')\n    result = []\n    for note in notes:\n        result.append(int(note[0]))\n    return result\n",
        "def parse_notes(s):\n    notes = s.split(' ')\n    notes_list = []\n    for note in notes:\n        if note[0] == 'C':\n            notes_list.append(int(note[1]))\n        elif note[0] == 'D':\n            notes_list.append(2 + int(note[1]))\n        elif note[0] == 'E':\n            notes_list.append(4 + int(note[1]))\n        elif note[0] == 'F':\n            notes_list.append(5 + int(note[1]))\n        elif note[0] == 'G':\n            notes_list.append(7 + int(note[1]))\n        elif note[0] == 'A':\n            notes_list.append(9 + int(note[1]))\n        elif note[0] == 'B':\n            notes_list.append(11 + int(note[1]))\n    return notes_list\n",
        "def parse_notes(s):\n    notes = s.split(' ')\n    notes_list = []\n    for note in notes:\n        if note[0] == 'C':\n            notes_list.append(int(note[1]))\n        elif note[0] == 'D':\n            notes_list.append(int(note[1]) + 2)\n        elif note[0] == 'E':\n            notes_list.append(int(note[1]) + 4)\n        elif note[0] == 'F':\n            notes_list.append(int(note[1]) + 5)\n        elif note[0] == 'G':\n            notes_list.append(int(note[1]) + 7)\n        elif note[0] == 'A':\n            notes_list.append(int(note[1]) + 9)\n        elif note[0] == 'B':\n            notes_list.append(int(note[1]) + 11)\n    return notes_list\n",
        "def parse_notes(s):\n    # your code here\n    return [int(x) for x in s.split()]\n",
        "def parse_notes(s):\n    notes = []\n    for i in s:\n        if i == ' ':\n            notes.append(0)\n        elif i == '.':\n            notes.append(1)\n        elif i == '-':\n            notes.append(2)\n        elif i == '_':\n            notes.append(3)\n        elif i == '=':\n            notes.append(4)\n        elif i == '#':\n            notes.append(5)\n        elif i == '$':\n            notes.append(6)\n        elif i == '%':\n            notes.append(7)\n        elif i == '&':\n            notes.append(8)\n        elif i == '*':\n            notes.append(9)\n        elif i == '+':\n            notes.append(10)\n        elif i == '@':\n            notes.append(11)\n        elif i == '!':\n            notes.append(12)\n        elif i == '~':\n            notes.append(13)\n        elif i == '`':\n            notes.append(14)\n        elif i == '^':\n            notes.append(15)\n        elif i == '|':\n            notes.append(16)\n        elif i == '{':\n            notes.append(17)\n        elif i == '}':\n            notes.append(18)\n        elif i == ':':\n            notes.append(19)\n        elif i == ';':\n            notes.append(20)\n        elif i == '<':\n            notes.append(21)\n        elif i == '>':\n            notes.append(22)\n        elif i == '?':\n            notes.append(23)\n        elif i == ',':\n            notes.append(24)\n        elif i == '.':\n            notes.append(25)\n        elif i == '/':\n            notes.append(26)\n        elif i == '\\\\':\n            notes.append(27)\n        elif i == '\n",
        "def parse_notes(s):\n    notes = s.split(' ')\n    notes = [note.split('/') for note in notes]\n    notes = [[int(note[0]), int(note[1])] for note in notes]\n    notes = [note[0] * note[1] for note in notes]\n    return notes\n",
        "def parse_notes(notes):\n    notes_list = notes.split()\n    notes_list = [int(i) for i in notes_list]\n    return notes_list\n"
    ],
    "results": 10
},{
    "id": "2326",
    "source": "humanEval",
    "language": "python",
    "query": "Find how many times a given substring can be found in the original string. Count overlaping cases.",
    "snippets": [
        "def count_substring(string, sub_string):\n    count = 0\n    for i in range(len(string)):\n        if string[i:i+len(sub_string)] == sub_string:\n            count += 1\n    return count\n",
        "def count_substring(string, sub_string):\n    count = 0\n    for i in range(len(string)):\n        if string[i:].startswith(sub_string):\n            count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "2327",
    "source": "humanEval",
    "language": "python",
    "query": "input is a space-delimited string of numberals from 'zero' to 'nine' Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'. Return the string with numbers sorted from smallest to largest.",
    "snippets": [
        "def order(string):\n    numbers = string.split()\n    numbers.sort()\n    return ' '.join(numbers)\n",
        "def sort_numbers(string):\n    numbers = string.split()\n    numbers.sort()\n    return ' '.join(numbers)\n",
        "def order(string):\n    numbers = []\n    for i in string.split():\n        numbers.append(int(i))\n    numbers.sort()\n    return ' '.join(str(i) for i in numbers)\n",
        "def sort(string):\n    numbers = string.split()\n    numbers.sort()\n    return ' '.join(numbers)\n",
        "def order(string):\n    return ''.join(sorted(string))\n"
    ],
    "results": 10
},{
    "id": "2328",
    "source": "humanEval",
    "language": "python",
    "query": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other. Return them in order (smaller number, larger number).",
    "snippets": [
        "def smallest_difference(list_of_numbers):\n    list_of_numbers.sort()\n    smallest_difference = list_of_numbers[1] - list_of_numbers[0]\n    for i in range(len(list_of_numbers)):\n        for j in range(i+1, len(list_of_numbers)):\n            if list_of_numbers[j] - list_of_numbers[i] < smallest_difference:\n                smallest_difference = list_of_numbers[j] - list_of_numbers[i]\n                smallest_difference_index = [i, j]\n    return smallest_difference_index\n",
        "def smallest_difference(list_of_numbers):\n    list_of_numbers.sort()\n    smallest_diff = list_of_numbers[1] - list_of_numbers[0]\n    for i in range(len(list_of_numbers)):\n        for j in range(i+1, len(list_of_numbers)):\n            if list_of_numbers[j] - list_of_numbers[i] < smallest_diff:\n                smallest_diff = list_of_numbers[j] - list_of_numbers[i]\n                smallest_diff_pair = [list_of_numbers[i], list_of_numbers[j]]\n    return smallest_diff_pair\n",
        "def smallest_difference(lst):\n    lst.sort()\n    smallest = lst[1] - lst[0]\n    for i in range(len(lst) - 1):\n        if lst[i + 1] - lst[i] < smallest:\n            smallest = lst[i + 1] - lst[i]\n            smallest_pair = [lst[i], lst[i + 1]]\n    return smallest_pair\n",
        "def two_smallest(numbers):\n    numbers.sort()\n    return numbers[0], numbers[1]\n",
        "def two_smallest(numbers):\n    numbers.sort()\n    return numbers[0:2]\n",
        "def twoClosest(list, number):\n    closest = []\n    for i in range(len(list)):\n        for j in range(len(list)):\n            if list[i] < list[j]:\n                closest.append(list[i])\n                closest.append(list[j])\n                return closest\n    return closest\n"
    ],
    "results": 10
},{
    "id": "2329",
    "source": "humanEval",
    "language": "python",
    "query": "Given list of numbers, apply a linear transform to that list. The smallest number will become 0 and the largest will become 1.",
    "snippets": [
        "def linear_transform(numbers):\n    smallest = min(numbers)\n    largest = max(numbers)\n    for i in range(len(numbers)):\n        numbers[i] = (numbers[i] - smallest) / (largest - smallest)\n    return numbers\n",
        "def linear_transform(numbers):\n    min_num = min(numbers)\n    max_num = max(numbers)\n    for i in range(len(numbers)):\n        numbers[i] = (numbers[i] - min_num) / (max_num - min_num)\n    return numbers\n",
        "def linear_transform(numbers):\n    smallest = min(numbers)\n    largest = max(numbers)\n    return [(number - smallest) / (largest - smallest) for number in numbers]\n",
        "def normalize(numbers):\n    smallest = min(numbers)\n    largest = max(numbers)\n    return [((number - smallest) / (largest - smallest)) for number in numbers]\n",
        "def linear_transform(numbers):\n    # Find the smallest and largest numbers in the list.\n    smallest = min(numbers)\n    largest = max(numbers)\n    # Calculate the range of numbers in the list.\n    range_of_numbers = largest - smallest\n    # Apply the linear transform to the list.\n    for i in range(len(numbers)):\n        numbers[i] = (numbers[i] - smallest) / range_of_numbers\n    return numbers\n",
        "def linear_transform(numbers):\n    # Your code here\n    return [x/max(numbers) for x in numbers]\n"
    ],
    "results": 10
},{
    "id": "2330",
    "source": "humanEval",
    "language": "python",
    "query": "Filter given list of any python values only for integers. filter_integers('a', 3.14, 5), 'a', 'b', 'c', 'd', 'e', 'f', 'g'",
    "snippets": [
        "def filter_integers(lst):\n    return [x for x in lst if isinstance(x, int)]\n",
        "def filter_integers(lst):\n    return filter(lambda x: isinstance(x, int), lst)\n",
        "def filter_integers(lst):\n    return [i for i in lst if isinstance(i, int)]\n",
        "def filter_integers(list):\n    return [i for i in list if isinstance(i, int)]\n"
    ],
    "results": 10
},{
    "id": "2331",
    "source": "humanEval",
    "language": "python",
    "query": "The length of a given string can be determined by strlen. Return length of given string is the length of the string.",
    "snippets": [
        "def strlen(s):\n    return len(s)\n"
    ],
    "results": 10
},{
    "id": "2332",
    "source": "humanEval",
    "language": "python",
    "query": "For a given number n, find the largest number that divides n evenly, smaller than n in a certain way. For example, largest_divisor(15) divides 15 evenly.",
    "snippets": [
        "def largest_divisor(n):\n    for i in range(n, 0, -1):\n        if n % i == 0:\n            return i\n    return None\n",
        "def largest_divisor(n):\n    for i in range(n, 0, -1):\n        if n % i == 0:\n            return i\n    return 1\n"
    ],
    "results": 10
},{
    "id": "2333",
    "source": "humanEval",
    "language": "python",
    "query": "Return list of prime factors of given integer in the order from smallest to largest. Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.",
    "snippets": [
        "def prime_factors(n):\n    i = 2\n    factors = []\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n",
        "def prime_factors(n):\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n",
        "def prime_factors(n):\n    factors = []\n    while n % 2 == 0:\n        factors.append(2)\n        n = n // 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            factors.append(i)\n            n = n // i\n    if n > 2:\n        factors.append(n)\n    return factors\n",
        "def prime_factors(n):\n    factors = []\n    d = 2\n    while n > 1:\n        while n % d == 0:\n            factors.append(d)\n            n //= d\n        d += 1\n    return factors\n"
    ],
    "results": 10
},{
    "id": "2334",
    "source": "humanEval",
    "language": "python",
    "query": "Remove all elements that occur more than once. Keep order of elements left the same as in the input.",
    "snippets": [
        "def remove_duplicates(lst):\n    return list(set(lst))\n"
    ],
    "results": 10
},{
    "id": "2335",
    "source": "humanEval",
    "language": "python",
    "query": "For a given string, flip lowercase characters to uppercase and lowercase to lowercase. For example, 'hELLO' is written as 'Hello'",
    "snippets": [
        "def swap_case(s):\n    return s.swapcase()\n",
        "def swap(s):\n    return s.swapcase()\n"
    ],
    "results": 10
},{
    "id": "2336",
    "source": "humanEval",
    "language": "python",
    "query": "Concatenate list of strings into a single string using concatenate.",
    "snippets": [
        "def concatenate(list_of_strings):\n    return ''.join(list_of_strings)\n",
        "def concatenate_strings(list_of_strings):\n    return ''.join(list_of_strings)\n",
        "def concatenate(string_list):\n    return ''.join(string_list)\n",
        "def concatenate_strings(strings):\n    return ''.join(strings)\n"
    ],
    "results": 10
},{
    "id": "2337",
    "source": "humanEval",
    "language": "python",
    "query": "Filter an input list of strings only for ones that start with a given prefix. For example, filter_by_ prefix is used to filter a list ofarray strings.",
    "snippets": [
        "def filter_by_prefix(input_list, prefix):\n    return [x for x in input_list if x.startswith(prefix)]\n",
        "def filter_by_prefix(list_of_strings, prefix):\n    return [s for s in list_of_strings if s.startswith(prefix)]\n",
        "def filter_by_prefix(list_of_strings, prefix):\n    return [string for string in list_of_strings if string.startswith(prefix)]\n"
    ],
    "results": 10
},{
    "id": "2338",
    "source": "humanEval",
    "language": "python",
    "query": "return only positive numbers in the list. Return only numbers that are positive.",
    "snippets": [
        "def positive_numbers(lst):\n    return [x for x in lst if x > 0]\n",
        "def positive_numbers(l):\n    return [x for x in l if x > 0]\n",
        "def positive_list(l):\n    return [x for x in l if x > 0]\n"
    ],
    "results": 10
},{
    "id": "2339",
    "source": "humanEval",
    "language": "python",
    "query": "Return true if a given number is prime, and false otherwise.",
    "snippets": [
        "def is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n",
        "def is_prime(num):\n    if num == 1:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2340",
    "source": "humanEval",
    "language": "python",
    "query": "Evaluates polynomial with coefficients xs at point x. find_zero only takes list xs having even number of coefficients and largest non zero coefficient.",
    "snippets": [
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] > 0:\n        raise ValueError(\"xs must have negative coefficients\")\n    if xs[-1] > 0:\n        raise ValueError(\"xs must have negative coefficients\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == -xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == -xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if\n",
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == 1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == 1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -2:\n        raise ValueError(\"xs must have non-two smallest coefficient\")\n    if xs[-1] == -2:\n        raise ValueError(\"xs must have non-two largest coefficient\")\n    if xs[0] == 2:\n        raise ValueError(\"xs must have non-two smallest coefficient\")\n    if xs[-1] == 2:\n        raise ValueError(\"xs must have non-two largest coefficient\")\n    if xs[0] == -3:\n        raise ValueError(\"xs must have non-three smallest coefficient\")\n    if xs[-1] == -3:\n        raise ValueError(\"xs must have non-three largest coefficient\")\n    if xs[0] == 3:\n        raise ValueError(\"xs must have non-three smallest coefficient\")\n    if xs[-1] == 3:\n        raise ValueError(\"xs must have non-three largest coefficient\")\n    if xs[0] == -4:\n        raise ValueError(\"xs must have non-four smallest coefficient\")\n    if xs[-1] == -4:\n        raise ValueError(\"xs must have non-four largest coefficient\")\n    if xs[0] == 4:\n        raise ValueError(\"xs must have non-four smallest coefficient\")\n    if xs[-\n",
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == 1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == 1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n",
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == 1:\n        raise ValueError(\"xs must have non-unit smallest coefficient\")\n    if xs[-1] == 1:\n        raise ValueError(\"xs must have non-unit largest coefficient\")\n    if xs[0] < 0:\n        raise ValueError(\"xs must have non-negative smallest coefficient\")\n    if xs[-1] < 0:\n        raise ValueError(\"xs must have non-negative largest coefficient\")\n    if xs[0] > 1:\n        raise ValueError(\"xs must have non-positive smallest coefficient\")\n    if xs[-1] > 1:\n        raise ValueError(\"xs must have non-positive largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-negative smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-negative largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-positive smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-positive largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-positive smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-positive largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-positive smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-positive largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-positive smallest coefficient\")\n    if xs[\n",
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == 1:\n        return xs[1]\n    if xs[0] == -1:\n        return -xs[1]\n    if xs[0] == 0:\n        return find_zero(xs[2:], x)\n    if xs[0] == 1:\n        return find_zero(xs[2:], x)\n    if xs[0] == -1:\n        return -find_zero(xs[2:], x)\n    if xs[0] == 0:\n        return find_zero(xs[2:], x)\n    if xs[0] == 1:\n        return find_zero(xs[2:], x)\n    if xs[0] == -1:\n        return -find_zero(xs[2:], x)\n    if xs[0] == 0:\n        return find_zero(xs[2:], x)\n    if xs[0] == 1:\n        return find_zero(xs[2:], x)\n    if xs[0] == -1:\n        return -find_zero(xs[2:], x)\n    if xs[0] == 0:\n        return find_zero(xs[2:], x)\n    if xs[0] == 1:\n        return find_zero(xs[2:], x)\n    if xs[0] == -1:\n        return -find_zero(xs[2:], x)\n    if xs[0] == 0:\n        return find_zero(xs[2:], x)\n    if xs[0] == 1:\n        return find_zero(xs[2:], x)\n    if xs[0] == -1:\n        return\n",
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] * xs[-1] > 0:\n        raise ValueError(\"xs must have opposite signs for smallest and largest coefficients\")\n    if xs[0] == 0:\n        return 0\n    if xs[-1] == 0:\n        return 0\n    if xs[0] * xs[-1] == 0:\n        return 0\n    if xs[0] * xs[-1] > 0:\n        return 0\n    if xs[0] * xs[-1] < 0:\n        return 0\n    if xs[0] * xs[-1] == 0:\n        return 0\n    if xs[0] * xs[-1] > 0:\n        return 0\n    if xs[0] * xs[-1] < 0:\n        return 0\n    if xs[0] * xs[-1] == 0:\n        return 0\n    if xs[0] * xs[-1] > 0:\n        return 0\n    if xs[0] * xs[-1] < 0:\n        return 0\n    if xs[0] * xs[-1] == 0:\n        return 0\n    if xs[0] * xs[-1] > 0:\n        return 0\n    if xs[0] * xs[-1] < 0:\n        return 0\n    if xs[0] * xs[-1] == 0:\n        return 0\n    if xs[0] * xs[-1] > 0:\n        return 0\n    if xs[0] * xs[-1] < 0:\n        return 0\n    if xs[0] * xs[-1] ==\n",
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero largest coefficient\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == 1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == 1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -1:\n        raise ValueError(\"xs must have non-one smallest coefficient\")\n    if xs[-1] == -1:\n        raise ValueError(\"xs must have non-one largest coefficient\")\n    if xs[0] == -xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == -xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == -xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == -xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == -xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\")\n    if xs[0] == xs[-1]:\n        raise ValueError(\"xs must have non-zero smallest coefficient\n",
        "def find_zero(xs, x):\n    if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[0] == 0:\n        raise ValueError(\"xs must have non-zero leading coefficient\")\n    if xs[-1] == 0:\n        raise ValueError(\"xs must have non-zero trailing coefficient\")\n    if xs[-1] < 0:\n        raise ValueError(\"xs must have positive trailing coefficient\")\n    if xs[0] < 0:\n        raise ValueError(\"xs must have positive leading coefficient\")\n    if xs[0] == 1:\n        raise ValueError(\"xs must have non-unity leading coefficient\")\n    if xs[-1] == 1:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-1] == xs[0]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[0] == xs[1]:\n        raise ValueError(\"xs must have non-unity leading coefficient\")\n    if xs[-2] == xs[-1]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-2] == xs[0]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-2] == xs[1]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-3] == xs[-2]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-3] == xs[-1]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-3] == xs[0]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-3] == xs[1]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-4] == xs[-3]:\n        raise ValueError(\"xs must have non-unity trailing coefficient\")\n    if xs[-\n"
    ],
    "results": 9
},{
    "id": "2341",
    "source": "humanEval",
    "language": "python",
    "query": "\"This function takes a list l and returns a list  such that    l' is identical to l in the indicies that are not divisible by three\"",
    "snippets": [
        "def f(l):\n    return [l[i] for i in range(len(l)) if i % 3 != 0]\n",
        "def f(l):\n    l2 = []\n    for i in range(len(l)):\n        if i % 3 != 0:\n            l2.append(l[i])\n    return l2\n",
        "def fizzbuzz(l):\n    l2 = []\n    for i in range(len(l)):\n        if i % 3 == 0:\n            l2.append(l[i])\n        elif i % 5 == 0:\n            l2.append(l[i])\n        else:\n            l2.append(l[i])\n    return l2\n",
        "def fizzbuzz(l):\n    return [x if x % 3 != 0 or x % 5 != 0 else \"fizzbuzz\" for x in l]\n"
    ],
    "results": 10
},{
    "id": "2342",
    "source": "humanEval",
    "language": "python",
    "query": "Return sorted unique elements in a list of elements. Unique is a type of element.",
    "snippets": [
        "def unique(lst):\n    return list(set(lst))\n",
        "def unique_list(lst):\n    return list(set(lst))\n"
    ],
    "results": 10
},{
    "id": "2343",
    "source": "humanEval",
    "language": "python",
    "query": "The max_element function returns the maximum element in the list. It can be used to find the most elements in a list.",
    "snippets": [
        "def max_element(lst):\n    max = lst[0]\n    for i in lst:\n        if i > max:\n            max = i\n    return max\n",
        "def max_element(lst):\n    max_element = lst[0]\n    for i in lst:\n        if i > max_element:\n            max_element = i\n    return max_element\n",
        "def max_element(lst):\n    max_num = lst[0]\n    for i in lst:\n        if i > max_num:\n            max_num = i\n    return max_num\n",
        "def max_element(lst):\n    max_elem = lst[0]\n    for i in lst:\n        if i > max_elem:\n            max_elem = i\n    return max_elem\n",
        "def max_element(lst):\n    max_element = lst[0]\n    for element in lst:\n        if element > max_element:\n            max_element = element\n    return max_element\n"
    ],
    "results": 10
},{
    "id": "2344",
    "source": "humanEval",
    "language": "python",
    "query": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.",
    "snippets": [
        "def count_seven(n):\n    count = 0\n    for i in range(n):\n        if i % 11 == 7 or i % 13 == 7:\n            count += 1\n    return count\n",
        "def count_sevens(n):\n    count = 0\n    for i in range(n):\n        if i % 11 == 7 or i % 13 == 7:\n            count += 1\n    return count\n",
        "def seven_digit_numbers(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if str(i).count('7') > 0:\n                count += 1\n    return count\n",
        "def seven(n):\n    count = 0\n    for i in range(n):\n        if i % 11 == 7 or i % 13 == 7:\n            count += 1\n    return count\n",
        "def seven(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            continue\n        if i % 10 == 7:\n            count += 1\n    return count\n",
        "def seven(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            continue\n        if str(i).count('7') > 0:\n            count += 1\n    return count\n",
        "def seven_digit_numbers(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if str(i).find('7') != -1:\n                count += 1\n    return count\n",
        "def count_seven(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if str(i).find('7') != -1:\n                count += 1\n    return count\n",
        "def seven(n):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 7 or i % 13 == 7:\n            count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "2345",
    "source": "humanEval",
    "language": "python",
    "query": "The sort_even function takes a list l and returns a list of odd and even indicies. Its values at the odd indicies of l are equal to the even values of l, sorted.",
    "snippets": [
        "def sort_even(l):\n    even = []\n    odd = []\n    for i in l:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    even.sort()\n    return even + odd\n",
        "def sort_even(l):\n    even = []\n    odd = []\n    for i in l:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    even.sort()\n    return odd + even\n"
    ],
    "results": 10
},{
    "id": "2346",
    "source": "humanEval",
    "language": "python",
    "query": "Groups are created by cycling groups of three characters. Each group has three elements of length 3.",
    "snippets": [
        "def group(s):\n    return [s[i:i+3] for i in range(0, len(s), 3)]\n",
        "def group(string):\n    return [string[i:i+3] for i in range(0, len(string), 3)]\n"
    ],
    "results": 10
},{
    "id": "2347",
    "source": "humanEval",
    "language": "python",
    "query": "prime_fib returns n-th number that is a Fibonacci number and it's also prime.",
    "snippets": [
        "def prime_fib(n):\n    fib = [1, 1]\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n    for i in range(len(fib)):\n        if is_prime(fib[i]):\n            return fib[i]\n    return -1\n",
        "def prime_fib(n):\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    if n == 3:\n        return 1\n    if n == 4:\n        return 2\n    if n == 5:\n        return 3\n    if n == 6:\n        return 5\n    if n == 7:\n        return 8\n    if n == 8:\n        return 13\n    if n == 9:\n        return 21\n    if n == 10:\n        return 34\n    if n == 11:\n        return 55\n    if n == 12:\n        return 89\n    if n == 13:\n        return 144\n    if n == 14:\n        return 233\n    if n == 15:\n        return 377\n    if n == 16:\n        return 610\n    if n == 17:\n        return 987\n    if n == 18:\n        return 1597\n    if n == 19:\n        return 2584\n    if n == 20:\n        return 4181\n    if n == 21:\n        return 6765\n    if n == 22:\n        return 10946\n    if n == 23:\n        return 17711\n    if n == 24:\n        return 28657\n    if n == 25:\n        return 46368\n    if n == 26:\n        return 75025\n    if n == 27:\n        return 121393\n    if n == 28:\n        return 196418\n    if n == 29:\n        return 317811\n    if n == 30:\n        return 514229\n    if n == 31:\n        return 832040\n    if n == 32:\n        return 1346269\n    if n == 33:\n        return 2178309\n    if n == 34:\n        return 3524578\n    if n == 35:\n        return 5702887\n    if n == 36:\n        return 9227465\n    if n == 37:\n        return 14930352\n    if n == 38:\n        return 24157817\n    if n == 39:\n        return 39088169\n    if n == 40:\n        return 63245986\n    if n == 41:\n        return 1023\n",
        "def prime_fib(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 3\n    if n == 5:\n        return 5\n    if n == 6:\n        return 8\n    if n == 7:\n        return 13\n    if n == 8:\n        return 21\n    if n == 9:\n        return 34\n    if n == 10:\n        return 55\n    if n == 11:\n        return 89\n    if n == 12:\n        return 144\n    if n == 13:\n        return 233\n    if n == 14:\n        return 377\n    if n == 15:\n        return 610\n    if n == 16:\n        return 987\n    if n == 17:\n        return 1597\n    if n == 18:\n        return 2584\n    if n == 19:\n        return 4181\n    if n == 20:\n        return 6765\n    if n == 21:\n        return 10946\n    if n == 22:\n        return 17711\n    if n == 23:\n        return 28657\n    if n == 24:\n        return 46368\n    if n == 25:\n        return 75025\n    if n == 26:\n        return 121393\n    if n == 27:\n        return 196418\n    if n == 28:\n        return 317811\n    if n == 29:\n        return 514229\n    if n == 30:\n        return 832040\n    if n == 31:\n        return 1346269\n    if n == 32:\n        return 2178309\n    if n == 33:\n        return 3524578\n    if n == 34:\n        return 5702887\n    if n == 35:\n        return 9227465\n    if n == 36:\n        return 14930352\n    if n == 37:\n        return 24157817\n    if n == 38:\n        return 39088169\n    if n == 39:\n        return 63245986\n    if n == 40:\n        return 1023\n",
        "def prime_fib(n):\n    fib_list = [1, 1]\n    for i in range(2, n):\n        fib_list.append(fib_list[i-1] + fib_list[i-2])\n    for i in range(len(fib_list)):\n        if is_prime(fib_list[i]):\n            return fib_list[i]\n    return -1\n",
        "def prime_fib(n):\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a = 0\n        b = 1\n        c = a + b\n        for i in range(3, n + 1):\n            a = b\n            b = c\n            c = a + b\n            if is_prime(c):\n                return c\n        return -1\n",
        "def prime_fib(n):\n    if n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a = 0\n        b = 1\n        c = a + b\n        for i in range(3, n + 1):\n            a = b\n            b = c\n            c = a + b\n            if c % 2 == 0:\n                c += 1\n            if is_prime(c):\n                if i == n:\n                    return c\n",
        "def prime_fib(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        a = 1\n        b = 1\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n            if is_prime(c):\n                return c\n        return -1\n",
        "def prime_fib(n):\n    a, b = 0, 1\n    while True:\n        a, b = b, a + b\n        if b > n:\n            break\n        if is_prime(b):\n            n -= b\n            if n == 0:\n                return b\n    return None\n"
    ],
    "results": 10
},{
    "id": "2348",
    "source": "humanEval",
    "language": "python",
    "query": "Triples_sum_to_zero takes a list of integers as an input. It returns True if there are three distinct elements in the list that sum to zero, and False otherwise.",
    "snippets": [
        "def Triples_sum_to_zero(L):\n    for i in range(len(L)):\n        for j in range(len(L)):\n            for k in range(len(L)):\n                if L[i] + L[j] + L[k] == 0:\n                    return True\n    return False\n",
        "def Triples_sum_to_zero(list):\n    for i in range(len(list)):\n        for j in range(len(list)):\n            for k in range(len(list)):\n                if list[i] + list[j] + list[k] == 0:\n                    return True\n    return False\n",
        "def Triples_sum_to_zero(list_of_numbers):\n    for i in range(len(list_of_numbers)):\n        for j in range(len(list_of_numbers)):\n            for k in range(len(list_of_numbers)):\n                if list_of_numbers[i] + list_of_numbers[j] + list_of_numbers[k] == 0:\n                    return True\n    return False\n",
        "def Triples_sum_to_zero(list):\n    for i in range(len(list)):\n        for j in range(i+1, len(list)):\n            for k in range(j+1, len(list)):\n                if list[i] + list[j] + list[k] == 0:\n                    return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "2349",
    "source": "humanEval",
    "language": "python",
    "query": "Two cars are said to collide when a car moving left to right hits a car that's moving right to left. This function outputs the number of such collisions.",
    "snippets": [
        "def collides(cars):\n    collisions = 0\n    for i in range(len(cars)):\n        for j in range(i + 1, len(cars)):\n            if cars[i] < cars[j] and cars[j] - cars[i] <= 1:\n                collisions += 1\n    return collisions\n",
        "def collides(cars):\n    collisions = 0\n    for i in range(len(cars)):\n        for j in range(i+1, len(cars)):\n            if cars[i][0] < cars[j][0] and cars[i][1] > cars[j][1]:\n                collisions += 1\n    return collisions\n",
        "def collides(cars):\n    collisions = 0\n    for i in range(len(cars)):\n        for j in range(i + 1, len(cars)):\n            if cars[i] > cars[j]:\n                collisions += 1\n    return collisions\n",
        "def collision(n, cars):\n    # Write your code here.\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if cars[i] > cars[j] and cars[j] + j - i <= n:\n                count += 1\n    return count\n",
        "def collide(cars):\n    count = 0\n    for i in range(len(cars)):\n        for j in range(i+1, len(cars)):\n            if cars[i][0] < cars[j][0] and cars[i][1] > cars[j][1]:\n                count += 1\n    return count\n",
        "def collision_count(cars):\n    count = 0\n    for i in range(len(cars)):\n        for j in range(i+1, len(cars)):\n            if cars[i][0] < cars[j][0] and cars[i][1] > cars[j][1]:\n                count += 1\n    return count\n",
        "def collision(n, cars):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if cars[i] > cars[j] and cars[j] + j - i <= n:\n                count += 1\n    return count\n",
        "def collision(n, cars):\n    # Write your code here\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if cars[i] > cars[j] and cars[i] - cars[j] <= 5:\n                count += 1\n    return count\n",
        "def car_collision(cars):\n    collisions = 0\n    for i in range(len(cars)):\n        for j in range(i + 1, len(cars)):\n            if cars[i][0] < cars[j][0] < cars[i][1] or cars[i][0] < cars[j][1] < cars[i][1]:\n                collisions += 1\n    return collisions\n"
    ],
    "results": 10
},{
    "id": "2350",
    "source": "humanEval",
    "language": "python",
    "query": "\"Return list with elements incremented by 1. \" \" \" List of elements with elements increased by 1\" \" List with elements decreased by 1.\"",
    "snippets": [
        "def main():\n    a = [1, 2, 3, 4, 5]\n    b = [x + 1 for x in a]\n    c = [x - 1 for x in a]\n    print(b)\n    print(c)\n",
        "def main():\n    list1 = [1, 2, 3, 4, 5]\n    list2 = [1, 2, 3, 4, 5]\n    list3 = [1, 2, 3, 4, 5]\n    list4 = [1, 2, 3, 4, 5]\n    list5 = [1, 2, 3, 4, 5]\n    list6 = [1, 2, 3, 4, 5]\n    list7 = [1, 2, 3, 4, 5]\n    list8 = [1, 2, 3, 4, 5]\n    list9 = [1, 2, 3, 4, 5]\n    list10 = [1, 2, 3, 4, 5]\n    list11 = [1, 2, 3, 4, 5]\n    list12 = [1, 2, 3, 4, 5]\n    list13 = [1, 2, 3, 4, 5]\n    list14 = [1, 2, 3, 4, 5]\n    list15 = [1, 2, 3, 4, 5]\n    list16 = [1, 2, 3, 4, 5]\n    list17 = [1, 2, 3, 4, 5]\n    list18 = [1, 2, 3, 4, 5]\n    list19 = [1, 2, 3, 4, 5]\n    list20 = [1, 2, 3, 4, 5]\n    list21 = [1, 2, 3, 4, 5]\n    list22 = [1, 2, 3, 4, 5]\n    list23 = [1, 2, 3, 4, 5]\n    list24 = [1, 2, 3, 4, 5]\n    list25 = [1, 2, 3, 4, 5]\n    list26 = [1, 2, 3, 4, 5]\n    list27 = [1, 2, 3, 4, 5]\n    list28 = [1, 2, 3, 4, 5]\n    list29 = [1, 2, 3, 4, 5]\n    list30 = [1, 2, 3, 4, 5]\n    list31 = [1, 2, 3, 4, 5]\n",
        "def main():\n    lst = [1, 2, 3, 4, 5]\n    print(lst)\n    print(increment(lst))\n    print(decrement(lst))\n    print(increment(decrement(lst)))\n",
        "def main():\n    lst = [1, 2, 3, 4, 5]\n    print(lst)\n    print(increment(lst))\n    print(decrement(lst))\n",
        "def main():\n    list1 = [1, 2, 3, 4, 5]\n    print(list1)\n    print(increment(list1))\n    print(decrement(list1))\n    print(increment(decrement(list1)))\n    print(decrement(increment(list1)))\n",
        "def main():\n    print(\"List of elements with elements increased by 1\")\n    print(\"List with elements decreased by 1.\")\n    print(\"List with elements multiplied by 2.\")\n    print(\"List with elements divided by 2.\")\n    print(\"List with elements modulo 2.\")\n    print(\"List with elements raised to the power of 2.\")\n    print(\"List with elements squared.\")\n    print(\"List with elements cubed.\")\n    print(\"List with elements raised to the power of 3.\")\n    print(\"List with elements raised to the power of 4.\")\n    print(\"List with elements raised to the power of 5.\")\n    print(\"List with elements raised to the power of 6.\")\n    print(\"List with elements raised to the power of 7.\")\n    print(\"List with elements raised to the power of 8.\")\n    print(\"List with elements raised to the power of 9.\")\n    print(\"List with elements raised to the power of 10.\")\n    print(\"List with elements raised to the power of 11.\")\n    print(\"List with elements raised to the power of 12.\")\n    print(\"List with elements raised to the power of 13.\")\n    print(\"List with elements raised to the power of 14.\")\n    print(\"List with elements raised to the power of 15.\")\n    print(\"List with elements raised to the power of 16.\")\n    print(\"List with elements raised to the power of 17.\")\n    print(\"List with elements raised to the power of 18.\")\n    print(\"List with elements raised to the power of 19.\")\n    print(\"List with elements raised to the power of 20.\")\n    print(\"List with elements raised to the power of 21.\")\n    print(\"List with elements raised to the power of 22.\")\n    print(\"List with elements raised to the power of 23.\")\n    print(\"List with elements raised to the power of 24.\")\n    print(\"List with elements raised to the power of 25.\")\n    print(\"List with elements raised to the power of 26.\")\n    print(\"List with elements raised to the power of 27.\")\n    print(\"List with elements raised to the power of 28.\")\n    print(\"List with elements raised to the power of 29.\")\n    print(\"List with elements raised to the power of 30.\")\n    print(\"List with elements raised to the power of 31.\")\n",
        "def my_map(func, lst):\n    new_list = []\n    for i in lst:\n        new_list.append(func(i))\n    return new_list\n",
        "def add_one(lst):\n    return [x + 1 for x in lst]\n",
        "def main():\n    print(\"This program prints a list of numbers.\")\n    print(\"Enter 'x' to end the program.\")\n    print()\n    while True:\n        num = input(\"Enter a number: \")\n        if num == \"x\":\n            break\n        else:\n            num = int(num)\n            num += 1\n            print(num)\n"
    ],
    "results": 10
},{
    "id": "2351",
    "source": "humanEval",
    "language": "python",
    "query": "Pairs_sum_to_zero takes a list of integers as an input. It returns True if there are two distinct elements in the list that sum to zero, and False otherwise.",
    "snippets": [
        "def pairs_sum_to_zero(lst):\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            if lst[i] + lst[j] == 0:\n                return True\n    return False\n",
        "def pairs_sum_to_zero(lst):\n    for i in lst:\n        for j in lst:\n            if i + j == 0:\n                return True\n    return False\n",
        "def pairs_sum_to_zero(lst):\n    for i in lst:\n        if -i in lst:\n            return True\n    return False\n",
        "def pairs_sum_to_zero(lst):\n    for i in range(len(lst)):\n        for j in range(len(lst)):\n            if i != j and lst[i] + lst[j] == 0:\n                return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "2352",
    "source": "humanEval",
    "language": "python",
    "query": "Change numerical base of input number x to base. Return string representation after the conversion.",
    "snippets": [
        "def convert(x, base):\n    if x < 0:\n        sign = \"-\"\n        x = -x\n    else:\n        sign = \"\"\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x > 0:\n        digits.append(x % base)\n        x //= base\n    digits.reverse()\n    return sign + \"\".join(map(str, digits))\n",
        "def convert(x, base):\n    if x < 0:\n        sign = \"-\"\n        x = -x\n    else:\n        sign = \"\"\n    if x == 0:\n        return \"0\"\n    result = \"\"\n    while x > 0:\n        result = str(x % base) + result\n        x //= base\n    return sign + result\n",
        "def convert(x, base):\n    if x < 0:\n        sign = \"-\"\n    else:\n        sign = \"\"\n    x = abs(x)\n    digits = []\n    while x > 0:\n        digits.append(x % base)\n        x = x // base\n    digits.reverse()\n    return sign + \"\".join(map(str, digits))\n",
        "def convert(x, base):\n    if x < 0:\n        sign = \"-\"\n        x = abs(x)\n    else:\n        sign = \"\"\n    if x == 0:\n        return \"0\"\n    if base < 2 or base > 36:\n        return \"Base must be between 2 and 36\"\n    if x > 0:\n        return sign + convert_positive(x, base)\n    else:\n        return sign + convert_negative(x, base)\n",
        "def base_converter(x, base):\n    if base < 2 or base > 36:\n        return \"Invalid base\"\n    if x < 0:\n        return \"-\" + base_converter(-x, base)\n    result = \"\"\n    while x > 0:\n        result = str(x % base) + result\n        x = x // base\n    return result\n",
        "def convert(x, base):\n    if x == 0:\n        return \"0\"\n    if base == 1:\n        return \"1\"\n    if base == 2:\n        return \"01\"\n    if base == 3:\n        return \"011\"\n    if base == 4:\n        return \"0111\"\n    if base == 5:\n        return \"01111\"\n    if base == 6:\n        return \"011111\"\n    if base == 7:\n        return \"0111111\"\n    if base == 8:\n        return \"01111111\"\n    if base == 9:\n        return \"011111111\"\n    if base == 10:\n        return \"0111111111\"\n    if base == 11:\n        return \"01111111111\"\n    if base == 12:\n        return \"011111111111\"\n    if base == 13:\n        return \"0111111111111\"\n    if base == 14:\n        return \"01111111111111\"\n    if base == 15:\n        return \"011111111111111\"\n    if base == 16:\n        return \"0111111111111111\"\n    if base == 17:\n        return \"01111111111111111\"\n    if base == 18:\n        return \"011111111111111111\"\n    if base == 19:\n        return \"0111111111111111111\"\n    if base == 20:\n        return \"01111111111111111111\"\n    if base == 21:\n        return \"011111111111111111111\"\n    if base == 22:\n        return \"0111111111111111111111\"\n    if base == 23:\n        return \"01111111111111111111111\"\n    if base == 24:\n        return \"011111111111111111111111\"\n    if base == 25:\n        return \"0111111111111111111111111\"\n    if base == 26:\n        return \"01111111111111111111111111\"\n    if base == 27:\n        return \"011111111111111111111111111\"\n    if base == 28:\n        return \"0111111111111111111111111111\"\n    if base == 29:\n        return \"01111111111111111111111111111\n"
    ],
    "results": 10
},{
    "id": "2353",
    "source": "humanEval",
    "language": "python",
    "query": "Given length of a side and high return area for a triangle. triangle_area(5, 3) returns a triangle with a radius of 7.5.",
    "snippets": [
        "def triangle_area(side, high):\n    return (side * high) / 2\n",
        "def triangle_area(side, high):\n    return side * high / 2\n",
        "def triangle_area(length, high):\n    return (length * high) / 2\n",
        "def triangle_area(length, high):\n    return length * high / 2\n"
    ],
    "results": 10
},{
    "id": "2354",
    "source": "humanEval",
    "language": "python",
    "query": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece. Do not use recursion. Please write a function to efficiently compute the n-th element of the fib4Number sequence.",
    "snippets": [
        "def fib4(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib4(n-1) + fib4(n-2)\n",
        "def fib4(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 3\n    if n == 5:\n        return 5\n    if n == 6:\n        return 8\n    if n == 7:\n        return 13\n    if n == 8:\n        return 21\n    if n == 9:\n        return 34\n    if n == 10:\n        return 55\n    if n == 11:\n        return 89\n    if n == 12:\n        return 144\n    if n == 13:\n        return 233\n    if n == 14:\n        return 377\n    if n == 15:\n        return 610\n    if n == 16:\n        return 987\n    if n == 17:\n        return 1597\n    if n == 18:\n        return 2584\n    if n == 19:\n        return 4181\n    if n == 20:\n        return 6765\n    if n == 21:\n        return 10946\n    if n == 22:\n        return 17711\n    if n == 23:\n        return 28657\n    if n == 24:\n        return 46368\n    if n == 25:\n        return 75025\n    if n == 26:\n        return 121393\n    if n == 27:\n        return 196418\n    if n == 28:\n        return 317811\n    if n == 29:\n        return 514229\n    if n == 30:\n        return 832040\n    if n == 31:\n        return 1346269\n    if n == 32:\n        return 2178309\n    if n == 33:\n        return 3524578\n    if n == 34:\n        return 5702887\n    if n == 35:\n        return 9227465\n    if n == 36:\n        return 14930352\n    if n == 37:\n        return 24157817\n    if n == 38:\n        return 39088169\n    if n == 39:\n        return 63245986\n    if n == 40:\n        return 102334155\n"
    ],
    "results": 10
},{
    "id": "2355",
    "source": "humanEval",
    "language": "python",
    "query": "Return median of elements in the list l.    >>> median([-10, 4, 6, 1000, 10, 20]], 15.0), 3.0.",
    "snippets": [
        "def median(l, m):\n    l.sort()\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        return l[len(l) // 2]\n    return m\n",
        "def median(l, m):\n    l.sort()\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        return l[len(l) // 2]\n",
        "def median(l):\n    l.sort()\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        return l[len(l) // 2]\n"
    ],
    "results": 10
},{
    "id": "2356",
    "source": "humanEval",
    "language": "python",
    "query": "Checks if given string is a palindrome. Checks if it's a \"palindrome\" or a \"phrase\"",
    "snippets": [
        "def is_palindrome(string):\n    string = string.lower()\n    string = string.replace(\" \", \"\")\n    string = string.replace(\".\", \"\")\n    string = string.replace(\",\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"?\", \"\")\n    string = string.replace(\"'\", \"\")\n    string = string.replace('\"', \"\")\n    string = string.replace(\";\", \"\")\n    string = string.replace(\":\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"*\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"&\", \"\")\n    string = string.replace(\"^\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"€\", \"\")\n    string = string.replace(\"¥\", \"\")\n    string = string.replace(\"£\", \"\")\n    string = string.replace(\"¢\", \"\")\n    string = string.replace(\"¤\", \"\")\n    string = string.replace(\"¡\", \"\")\n    string = string.replace(\"¿\", \"\")\n    string = string.replace(\"¬\", \"\")\n    string = string.replace(\"¦\", \"\")\n",
        "def is_palindrome(string):\n    string = string.lower()\n    string = string.replace(\" \", \"\")\n    string = string.replace(\".\", \"\")\n    string = string.replace(\",\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"?\", \"\")\n    string = string.replace(\"'\", \"\")\n    string = string.replace('\"', \"\")\n    string = string.replace(\";\", \"\")\n    string = string.replace(\":\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"*\", \"\")\n    string = string.replace(\"&\", \"\")\n    string = string.replace(\"^\", \"\")\n    string = string.replace(\"~\", \"\")\n    string = string.replace(\"`\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace\n",
        "def is_palindrome(string):\n    string = string.lower()\n    string = string.replace(\" \", \"\")\n    string = string.replace(\".\", \"\")\n    string = string.replace(\",\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"?\", \"\")\n    string = string.replace(\"'\", \"\")\n    string = string.replace('\"', \"\")\n    string = string.replace(\";\", \"\")\n    string = string.replace(\":\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"*\", \"\")\n    string = string.replace(\"&\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"^\", \"\")\n    string = string.replace(\"~\", \"\")\n    string = string.replace(\"`\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\n",
        "def is_palindrome(string):\n    string = string.lower()\n    string = string.replace(\" \", \"\")\n    string = string.replace(\".\", \"\")\n    string = string.replace(\",\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"?\", \"\")\n    string = string.replace(\"'\", \"\")\n    string = string.replace('\"', \"\")\n    string = string.replace(\";\", \"\")\n    string = string.replace(\":\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"*\", \"\")\n    string = string.replace(\"&\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"^\", \"\")\n    string = string.replace(\"~\", \"\")\n    string = string.replace(\"`\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"\n",
        "def is_palindrome(string):\n    string = string.lower()\n    string = string.replace(\" \", \"\")\n    string = string.replace(\".\", \"\")\n    string = string.replace(\",\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"?\", \"\")\n    string = string.replace(\"'\", \"\")\n    string = string.replace(\"\\\"\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\";\", \"\")\n    string = string.replace(\":\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"*\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"&\", \"\")\n    string = string.replace(\"^\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"€\", \"\")\n    string = string.replace(\"£\", \"\")\n    string = string.replace(\"¢\", \"\")\n    string = string.replace(\"¥\", \"\")\n    string = string.replace(\"¤\", \"\")\n    string = string.replace(\"¦\", \"\")\n    string = string.replace(\"¬\", \"\")\n    string = string.replace(\"ª\", \"\")\n    string = string.replace(\"º\", \"\")\n",
        "def is_palindrome(string):\n    string = string.lower()\n    string = string.replace(\" \", \"\")\n    string = string.replace(\",\", \"\")\n    string = string.replace(\".\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"?\", \"\")\n    string = string.replace(\"'\", \"\")\n    string = string.replace(\"\\\"\", \"\")\n    string = string.replace(\";\", \"\")\n    string = string.replace(\":\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"*\", \"\")\n    string = string.replace(\"&\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"~\", \"\")\n    string = string.replace(\"`\", \"\")\n    string = string.replace(\"^\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"\n",
        "def is_palindrome(string):\n    string = string.lower()\n    string = string.replace(\" \", \"\")\n    string = string.replace(\",\", \"\")\n    string = string.replace(\".\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"?\", \"\")\n    string = string.replace(\"'\", \"\")\n    string = string.replace(\"\\\"\", \"\")\n    string = string.replace(\"-\", \"\")\n    string = string.replace(\"_\", \"\")\n    string = string.replace(\";\", \"\")\n    string = string.replace(\":\", \"\")\n    string = string.replace(\"/\", \"\")\n    string = string.replace(\"\\\\\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"<\", \"\")\n    string = string.replace(\">\", \"\")\n    string = string.replace(\"+\", \"\")\n    string = string.replace(\"=\", \"\")\n    string = string.replace(\"*\", \"\")\n    string = string.replace(\"&\", \"\")\n    string = string.replace(\"%\", \"\")\n    string = string.replace(\"$\", \"\")\n    string = string.replace(\"#\", \"\")\n    string = string.replace(\"@\", \"\")\n    string = string.replace(\"!\", \"\")\n    string = string.replace(\"~\", \"\")\n    string = string.replace(\"`\", \"\")\n    string = string.replace(\"^\", \"\")\n    string = string.replace(\"|\", \"\")\n    string = string.replace(\"}\", \"\")\n    string = string.replace(\"{\", \"\")\n    string = string.replace(\"]\", \"\")\n    string = string.replace(\"[\", \"\")\n    string = string.replace(\"(\", \"\")\n    string = string.replace(\")\", \"\")\n    string = string.replace(\"\n",
        "def is_palindrome(string):\n    if string == string[::-1]:\n        return True\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "2357",
    "source": "humanEval",
    "language": "python",
    "query": "Return 2^n modulo p (be aware of numerics) 1. P is the number of letters in a word. 2. The word is the length of the word. 3. The letter is the word's length.",
    "snippets": [
        "def power(n, p, letter):\n    return (2**n) % p\n",
        "def power(n, p, letter):\n    if n == 0:\n        return 1\n    else:\n        return (letter ** n) % p\n",
        "def power(n, p, letter):\n    return (2**n) % p % letter\n"
    ],
    "results": 10
},{
    "id": "2358",
    "source": "humanEval",
    "language": "python",
    "query": "The encoding function shifts every character by 5 in the alphabet. It takes as input string encoded with encode_shift function.",
    "snippets": [
        "def decode_shift(encoded_string):\n    decoded_string = \"\"\n    for char in encoded_string:\n        if char.isalpha():\n            if char.isupper():\n                decoded_string += chr((ord(char) - ord('A') - 5) % 26 + ord('A'))\n            else:\n                decoded_string += chr((ord(char) - ord('a') - 5) % 26 + ord('a'))\n        else:\n            decoded_string += char\n    return decoded_string\n",
        "def decode_shift(encoded_string):\n    decoded_string = ''\n    for char in encoded_string:\n        if char.isalpha():\n            if char.isupper():\n                decoded_string += chr((ord(char) - ord('A') - 5) % 26 + ord('A'))\n            else:\n                decoded_string += chr((ord(char) - ord('a') - 5) % 26 + ord('a'))\n        else:\n            decoded_string += char\n    return decoded_string\n",
        "def decode_shift(encoded_string):\n    decoded_string = \"\"\n    for char in encoded_string:\n        if char.isalpha():\n            if char.isupper():\n                decoded_string += chr((ord(char) - 5 - ord('A')) % 26 + ord('A'))\n            else:\n                decoded_string += chr((ord(char) - 5 - ord('a')) % 26 + ord('a'))\n        else:\n            decoded_string += char\n    return decoded_string\n",
        "def decode_shift(encoded_string):\n    decoded_string = \"\"\n    for char in encoded_string:\n        if char.isalpha():\n            if char.isupper():\n                decoded_string += chr((ord(char) - 5 - 65) % 26 + 65)\n            else:\n                decoded_string += chr((ord(char) - 5 - 97) % 26 + 97)\n        else:\n            decoded_string += char\n    return decoded_string\n",
        "def decode_shift(encoded_string):\n    decoded_string = ''\n    for char in encoded_string:\n        if char.isalpha():\n            if char.isupper():\n                decoded_string += chr((ord(char) - 5 - 65) % 26 + 65)\n            else:\n                decoded_string += chr((ord(char) - 5 - 97) % 26 + 97)\n        else:\n            decoded_string += char\n    return decoded_string\n",
        "def decode_shift(encoded_string):\n    decoded_string = \"\"\n    for char in encoded_string:\n        if char.isalpha():\n            decoded_string += chr(ord(char) - 5)\n        else:\n            decoded_string += char\n    return decoded_string\n"
    ],
    "results": 10
},{
    "id": "2359",
    "source": "humanEval",
    "language": "python",
    "query": "remove_vowels is a function that takes string and returns string without vowels.",
    "snippets": [
        "def remove_vowels(string):\n    vowels = 'aeiouAEIOU'\n    for char in string:\n        if char in vowels:\n            string = string.replace(char, '')\n    return string\n",
        "def remove_vowels(string):\n    vowels = \"aeiouAEIOU\"\n    for char in string:\n        if char in vowels:\n            string = string.replace(char, \"\")\n    return string\n",
        "def remove_vowels(s):\n    vowels = 'aeiouAEIOU'\n    for i in vowels:\n        s = s.replace(i, '')\n    return s\n",
        "def remove_vowels(string):\n    vowels = 'aeiou'\n    string = string.lower()\n    for i in string:\n        if i in vowels:\n            string = string.replace(i, '')\n    return string\n"
    ],
    "results": 10
},{
    "id": "2360",
    "source": "humanEval",
    "language": "python",
    "query": "below_threshold is True if all numbers in the list l are below threshold t.",
    "snippets": [
        "def below_threshold(l, t):\n    for i in l:\n        if i > t:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2361",
    "source": "humanEval",
    "language": "python",
    "query": "Add two numbers x and y to a list of numbers.",
    "snippets": [
        "def add_two_numbers(x, y):\n    return x + y\n"
    ],
    "results": 10
},{
    "id": "2362",
    "source": "humanEval",
    "language": "python",
    "query": "Check if two words have the same characters. Check if they are the same character.",
    "snippets": [
        "def check_if_same_char(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    if len(word1) != len(word2):\n        return False\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            return False\n    return True\n",
        "def check_same_char(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    if len(word1) != len(word2):\n        return False\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            return False\n    return True\n",
        "def check_same_char(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    if len(word1) != len(word2):\n        return False\n    for char in word1:\n        if char not in word2:\n            return False\n    return True\n",
        "def check_anagram(word1, word2):\n    word1 = word1.replace(\" \", \"\").lower()\n    word2 = word2.replace(\" \", \"\").lower()\n    if len(word1) != len(word2):\n        return False\n    for letter in word1:\n        if letter not in word2:\n            return False\n    return True\n",
        "def check_if_same_characters(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    if len(word1) != len(word2):\n        return False\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            return False\n    return True\n",
        "def check_if_same_char(word1, word2):\n    word1_list = list(word1)\n    word2_list = list(word2)\n    for i in range(len(word1_list)):\n        if word1_list[i] in word2_list:\n            word2_list.remove(word1_list[i])\n        else:\n            return False\n    return True\n",
        "def check_same_char(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    for char in word1:\n        if char in word2:\n            return True\n    return False\n",
        "def check_if_same_char(word1, word2):\n    word1 = word1.lower()\n    word2 = word2.lower()\n    for char in word1:\n        if char not in word2:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2363",
    "source": "humanEval",
    "language": "python",
    "query": "Fibonacci number is a Fibonacci sequence of numbers. The number n is the number of Fibonaccis.",
    "snippets": [
        "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n"
    ],
    "results": 10
},{
    "id": "2364",
    "source": "humanEval",
    "language": "python",
    "query": "brackets is a string of \"<\" and \">\". return True if every opening bracket has a corresponding closing bracket.",
    "snippets": [
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        elif bracket == '>':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        elif bracket == '>':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '<':\n            stack.append(bracket)\n        elif bracket == '>':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def brackets(brackets):\n    stack = []\n    for i in brackets:\n        if i == '<':\n            stack.append(i)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_balanced(brackets):\n    # your code here\n    if len(brackets) % 2 != 0:\n        return False\n    else:\n        for i in range(len(brackets)):\n            if brackets[i] == '<':\n                brackets.append('>')\n            elif brackets[i] == '>':\n                brackets.append('<')\n        if brackets == ['<', '<', '<', '>', '>', '>', '>']:\n            return True\n        else:\n            return False\n"
    ],
    "results": 10
},{
    "id": "2365",
    "source": "humanEval",
    "language": "python",
    "query": "Return True is list elements are monotonically increasing or decreasing. For example, a list of 20 elements would look like this:",
    "snippets": [
        "def is_monotonic(lst):\n    if len(lst) <= 1:\n        return True\n    else:\n        if lst[0] < lst[1]:\n            for i in range(1, len(lst)):\n                if lst[i] < lst[i-1]:\n                    return False\n            return True\n        else:\n            for i in range(1, len(lst)):\n                if lst[i] > lst[i-1]:\n                    return False\n            return True\n",
        "def is_monotonic(lst):\n    if len(lst) < 2:\n        return True\n    else:\n        if lst[0] < lst[1]:\n            for i in range(1, len(lst)):\n                if lst[i] < lst[i-1]:\n                    return False\n            return True\n        else:\n            for i in range(1, len(lst)):\n                if lst[i] > lst[i-1]:\n                    return False\n            return True\n",
        "def is_monotonic(lst):\n    if len(lst) <= 1:\n        return True\n    if lst[0] < lst[1]:\n        for i in range(1, len(lst)):\n            if lst[i] < lst[i-1]:\n                return False\n    elif lst[0] > lst[1]:\n        for i in range(1, len(lst)):\n            if lst[i] > lst[i-1]:\n                return False\n    return True\n",
        "def is_monotonic(lst):\n    if len(lst) <= 1:\n        return True\n    if lst[0] < lst[1]:\n        for i in range(1, len(lst)):\n            if lst[i] < lst[i-1]:\n                return False\n        return True\n    if lst[0] > lst[1]:\n        for i in range(1, len(lst)):\n            if lst[i] > lst[i-1]:\n                return False\n        return True\n    return False\n",
        "def is_monotonic(lst):\n    if len(lst) < 2:\n        return True\n    if lst[0] < lst[1]:\n        for i in range(1, len(lst)):\n            if lst[i] < lst[i-1]:\n                return False\n        return True\n    else:\n        for i in range(1, len(lst)):\n            if lst[i] > lst[i-1]:\n                return False\n        return True\n",
        "def is_monotonic(lst):\n    if len(lst) == 1:\n        return True\n    if lst[0] < lst[1]:\n        for i in range(1, len(lst)):\n            if lst[i] < lst[i-1]:\n                return False\n        return True\n    else:\n        for i in range(1, len(lst)):\n            if lst[i] > lst[i-1]:\n                return False\n        return True\n",
        "def is_monotonic(lst):\n    if len(lst) == 1:\n        return True\n    elif len(lst) == 2:\n        return lst[0] < lst[1]\n    else:\n        if lst[0] < lst[1]:\n            for i in range(1, len(lst)-1):\n                if lst[i] < lst[i+1]:\n                    continue\n                else:\n                    return False\n            return True\n        else:\n            for i in range(1, len(lst)-1):\n                if lst[i] > lst[i+1]:\n                    continue\n                else:\n                    return False\n            return True\n"
    ],
    "results": 10
},{
    "id": "2366",
    "source": "humanEval",
    "language": "python",
    "query": "Return sorted unique common elements for two lists. Common: 1, 4, 3, 34, 653, 2, 5, [5, 7, 1,. 5, 9, 121], common: 5, 3,. 2, 8, [3, 2], [2, 3]",
    "snippets": [
        "def common_elements(list1, list2):\n    common = []\n    for i in list1:\n        for j in list2:\n            if i == j:\n                common.append(i)\n    return sorted(list(set(common)))\n",
        "def common_elements(list1, list2):\n    common = []\n    for i in list1:\n        for j in list2:\n            if i == j:\n                common.append(i)\n    return common\n",
        "def common_elements(list1, list2):\n    common = []\n    for i in list1:\n        if i in list2:\n            common.append(i)\n    return sorted(set(common))\n",
        "def common_elements(list1, list2):\n    common = []\n    for i in list1:\n        if i in list2:\n            common.append(i)\n    return sorted(list(set(common)))\n",
        "def common_elements(list1, list2):\n    common = []\n    for i in list1:\n        if i in list2:\n            common.append(i)\n    return common\n",
        "def common_elements(list1, list2):\n    common = []\n    for i in list1:\n        if i in list2:\n            common.append(i)\n    return sorted(common)\n",
        "def common_elements(list1, list2):\n    return sorted(list(set(list1) & set(list2)))\n",
        "def common_elements(list1, list2):\n    return sorted(set(list1) & set(list2))\n"
    ],
    "results": 10
},{
    "id": "2367",
    "source": "humanEval",
    "language": "python",
    "query": "Return the largest prime factor of n. Assume n > 1 and is not a prime.",
    "snippets": [
        "def largest_prime_factor(n):\n    i = 2\n    while i <= n:\n        if n % i == 0:\n            n = n / i\n        else:\n            i += 1\n    return i\n",
        "def largest_prime_factor(n):\n    i = 2\n    while i < n:\n        if n % i == 0:\n            n = n / i\n        else:\n            i += 1\n    return n\n",
        "def largest_prime_factor(n):\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n\n",
        "def largest_prime_factor(n):\n    i = 2\n    while i <= n:\n        if n % i == 0:\n            n = n / i\n        else:\n            i += 1\n    return n\n"
    ],
    "results": 10
},{
    "id": "2368",
    "source": "humanEval",
    "language": "python",
    "query": "sum_to_n is a function that sums numbers from 1 to n.",
    "snippets": [
        "def sum_to_n(n):\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n-1)\n",
        "def sum_to_n(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i\n    return sum\n",
        "def sum_to_n(n):\n    \"\"\"\n    Sums numbers from 1 to n.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n - 1)\n"
    ],
    "results": 10
},{
    "id": "2369",
    "source": "humanEval",
    "language": "python",
    "query": "brackets is a string of \"(\" and \")\". return True if every opening bracket has a corresponding closing bracket.",
    "snippets": [
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_balanced(brackets):\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_balanced(brackets):\n    stack = []\n    for char in brackets:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def is_balanced(brackets):\n    stack = []\n    for i in brackets:\n        if i == \"(\":\n            stack.append(i)\n        elif i == \")\":\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "2370",
    "source": "humanEval",
    "language": "python",
    "query": "\" xs represent coefficients of a polynomial. \" xs[0] + xs [1] * x + x's[2]* x^2 + .... \" Return derivative of this polynomic in the same form.",
    "snippets": [
        "def derivative(xs):\n    if len(xs) == 1:\n        return 0\n    else:\n        return [xs[i] * i for i in range(1, len(xs))]\n",
        "def derivative(xs):\n    return [xs[i] * i for i in range(1, len(xs))]\n",
        "def derivative(xs):\n    return [x * i for i, x in enumerate(xs[1:])]\n",
        "def derivative(xs):\n    if len(xs) == 1:\n        return 0\n    else:\n        return [xs[0] * xs[1]] + derivative(xs[1:])\n",
        "def derivative(xs):\n    if len(xs) == 1:\n        return 0\n    else:\n        return xs[1] * len(xs)\n"
    ],
    "results": 10
},{
    "id": "2371",
    "source": "humanEval",
    "language": "python",
    "query": "The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows. Please write a function to efficiently compute the n-th element of the fibfibNumber sequence.",
    "snippets": [
        "def fibfib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2)\n",
        "def fibfibNumber(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibfibNumber(n-1) + fibfibNumber(n-2)\n"
    ],
    "results": 10
},{
    "id": "2372",
    "source": "humanEval",
    "language": "python",
    "query": "Vowels_count takes a string representing a word as input and returns the number of vowels in the string. Vowels in this case are 'a', 'e', 'i', 'o', 'u'",
    "snippets": [
        "def vowels_count(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for letter in word:\n        if letter in vowels:\n            count += 1\n    return count\n",
        "def Vowels_count(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for letter in word:\n        if letter in vowels:\n            count += 1\n    return count\n",
        "def Vowels_count(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    for i in word:\n        if i in vowels:\n            count += 1\n    return count\n",
        "def Vowels_count(word):\n    count = 0\n    for i in word:\n        if i in 'aeiou':\n            count += 1\n    return count\n",
        "def vowels_count(word):\n    count = 0\n    for i in word:\n        if i in 'aeiou':\n            count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "2373",
    "source": "humanEval",
    "language": "python",
    "query": "Circular shift the digits of the integer x. Return the result as a string. If shift > number of digits, return digits reversed.",
    "snippets": [
        "def shift(x, shift):\n    if shift > len(str(x)):\n        return str(x)[::-1]\n    else:\n        return str(x)[shift:] + str(x)[:shift]\n",
        "def circular_shift(x, shift):\n    if shift > len(str(x)):\n        return str(x)[::-1]\n    else:\n        return str(x)[shift:] + str(x)[:shift]\n"
    ],
    "results": 10
},{
    "id": "2374",
    "source": "humanEval",
    "language": "python",
    "query": "Task: Write a function that takes a string as input and returns the sum of the upper characters only. Examples: digitSum(\"abAB\") and digitSum (\"woArBld\")",
    "snippets": [
        "def digitSum(string):\n    sum = 0\n    for i in string:\n        if i.isupper():\n            sum += int(i)\n    return sum\n",
        "def digitSum(string):\n    sum = 0\n    for i in string:\n        if i.isupper():\n            sum += ord(i) - ord('A') + 1\n    return sum\n",
        "def digitSum(string):\n    sum = 0\n    for i in string:\n        if i.isupper():\n            sum += ord(i) - 64\n    return sum\n"
    ],
    "results": 10
},{
    "id": "2375",
    "source": "humanEval",
    "language": "python",
    "query": "In this task, you will be given a string that represents a number of apples and oranges that are distributed in a basket of fruit. Given the string, return the number of mango fruits in the basket.",
    "snippets": [
        "def count_mangoes(s):\n    return s.count('m')\n",
        "def count_mangoes(fruit_basket):\n    return fruit_basket.count('m')\n",
        "def count_mangoes(basket):\n    return basket.count('m')\n",
        "def count_mangos(basket):\n    return basket.count('m')\n"
    ],
    "results": 10
},{
    "id": "2376",
    "source": "humanEval",
    "language": "python",
    "query": "Given an array representing a branch of a tree that has non-negative integer nodes, your task is to pluck one of the nodes and return it. The plucked node should be the node with the smallest even value. If there are no even values or the given array is empty, return [].",
    "snippets": [
        "def pluck(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return []\n    if arr[0] % 2 == 0:\n        return [arr[0]] + pluck(arr[1:])\n    else:\n        return pluck(arr[1:]) + [arr[0]]\n",
        "def pluck(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return []\n    if len(arr) == 3:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1]]\n    if len(arr) == 4:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1], arr[2]]\n    if len(arr) == 5:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1], arr[2], arr[3]]\n    if len(arr) == 6:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1], arr[2], arr[3], arr[4]]\n    if len(arr) == 7:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1], arr[2], arr[3], arr[4], arr[5]]\n    if len(arr) == 8:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1], arr[2], arr[3], arr[4], arr[5], arr[6]]\n    if len(arr) == 9:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7]]\n    if len(arr) == 10:\n        if arr[0] % 2 == 0:\n            return arr\n        else:\n            return [arr[1], arr[2], arr[3], arr[4], arr[5], arr[6], arr[7], arr[8]]\n    if len(arr) == 11:\n        if arr[0] % 2 ==\n",
        "def pluck_node(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        return [arr[0] if arr[0] % 2 == 0 else arr[1]]\n    if len(arr) == 3:\n        return [arr[0] if arr[0] % 2 == 0 else arr[1]] if arr[1] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[2]]\n    if len(arr) == 4:\n        return [arr[0] if arr[0] % 2 == 0 else arr[1]] if arr[1] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[2]] if arr[2] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[3]]\n    if len(arr) == 5:\n        return [arr[0] if arr[0] % 2 == 0 else arr[1]] if arr[1] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[2]] if arr[2] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[3]] if arr[3] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[4]]\n    if len(arr) == 6:\n        return [arr[0] if arr[0] % 2 == 0 else arr[1]] if arr[1] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[2]] if arr[2] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[3]] if arr[3] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[4]] if arr[4] % 2 == 0 else [arr[0] if arr[0] % 2 == 0 else arr[5]]\n    if len(arr) == 7:\n        return [arr[0]\n",
        "def pluck(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 3:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 4:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 5:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 6:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 7:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 8:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 9:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 10:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 11:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 12:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 13:\n        if arr[0] % 2 == 0:\n            return arr\n",
        "def pluck(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr\n    if arr[0] % 2 == 0:\n        return [arr[0]]\n    if arr[-1] % 2 == 0:\n        return [arr[-1]]\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0:\n            return [arr[i]]\n    return []\n",
        "def pluck(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        return [arr[0]] if arr[0] % 2 == 0 else [arr[1]]\n    if len(arr) == 3:\n        return [arr[0]] if arr[0] % 2 == 0 else [arr[1]] if arr[1] % 2 == 0 else [arr[2]]\n    if len(arr) == 4:\n        return [arr[0]] if arr[0] % 2 == 0 else [arr[1]] if arr[1] % 2 == 0 else [arr[2]] if arr[2] % 2 == 0 else [arr[3]]\n    if len(arr) == 5:\n        return [arr[0]] if arr[0] % 2 == 0 else [arr[1]] if arr[1] % 2 == 0 else [arr[2]] if arr[2] % 2 == 0 else [arr[3]] if arr[3] % 2 == 0 else [arr[4]]\n    if len(arr) == 6:\n        return [arr[0]] if arr[0] % 2 == 0 else [arr[1]] if arr[1] % 2 == 0 else [arr[2]] if arr[2] % 2 == 0 else [arr[3]] if arr[3] % 2 == 0 else [arr[4]] if arr[4] % 2 == 0 else [arr[5]]\n    if len(arr) == 7:\n        return [arr[0]] if arr[0] % 2 == 0 else [arr[1]] if arr[1] % 2 == 0 else [arr[2]] if arr[2] % 2 == 0 else [arr[3]] if arr[3] % 2 == 0 else [arr[4]] if arr[4] % 2 == 0 else [arr[5]] if arr[5] % 2 == 0 else [arr[6]]\n    if len(arr) == 8:\n        return [arr[0]] if arr[0] % 2 == 0 else [arr[1]] if arr[1] % 2 == 0 else [arr[2\n",
        "def pluck(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 3:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 4:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 5:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 6:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 7:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 8:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 9:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 10:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 11:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 12:\n        if arr[0] % 2 == 0:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) == 13:\n        if arr[0] % 2 == 0:\n",
        "def pluck_node(arr):\n    if not arr:\n        return []\n    min_even = arr[0]\n    for i in range(1, len(arr)):\n        if arr[i] % 2 == 0 and arr[i] < min_even:\n            min_even = arr[i]\n    return [min_even]\n",
        "def pluck(arr):\n    if not arr:\n        return []\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return arr[0] if arr[0] % 2 == 0 else arr[1]\n    if len(arr) == 3:\n        return arr[0] if arr[0] % 2 == 0 else arr[1] if arr[1] % 2 == 0 else arr[2]\n    if len(arr) == 4:\n        return arr[0] if arr[0] % 2 == 0 else arr[1] if arr[1] % 2 == 0 else arr[2] if arr[2] % 2 == 0 else arr[3]\n    if len(arr) == 5:\n        return arr[0] if arr[0] % 2 == 0 else arr[1] if arr[1] % 2 == 0 else arr[2] if arr[2] % 2 == 0 else arr[3] if arr[3] % 2 == 0 else arr[4]\n    if len(arr) == 6:\n        return arr[0] if arr[0] % 2 == 0 else arr[1] if arr[1] % 2 == 0 else arr[2] if arr[2] % 2 == 0 else arr[3] if arr[3] % 2 == 0 else arr[4] if arr[4] % 2 == 0 else arr[5]\n    if len(arr) == 7:\n        return arr[0] if arr[0] % 2 == 0 else arr[1] if arr[1] % 2 == 0 else arr[2] if arr[2] % 2 == 0 else arr[3] if arr[3] % 2 == 0 else arr[4] if arr[4] % 2 == 0 else arr[5] if arr[5] % 2 == 0 else arr[6]\n    if len(arr) == 8:\n        return arr[0] if arr[0] % 2 == 0 else arr[1] if arr[1] % 2 == 0 else arr[2] if arr[2] % 2 == 0 else arr[3] if arr[3] % 2 == 0 else arr[\n"
    ],
    "results": 10
},{
    "id": "2377",
    "source": "humanEval",
    "language": "python",
    "query": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than    zero. If no such a value exist, return -1.",
    "snippets": [
        "def find_greatest(arr):\n    for i in range(len(arr)):\n        if arr[i] > 0:\n            return arr[i]\n    return -1\n",
        "def find_greatest(arr):\n    if len(arr) == 0:\n        return -1\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        if arr[0] > arr[1]:\n            return arr[0]\n        else:\n            return arr[1]\n    if len(arr) > 2:\n        if arr[0] > arr[1]:\n            return arr[0]\n        else:\n            return arr[1]\n        for i in range(2, len(arr)):\n            if arr[i] > arr[i-1] and arr[i] > arr[i+1]:\n                return arr[i]\n            else:\n                return -1\n    return -1\n",
        "def find_greatest(lst):\n    for i in lst:\n        if i > 0:\n            return i\n    return -1\n",
        "def greatest_integer(list):\n    if list == []:\n        return -1\n    else:\n        list.sort()\n        for i in list:\n            if i > 0:\n                return i\n        return -1\n",
        "def find_greatest(arr):\n    if arr == []:\n        return -1\n    for i in arr:\n        if i > 0:\n            return i\n    return -1\n",
        "def find_greatest(list):\n    if list == []:\n        return -1\n    else:\n        for i in list:\n            if i > 0:\n                return i\n        return -1\n",
        "def find_greatest(numbers):\n    for i in numbers:\n        if i > 0:\n            return i\n    return -1\n",
        "def find_greatest(list):\n    if list == []:\n        return -1\n    else:\n        list.sort()\n        return list[-1]\n",
        "def greatest_integer(list):\n    if list == []:\n        return -1\n    else:\n        list.sort()\n        return list[-1]\n",
        "def next_greatest_value(lst):\n    if lst == []:\n        return -1\n    lst.sort()\n    for i in range(len(lst)):\n        if lst[i] > 0:\n            return lst[i]\n    return -1\n"
    ],
    "results": 10
},{
    "id": "2378",
    "source": "humanEval",
    "language": "python",
    "query": "Given list of integers, return list in strange order. Examples: 1, 2, 3, 4, 5, 5.",
    "snippets": [
        "def strange_order(lst):\n    lst.sort()\n    lst.reverse()\n    return lst\n",
        "def strange_order(list_of_ints):\n    list_of_ints.sort()\n    list_of_ints.reverse()\n    return list_of_ints\n",
        "def strange_order(list):\n    list.sort()\n    list.reverse()\n    return list\n",
        "def strange_order(list_of_ints):\n    return list_of_ints[::-1]\n",
        "def strange_order(lst):\n    return lst[::-1]\n",
        "def strange_order(list):\n    return list[::-1]\n",
        "def strange_order(list_of_ints):\n    return list_of_ints[::-2]\n"
    ],
    "results": 10
},{
    "id": "2379",
    "source": "humanEval",
    "language": "python",
    "query": "Three sides make a valid triangle when the sum of any two sides is greater than the third side. Return the area of the triangle rounded to 2 decimal points if the three sides form avalid triangle.",
    "snippets": [
        "def triangle(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return round((a + b + c) / 2, 2)\n    else:\n        return 0\n",
        "def triangle(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return round((a + b + c) / 2, 2)\n    else:\n        return \"Not a triangle\"\n",
        "def valid_triangle(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return round((a + b + c) / 2, 2)\n    else:\n        return 0.00\n",
        "def valid_triangle(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return round((a * b * c) / 2, 2)\n    else:\n        return \"Not a valid triangle\"\n",
        "def triangle(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return round(0.5 * (a + b + c), 2)\n    else:\n        return 0\n",
        "def triangle(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return round(a * b * c / 2, 2)\n    else:\n        return \"Invalid\"\n",
        "def triangle(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return round((a * b * c) / 2, 2)\n    else:\n        return 0\n"
    ],
    "results": 10
},{
    "id": "2380",
    "source": "humanEval",
    "language": "python",
    "query": "The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight. Write a function that returns True if the objectq will fly, and False otherwise.",
    "snippets": [
        "def will_fly(q):\n    if q == q[::-1]:\n        return sum(q) <= max(q)\n    else:\n        return False\n",
        "def will_fly(q):\n    if is_palindrome(q):\n        return sum(q) <= max_weight(q)\n    else:\n        return False\n",
        "def will_fly(q):\n    if is_palindrome(q):\n        if sum(q) <= max_weight:\n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def will_fly(q, max_weight):\n    if q == q[::-1]:\n        return sum(q) <= max_weight\n    return False\n"
    ],
    "results": 10
},{
    "id": "2381",
    "source": "humanEval",
    "language": "python",
    "query": "A palindromic array is an array that is read the same backwards and forwards. In one change, you can change one element to any other element.",
    "snippets": [
        "def palindrome(arr):\n    # Write your code here.\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if arr[i] == arr[j]:\n                arr[i] = arr[j] = '*'\n    return arr\n",
        "def palindrome(arr):\n    # Write your code here.\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            arr[i], arr[j] = arr[j], arr[i]\n            if arr == arr[::-1]:\n                return True\n            arr[i], arr[j] = arr[j], arr[i]\n    return False\n",
        "def palindrome(arr):\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j and arr[i] == arr[j]:\n                arr[i] = arr[i] + 1\n                arr[j] = arr[j] - 1\n                return arr\n    return arr\n",
        "def palindrome(arr):\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j:\n                arr[i], arr[j] = arr[j], arr[i]\n                if arr == arr[::-1]:\n                    return True\n                else:\n                    arr[i], arr[j] = arr[j], arr[i]\n    return False\n",
        "def palindrome(arr):\n    # Write your code here.\n    for i in range(len(arr)):\n        for j in range(len(arr)):\n            if i != j and arr[i] == arr[j]:\n                arr[i] = arr[j] = '*'\n    return ''.join(arr)\n",
        "def palindrome(arr):\n    # Write your code here.\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            if i != j and arr[i] == arr[j]:\n                arr[i] = arr[n-1]\n                arr[n-1] = arr[j]\n                return True\n    return False\n",
        "def palindrome(arr):\n    # Write your code here.\n    n = len(arr)\n    for i in range(n):\n        for j in range(n):\n            if i != j and arr[i] == arr[j]:\n                arr[i] = arr[n - 1 - j]\n                arr[n - 1 - j] = arr[i]\n    return arr\n",
        "def palindrome(arr):\n    # Write your code here.\n    # arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    # arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    # arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204\n"
    ],
    "results": 10
},{
    "id": "2382",
    "source": "humanEval",
    "language": "python",
    "query": "Write a function that accepts two lists of strings and returns the list that has the total number of chars in the all strings of the list less than the other list.",
    "snippets": [
        "def list_diff(list1, list2):\n    list1_total = 0\n    list2_total = 0\n    for i in list1:\n        list1_total += len(i)\n    for i in list2:\n        list2_total += len(i)\n    if list1_total > list2_total:\n        return list2\n    else:\n        return list1\n",
        "def char_difference(list1, list2):\n    list1_total = 0\n    list2_total = 0\n    for i in list1:\n        list1_total += len(i)\n    for i in list2:\n        list2_total += len(i)\n    if list1_total > list2_total:\n        return list2\n    else:\n        return list1\n",
        "def char_count(list1, list2):\n    list1_total = 0\n    list2_total = 0\n    for i in list1:\n        list1_total += len(i)\n    for i in list2:\n        list2_total += len(i)\n    if list1_total > list2_total:\n        return list2\n    else:\n        return list1\n",
        "def list_difference(list1, list2):\n    list1_total = 0\n    list2_total = 0\n    for i in list1:\n        list1_total += len(i)\n    for i in list2:\n        list2_total += len(i)\n    if list1_total > list2_total:\n        return list1\n    else:\n        return list2\n",
        "def list_difference(list1, list2):\n    list1_total = 0\n    list2_total = 0\n    for i in list1:\n        list1_total += len(i)\n    for i in list2:\n        list2_total += len(i)\n    if list1_total > list2_total:\n        return list2\n    else:\n        return list1\n",
        "def char_diff(list1, list2):\n    list1_total = 0\n    list2_total = 0\n    for i in list1:\n        list1_total += len(i)\n    for i in list2:\n        list2_total += len(i)\n    if list1_total > list2_total:\n        return list2\n    else:\n        return list1\n",
        "def list_diff(list1, list2):\n    list1_len = 0\n    list2_len = 0\n    for i in list1:\n        list1_len += len(i)\n    for i in list2:\n        list2_len += len(i)\n    if list1_len > list2_len:\n        return list2\n    else:\n        return list1\n"
    ],
    "results": 10
},{
    "id": "2383",
    "source": "humanEval",
    "language": "python",
    "query": "Write a function that returns true if the given number is the multiplication of 3 prime numbers and false otherwise. Example: is_multiply_prime(30) == True.",
    "snippets": [
        "def is_multiply_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n",
        "def is_multiply_prime(num):\n    if num < 3:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n",
        "def is_multiply_prime(num):\n    if num == 1:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n",
        "def is_multiply_prime(num):\n    if num < 2:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    for i in range(3, int(num ** 0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    return True\n",
        "def is_multiply_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n",
        "def is_multiply_prime(num):\n    if num < 2:\n        return False\n    elif num == 2:\n        return True\n    elif num % 2 == 0:\n        return False\n    else:\n        for i in range(3, num, 2):\n            if num % i == 0:\n                return False\n        return True\n",
        "def is_multiply_prime(num):\n    if num % 3 == 0:\n        return False\n    else:\n        for i in range(2, num):\n            if num % i == 0:\n                return False\n        return True\n"
    ],
    "results": 10
},{
    "id": "2384",
    "source": "humanEval",
    "language": "python",
    "query": "A simple power is a power of n if n**int=x and false in other cases. For example: is_simple_power(1, 4) = true.",
    "snippets": [
        "def is_simple_power(x, n):\n    if x == n**int(n):\n        return True\n    else:\n        return False\n",
        "def is_simple_power(n, x):\n    if n**int(x) == x:\n        return True\n    else:\n        return False\n",
        "def is_simple_power(x, n):\n    if x == n**int(n**0.5):\n        return True\n    else:\n        return False\n",
        "def is_simple_power(x, n):\n    if n**int(x) == x:\n        return True\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "2385",
    "source": "humanEval",
    "language": "python",
    "query": "Write a function that takes an integer a and returns True if this ingeger is a cube of some integer number. Note: you may assume the input is always valid.",
    "snippets": [
        "def is_cube(a):\n    for i in range(1, a+1):\n        if i**3 == a:\n            return True\n    return False\n",
        "def is_cube(a):\n    for i in range(1, a):\n        if i ** 3 == a:\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "2386",
    "source": "humanEval",
    "language": "python",
    "query": "Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F. You may assume the input is always correct or empty string. symbols A,B,C,D,E,F are always uppercase.",
    "snippets": [
        "def hexadecimal_to_decimal(hexadecimal):\n    decimal = 0\n    for i in range(len(hexadecimal)):\n        if hexadecimal[i] == 'A':\n            decimal += 10 * (16 ** (len(hexadecimal) - i - 1))\n        elif hexadecimal[i] == 'B':\n            decimal += 11 * (16 ** (len(hexadecimal) - i - 1))\n        elif hexadecimal[i] == 'C':\n            decimal += 12 * (16 ** (len(hexadecimal) - i - 1))\n        elif hexadecimal[i] == 'D':\n            decimal += 13 * (16 ** (len(hexadecimal) - i - 1))\n        elif hexadecimal[i] == 'E':\n            decimal += 14 * (16 ** (len(hexadecimal) - i - 1))\n        elif hexadecimal[i] == 'F':\n            decimal += 15 * (16 ** (len(hexadecimal) - i - 1))\n        else:\n            decimal += int(hexadecimal[i]) * (16 ** (len(hexadecimal) - i - 1))\n    return decimal\n",
        "def hex_to_dec(s):\n    if s == '':\n        return 0\n    else:\n        if s[0] == 'A':\n            return 10 + hex_to_dec(s[1:])\n        elif s[0] == 'B':\n            return 11 + hex_to_dec(s[1:])\n        elif s[0] == 'C':\n            return 12 + hex_to_dec(s[1:])\n        elif s[0] == 'D':\n            return 13 + hex_to_dec(s[1:])\n        elif s[0] == 'E':\n            return 14 + hex_to_dec(s[1:])\n        elif s[0] == 'F':\n            return 15 + hex_to_dec(s[1:])\n        else:\n            return int(s[0]) + hex_to_dec(s[1:])\n",
        "def hex_to_dec(s):\n    if s == '':\n        return 0\n    else:\n        return 16 * hex_to_dec(s[:-1]) + hex_to_dec_digit(s[-1])\n",
        "def hex_to_dec(s):\n    if s == '':\n        return 0\n    else:\n        return hex_to_dec(s[:-1]) * 16 + hex_to_dec(s[-1])\n",
        "def hex_to_decimal(hex_str):\n    hex_str = hex_str.upper()\n    decimal = 0\n    for i in range(len(hex_str)):\n        if hex_str[i] == 'A':\n            decimal += 10 * (16 ** (len(hex_str) - i - 1))\n        elif hex_str[i] == 'B':\n            decimal += 11 * (16 ** (len(hex_str) - i - 1))\n        elif hex_str[i] == 'C':\n            decimal += 12 * (16 ** (len(hex_str) - i - 1))\n        elif hex_str[i] == 'D':\n            decimal += 13 * (16 ** (len(hex_str) - i - 1))\n        elif hex_str[i] == 'E':\n            decimal += 14 * (16 ** (len(hex_str) - i - 1))\n        elif hex_str[i] == 'F':\n            decimal += 15 * (16 ** (len(hex_str) - i - 1))\n        else:\n            decimal += int(hex_str[i]) * (16 ** (len(hex_str) - i - 1))\n    return decimal\n",
        "def hex_to_dec(hex_str):\n    if hex_str == '':\n        return 0\n    else:\n        return 16 * hex_to_dec(hex_str[:-1]) + hex_to_dec_helper(hex_str[-1])\n",
        "def hex_to_dec(hex_str):\n    if hex_str == '':\n        return 0\n    else:\n        return 16 * hex_to_dec(hex_str[:-1]) + hex_to_dec_digit(hex_str[-1])\n",
        "def hex_to_dec(hex_str):\n    if not hex_str:\n        return 0\n    else:\n        return 16 * hex_to_dec(hex_str[:-1]) + hex_to_dec_helper(hex_str[-1])\n",
        "def hex_to_dec(hex_str):\n    if not hex_str:\n        return 0\n    else:\n        return int(hex_str, 16)\n"
    ],
    "results": 10
},{
    "id": "2387",
    "source": "humanEval",
    "language": "python",
    "query": "You will be given a number in decimal form and your task is to convert it to binary format. The function should return a string, with each character representing a binary number. Each character in the string will be '0' or '1'",
    "snippets": [
        "def decimal_to_binary(decimal_number):\n    binary_number = ''\n    while decimal_number > 0:\n        binary_number = str(decimal_number % 2) + binary_number\n        decimal_number = decimal_number // 2\n    return binary_number\n",
        "def decimal_to_binary(decimal):\n    binary = \"\"\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary\n",
        "def decimal_to_binary(decimal):\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary\n",
        "def decimal_to_binary(num):\n    return bin(num)[2:]\n",
        "def decimal_to_binary(n):\n    return bin(n)[2:]\n"
    ],
    "results": 10
},{
    "id": "2388",
    "source": "humanEval",
    "language": "python",
    "query": "A string is happy if its length is at least 3 and every 3 consecutive letters are distinct. For example: is_happy(a)    is_ happy(aa) => False. The task is to check if the string isHappy.",
    "snippets": [
        "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(0, len(s) - 2, 3):\n        if s[i] == s[i + 1] and s[i] == s[i + 2]:\n            return False\n    return True\n",
        "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(0, len(s) - 2, 3):\n        if s[i] == s[i + 1] == s[i + 2]:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2389",
    "source": "humanEval",
    "language": "python",
    "query": "The teacher has been making her own algorithm for grading. She has given you a list of GPAs for some students and you have to write a function that can output a list. of letter grades.",
    "snippets": [
        "def letter_grade(gpa):\n    if gpa >= 4.0:\n        return \"A\"\n    elif gpa >= 3.0:\n        return \"B\"\n    elif gpa >= 2.0:\n        return \"C\"\n    elif gpa >= 1.0:\n        return \"D\"\n    else:\n        return \"F\"\n",
        "def grade_converter(gpa):\n    if gpa >= 4.0:\n        return \"A\"\n    elif gpa >= 3.0:\n        return \"B\"\n    elif gpa >= 2.0:\n        return \"C\"\n    elif gpa >= 1.0:\n        return \"D\"\n    else:\n        return \"F\"\n",
        "def letter_grade(gpa):\n    if gpa >= 3.5:\n        return \"A\"\n    elif gpa >= 3.0:\n        return \"B\"\n    elif gpa >= 2.5:\n        return \"C\"\n    elif gpa >= 2.0:\n        return \"D\"\n    else:\n        return \"F\"\n",
        "def grade_calc(gpa):\n    if gpa >= 4.0:\n        return \"A\"\n    elif gpa >= 3.0:\n        return \"B\"\n    elif gpa >= 2.0:\n        return \"C\"\n    elif gpa >= 1.0:\n        return \"D\"\n    else:\n        return \"F\"\n",
        "def grade_calc(gpa):\n    if gpa >= 3.5:\n        return \"A\"\n    elif gpa >= 3.0:\n        return \"B\"\n    elif gpa >= 2.5:\n        return \"C\"\n    elif gpa >= 2.0:\n        return \"D\"\n    else:\n        return \"F\"\n",
        "def grade_calc(gpa):\n    if gpa >= 3.0:\n        return \"A\"\n    elif gpa >= 2.0:\n        return \"B\"\n    elif gpa >= 1.0:\n        return \"C\"\n    elif gpa >= 0.0:\n        return \"D\"\n    else:\n        return \"F\"\n"
    ],
    "results": 10
},{
    "id": "2390",
    "source": "humanEval",
    "language": "python",
    "query": "Prime is a function that takes a string and returns True if the string's length is a prime number or False otherwise. Prime_length('Hello') returns True, prime_length ('abcdcba') returns False.",
    "snippets": [
        "def prime_length(string):\n    if len(string) == 1:\n        return False\n    for i in range(2, len(string)):\n        if len(string) % i == 0:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2391",
    "source": "humanEval",
    "language": "python",
    "query": "Given a positive integer n, return the count of the numbers of n-digit integers that start or end with 1.",
    "snippets": [
        "def count_digits(n):\n    if n < 10:\n        return 1\n    else:\n        return count_digits(n // 10) + 1\n",
        "def count_digits(n):\n    count = 0\n    for i in range(1, n+1):\n        if i % 10 == 1:\n            count += 1\n    return count\n",
        "def count_ones(n):\n    count = 0\n    for i in range(1, n+1):\n        if i % 10 == 1:\n            count += 1\n    return count\n",
        "def count_digits(n):\n    if n == 0:\n        return 0\n    return count_digits(n // 10) + 1\n"
    ],
    "results": 10
},{
    "id": "2392",
    "source": "humanEval",
    "language": "python",
    "query": "Given a positive integer N, return the total sum of its digits in binary. For N = 1000, the sum of digits will be 1 the output should be \"1\"",
    "snippets": [
        "def sum_digits(n):\n    return sum(int(i) for i in str(n))\n",
        "def sum_digits(N):\n    return sum(int(digit) for digit in bin(N)[2:])\n",
        "def sum_digits(n):\n    return sum(int(digit) for digit in bin(n)[2:])\n",
        "def sum_binary(n):\n    return sum(int(digit) for digit in bin(n)[2:])\n",
        "def sum_digits(N):\n    return sum(int(i) for i in str(N))\n",
        "def sum_digits(N):\n    return sum(int(i) for i in str(bin(N))[2:])\n",
        "def sum_digits(N):\n    return sum([int(i) for i in str(N)])\n",
        "def sum_of_digits(N):\n    return sum(int(i) for i in str(N))\n"
    ],
    "results": 10
},{
    "id": "2393",
    "source": "humanEval",
    "language": "python",
    "query": "Given a non-empty list of integers lst. add the even elements that are at odd indices. Examples: add([4, 2, 6, 7]) ==> 2.",
    "snippets": [
        "def add(lst):\n    sum = 0\n    for i in range(1, len(lst), 2):\n        sum += lst[i]\n    return sum\n"
    ],
    "results": 10
},{
    "id": "2394",
    "source": "humanEval",
    "language": "python",
    "query": "An ordered version of string is a string where all words (separated by space) are replaced by a new word. All the characters are arranged in ascending order based on ascii value.",
    "snippets": [
        "def ordered_string(string):\n    string = string.split()\n    string = sorted(string)\n    string = ' '.join(string)\n    return string\n",
        "def ordered_string(string):\n    return ' '.join(sorted(string.split(), key=lambda x: ord(x[0])))\n",
        "def ordered_string(str):\n    return ' '.join(sorted(str.split(), key=lambda x: ord(x[0])))\n",
        "def ordered_string(s):\n    return ' '.join(sorted(s.split()))\n",
        "def ordered_string(string):\n    return ' '.join(sorted(string.split()))\n"
    ],
    "results": 10
},{
    "id": "2395",
    "source": "humanEval",
    "language": "python",
    "query": "You are given a 2 dimensional data, as a nested lists, which is similar to matrix, however, unlike matrices, each row may contain a different number of columns. Sort coordinates initially by rows in ascending order.",
    "snippets": [
        "def sort_by_row(data):\n    return sorted(data, key=lambda x: x[0])\n"
    ],
    "results": 10
},{
    "id": "2396",
    "source": "humanEval",
    "language": "python",
    "query": "Given an array of non-negative integers, return a copy of the given array after sorting. You will sort it in ascending order if the sum( first index value, last index value) is odd, or in descending order if it is even.",
    "snippets": [
        "def sort_array(arr):\n    if sum(arr[0], arr[-1]) % 2 == 0:\n        arr.sort()\n    else:\n        arr.sort(reverse=True)\n    return arr\n",
        "def sort_array(arr):\n    if sum(arr[0], arr[-1]) % 2 == 0:\n        return sorted(arr)\n    else:\n        return sorted(arr, reverse=True)\n",
        "def sort_array(array):\n    if sum(array[0], array[-1]) % 2 == 0:\n        return sorted(array)\n    else:\n        return sorted(array, reverse=True)\n"
    ],
    "results": 10
},{
    "id": "2397",
    "source": "humanEval",
    "language": "python",
    "query": "The alphabet should be rotated in a manner such that the letters    shift down by two multiplied to two places. For example: encrypt('hi') returns 'lm' encrypt('asdfghjkl) returns 'ewhjklnop'",
    "snippets": [
        "def encrypt(text):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for letter in text:\n        if letter in alphabet:\n            encrypted += alphabet[(alphabet.index(letter) + 2) % 26]\n        else:\n            encrypted += letter\n    return encrypted\n",
        "def encrypt(text):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for letter in text:\n        if letter in alphabet:\n            index = alphabet.index(letter)\n            encrypted += alphabet[(index + 2) % 26]\n        else:\n            encrypted += letter\n    return encrypted\n",
        "def encrypt(text):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted = ''\n    for letter in text:\n        if letter in alphabet:\n            index = alphabet.index(letter)\n            encrypted += alphabet[index + 2]\n        else:\n            encrypted += letter\n    return encrypted\n",
        "def encrypt(text):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n    for letter in text:\n        if letter in alphabet:\n            index = alphabet.index(letter)\n            encrypted_text += alphabet[index + 2]\n        else:\n            encrypted_text += letter\n    return encrypted_text\n"
    ],
    "results": 10
},{
    "id": "2398",
    "source": "humanEval",
    "language": "python",
    "query": "Next_smallest is a function that returns the 2nd smallest element of the list. Return None if there is no such element.",
    "snippets": [
        "def Next_smallest(list):\n    if len(list) == 1:\n        return None\n    if len(list) == 2:\n        return list[1]\n    if len(list) == 3:\n        if list[1] > list[2]:\n            return list[2]\n        else:\n            return list[1]\n    if len(list) == 4:\n        if list[1] > list[2]:\n            if list[2] > list[3]:\n                return list[3]\n            else:\n                return list[2]\n        else:\n            if list[1] > list[3]:\n                return list[3]\n            else:\n                return list[1]\n    if len(list) == 5:\n        if list[1] > list[2]:\n            if list[2] > list[3]:\n                if list[3] > list[4]:\n                    return list[4]\n                else:\n                    return list[3]\n            else:\n                if list[3] > list[4]:\n                    return list[4]\n                else:\n                    return list[3]\n        else:\n            if list[1] > list[3]:\n                if list[3] > list[4]:\n                    return list[4]\n                else:\n                    return list[3]\n            else:\n                if list[1] > list[4]:\n                    return list[4]\n                else:\n                    return list[1]\n    if len(list) == 6:\n        if list[1] > list[2]:\n            if list[2] > list[3]:\n                if list[3] > list[4]:\n                    if list[4] > list[5]:\n                        return list[5]\n                    else:\n                        return list[4]\n                else:\n                    if list[4] > list[5]:\n                        return list[5]\n                    else:\n                        return list[4]\n            else:\n                if list[3] > list[4]:\n                    if list[4] > list[5]:\n                        return list[5]\n                    else:\n                        return list[4]\n",
        "def Next_smallest(list):\n    if len(list) == 1:\n        return None\n    if len(list) == 2:\n        return list[1]\n    if len(list) == 3:\n        if list[0] < list[1] < list[2]:\n            return list[1]\n        if list[0] < list[2] < list[1]:\n            return list[2]\n        if list[1] < list[0] < list[2]:\n            return list[0]\n        if list[1] < list[2] < list[0]:\n            return list[2]\n        if list[2] < list[0] < list[1]:\n            return list[0]\n        if list[2] < list[1] < list[0]:\n            return list[1]\n    if len(list) > 3:\n        if list[0] < list[1] < list[2] < list[3]:\n            return list[1]\n        if list[0] < list[2] < list[3] < list[1]:\n            return list[2]\n        if list[0] < list[3] < list[1] < list[2]:\n            return list[3]\n        if list[1] < list[0] < list[2] < list[3]:\n            return list[0]\n        if list[1] < list[2] < list[3] < list[0]:\n            return list[2]\n        if list[1] < list[3] < list[0] < list[2]:\n            return list[3]\n        if list[2] < list[0] < list[3] < list[1]:\n            return list[0]\n        if list[2] < list[1] < list[3] < list[0]:\n            return list[1]\n        if list[2] < list[3] < list[1] < list[0]:\n            return list[3]\n        if list[3] < list[0] < list[1] < list[2]:\n            return list[0]\n        if list[3]\n",
        "def Next_smallest(list):\n    if len(list) == 1:\n        return None\n    if len(list) == 2:\n        return list[1]\n    if len(list) == 3:\n        if list[0] < list[1] < list[2]:\n            return list[1]\n        if list[0] < list[2] < list[1]:\n            return list[2]\n        if list[1] < list[0] < list[2]:\n            return list[0]\n        if list[1] < list[2] < list[0]:\n            return list[2]\n        if list[2] < list[0] < list[1]:\n            return list[0]\n        if list[2] < list[1] < list[0]:\n            return list[1]\n    if len(list) > 3:\n        for i in range(len(list)):\n            if list[i] > list[i+1]:\n                return list[i+1]\n    return None\n",
        "def Next_smallest(list):\n    if len(list) == 1:\n        return None\n    if len(list) == 2:\n        return list[1]\n    if len(list) == 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 4:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 5:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 6:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 7:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 8:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 9:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 10:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 11:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 12:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 13:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) == 14:\n        if list[0] > list[1\n",
        "def next_smallest(lst):\n    if len(lst) == 1:\n        return None\n    if len(lst) == 2:\n        return lst[1]\n    if len(lst) == 3:\n        if lst[0] < lst[1] and lst[1] < lst[2]:\n            return lst[1]\n        elif lst[0] < lst[1] and lst[1] > lst[2]:\n            return lst[2]\n        elif lst[0] > lst[1] and lst[1] < lst[2]:\n            return lst[0]\n        elif lst[0] > lst[1] and lst[1] > lst[2]:\n            return lst[1]\n        elif lst[0] == lst[1] and lst[1] < lst[2]:\n            return lst[2]\n        elif lst[0] == lst[1] and lst[1] > lst[2]:\n            return lst[0]\n        elif lst[0] == lst[2] and lst[2] < lst[1]:\n            return lst[1]\n        elif lst[0] == lst[2] and lst[2] > lst[1]:\n            return lst[0]\n    if len(lst) > 3:\n        if lst[0] < lst[1] and lst[1] < lst[2] and lst[2] < lst[3]:\n            return lst[2]\n        elif lst[0] < lst[1] and lst[1] < lst[2] and lst[2] > lst[3]:\n            return lst[3]\n        elif lst[0] < lst[1] and lst[1] > lst[2] and lst[2] < lst[3]:\n            return lst[1]\n        elif lst[0] < lst[1] and\n",
        "def Next_smallest(list):\n    if len(list) < 2:\n        return None\n    if len(list) == 2:\n        return list[1]\n    if len(list) == 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1]:\n            return list[1]\n        else:\n            return list[2]\n    if len(list) > 3:\n        if list[0] > list[1\n",
        "def Next_smallest(list):\n    if len(list) == 1:\n        return None\n    elif len(list) == 2:\n        return list[1]\n    else:\n        list.sort()\n        if list[1] == list[-1]:\n            return None\n        else:\n            return list[1]\n",
        "def Next_smallest(list):\n    if len(list) == 1:\n        return None\n    elif len(list) == 2:\n        return list[1]\n    else:\n        list.sort()\n        if list[1] == list[2]:\n            return None\n        else:\n            return list[1]\n",
        "def Next_smallest(L):\n    if len(L) < 2:\n        return None\n    if len(L) == 2:\n        return L[1]\n    if len(L) == 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1]:\n            return L[1]\n        else:\n            return L[2]\n    if len(L) > 3:\n        if L[0] > L[1\n",
        "def Next_smallest(list):\n    if len(list) == 0:\n        return None\n    if len(list) == 1:\n        return None\n    if len(list) == 2:\n        return list[1]\n    if len(list) == 3:\n        return list[2]\n    if len(list) == 4:\n        return list[3]\n    if len(list) == 5:\n        return list[4]\n    if len(list) == 6:\n        return list[5]\n    if len(list) == 7:\n        return list[6]\n    if len(list) == 8:\n        return list[7]\n    if len(list) == 9:\n        return list[8]\n    if len(list) == 10:\n        return list[9]\n    if len(list) == 11:\n        return list[10]\n    if len(list) == 12:\n        return list[11]\n    if len(list) == 13:\n        return list[12]\n    if len(list) == 14:\n        return list[13]\n    if len(list) == 15:\n        return list[14]\n    if len(list) == 16:\n        return list[15]\n    if len(list) == 17:\n        return list[16]\n    if len(list) == 18:\n        return list[17]\n    if len(list) == 19:\n        return list[18]\n    if len(list) == 20:\n        return list[19]\n    if len(list) == 21:\n        return list[20]\n    if len(list) == 22:\n        return list[21]\n    if len(list) == 23:\n        return list[22]\n    if len(list) == 24:\n        return list[23]\n    if len(list) == 25:\n        return list[24]\n    if len(list) == 26:\n        return list[25]\n    if len(list) == 27:\n        return list[26]\n    if len(list) == 28:\n        return list[27]\n    if len(\n"
    ],
    "results": 10
},{
    "id": "2399",
    "source": "humanEval",
    "language": "python",
    "query": "A boredom is a sentence that starts with the word \"I\" Sentences are delimited by '.', '?' or '!'.",
    "snippets": [
        "def boredom(sentence):\n    if sentence.startswith('I'):\n        if sentence.endswith('.') or sentence.endswith('?') or sentence.endswith('!'):\n            return 1\n        else:\n            return 0\n    else:\n        return 0\n",
        "def boredom(sentence):\n    if sentence.startswith('I'):\n        if sentence.endswith('.') or sentence.endswith('?') or sentence.endswith('!'):\n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def boredom(text):\n    if text.startswith('I'):\n        if text.endswith('.') or text.endswith('?') or text.endswith('!'):\n            return True\n    return False\n",
        "def boredom(sentence):\n    if sentence.startswith('I'):\n        if sentence.endswith('.') or sentence.endswith('?') or sentence.endswith('!'):\n            return 0\n        else:\n            return 1\n    else:\n        return 1\n",
        "def boredom(text):\n    if text.startswith('I'):\n        if text.endswith('.') or text.endswith('?') or text.endswith('!'):\n            return True\n        else:\n            return False\n    else:\n        return False\n",
        "def boredom(sentence):\n    if sentence.startswith(\"I\"):\n        if sentence.endswith(\".\"):\n            return 0\n        elif sentence.endswith(\"?\"):\n            return 1\n        elif sentence.endswith(\"!\"):\n            return 2\n        else:\n            return 3\n    else:\n        return 4\n",
        "def boredom(text):\n    if text.startswith(\"I\"):\n        return 0\n    else:\n        return 1\n"
    ],
    "results": 10
},{
    "id": "2400",
    "source": "humanEval",
    "language": "python",
    "query": "create a function that takes 3 numbers. Returns true if one of the numbers is equal to the sum of the other two. Returns false in any other cases.",
    "snippets": [
        "def sum_to_three(a, b, c):\n    if a == b + c or b == a + c or c == a + b:\n        return True\n    else:\n        return False\n",
        "def sum_to(a, b, c):\n    if a == b + c or b == a + c or c == a + b:\n        return True\n    else:\n        return False\n",
        "def sum_to_ten(a, b, c):\n    if a == b + c or b == a + c or c == a + b:\n        return True\n    else:\n        return False\n",
        "def sum_check(num1, num2, num3):\n    if num1 == num2 + num3 or num2 == num1 + num3 or num3 == num1 + num2:\n        return True\n    else:\n        return False\n",
        "def sum_to_n(n):\n    if n == 0:\n        return True\n    elif n < 0:\n        return False\n    else:\n        return sum_to_n(n-1)\n"
    ],
    "results": 10
},{
    "id": "2401",
    "source": "humanEval",
    "language": "python",
    "query": "A function that takes a message, and encodes in such a way that it swaps case of all letters, replaces all vowels in the message with the letter that appears 2 places ahead of that. Examples: 'tHKS KS C MGSSCGG'",
    "snippets": [
        "def encode(message):\n    # Create a list of all the letters in the message\n    letters = list(message)\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vow\n",
        "def encode(message):\n    # Create a list of all the letters in the message\n    letters = list(message)\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the conson\n",
        "def encode(message):\n    # Create a list of all the letters in the message\n    message_list = list(message)\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels_list = list(vowels)\n    # Create a list of all the consonants in the message\n    consonants_list = list(consonants)\n    # Create a list of all the vowels in the message\n    vowels_list = list(vowels)\n    # Create a list of all the consonants in the message\n    consonants_list = list(consonants)\n    # Create a list of all the vowels in the message\n    vowels_list = list(vowels)\n    # Create a list of all the consonants in the message\n    consonants_list = list(consonants)\n    # Create a list of all the vowels in the message\n    vowels_list = list(vowels)\n    # Create a list of all the consonants in the message\n    consonants_list = list(consonants)\n    # Create a list of all the vowels in the message\n    vowels_list = list(vowels)\n    # Create a list of all the consonants in the message\n    consonants_list = list(consonants)\n    # Create a list of all the vowels in the message\n    vowels_list = list(vowels)\n    # Create a list of all the consonants in the message\n    consonants_list = list(consonants)\n    # Create a list of all the vowels in the message\n    vowels_list = list(vowels)\n    # Create a\n",
        "def encode(message):\n    # Create a list of all the letters in the message\n    message_list = list(message)\n    # Create a list of all the vowels in the message\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    # Create a list of all the consonants in the message\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    # Create a list of all the vowels in the message\n    vowels_list = []\n    # Create a list of all the consonants in the message\n    consonants_list = []\n    # Create a list of all the vowels in the message\n    for letter in message_list:\n        if letter in vowels:\n            vowels_list.append(letter)\n        elif letter in consonants:\n            consonants_list.append(letter)\n    # Create a list of all the vowels in the message\n    for vowel in vowels_list:\n        # Find the index of the vowel in the message\n        index = message_list.index(vowel)\n        # Find the index of the vowel 2 places ahead of the vowel in the message\n        index_2 = index + 2\n        # Find the letter that is 2 places ahead of the vowel in the message\n        letter_2 = message_list[index_2]\n        # Find the index of the letter 2 places ahead of the vowel in the message\n        index_2 = message_list.index(letter_2)\n        # Find the letter that is 2 places ahead of the vowel in the message\n        letter_2 = message_list[index_2]\n        # Find the index of the letter 2 places ahead of the vowel in the message\n        index_2 = message_list.index(letter_2)\n        # Find the letter that is 2 places ahead of the vowel in the message\n        letter_2 = message_list[index_2]\n        # Find the index of the letter 2 places ahead\n",
        "def encode(message):\n    message = message.lower()\n    message = message.replace('a', '@')\n    message = message.replace('e', '&')\n    message = message.replace('i', '!')\n    message = message.replace('o', '*')\n    message = message.replace('u', '#')\n    message = message.replace('@', 'a')\n    message = message.replace('&', 'e')\n    message = message.replace('!', 'i')\n    message = message.replace('*', 'o')\n    message = message.replace('#', 'u')\n    message = message.replace(' ', '')\n    message = message.swapcase()\n    return message\n"
    ],
    "results": 10
},{
    "id": "2402",
    "source": "humanEval",
    "language": "python",
    "query": "\"You are given a list of integers. You need to find the largest prime value and return its sum\"",
    "snippets": [
        "def largest_prime_value(lst):\n    # your code here\n    prime_list = []\n    for i in lst:\n        if i > 1:\n            for j in range(2, i):\n                if (i % j) == 0:\n                    break\n            else:\n                prime_list.append(i)\n    if len(prime_list) == 0:\n        return 0\n    else:\n        return sum(prime_list)\n",
        "def largest_prime_value(lst):\n    # your code here\n    prime_list = []\n    for i in lst:\n        if i > 1:\n            for j in range(2, i):\n                if (i % j) == 0:\n                    break\n            else:\n                prime_list.append(i)\n    if prime_list:\n        return sum(prime_list)\n    else:\n        return 0\n",
        "def largest_prime(n):\n    # your code here\n    prime = []\n    for i in range(2, n+1):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            prime.append(i)\n    return sum(prime)\n",
        "def largest_prime_value(lst):\n    # your code here\n    largest_prime = 0\n    for i in lst:\n        if i > largest_prime and is_prime(i):\n            largest_prime = i\n    return largest_prime\n",
        "def largest_prime(numbers):\n    # your code here\n    prime = []\n    for i in numbers:\n        if i > 1:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                prime.append(i)\n    return sum(prime)\n",
        "def largest_prime_value(numbers):\n    # your code here\n    prime_list = []\n    for i in range(2, numbers):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            prime_list.append(i)\n    prime_list.sort()\n    prime_list.reverse()\n    for i in prime_list:\n        if numbers % i == 0:\n            return i\n    return 0\n",
        "def largest_prime_value(lst):\n    # Your code here\n    largest_prime = 0\n    for i in lst:\n        if is_prime(i):\n            largest_prime = i\n    return largest_prime\n",
        "def largest_prime_value(lst):\n    # your code here\n    prime_lst = []\n    for i in lst:\n        if is_prime(i):\n            prime_lst.append(i)\n    return sum(prime_lst)\n",
        "def largest_prime_value(n):\n    # your code here\n    return sum(prime_factors(n))\n"
    ],
    "results": 10
},{
    "id": "2403",
    "source": "humanEval",
    "language": "python",
    "query": "Given a dictionary, return True if all keys are strings in lower case. If keys are in upper case, return False. The function should return False is the given dictionary is empty.",
    "snippets": [
        "def all_lower_case(dictionary):\n    if dictionary == {}:\n        return False\n    for key in dictionary:\n        if key.isupper():\n            return False\n    return True\n",
        "def all_lower(d):\n    if d == {}:\n        return False\n    for key in d:\n        if key.isupper():\n            return False\n    return True\n",
        "def all_lower(dictionary):\n    if dictionary == {}:\n        return False\n    for key in dictionary:\n        if key.isupper():\n            return False\n    return True\n",
        "def all_lower_case(a_dictionary):\n    if a_dictionary == {}:\n        return False\n    for key in a_dictionary:\n        if key.isupper():\n            return False\n    return True\n",
        "def is_all_keys_lowercase(dictionary):\n    if dictionary == {}:\n        return False\n    for key in dictionary:\n        if key.isupper():\n            return False\n    return True\n",
        "def is_all_strings_lowercase(dictionary):\n    if dictionary == {}:\n        return False\n    for key in dictionary:\n        if key.isupper():\n            return False\n    return True\n",
        "def is_all_keys_lower(dictionary):\n    if dictionary == {}:\n        return False\n    for key in dictionary:\n        if key.isupper():\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2404",
    "source": "humanEval",
    "language": "python",
    "query": "Implement a function that takes an non-negative integer and returns an array of the first n prime numbers.",
    "snippets": [
        "def prime_numbers(n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [2]\n    primes = [2]\n    i = 3\n    while len(primes) < n:\n        for prime in primes:\n            if i % prime == 0:\n                break\n        else:\n            primes.append(i)\n        i += 2\n    return primes\n",
        "def prime_numbers(n):\n    if n < 1:\n        return []\n    if n == 1:\n        return [2]\n    primes = [2]\n    i = 3\n    while len(primes) < n:\n        for prime in primes:\n            if i % prime == 0:\n                break\n        else:\n            primes.append(i)\n        i += 2\n    return primes\n",
        "def prime_numbers(n):\n    if n < 1:\n        return []\n    if n == 1:\n        return [2]\n    primes = [2]\n    i = 3\n    while len(primes) < n:\n        for p in primes:\n            if i % p == 0:\n                break\n        else:\n            primes.append(i)\n        i += 2\n    return primes\n",
        "def prime_numbers(n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [2]\n    if n == 2:\n        return [2, 3]\n    if n == 3:\n        return [2, 3, 5]\n    if n == 4:\n        return [2, 3, 5, 7]\n    if n == 5:\n        return [2, 3, 5, 7, 11]\n    if n == 6:\n        return [2, 3, 5, 7, 11, 13]\n    if n == 7:\n        return [2, 3, 5, 7, 11, 13, 17]\n    if n == 8:\n        return [2, 3, 5, 7, 11, 13, 17, 19]\n    if n == 9:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23]\n    if n == 10:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    if n == 11:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]\n    if n == 12:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    if n == 13:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]\n    if n == 14:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43]\n    if n == 15:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n    if n == 16:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]\n    if n == 17:\n        return [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\n",
        "def prime_numbers(n):\n    if n < 1:\n        return []\n    primes = [2]\n    i = 3\n    while len(primes) < n:\n        for prime in primes:\n            if i % prime == 0:\n                break\n        else:\n            primes.append(i)\n        i += 2\n    return primes\n"
    ],
    "results": 10
},{
    "id": "2405",
    "source": "humanEval",
    "language": "python",
    "query": "\"Complete the function that takes two integers and returns the product of their unit digits\" \"Assume the input is always valid\"",
    "snippets": [
        "def product_unit_digits(num):\n    num = str(num)\n    product = 1\n    for i in num:\n        product *= int(i)\n    return product\n",
        "def product_unit_digits(num):\n    num = str(num)\n    result = 1\n    for i in num:\n        result *= int(i)\n    return result\n",
        "def product(n):\n    n = str(n)\n    product = 1\n    for i in n:\n        product *= int(i)\n    return product\n",
        "def product(n):\n    return int(str(n)[0]) * int(str(n)[1]) * int(str(n)[2])\n",
        "def product(n):\n    n = str(n)\n    result = 1\n    for i in n:\n        result *= int(i)\n    return result\n",
        "def product(n):\n    return int(str(n)[0]) * int(str(n)[1])\n",
        "def product(a, b):\n    return sum([int(i) for i in str(a * b)])\n"
    ],
    "results": 10
},{
    "id": "2406",
    "source": "humanEval",
    "language": "python",
    "query": "Given a string s, count the number of uppercase vowels in even indices. For example: count_upper('aBCdEf') returns 1. count_higher('abcdefg') returns 0.",
    "snippets": [
        "def count_upper(s):\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i].isupper():\n            count += 1\n    return count\n",
        "def count_upper(s):\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "2407",
    "source": "humanEval",
    "language": "python",
    "query": "If the number is equidistant from two integers, round it away from zero. For example closest_integer(\"14.5\") should return 15 and closest_ integer(\"-14.4\") will return -15.",
    "snippets": [
        "def closest_integer(number):\n    if number > 0:\n        return int(number + 0.5)\n    else:\n        return int(number - 0.5)\n",
        "def closest_integer(number):\n    if number >= 0:\n        return int(number + 0.5)\n    else:\n        return int(number - 0.5)\n",
        "def closest_integer(number):\n    if number % 1 == 0:\n        return int(number)\n    else:\n        if number > 0:\n            return int(number + 1)\n        else:\n            return int(number - 1)\n",
        "def closest_integer(n):\n    if n > 0:\n        return int(n + 0.5)\n    else:\n        return int(n - 0.5)\n"
    ],
    "results": 10
},{
    "id": "2408",
    "source": "humanEval",
    "language": "python",
    "query": "Given a positive integer n, you have to make a pile of n levels of stones. Return the number of stones in each level in a list.",
    "snippets": [
        "def pile(n):\n    if n == 1:\n        return [1]\n    else:\n        return [n] + pile(n-1)\n",
        "def stone_piles(n):\n    return [2**i for i in range(n)]\n",
        "def make_pile(n):\n    return [i for i in range(1, n+1)]\n",
        "def make_pile(n):\n    return [n*i for i in range(1,n+1)]\n",
        "def make_pile(n):\n    return [n] * n\n",
        "def make_stone(n):\n    return [n * i for i in range(1, n + 1)]\n"
    ],
    "results": 10
},{
    "id": "2409",
    "source": "humanEval",
    "language": "python",
    "query": "You will be given a string of words separated by commas or spaces. Your task is to split the string into words and return an array of the words.",
    "snippets": [
        "def split_and_clean(string):\n    return [word.strip() for word in string.split(',')]\n",
        "def split_and_remove(string):\n    return [word.strip() for word in string.split(',')]\n",
        "def split_and_remove(str):\n    return [word.strip() for word in str.split(',')]\n"
    ],
    "results": 9
},{
    "id": "2410",
    "source": "humanEval",
    "language": "python",
    "query": "The choose_num function takes two positive numbers x and y and returns the biggest even integer number that is in the range [x, y] inclusive. If there's no such number, then the function should return -1. For example: choose_ num(12, 15) = 14    Choose_num(13, 12) = -1",
    "snippets": [
        "def choose_num(x, y):\n    for i in range(x, y+1):\n        if i % 2 == 0:\n            return i\n    return -1\n",
        "def choose_num(x, y):\n    if x % 2 != 0:\n        x += 1\n    if y % 2 != 0:\n        y -= 1\n    if x > y:\n        return -1\n    else:\n        for i in range(x, y + 1, 2):\n            if i >= x and i <= y:\n                return i\n        return -1\n",
        "def choose_num(x, y):\n    if x % 2 != 0:\n        x += 1\n    if y % 2 != 0:\n        y -= 1\n    if x > y:\n        return -1\n    for i in range(x, y + 1, 2):\n        if x <= i <= y:\n            return i\n    return -1\n",
        "def choose_num(x, y):\n    if x % 2 != 0:\n        x += 1\n    if y % 2 != 0:\n        y -= 1\n    if x > y:\n        return -1\n    else:\n        for i in range(x, y + 1, 2):\n            if i > x and i < y:\n                return i\n        return -1\n",
        "def choose_num(x, y):\n    if x % 2 == 0:\n        x = x\n    else:\n        x = x + 1\n    if y % 2 == 0:\n        y = y\n    else:\n        y = y - 1\n    if x > y:\n        return -1\n    else:\n        for i in range(x, y + 1):\n            if i % 2 == 0:\n                return i\n    return -1\n",
        "def choose_num(x, y):\n    if x % 2 == 0:\n        x -= 1\n    while x <= y:\n        x += 2\n    if x % 2 == 0:\n        return x\n    else:\n        return -1\n"
    ],
    "results": 10
},{
    "id": "2411",
    "source": "humanEval",
    "language": "python",
    "query": "You are given two positive integers n and m, and your task is to compute the average of the integers from n through m. Round the answer to the nearest integer and convert that to binary. If n is greater than m, return -1.",
    "snippets": [
        "def average(n, m):\n    if n > m:\n        return -1\n    return (m + n) // 2\n",
        "def average(n, m):\n    if n > m:\n        return -1\n    else:\n        return (n + m) // 2\n",
        "def average(n, m):\n    if n > m:\n        return -1\n    return int((n + m) / 2)\n",
        "def average(n, m):\n    if n > m:\n        return -1\n    return round((n + m) / 2)\n",
        "def average_binary(n, m):\n    if n > m:\n        return -1\n    else:\n        return int(bin(n + m // 2)[2:])\n",
        "def average(n, m):\n    if n > m:\n        return -1\n    return round((m + n) / 2)\n"
    ],
    "results": 10
},{
    "id": "2412",
    "source": "humanEval",
    "language": "python",
    "query": "Given a list of positive integers x. return a sorted list of all elements that haven't any even digit. Note: Returned list should be sorted in increasing order.",
    "snippets": [
        "def sort_odd(lst):\n    odd_lst = []\n    for i in lst:\n        if i % 2 != 0:\n            odd_lst.append(i)\n    odd_lst.sort()\n    return odd_lst\n",
        "def sort_odd(lst):\n    odd = []\n    for i in lst:\n        if i % 2 != 0:\n            odd.append(i)\n    odd.sort()\n    return odd\n",
        "def sort_odd(lst):\n    return sorted([x for x in lst if x % 2 != 0])\n",
        "def sort_odd(x):\n    return sorted([i for i in x if i % 2 != 0])\n",
        "def sort_odd(lst):\n    return sorted([x for x in lst if not any(y % 2 == 0 for y in str(x))])\n"
    ],
    "results": 10
},{
    "id": "2413",
    "source": "humanEval",
    "language": "python",
    "query": "Given an array of integers, sort the integers that are between 1 and 9 inclusive, reverse the resulting array, and then replace each digit by its corresponding name. If the array is empty, return an empty array: arr = [1, -1 , 55]",
    "snippets": [
        "def sort_digits(arr):\n    arr = [x for x in arr if x >= 1 and x <= 9]\n    arr.sort()\n    arr.reverse()\n    return [str(x) if x == 1 else x for x in arr]\n",
        "def replace_numbers(arr):\n    new_arr = []\n    for i in arr:\n        if i >= 1 and i <= 9:\n            new_arr.append(i)\n    new_arr.sort()\n    new_arr.reverse()\n    for i in range(len(new_arr)):\n        if new_arr[i] == 1:\n            new_arr[i] = \"one\"\n        elif new_arr[i] == 2:\n            new_arr[i] = \"two\"\n        elif new_arr[i] == 3:\n            new_arr[i] = \"three\"\n        elif new_arr[i] == 4:\n            new_arr[i] = \"four\"\n        elif new_arr[i] == 5:\n            new_arr[i] = \"five\"\n        elif new_arr[i] == 6:\n            new_arr[i] = \"six\"\n        elif new_arr[i] == 7:\n            new_arr[i] = \"seven\"\n        elif new_arr[i] == 8:\n            new_arr[i] = \"eight\"\n        elif new_arr[i] == 9:\n            new_arr[i] = \"nine\"\n    return new_arr\n",
        "def replace_digits(arr):\n    if not arr:\n        return []\n    arr = [str(i) for i in arr]\n    arr = [i for i in arr if i.isdigit() and int(i) in range(1, 10)]\n    arr.sort()\n    arr.reverse()\n    arr = [i if i.isdigit() else str(ord(i) - ord('0')) for i in arr]\n    arr = [i if i.isdigit() else chr(ord('0') + int(i)) for i in arr]\n    return arr\n",
        "def replace_digits(arr):\n    if not arr:\n        return []\n    arr = [str(i) for i in arr]\n    arr = [i for i in arr if i[0] in '123456789']\n    arr = [i for i in arr if i[1] in '123456789']\n    arr = [i for i in arr if i[2] in '123456789']\n    arr = [i for i in arr if i[3] in '123456789']\n    arr = [i for i in arr if i[4] in '123456789']\n    arr = [i for i in arr if i[5] in '123456789']\n    arr = [i for i in arr if i[6] in '123456789']\n    arr = [i for i in arr if i[7] in '123456789']\n    arr = [i for i in arr if i[8] in '123456789']\n    arr = [i for i in arr if i[9] in '123456789']\n    arr = [i for i in arr if i[10] in '123456789']\n    arr = [i for i in arr if i[11] in '123456789']\n    arr = [i for i in arr if i[12] in '123456789']\n    arr = [i for i in arr if i[13] in '123456789']\n    arr = [i for i in arr if i[14] in '123456789']\n    arr = [i for i in arr if i[15] in '123456789']\n    arr = [i for i in arr if i[16] in '123456789']\n    arr = [i for i in arr if i[17] in '123456789']\n    arr = [i for i in arr if i[18] in '123456789']\n    arr = [i for i in arr if i[19] in '123456789']\n    arr = [i for i in arr if i[20] in '123456789']\n    arr = [i\n",
        "def replace_digits(arr):\n    if not arr:\n        return []\n    result = []\n    for i in arr:\n        if i >= 1 and i <= 9:\n            result.append(i)\n    result.sort()\n    result.reverse()\n    for i in range(len(result)):\n        if result[i] == 1:\n            result[i] = 'one'\n        elif result[i] == 2:\n            result[i] = 'two'\n        elif result[i] == 3:\n            result[i] = 'three'\n        elif result[i] == 4:\n            result[i] = 'four'\n        elif result[i] == 5:\n            result[i] = 'five'\n        elif result[i] == 6:\n            result[i] = 'six'\n        elif result[i] == 7:\n            result[i] = 'seven'\n        elif result[i] == 8:\n            result[i] = 'eight'\n        elif result[i] == 9:\n            result[i] = 'nine'\n    return result\n",
        "def replace_digits(arr):\n    if not arr:\n        return []\n    else:\n        new_arr = []\n        for i in arr:\n            if i in range(1, 10):\n                new_arr.append(i)\n        new_arr.sort()\n        new_arr.reverse()\n        for i in range(len(new_arr)):\n            if new_arr[i] == 1:\n                new_arr[i] = 'one'\n            elif new_arr[i] == 2:\n                new_arr[i] = 'two'\n            elif new_arr[i] == 3:\n                new_arr[i] = 'three'\n            elif new_arr[i] == 4:\n                new_arr[i] = 'four'\n            elif new_arr[i] == 5:\n                new_arr[i] = 'five'\n            elif new_arr[i] == 6:\n                new_arr[i] = 'six'\n            elif new_arr[i] == 7:\n                new_arr[i] = 'seven'\n            elif new_arr[i] == 8:\n                new_arr[i] = 'eight'\n            elif new_arr[i] == 9:\n                new_arr[i] = 'nine'\n        return new_arr\n",
        "def sort_digits(arr):\n    if not arr:\n        return []\n    arr = [str(i) for i in arr]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr.sort()\n    arr.reverse()\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit()]\n    arr = [i for i in arr if int(i) in range(1, 10)]\n    arr = [i for i in arr if i.isdigit\n",
        "def sort_digits(arr):\n    arr = [x for x in arr if x >= 1 and x <= 9]\n    arr.sort()\n    arr.reverse()\n    return [digit_to_name(x) for x in arr]\n",
        "def arr_to_names(arr):\n    if not arr:\n        return []\n    arr = [i for i in arr if i in range(1, 10)]\n    arr.sort()\n    arr.reverse()\n    return [str(i) for i in arr]\n"
    ],
    "results": 9
},{
    "id": "2414",
    "source": "humanEval",
    "language": "python",
    "query": "function f takes n as a parameter and returns a list of size n. Value of element at index i is factorial of i if i is even or the sum of numbers from 1 to i otherwise.",
    "snippets": [
        "def f(n):\n    l = []\n    for i in range(n):\n        if i % 2 == 0:\n            l.append(factorial(i))\n        else:\n            l.append(sum(range(1, i + 1)))\n    return l\n",
        "def f(n):\n    if n == 0:\n        return []\n    elif n % 2 == 0:\n        return [f(n-1) * n]\n    else:\n        return [f(n-1) + n]\n",
        "def f(n):\n    if n == 0:\n        return []\n    else:\n        if n % 2 == 0:\n            return [factorial(n)] + f(n-1)\n        else:\n            return [sum(range(1, n+1))] + f(n-1)\n"
    ],
    "results": 10
},{
    "id": "2415",
    "source": "humanEval",
    "language": "python",
    "query": "Given a positive integer n, return a tuple that has the number of even and odd integer palindromes that fall within the range(1, n), inclusive.",
    "snippets": [
        "def even_odd_palindromes(n):\n    even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)\n",
        "def even_odd_palindromes(n):\n    even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)\n",
        "def even_odd_palindromes(n):\n    even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if is_palindrome(str(i)):\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)\n",
        "def even_odd_palindrome(n):\n    even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)\n",
        "def count_even_odd_palindromes(n):\n    even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)\n",
        "def count_even_odd_palindromes(n):\n    even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if is_palindrome(str(i)):\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)\n"
    ],
    "results": 10
},{
    "id": "2416",
    "source": "humanEval",
    "language": "python",
    "query": "count_nums is a function which takes an array of integers and returns the number of elements which has a sum of digits > 0. If a number is negative, then its first signed digit will be negative: -123 has signed digits -1, 2, and 3.",
    "snippets": [
        "def count_nums(arr):\n    count = 0\n    for i in arr:\n        if sum(int(x) for x in str(i)) > 0:\n            count += 1\n    return count\n",
        "def count_nums(arr):\n    count = 0\n    for i in arr:\n        if i > 0:\n            if sum(int(j) for j in str(i)) > 0:\n                count += 1\n        else:\n            if sum(int(j) for j in str(i)[1:]) > 0:\n                count += 1\n    return count\n",
        "def count_nums(arr):\n    count = 0\n    for i in arr:\n        if i > 0:\n            if sum(int(x) for x in str(i)) > 0:\n                count += 1\n        else:\n            if sum(int(x) for x in str(i)[1:]) > 0:\n                count += 1\n    return count\n",
        "def count_nums(arr):\n    count = 0\n    for num in arr:\n        if sum(int(digit) for digit in str(num)) > 0:\n            count += 1\n    return count\n",
        "def count_nums(arr):\n    count = 0\n    for num in arr:\n        if sum(int(i) for i in str(num)) > 0:\n            count += 1\n    return count\n"
    ],
    "results": 10
},{
    "id": "2417",
    "source": "humanEval",
    "language": "python",
    "query": "The given list is guaranteed to have unique elements. By performin 2 right shift operations, non-decreasing order can be achieved for the given array.",
    "snippets": [
        "def sort_array(arr):\n    if len(arr) <= 1:\n        return arr\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] > arr[right]:\n            arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n        if arr[left] > arr[right]:\n            arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr\n",
        "def sort_array(arr):\n    if len(arr) <= 1:\n        return arr\n    left = 0\n    right = len(arr) - 1\n    while left < right:\n        if arr[left] > arr[right]:\n            arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    return arr\n",
        "def sortArrayByParity(A):\n    i = 0\n    j = len(A) - 1\n    while i < j:\n        if A[i] % 2 == 0:\n            i += 1\n        else:\n            A[i], A[j] = A[j], A[i]\n            j -= 1\n    return A\n",
        "def rotate(nums, k):\n    k %= len(nums)\n    nums[:] = nums[-k:] + nums[:-k]\n    return nums\n",
        "def sortArray(arr):\n    if len(arr) <= 1:\n        return arr\n    left = sortArray(arr[:len(arr)//2])\n    right = sortArray(arr[len(arr)//2:])\n    return merge(left, right)\n",
        "def shift(arr, n):\n    for i in range(n):\n        arr.insert(0, arr.pop())\n    return arr\n",
        "def sort(arr):\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                arr[i], arr[j] = arr[j], arr[i]\n    return arr\n",
        "def sortArray(arr):\n    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return arr\n    if len(arr) == 2:\n        if arr[0] > arr[1]:\n            return [arr[1], arr[0]]\n        else:\n            return arr\n    mid = len(arr) // 2\n    left = sortArray(arr[:mid])\n    right = sortArray(arr[mid:])\n    return merge(left, right)\n",
        "def sort(arr):\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            arr[i], arr[0] = arr[0], arr[i]\n            return arr\n    return arr\n",
        "def sort(arr):\n    if len(arr) == 1:\n        return arr\n    else:\n        return sort(arr[1:]) + [arr[0]]\n"
    ],
    "results": 10
},{
    "id": "2418",
    "source": "humanEval",
    "language": "python",
    "query": "In this problem, you will implement a function that takes two lists of numbers, and determines whether it is possible to perform an exchange of elements between them. There is no limit on the number of exchanged elements between lst1 and lst2.",
    "snippets": [
        "def exchange(lst1, lst2):\n    if len(lst1) == 0 or len(lst2) == 0:\n        return False\n    if len(lst1) == len(lst2):\n        return True\n    if len(lst1) > len(lst2):\n        return exchange(lst2, lst1)\n    for i in range(len(lst1)):\n        if lst1[i] in lst2:\n            lst2.remove(lst1[i])\n        else:\n            return False\n    return True\n",
        "def exchange(lst1, lst2):\n    if len(lst1) == 0 or len(lst2) == 0:\n        return False\n    if len(lst1) == len(lst2):\n        return True\n    if len(lst1) > len(lst2):\n        return exchange(lst2, lst1)\n    for i in range(len(lst1)):\n        if lst1[i] in lst2:\n            lst2.remove(lst1[i])\n            if len(lst1) == len(lst2):\n                return True\n            if len(lst1) > len(lst2):\n                return exchange(lst2, lst1)\n    return False\n",
        "def exchange(lst1, lst2):\n    if len(lst1) == 0 or len(lst2) == 0:\n        return False\n    if len(lst1) == len(lst2):\n        return True\n    if len(lst1) > len(lst2):\n        return exchange(lst2, lst1)\n    for i in range(len(lst1)):\n        if lst1[i] in lst2:\n            lst2.remove(lst1[i])\n            if len(lst1) == len(lst2):\n                return True\n    return False\n",
        "def exchange(lst1, lst2):\n    if len(lst1) != len(lst2):\n        return False\n    for i in range(len(lst1)):\n        if lst1[i] in lst2:\n            lst2.remove(lst1[i])\n        else:\n            return False\n    return True\n",
        "def exchange(lst1, lst2):\n    # Your code here\n    if len(lst1) == 0 or len(lst2) == 0:\n        return False\n    if len(lst1) == len(lst2):\n        return True\n    if len(lst1) > len(lst2):\n        return False\n    if len(lst1) < len(lst2):\n        return True\n    return False\n",
        "def exchange(lst1, lst2):\n    if len(lst1) == 0 or len(lst2) == 0:\n        return False\n    else:\n        for i in lst1:\n            if i in lst2:\n                lst1.remove(i)\n                lst2.remove(i)\n                return True\n        return False\n",
        "def exchange(lst1, lst2):\n    # Your code here\n    lst1.extend(lst2)\n    lst2.clear()\n    for i in range(len(lst1)):\n        if i % 2 == 0:\n            lst2.append(lst1[i])\n        else:\n            lst1.append(lst1[i])\n    lst1.clear()\n    lst1.extend(lst2)\n    lst2.clear()\n    return lst1\n",
        "def can_exchange(lst1, lst2):\n    # Your code here\n    return True\n"
    ],
    "results": 10
},{
    "id": "2419",
    "source": "humanEval",
    "language": "python",
    "query": "Given a string representing a space separated lowercase letters, return a dictionary of the letter with the most repetition and containing the corresponding count.",
    "snippets": [
        "def letter_frequency(string):\n    letters = {}\n    for letter in string:\n        if letter in letters:\n            letters[letter] += 1\n        else:\n            letters[letter] = 1\n    return letters\n",
        "def letter_frequency(string):\n    string = string.lower()\n    string = string.split()\n    d = {}\n    for i in string:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    return d\n",
        "def letter_frequency(string):\n    string = string.lower()\n    string = string.split()\n    dict = {}\n    for i in string:\n        if i in dict:\n            dict[i] += 1\n        else:\n            dict[i] = 1\n    max_value = max(dict.values())\n    for key, value in dict.items():\n        if value == max_value:\n            return {key: value}\n",
        "def letter_frequency(string):\n    string = string.lower()\n    string = string.split()\n    dict = {}\n    for i in string:\n        if i in dict:\n            dict[i] += 1\n        else:\n            dict[i] = 1\n    max_value = max(dict.values())\n    for key, value in dict.items():\n        if value == max_value:\n            return key, value\n",
        "def letter_frequency(string):\n    string = string.lower()\n    string = string.split()\n    dic = {}\n    for i in string:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    max_value = max(dic.values())\n    for key, value in dic.items():\n        if value == max_value:\n            return {key: value}\n",
        "def letter_freq(string):\n    string = string.lower()\n    string = string.split()\n    d = {}\n    for i in string:\n        if i in d:\n            d[i] += 1\n        else:\n            d[i] = 1\n    return d\n",
        "def letter_freq(string):\n    string = string.lower()\n    string = string.split()\n    freq = {}\n    for letter in string:\n        if letter in freq:\n            freq[letter] += 1\n        else:\n            freq[letter] = 1\n    max_letter = max(freq, key=freq.get)\n    return {max_letter: freq[max_letter]}\n",
        "def letter_frequency(string):\n    string = string.lower()\n    string = string.split()\n    dictionary = {}\n    for letter in string:\n        if letter in dictionary:\n            dictionary[letter] += 1\n        else:\n            dictionary[letter] = 1\n    max_letter = max(dictionary, key=dictionary.get)\n    return {max_letter: dictionary[max_letter]}\n",
        "def letter_frequency(string):\n    return {letter: string.count(letter) for letter in string}\n"
    ],
    "results": 10
},{
    "id": "2420",
    "source": "humanEval",
    "language": "python",
    "query": "A string is called palindrome if it reads the same backward as forward. We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c then check if the result string is palindromic.",
    "snippets": [
        "def is_palindrome(s, c):\n    for i in c:\n        s = s.replace(i, '')\n    return s == s[::-1]\n",
        "def palindrome(s, c):\n    for i in c:\n        s = s.replace(i, '')\n    return s == s[::-1]\n",
        "def is_palindrome(s, c):\n    for i in c:\n        s = s.replace(i, \"\")\n    return s == s[::-1]\n",
        "def is_palindrome(s, c):\n    for char in c:\n        s = s.replace(char, '')\n    return s == s[::-1]\n"
    ],
    "results": 10
},{
    "id": "2421",
    "source": "humanEval",
    "language": "python",
    "query": "Given a list of strings, where each string consists of only digits, return a list. Each element i of the output should be \"the number of odd elements in the string i\"",
    "snippets": [
        "def count_odd(lst):\n    return [len(list(filter(lambda x: x % 2 == 1, lst[i]))) for i in range(len(lst))]\n",
        "def count_odd_elements(lst):\n    return [len(list(filter(lambda x: x % 2 != 0, lst[i]))) for i in range(len(lst))]\n",
        "def odd_numbers(lst):\n    return [len(list(filter(lambda x: x % 2 != 0, lst[i]))) for i in range(len(lst))]\n",
        "def count_odd(lst):\n    return [len([x for x in lst[i] if int(x) % 2 == 1]) for i in range(len(lst))]\n",
        "def count_odd(lst):\n    return [len([x for x in s if x % 2 == 1]) for s in lst]\n",
        "def count_odd(lst):\n    return [len([x for x in lst[i] if int(x) % 2 != 0]) for i in range(len(lst))]\n",
        "def odd_count(lst):\n    return [len([x for x in s if x % 2 == 1]) for s in lst]\n",
        "def odd_numbers(lst):\n    return [len(list(filter(lambda x: x % 2 == 1, s))) for s in lst]\n"
    ],
    "results": 10
},{
    "id": "2422",
    "source": "humanEval",
    "language": "python",
    "query": "Given an array of integers nums, find the minimum sum of any non-empty sub-array of nums. minSubArraySum is the sum of all the sub-arrays in the array.",
    "snippets": [
        "def minSubArraySum(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    min_sum = float('inf')\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum < k:\n            continue\n        if sum - k < min_sum:\n            min_sum = sum - k\n        sum -= nums[i - 1]\n    return min_sum if min_sum != float('inf') else 0\n",
        "def minSubArraySum(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    min_sum = float('inf')\n    cur_sum = 0\n    for i in range(len(nums)):\n        cur_sum += nums[i]\n        if cur_sum < k:\n            continue\n        if cur_sum - k < min_sum:\n            min_sum = cur_sum - k\n        cur_sum -= nums[i]\n    return min_sum if min_sum != float('inf') else 0\n",
        "def minSubArraySum(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    min_sum = float('inf')\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum >= k:\n            min_sum = min(min_sum, sum)\n        if sum < k:\n            sum = 0\n    return min_sum if min_sum != float('inf') else 0\n",
        "def minSubArraySum(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    min_sum = float('inf')\n    cur_sum = 0\n    for i in range(len(nums)):\n        cur_sum += nums[i]\n        if cur_sum < k:\n            continue\n        if cur_sum - k < min_sum:\n            min_sum = cur_sum - k\n        cur_sum -= nums[i - 1]\n    return min_sum if min_sum != float('inf') else 0\n",
        "def minSubArraySum(nums, k):\n    \"\"\"\n    :type nums: List[int]\n    :type k: int\n    :rtype: int\n    \"\"\"\n    if not nums:\n        return 0\n    min_sum = float('inf')\n    cur_sum = 0\n    for i in range(len(nums)):\n        cur_sum += nums[i]\n        if cur_sum >= k:\n            min_sum = min(min_sum, cur_sum)\n        else:\n            cur_sum = 0\n    return min_sum if min_sum != float('inf') else 0\n",
        "def minSubArraySum(nums, k):\n    if not nums:\n        return 0\n    min_sum = float('inf')\n    sum = 0\n    for i in range(len(nums)):\n        sum += nums[i]\n        if sum < k:\n            continue\n        if sum - k < min_sum:\n            min_sum = sum - k\n        sum -= nums[i - 1]\n    return min_sum if min_sum != float('inf') else 0\n",
        "def minSubArraySum(nums, k):\n    if not nums:\n        return 0\n    min_sum = float('inf')\n    cur_sum = 0\n    for i in range(len(nums)):\n        cur_sum += nums[i]\n        if cur_sum < k:\n            continue\n        if cur_sum - k < min_sum:\n            min_sum = cur_sum - k\n        cur_sum -= nums[i - 1]\n    return min_sum if min_sum != float('inf') else 0\n"
    ],
    "results": 10
},{
    "id": "2423",
    "source": "humanEval",
    "language": "python",
    "query": "Every well has a corresponding bucket that can be used to extract water from it, and all buckets have the same capacity. The number of times you need to lower the buckets depends on the number of wells you have.",
    "snippets": [
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    buckets.sort()\n    buckets.reverse()\n    for i in range(n):\n        if wells[i] > buckets[0]:\n            print(i+1)\n            return\n        else:\n            buckets[0] -= wells[i]\n    print(\"-1\")\n",
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    buckets.sort()\n    buckets.reverse()\n    for i in range(n):\n        if wells[i] > buckets[i]:\n            print(i+1)\n            return\n    print(\"-1\")\n",
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    buckets.sort()\n    buckets.reverse()\n    for i in range(n):\n        if wells[i] > buckets[0]:\n            print(i + 1)\n            return\n        else:\n            buckets[0] -= wells[i]\n    print(\"use all\")\n",
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    buckets.sort()\n    buckets.reverse()\n    for i in range(n):\n        if wells[i] > buckets[0]:\n            print(i + 1)\n            return\n        buckets[0] -= wells[i]\n        buckets[0] += buckets[1]\n        buckets.pop(1)\n    print(\"use infinitely many buckets\")\n",
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    print(min(wells) * min(buckets))\n",
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    for i in range(n):\n        if wells[i] > buckets[i]:\n            print(i+1)\n            return\n    print(\"par\")\n",
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    buckets.sort()\n    buckets.reverse()\n    for i in range(n):\n        if wells[i] > buckets[0]:\n            print(i + 1)\n            break\n        else:\n            buckets[0] -= wells[i]\n            if buckets[0] == 0:\n                buckets.pop(0)\n            if len(buckets) == 0:\n                print(i + 1)\n                break\n",
        "def main():\n    n = int(input())\n    wells = list(map(int, input().split()))\n    buckets = list(map(int, input().split()))\n    buckets.sort()\n    buckets.reverse()\n    for i in range(n):\n        if wells[i] > buckets[i]:\n            print('NO')\n            return\n    print('YES')\n"
    ],
    "results": 10
},{
    "id": "2424",
    "source": "humanEval",
    "language": "python",
    "query": "In this Kata, you have to sort an array of non-negative integers according to the number of ones in their binary representation. It must be implemented like this:",
    "snippets": [
        "def sort_by_binary(arr):\n    return sorted(arr, key=lambda x: bin(x).count('1'))\n",
        "def countBits(n):\n    return [bin(i).count('1') for i in range(n+1)]\n",
        "def sortByBits(arr):\n    return sorted(arr, key=lambda x: bin(x).count('1'))\n",
        "def count_bits(n):\n    return bin(n).count('1')\n",
        "def sortByBits(arr):\n    return sorted(arr, key=lambda x: bin(x)[2:].count('1'))\n",
        "def count_bits(n):\n    return sum(bin(i).count('1') for i in range(n + 1))\n"
    ],
    "results": 10
},{
    "id": "2425",
    "source": "humanEval",
    "language": "python",
    "query": "Given a string s and a natural number n, you have been tasked to implement a function that returns a list of all words from string s that contain exactly    n consonants. If the string s is empty then the function should return an empty list.",
    "snippets": [
        "def consonant_words(s, n):\n    return [word for word in s.split() if len(word) == n and sum(1 for c in word if c in 'bcdfghjklmnpqrstvwxyz') == n]\n",
        "def consonant_words(s, n):\n    if s == \"\":\n        return []\n    else:\n        return [word for word in s.split() if len(word) == n and word.isalpha() and word.lower().count(\"a\") == 0 and word.lower().count(\"e\") == 0 and word.lower().count(\"i\") == 0 and word.lower().count(\"o\") == 0 and word.lower().count(\"u\") == 0]\n",
        "def consonant_words(s, n):\n    if s == \"\":\n        return []\n    else:\n        return [word for word in s.split() if len(word) == n and sum(1 for c in word if c in \"bcdfghjklmnpqrstvwxyz\") == n]\n",
        "def consonant_words(s, n):\n    if s == '':\n        return []\n    else:\n        return [word for word in s.split() if len(word) == n and sum(1 for c in word if c in 'bcdfghjklmnpqrstvwxyz') == n]\n",
        "def find_consonants(s, n):\n    if s == \"\":\n        return []\n    else:\n        return [word for word in s.split() if len(word) == n and word.isalpha() and word.isupper() and word.count(\"A\") == 0 and word.count(\"E\") == 0 and word.count(\"I\") == 0 and word.count(\"O\") == 0 and word.count(\"U\") == 0]\n",
        "def consonant_words(s, n):\n    if s == \"\":\n        return []\n    else:\n        return [word for word in s.split() if len(word) == n and sum([1 for c in word if c in \"bcdfghjklmnpqrstvwxyz\"]) == n]\n"
    ],
    "results": 10
},{
    "id": "2426",
    "source": "humanEval",
    "language": "python",
    "query": "Find the closest vowel that stands between two consonants from the right side of the word. Vowels in the beginning and ending doesn't count.",
    "snippets": [
        "def closest_vowel(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    vowels_count = 0\n    consonants_count = 0\n    for i in word:\n        if i in vowels:\n            vowels_count += 1\n        elif i in consonants:\n            consonants_count += 1\n    if vowels_count == 0 or consonants_count == 0:\n        return None\n    else:\n        for i in range(len(word)):\n            if word[i] in vowels:\n                if i == 0:\n                    return word[i]\n                elif i == len(word) - 1:\n                    return word[i]\n                elif word[i-1] in consonants and word[i+1] in consonants:\n                    return word[i]\n        return None\n",
        "def find_closest_vowel(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    closest_vowel = ''\n    closest_vowel_distance = 0\n    for i in range(len(word)):\n        if word[i] in vowels:\n            if closest_vowel_distance == 0:\n                closest_vowel = word[i]\n                closest_vowel_distance = i\n            else:\n                if i < closest_vowel_distance:\n                    closest_vowel = word[i]\n                    closest_vowel_distance = i\n    return closest_vowel\n",
        "def closest_vowel(word):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    word = word.lower()\n    consonants_count = 0\n    for i in range(len(word)):\n        if word[i] in consonants:\n            consonants_count += 1\n    for i in range(len(word)):\n        if word[i] in vowels:\n            if consonants_count == 0:\n                return word[i]\n            else:\n                consonants_count -= 1\n    return None\n",
        "def closest_vowel(word):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    word = word.lower()\n    consonants_index = []\n    for i in range(len(word)):\n        if word[i] in consonants:\n            consonants_index.append(i)\n    if len(consonants_index) < 2:\n        return None\n    for i in range(len(consonants_index) - 1):\n        if consonants_index[i + 1] - consonants_index[i] == 1:\n            return word[consonants_index[i] + 1:consonants_index[i + 1]]\n    return None\n",
        "def find_vowel(word):\n    vowels = ['a', 'e', 'i', 'o', 'u']\n    consonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']\n    word = word.lower()\n    for i in range(len(word)):\n        if word[i] in vowels:\n            if i == 0:\n                return word[i+1]\n            elif i == len(word)-1:\n                return word[i-1]\n            else:\n                if word[i-1] in consonants and word[i+1] in consonants:\n                    return word[i]\n                elif word[i-1] in consonants:\n                    return word[i+1]\n                elif word[i+1] in consonants:\n                    return word[i-1]\n                else:\n                    return word[i]\n    return word\n",
        "def find_closest_vowel(word):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    word = word.lower()\n    word_list = list(word)\n    for i in range(len(word_list)):\n        if word_list[i] in vowels:\n            if i == 0:\n                return word_list[i]\n            elif word_list[i-1] in consonants:\n                return word_list[i]\n    return word_list[-1]\n",
        "def find_closest_vowel(word):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    word = word.lower()\n    for i in range(len(word)):\n        if word[i] in vowels:\n            for j in range(i, len(word)):\n                if word[j] in consonants:\n                    return word[j]\n    return None\n",
        "def closest_vowel(word):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    consonants_list = list(consonants)\n    vowels_list = list(vowels)\n    word_list = list(word)\n    for i in range(len(word_list)):\n        if word_list[i] in consonants_list:\n            for j in range(i, len(word_list)):\n                if word_list[j] in vowels_list:\n                    return word_list[j]\n    return None\n",
        "def closest_vowel(word):\n    vowels = 'aeiou'\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    consonants_list = list(consonants)\n    vowels_list = list(vowels)\n    word_list = list(word)\n    word_list.reverse()\n    word_list_reversed = word_list\n    word_list_reversed.reverse()\n    word_list_reversed_str = ''.join(word_list_reversed)\n    word_list_str = ''.join(word_list)\n    word_list_reversed_str_list = list(word_list_reversed_str)\n    word_list_str_list = list(word_list_str)\n    for i in range(len(word_list_reversed_str_list)):\n        if word_list_reversed_str_list[i] in vowels_list:\n            for j in range(len(word_list_str_list)):\n                if word_list_str_list[j] in consonants_list:\n                    if word_list_str_list[j] == word_list_reversed_str_list[i]:\n                        return word_list_str_list[j]\n    return 'No closest vowel'\n",
        "def closest_vowel(word):\n    vowels = 'aeiou'\n    word = word.lower()\n    consonants = ''\n    for i in range(len(word)):\n        if word[i] in vowels:\n            return word[i]\n        else:\n            consonants += word[i]\n    for i in range(len(consonants)):\n        if consonants[i] in vowels:\n            return consonants[i]\n    return None\n"
    ],
    "results": 10
},{
    "id": "2427",
    "source": "humanEval",
    "language": "python",
    "query": "You are given a list of two strings, both strings consist of open parentheses '(' or close parentheses ')' only. Your job is to check if it is possible to concatenate the two strings in some order, that the resulting string will be good.",
    "snippets": [
        "def is_balanced(s):\n    stack = []\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    return len(stack) == 0\n",
        "def is_balanced(s):\n    stack = []\n    for i in s:\n        if i == '(':\n            stack.append(i)\n        else:\n            if len(stack) == 0:\n                return False\n            else:\n                stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_good(s1, s2):\n    stack = []\n    for i in range(len(s1)):\n        if s1[i] == '(':\n            stack.append(s1[i])\n        else:\n            if len(stack) == 0:\n                return False\n            stack.pop()\n    if len(stack) == 0:\n        return True\n    else:\n        return False\n",
        "def is_good(s1, s2):\n    if s1 == s2:\n        return True\n    if s1 == '':\n        return True\n    if s2 == '':\n        return True\n    if s1[0] == '(' and s2[0] == ')':\n        return is_good(s1[1:], s2[1:])\n    if s1[0] == ')' and s2[0] == '(':\n        return is_good(s1[1:], s2[1:])\n    return False\n"
    ],
    "results": 10
},{
    "id": "2428",
    "source": "humanEval",
    "language": "python",
    "query": "Given an array arr of integers and a positive integer k, return a sorted list of length k with the maximum k numbers in arr. The length of the array will be in the range of [1, 1].",
    "snippets": [
        "def max_k(arr, k):\n    return sorted(arr, reverse=True)[:k]\n",
        "def max_k_numbers(arr, k):\n    return sorted(arr, reverse=True)[:k]\n",
        "def max_k_numbers(arr, k):\n    return sorted(arr)[-k:]\n"
    ],
    "results": 10
},{
    "id": "2429",
    "source": "humanEval",
    "language": "python",
    "query": "Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions. Examples include: solution([5, 8, 7, 1], solution([3, 3, 3,. 3], solution[30, 13, 24, 321]",
    "snippets": [
        "def solution(lst):\n    sum = 0\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            if lst[i] % 2 != 0:\n                sum += lst[i]\n    return sum\n",
        "def solution(lst):\n    sum = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum\n"
    ],
    "results": 10
},{
    "id": "2430",
    "source": "humanEval",
    "language": "python",
    "query": "Given a non-empty array of integers arr and an integer k, return the sum of the elements with at most two digits from the first k elements of arr. Example: arr = [111,21,3,4000,5,6,7,8,9], k = 4.",
    "snippets": [
        "def sumOfTwoDigits(arr, k):\n    sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum\n",
        "def sum_of_two_digits(arr, k):\n    sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum\n",
        "def sum_two_digits(arr, k):\n    sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum\n",
        "def sum_of_two_digits(arr, k):\n    sum = 0\n    for i in range(k):\n        if arr[i] < 100:\n            sum += arr[i]\n        else:\n            sum += int(arr[i] / 10) + int(arr[i] % 10)\n    return sum\n",
        "def sum_of_two_digits(arr, k):\n    sum = 0\n    for i in range(k):\n        if arr[i] < 100:\n            sum += arr[i]\n        else:\n            sum += int(str(arr[i])[0]) + int(str(arr[i])[1])\n    return sum\n",
        "def sum_of_digits(arr, k):\n    sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum\n",
        "def sum_of_two_digits(arr, k):\n    sum = 0\n    for i in range(k):\n        if arr[i] < 10:\n            sum += arr[i]\n        else:\n            sum += int(str(arr[i])[0]) + int(str(arr[i])[1])\n    return sum\n",
        "def sum_two_digits_at_most_two_digits(arr, k):\n    sum = 0\n    for i in range(k):\n        if arr[i] < 100:\n            sum += arr[i]\n        else:\n            sum += int(str(arr[i])[0]) + int(str(arr[i])[1])\n    return sum\n"
    ],
    "results": 10
},{
    "id": "2431",
    "source": "humanEval",
    "language": "python",
    "query": "The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined by a positive integer n. The conjecture is that no matter what value of n, the sequence will always reach 1.",
    "snippets": [
        "def collatz(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return 3 * n + 1\n"
    ],
    "results": 10
},{
    "id": "2432",
    "source": "humanEval",
    "language": "python",
    "query": "The date is valid if all of the following rules are satisfied: The date string is not empty. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12.",
    "snippets": [
        "def is_valid_date(date):\n    if date == '':\n        return False\n    else:\n        date_list = date.split('-')\n        if len(date_list) != 3:\n            return False\n        else:\n            if int(date_list[0]) < 1 or int(date_list[0]) > 12:\n                return False\n            else:\n                if int(date_list[1]) < 1 or int(date_list[1]) > 31:\n                    return False\n                else:\n                    if int(date_list[2]) < 1 or int(date_list[2]) > 31:\n                        return False\n                    else:\n                        return True\n",
        "def is_valid_date(date):\n    if date == '':\n        return False\n    else:\n        date_list = date.split('-')\n        if len(date_list) != 3:\n            return False\n        else:\n            if int(date_list[0]) < 1 or int(date_list[0]) > 12:\n                return False\n            elif int(date_list[1]) < 1 or int(date_list[1]) > 31:\n                return False\n            elif int(date_list[2]) < 1 or int(date_list[2]) > 2020:\n                return False\n            else:\n                return True\n",
        "def is_valid_date(date):\n    if date == '':\n        return False\n    else:\n        date_list = date.split('-')\n        if len(date_list) != 3:\n            return False\n        else:\n            if int(date_list[0]) < 1 or int(date_list[0]) > 12:\n                return False\n            if int(date_list[1]) < 1 or int(date_list[1]) > 31:\n                return False\n            if int(date_list[2]) < 1 or int(date_list[2]) > 2020:\n                return False\n            return True\n",
        "def is_valid_date(date):\n    if date == '':\n        return False\n    else:\n        date_list = date.split('-')\n        if len(date_list) != 3:\n            return False\n        else:\n            if int(date_list[0]) < 1 or int(date_list[0]) > 31:\n                return False\n            elif int(date_list[1]) < 1 or int(date_list[1]) > 12:\n                return False\n            elif int(date_list[2]) < 1 or int(date_list[2]) > 9999:\n                return False\n            else:\n                return True\n",
        "def is_valid_date(date):\n    if date == '':\n        return False\n    date_list = date.split('-')\n    if len(date_list) != 3:\n        return False\n    if int(date_list[0]) < 1 or int(date_list[0]) > 12:\n        return False\n    if int(date_list[1]) < 1 or int(date_list[1]) > 31:\n        return False\n    if int(date_list[2]) < 1 or int(date_list[2]) > 9999:\n        return False\n    return True\n",
        "def is_valid_date(date):\n    if date == \"\":\n        return False\n    date_list = date.split(\"-\")\n    if len(date_list) != 3:\n        return False\n    if int(date_list[0]) < 1 or int(date_list[0]) > 31:\n        return False\n    if int(date_list[1]) < 1 or int(date_list[1]) > 12:\n        return False\n    if int(date_list[2]) < 1 or int(date_list[2]) > 9999:\n        return False\n    return True\n",
        "def is_valid_date(date):\n    if date == \"\":\n        return False\n    else:\n        date_list = date.split(\"-\")\n        if len(date_list) != 3:\n            return False\n        else:\n            if int(date_list[0]) < 1 or int(date_list[0]) > 31:\n                return False\n            elif int(date_list[1]) < 1 or int(date_list[1]) > 12:\n                return False\n            elif int(date_list[2]) < 1 or int(date_list[2]) > 9999:\n                return False\n            else:\n                return True\n",
        "def is_valid_date(date):\n    if date == '':\n        return False\n    else:\n        date = date.split('-')\n        if int(date[0]) < 1 or int(date[0]) > 31:\n            return False\n        if int(date[1]) < 1 or int(date[1]) > 12:\n            return False\n        if int(date[2]) < 1 or int(date[2]) > 9999:\n            return False\n        if int(date[1]) == 1 or int(date[1]) == 3 or int(date[1]) == 5 or int(date[1]) == 7 or int(date[1]) == 8 or int(date[1]) == 10 or int(date[1]) == 12:\n            if int(date[0]) > 31:\n                return False\n        if int(date[1]) == 4 or int(date[1]) == 6 or int(date[1]) == 9 or int(date[1]) == 11:\n            if int(date[0]) > 30:\n                return False\n        if int(date[1]) == 2:\n            if int(date[0]) > 28:\n                return False\n        return True\n",
        "def is_valid_date(date):\n    if date == '':\n        return False\n    else:\n        day, month, year = date.split('-')\n        if int(day) < 1 or int(day) > 31:\n            return False\n        if int(month) == 1 or int(month) == 3 or int(month) == 5 or int(month) == 7 or int(month) == 8 or int(month) == 10 or int(month) == 12:\n            if int(day) > 31:\n                return False\n        if int(month) == 4 or int(month) == 6 or int(month) == 9 or int(month) == 11:\n            if int(day) > 30:\n                return False\n        if int(month) == 2:\n            if int(day) > 28:\n                return False\n            if int(year) % 4 == 0:\n                if int(day) > 29:\n                    return False\n            else:\n                if int(day) > 28:\n                    return False\n        return True\n",
        "def is_valid_date(date):\n    if date == \"\":\n        return False\n    else:\n        date = date.split(\"-\")\n        if int(date[0]) < 1 or int(date[0]) > 31:\n            return False\n        if int(date[1]) < 1 or int(date[1]) > 12:\n            return False\n        if int(date[2]) < 1 or int(date[2]) > 9999:\n            return False\n        if int(date[1]) == 2:\n            if int(date[0]) > 28:\n                return False\n        if int(date[1]) in [4, 6, 9, 11]:\n            if int(date[0]) > 30:\n                return False\n        return True\n"
    ],
    "results": 10
},{
    "id": "2433",
    "source": "humanEval",
    "language": "python",
    "query": "Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the alphabet.",
    "snippets": [
        "def split_words(text):\n    if text.find(' ') != -1:\n        return text.split(' ')\n    elif text.find(',') != -1:\n        return text.split(',')\n    else:\n        return [word for word in text if word.islower() and word.find(' ') == -1 and word.find(',') == -1]\n",
        "def split_words(text):\n    if text.find(' ') != -1:\n        return text.split(' ')\n    elif text.find(',') != -1:\n        return text.split(',')\n    else:\n        return [x for x in text if x.islower() and text.index(x) % 2 == 1]\n",
        "def split_string(string):\n    if string.find(' ') != -1:\n        return string.split(' ')\n    elif string.find(',') != -1:\n        return string.split(',')\n    else:\n        return [x for x in string if x.islower() and string.index(x) % 2 == 1]\n",
        "def split_string(string):\n    if ' ' in string:\n        return string.split(' ')\n    elif ',' in string:\n        return string.split(',')\n    else:\n        return [i for i in string if i.islower() and string.index(i) % 2 == 1]\n",
        "def split_string(string):\n    return string.split()\n    # return string.split(' ')\n    # return string.split(',')\n    # return string.split('.')\n    # return string.split('!')\n    # return string.split('?')\n    # return string.split(';')\n    # return string.split(':')\n    # return string.split('\\n')\n    # return string.split('\\t')\n    # return string.split('\\r')\n    # return string.split('\\f')\n    # return string.split('\\v')\n    # return string.split('\\a')\n    # return string.split('\\b')\n    # return string.split('\\0')\n    # return string.split('\\x0')\n    # return string.split('\\x')\n    # return string.split('\\u')\n    # return string.split('\\U')\n    # return string.split('\\N')\n    # return string.split('\\X')\n    # return string.split('\\x')\n    # return string.split('\\u')\n    # return string.split('\\U')\n    # return string.split('\\N')\n    # return string.split('\\X')\n    # return string.split('\\x')\n    # return string.split('\\u')\n    # return string.split('\\U')\n    # return string.split('\\N')\n    # return string.split('\\X')\n    # return string.split('\\x')\n    # return string.split('\\u')\n    # return string.split('\\U')\n    # return string.split('\\N')\n    # return string.split('\\X')\n    # return string.split('\\x')\n    # return string.split('\\u')\n    # return string.split('\\U')\n    # return string.split('\\N')\n    # return string.split('\\X')\n    # return string.split('\\x')\n    # return string.split('\\u')\n    # return string.split('\\U')\n    # return string.split\n"
    ],
    "results": 7
},{
    "id": "2434",
    "source": "humanEval",
    "language": "python",
    "query": "Given a list of numbers, return whether or not they are sorted in ascending order. If list has more than 1 duplicate of the same number, return False. Assume no negative numbers and only integers.",
    "snippets": [
        "def is_sorted(numbers):\n    for i in range(len(numbers)-1):\n        if numbers[i] > numbers[i+1]:\n            return False\n    return True\n",
        "def is_sorted(nums):\n    for i in range(len(nums)-1):\n        if nums[i] > nums[i+1]:\n            return False\n    return True\n",
        "def is_sorted(numbers):\n    if numbers == sorted(numbers):\n        return True\n    else:\n        return False\n",
        "def is_sorted(numbers):\n    if len(numbers) == 0:\n        return True\n    if len(numbers) == 1:\n        return True\n    if numbers[0] > numbers[1]:\n        return False\n    for i in range(len(numbers)-1):\n        if numbers[i] > numbers[i+1]:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2435",
    "source": "humanEval",
    "language": "python",
    "query": "You are given two intervals, where each interval is a pair of integers. For each given interval, it is assumed that its start is less or equal its end. Your task is to determine whether the length of intersection of these two intervals is a prime number.",
    "snippets": [
        "def is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True\n",
        "def is_prime(n):\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n",
        "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n",
        "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n"
    ],
    "results": 10
},{
    "id": "2436",
    "source": "humanEval",
    "language": "python",
    "query": "prod_signs is a function that returns the sum of magnitudes of integers multiplied by product of all signs of each number in the array. Note: return None for empty arr.",
    "snippets": [
        "def prod_signs(arr):\n    if len(arr) == 0:\n        return None\n    else:\n        prod = 1\n        sum = 0\n        for i in arr:\n            prod *= i\n            sum += abs(i)\n        return sum * prod\n",
        "def prod_signs(arr):\n    if len(arr) == 0:\n        return None\n    else:\n        prod = 1\n        for i in arr:\n            prod *= i\n        sum = 0\n        for i in arr:\n            sum += abs(i)\n        return sum * prod\n",
        "def prod_signs(arr):\n    if not arr:\n        return None\n    prod = 1\n    for i in arr:\n        prod *= i\n    return sum(abs(i) for i in arr) * prod\n",
        "def prod_signs(arr):\n    if not arr:\n        return None\n    else:\n        prod = 1\n        sum = 0\n        for i in arr:\n            prod *= i\n            sum += abs(i)\n        return sum * prod\n"
    ],
    "results": 10
},{
    "id": "2437",
    "source": "humanEval",
    "language": "python",
    "query": "Given a grid with N rows and N columns (N >= 2) and a positive integer k, each cell of the grid contains a value. You have to find the minimum path of length k in the grid. A path A is considered less than a path B (of length k) if A and B go through the same cell.",
    "snippets": [
        "def min_path(grid, k):\n    if k == 1:\n        return grid[0][0]\n    if k == 2:\n        return min(grid[0][0], grid[0][1], grid[1][0])\n    if k == 3:\n        return min(grid[0][0], grid[0][1], grid[0][2], grid[1][0], grid[1][1], grid[1][2], grid[2][0], grid[2][1], grid[2][2])\n    if k == 4:\n        return min(grid[0][0], grid[0][1], grid[0][2], grid[0][3], grid[1][0], grid[1][1], grid[1][2], grid[1][3], grid[2][0], grid[2][1], grid[2][2], grid[2][3], grid[3][0], grid[3][1], grid[3][2], grid[3][3])\n    if k == 5:\n        return min(grid[0][0], grid[0][1], grid[0][2], grid[0][3], grid[0][4], grid[1][0], grid[1][1], grid[1][2], grid[1][3], grid[1][4], grid[2][0], grid[2][1], grid[2][2], grid[2][3], grid[2][4], grid[3][0], grid[3][1], grid[3][2], grid[3][3], grid[3][4], grid[4][0], grid[4][1], grid[4][2], grid[4][3], grid[4][4])\n    if k == 6:\n        return min(grid[0][0], grid[0][1], grid[0][2], grid[0][3], grid[0][4], grid[0][5], grid[1][0], grid[1][1], grid[1][2], grid[1][3], grid[1][4], grid[1][5], grid[2][0], grid[2][1], grid[2][2], grid[2][3], grid\n",
        "def min_path(grid, k):\n    if not grid or not grid[0]:\n        return 0\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[n - 1][m - 1]\n",
        "def min_path(grid, k):\n    if not grid:\n        return None\n    if not grid[0]:\n        return None\n    if not grid[0][0]:\n        return None\n    if not grid[0][0][0]:\n        return None\n    if not grid[0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if not grid[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]:\n        return None\n    if\n",
        "def min_path(grid, k):\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[n - 1][m - 1]\n",
        "def min_path(grid, k):\n    if not grid or not grid[0]:\n        return None\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[n - 1][m - 1]\n",
        "def min_path(grid, k):\n    if not grid or not grid[0]:\n        return None\n    n = len(grid)\n    m = len(grid[0])\n    if k > n * m:\n        return None\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = grid[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + grid[i][0]\n    for j in range(1, m):\n        dp[0][j] = dp[0][j - 1] + grid[0][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n    return dp[n - 1][m - 1]\n",
        "def min_path(grid, k):\n    if not grid or not grid[0]:\n        return None\n    if k == 1:\n        return grid[0][0]\n    if k == 2:\n        return min(grid[0][0], grid[0][1], grid[1][0])\n    if k == 3:\n        return min(grid[0][0], grid[0][1], grid[1][0], grid[1][1])\n    if k == 4:\n        return min(grid[0][0], grid[0][1], grid[1][0], grid[1][1], grid[2][0], grid[2][1])\n    if k == 5:\n        return min(grid[0][0], grid[0][1], grid[1][0], grid[1][1], grid[2][0], grid[2][1], grid[3][0], grid[3][1])\n    if k == 6:\n        return min(grid[0][0], grid[0][1], grid[1][0], grid[1][1], grid[2][0], grid[2][1], grid[3][0], grid[3][1], grid[4][0], grid[4][1])\n    if k == 7:\n        return min(grid[0][0], grid[0][1], grid[1][0], grid[1][1], grid[2][0], grid[2][1], grid[3][0], grid[3][1], grid[4][0], grid[4][1], grid[5][0], grid[5][1])\n    if k == 8:\n        return min(grid[0][0], grid[0][1], grid[1][0], grid[1][1], grid[2][0], grid[2][1], grid[3][0], grid[3][1], grid[4][0], grid[4][1], grid[5][0], grid[5][1], grid[6][0], grid[6][1])\n    if k == 9:\n        return min(grid[0][0], grid[0][1], grid[1][0], grid[1][\n"
    ],
    "results": 10
},{
    "id": "2438",
    "source": "humanEval",
    "language": "python",
    "query": "Tronacci sequence is defined by the recurrence: tri(1) = 3. You are given a non-negative integer number n, you have to return a list of the first n + 1 numbers of the Tribonacci sequence. For example, tri(3) = [1, 3, 2, 8]",
    "snippets": [
        "def tribonacci(n):\n    if n == 0:\n        return []\n    elif n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 3]\n    else:\n        return tribonacci(n-1) + [tribonacci(n-1)[-1] + tribonacci(n-2)[-1] + tribonacci(n-3)[-1]]\n",
        "def tribonacci(n):\n    if n == 0:\n        return []\n    elif n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 3]\n    else:\n        return tribonacci(n - 1) + [sum(tribonacci(n - 1))]\n",
        "def tribonacci(n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 3]\n    if n == 3:\n        return [1, 3, 2]\n    tribonacci_list = [1, 3, 2]\n    for i in range(n - 3):\n        tribonacci_list.append(tribonacci_list[-1] + tribonacci_list[-2] + tribonacci_list[-3])\n    return tribonacci_list\n",
        "def tribonacci(n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 3]\n    tribonacci_list = [1, 3, 2]\n    for i in range(n - 2):\n        tribonacci_list.append(tribonacci_list[-1] + tribonacci_list[-2] + tribonacci_list[-3])\n    return tribonacci_list\n",
        "def tribonacci(n):\n    if n == 0:\n        return []\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 1]\n    if n == 3:\n        return [1, 1, 2]\n    trib = [1, 1, 2]\n    for i in range(3, n + 1):\n        trib.append(trib[i - 1] + trib[i - 2] + trib[i - 3])\n    return trib\n",
        "def tribonacci(n):\n    tribonacci_sequence = [1, 3, 2]\n    if n == 0:\n        return []\n    elif n == 1:\n        return [1]\n    elif n == 2:\n        return [1, 3]\n    else:\n        for i in range(n - 2):\n            tribonacci_sequence.append(tribonacci_sequence[-1] + tribonacci_sequence[-2] + tribonacci_sequence[-3])\n        return tribonacci_sequence\n"
    ],
    "results": 10
},{
    "id": "2439",
    "source": "humanEval",
    "language": "python",
    "query": "Given a positive integer n, return the product of the odd digits. Return 0 if all digits are even.",
    "snippets": [
        "def odd_product(n):\n    if n == 0:\n        return 0\n    else:\n        return odd_product(n // 10) * (n % 10) if n % 2 else odd_product(n // 10)\n",
        "def odd_product(n):\n    if n == 0:\n        return 0\n    else:\n        return odd_product(n // 10) * (n % 10) if n % 2 == 1 else odd_product(n // 10)\n",
        "def odd_product(n):\n    if n == 0:\n        return 0\n    else:\n        return odd_product(n // 10) * (n % 10) if n % 2 != 0 else odd_product(n // 10)\n",
        "def odd_product(n):\n    if n == 0:\n        return 0\n    else:\n        return int(n % 10) * odd_product(n // 10)\n",
        "def odd_product(n):\n    if n == 0:\n        return 0\n    else:\n        return odd_product(n//10) * (n%10)\n"
    ],
    "results": 10
},{
    "id": "2440",
    "source": "humanEval",
    "language": "python",
    "query": "create a function that takes a string as input which contains only square brackets. The function should return True if and only if there is a valid subsequence of brackets    where at least one bracket is nested.",
    "snippets": [
        "def valid_brackets(string):\n    if string == '':\n        return True\n    if string[0] == ']':\n        return False\n    if string[-1] == '[':\n        return False\n    if string[0] == '[' and string[-1] == ']':\n        return valid_brackets(string[1:-1])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[-1] == ']':\n        return valid_brackets(string[:-1])\n    return valid_brackets(string[1:-1])\n",
        "def valid_brackets(string):\n    if string == '':\n        return True\n    if string[0] == ']':\n        return False\n    if string[-1] == '[':\n        return False\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[-1] == ']':\n        return valid_brackets(string[:-1])\n    if string[0] == '[' and string[-1] == ']':\n        return valid_brackets(string[1:-1])\n    return False\n",
        "def valid_brackets(string):\n    if string == \"\":\n        return True\n    if string[0] == \"]\":\n        return False\n    if string[-1] == \"[\":\n        return False\n    if string[0] == \"[\" and string[-1] == \"]\":\n        return valid_brackets(string[1:-1])\n    if string[0] == \"[\":\n        return valid_brackets(string[1:])\n    if string[-1] == \"]\":\n        return valid_brackets(string[:-1])\n    return False\n",
        "def valid_brackets(string):\n    if string == '':\n        return True\n    if string[0] == '[' and string[-1] == ']':\n        return valid_brackets(string[1:-1])\n    else:\n        return False\n",
        "def valid_brackets(string):\n    if string == \"\":\n        return True\n    if string[0] == \"]\":\n        return False\n    if string[-1] == \"[\":\n        return False\n    if string[0] == \"[\":\n        return valid_brackets(string[1:])\n    if string[-1] == \"]\":\n        return valid_brackets(string[:-1])\n    if string[0] == \"[\" and string[-1] == \"]\":\n        return valid_brackets(string[1:-1])\n    return False\n",
        "def valid_brackets(string):\n    if string == '':\n        return True\n    if string[0] == ']':\n        return False\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string\n",
        "def valid_brackets(string):\n    if string == '':\n        return True\n    if string[0] == ']' or string[0] == ')':\n        return False\n    if string[0] == '(':\n        return valid_brackets(string[1:])\n    if string[0] == '[':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == ')':\n        return valid_brackets(string[1:])\n    if string[0] == '}':\n        return valid_brackets(string[1:])\n    if string[0] == '{':\n        return valid_brackets(string[1:])\n    if string[0] == ')':\n        return valid_brackets(string[1:])\n    if string[0] == '}':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '}':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '}':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '}':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '}':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string[0] == '}':\n        return valid_brackets(string[1:])\n    if string[0] == ']':\n        return valid_brackets(string[1:])\n    if string\n",
        "def valid_brackets(string):\n    if len(string) % 2 != 0:\n        return False\n    else:\n        for i in range(len(string)):\n            if string[i] == '[' and string[i+1] == ']':\n                return True\n            elif string[i] == '{' and string[i+1] == '}':\n                return True\n            elif string[i] == '(' and string[i+1] == ')':\n                return True\n        return False\n",
        "def valid_brackets(string):\n    # create a stack\n    stack = []\n    # create a dictionary\n    d = {'[': ']', '{': '}', '(': ')'}\n    # loop through the string\n    for i in string:\n        # if the current character is a key in the dictionary\n        if i in d:\n            # push the key to the stack\n            stack.append(i)\n        # if the current character is a value in the dictionary\n        elif i in d.values():\n            # if the stack is empty\n            if not stack:\n                # return false\n                return False\n            # if the top of the stack is not equal to the value of the current character\n            if stack[-1] != d[i]:\n                # return false\n                return False\n            # if the top of the stack is equal to the value of the current character\n            else:\n                # pop the top of the stack\n                stack.pop()\n    # if the stack is empty\n    if not stack:\n        # return true\n        return True\n    # if the stack is not empty\n    else:\n        # return false\n        return False\n"
    ],
    "results": 9
},{
    "id": "2441",
    "source": "humanEval",
    "language": "python",
    "query": "You are given a list of numbers. You need to return the sum of squared numbers in the given list. Round each element in the list to the upper int(Ceiling) first.",
    "snippets": [
        "def square_sum(numbers):\n    return sum(map(lambda x: int(x**2), numbers))\n",
        "def square_sum(numbers):\n    return sum([int(x**2) for x in numbers])\n",
        "def square_sum(numbers):\n    return sum([int(x)**2 for x in numbers])\n",
        "def square_sum(numbers):\n    return sum(map(lambda x: x**2, numbers))\n"
    ],
    "results": 10
},{
    "id": "2442",
    "source": "humanEval",
    "language": "python",
    "query": "create a function that returns True if the last character of a given string is an alphabetical character and is not a part of a word. Note: \"word\" is a group of characters separated by space. Examples: check_if_last_char_is_a_letter(\"apple pie\") ? False.",
    "snippets": [
        "def check_if_last_char_is_a_letter(string):\n    if string[-1].isalpha():\n        return True\n    else:\n        return False\n",
        "def check_if_last_char_is_a_letter(string):\n    if string[-1].isalpha() and string[-1] not in string.split():\n        return True\n    else:\n        return False\n",
        "def check_if_last_char_is_a_letter(string):\n    if string[-1].isalpha() and string.count(string[-1]) == 1:\n        return True\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "2443",
    "source": "humanEval",
    "language": "python",
    "query": "can_arrange() returns the largest index of an element which is not greater than or equal to the element immediately preceding it. If no such element exists then return -1. The given array will not contain duplicate values.",
    "snippets": [
        "def can_arrange(arr, n):\n    arr.sort()\n    for i in range(n):\n        if arr[i] >= arr[i-1]:\n            return i\n    return -1\n",
        "def can_arrange(arr):\n    arr.sort()\n    for i in range(len(arr)):\n        if arr[i] >= arr[i-1]:\n            return i\n    return -1\n",
        "def can_arrange(arr, n):\n    # Write your code here.\n    arr.sort()\n    for i in range(n-1):\n        if arr[i] >= arr[i+1]:\n            return i\n    return -1\n",
        "def can_arrange(arr, k):\n    for i in range(len(arr)):\n        if arr[i] >= k - arr[i]:\n            return i\n    return -1\n",
        "def can_arrange(arr, k):\n    for i in range(len(arr)):\n        if arr[i] >= k - i:\n            return i\n    return -1\n",
        "def can_arrange(arr, n):\n    if n == 1:\n        return 0\n    if n == 2:\n        if arr[0] == arr[1]:\n            return -1\n        return 0\n    if arr[0] > arr[1]:\n        return 0\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[1]:\n        return 1\n    if arr[0] == arr[1]:\n        return -1\n    if arr[0] < arr[1]:\n        return 1\n    if arr[0] > arr[\n",
        "def can_arrange(arr, k):\n    # Write your code here.\n    for i in range(len(arr)):\n        if arr[i] >= k - i:\n            return i\n    return -1\n",
        "def can_arrange(arr):\n    arr.sort()\n    for i in range(len(arr)):\n        if arr[i] < arr[i-1]:\n            return i-1\n    return -1\n",
        "def can_arrange(arr, n):\n    for i in range(n):\n        if arr[i] >= arr[i + 1]:\n            return i\n    return -1\n"
    ],
    "results": 10
},{
    "id": "2444",
    "source": "humanEval",
    "language": "python",
    "query": "Create a function that returns a tuple (a, b), where 'a' is the largest of negative integers. If there is no negative or positive integers, return them as None. Examples: largest_smallest_integers([2, 4, 1, 3, 5, 7] != (None, 1)",
    "snippets": [
        "def largest_smallest_integers(lst):\n    if lst == []:\n        return (None, None)\n    else:\n        lst.sort()\n        return (lst[0], lst[-1])\n",
        "def largest_smallest_integers(lst):\n    if lst == []:\n        return (None, None)\n    else:\n        lst.sort()\n        return (lst[-1], lst[0])\n",
        "def largest_smallest_integers(lst):\n    if len(lst) == 0:\n        return (None, None)\n    else:\n        lst.sort()\n        return (lst[-1], lst[0])\n",
        "def largest_smallest_integers(arr):\n    if len(arr) == 0:\n        return None, None\n    else:\n        largest = -1\n        smallest = 100\n        for i in arr:\n            if i > largest:\n                largest = i\n            if i < smallest:\n                smallest = i\n        return largest, smallest\n"
    ],
    "results": 10
},{
    "id": "2445",
    "source": "humanEval",
    "language": "python",
    "query": "Compare is a function that takes an integer or a string and returns the larger variable in its given variable type. It returns None if the values are equal.",
    "snippets": [
        "def compare(a, b):\n    if a > b:\n        return a\n    elif a < b:\n        return b\n    else:\n        return None\n",
        "def compare(a, b):\n    if type(a) == type(b):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    else:\n        return None\n",
        "def compare(a, b):\n    if a == b:\n        return None\n    elif a > b:\n        return a\n    else:\n        return b\n"
    ],
    "results": 10
},{
    "id": "2446",
    "source": "humanEval",
    "language": "python",
    "query": "\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\" \"Is_equal_to_sum_even(4) is_equal-to-sum-even(5) is�equal�to�sum-of-even numbers (6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46",
    "snippets": [
        "def Is_equal_to_sum_even(n):\n    for i in range(1, n):\n        if n == i + i + i + i:\n            return True\n    return False\n",
        "def Is_equal_to_sum_even(n):\n    for i in range(1, n):\n        if n % i == 0:\n            if i % 2 == 0:\n                if n / i == i:\n                    return True\n    return False\n",
        "def Is_equal_to_sum_even(n):\n    if n % 2 != 0:\n        return False\n    else:\n        for i in range(1, n // 2 + 1):\n            if n == i + i + i + i:\n                return True\n        return False\n",
        "def Is_equal_to_sum_even(n):\n    if n % 2 != 0:\n        return False\n    else:\n        if n == 2:\n            return True\n        else:\n            if n == 4:\n                return True\n            else:\n                if n == 6:\n                    return True\n                else:\n                    if n == 8:\n                        return True\n                    else:\n                        if n == 10:\n                            return True\n                        else:\n                            if n == 12:\n                                return True\n                            else:\n                                if n == 14:\n                                    return True\n                                else:\n                                    if n == 16:\n                                        return True\n                                    else:\n                                        if n == 18:\n                                            return True\n                                        else:\n                                            if n == 20:\n                                                return True\n                                            else:\n                                                if n == 22:\n                                                    return True\n                                                else:\n                                                    if n == 24:\n                                                        return True\n                                                    else:\n                                                        if n == 26:\n                                                            return True\n                                                        else:\n                                                            if n == 28:\n                                                                return True\n                                                            else:\n                                                                if n == 30:\n                                                                    return True\n                                                                else:\n                                                                    if n == 32:\n                                                                        return True\n                                                                    else:\n                                                                        if n == 34:\n                                                                            return True\n                                                                        else:\n                                                                            if n == 36:\n                                                                                return True\n                                                                            else:\n                                                                                if n == 38:\n                                                                                    return True\n                                                                                else:\n                                                                                    if n == 40:\n                                                                                        return True\n                                                                                    else:\n                                                                                        if n == 42:\n                                                                                            return True\n                                                                                        else:\n                                                                                            if n == 44:\n                                                                                                return True\n                                                                                            else:\n",
        "def Is_equal_to_sum_even(n):\n    if n % 2 == 0:\n        for i in range(1, n // 2 + 1):\n            if n == i + i + i + i:\n                return True\n    return False\n",
        "def Is_equal_to_sum_even(n):\n    if n % 2 == 1:\n        return False\n    else:\n        for i in range(1, n // 2 + 1):\n            if n == i + i + i + i:\n                return True\n        return False\n",
        "def Is_equal_to_sum_even(n):\n    if n % 2 == 0:\n        if n == 2:\n            return True\n        else:\n            for i in range(2, n, 2):\n                if n == i:\n                    return True\n                else:\n                    return False\n    else:\n        return False\n",
        "def Is_equal_to_sum_even(n):\n    for i in range(1, n):\n        if i % 2 == 0:\n            if n == i + i + i + i:\n                return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "2447",
    "source": "humanEval",
    "language": "python",
    "query": "The Brazilian factorial is defined as: brazilian_factorial(n) = n! * (n-1)! * ( n-2)! * ... * 1! where n > 0.",
    "snippets": [
        "def brazilian_factorial(n):\n    if n == 0:\n        return 1\n    else:\n        return n * brazilian_factorial(n-1)\n"
    ],
    "results": 10
},{
    "id": "2448",
    "source": "humanEval",
    "language": "python",
    "query": "Given a string text, replace all spaces in it with underscores. If a string has more than 2 consecutive spaces, then replace all consecutive spaces with -.",
    "snippets": [
        "def replace_spaces(text):\n    return text.replace(' ', '_').replace('  ', '-')\n",
        "def replace_spaces(text):\n    return text.replace(\" \", \"_\").replace(\"  \", \"-\")\n"
    ],
    "results": 10
},{
    "id": "2449",
    "source": "humanEval",
    "language": "python",
    "query": "A file's name is considered to be valid if and only if all the following conditions are met. There should not be more than three digits ('0'-'9') in the name. The name should start with a latin alphapet letter (a'-'z' and 'A'-'Z').",
    "snippets": [
        "def is_valid_file_name(file_name):\n    if len(file_name) > 3:\n        return False\n    if file_name[0] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    if file_name[1] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    if file_name[2] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    if file_name[3] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    return True\n",
        "def is_valid_file_name(file_name):\n    if len(file_name) > 3:\n        return False\n    if file_name[0] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    for i in range(1, len(file_name)):\n        if file_name[i] not in '0123456789':\n            return False\n    return True\n",
        "def is_valid_file_name(file_name):\n    if len(file_name) > 3:\n        return False\n    if file_name[0] not in string.ascii_letters:\n        return False\n    if file_name[1] not in string.digits:\n        return False\n    if file_name[2] not in string.digits:\n        return False\n    return True\n",
        "def is_valid_name(name):\n    if len(name) > 3:\n        return False\n    if name[0] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    if name[1] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    if name[2] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    if name[3] not in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':\n        return False\n    return True\n",
        "def is_valid_file_name(file_name):\n    if len(file_name) > 3:\n        return False\n    if file_name[0].isalpha() == False:\n        return False\n    if file_name[1:].isdigit() == False:\n        return False\n    return True\n",
        "def is_valid_file_name(file_name):\n    if len(file_name) > 3:\n        return False\n    if file_name[0].isalpha() == False:\n        return False\n    if file_name[1:].isdigit() == True:\n        return False\n    return True\n",
        "def is_valid_file_name(file_name):\n    if len(file_name) > 3 and file_name[0].isalpha() and file_name[1:].isdigit() and file_name[2:].isdigit():\n        return True\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "2450",
    "source": "humanEval",
    "language": "python",
    "query": "The function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a multiple of 3. The function shall then return the sum of all entries. Examples: For lst = [1,2,3] the output should be 6.",
    "snippets": [
        "def sum_of_squares(lst):\n    sum = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            sum += lst[i] ** 2\n    return sum\n"
    ],
    "results": 10
},{
    "id": "2451",
    "source": "humanEval",
    "language": "python",
    "query": "You are given a string representing a sentence. The sentence contains some words separated by a space. You have to return a string that contains the words from the original sentence.",
    "snippets": [
        "def reverse_sentence(sentence):\n    return ' '.join(sentence.split()[::-1])\n",
        "def reverse_words(sentence):\n    return ' '.join(sentence.split()[::-1])\n",
        "def separate_words(sentence):\n    return \" \".join(sentence.split())\n",
        "def separate_words(sentence):\n    return ' '.join(sentence.split())\n",
        "def reverse_words(sentence):\n    return \" \".join(sentence.split(\" \")[::-1])\n",
        "def reverse_words(s):\n    return ' '.join(s.split()[::-1])\n",
        "def reorder_sentence(sentence):\n    words = sentence.split()\n    words.sort()\n    return ' '.join(words)\n"
    ],
    "results": 10
},{
    "id": "2452",
    "source": "humanEval",
    "language": "python",
    "query": "Simplify is a function that will simplify the expression x * n. The function returns True if x* n evaluates to a whole number and False if it does not.",
    "snippets": [
        "def simplify(x, n):\n    if x * n == int(x * n):\n        return True\n    else:\n        return False\n",
        "def simplify(x, n):\n    if x * n % 1 == 0:\n        return True\n    else:\n        return False\n"
    ],
    "results": 10
},{
    "id": "2453",
    "source": "humanEval",
    "language": "python",
    "query": "order_by_points sorts the given list of integers in ascending order according to the sum of their digits. If there are several items with similar sum, order them based on their index in original list.",
    "snippets": [
        "def order_by_points(lst):\n    return sorted(lst, key=lambda x: (sum(int(i) for i in str(x)), x))\n",
        "def order_by_points(lst):\n    return sorted(lst, key=lambda x: sum(int(i) for i in str(x)))\n",
        "def order_by_points(lst):\n    lst.sort(key=lambda x: sum(int(i) for i in str(x)), reverse=True)\n    lst.sort(key=lambda x: x)\n    return lst\n",
        "def order_by_points(lst):\n    return sorted(lst, key=lambda x: sum(int(i) for i in str(x)), reverse=True)\n",
        "def order_by_points(lst):\n    lst.sort(key=lambda x: sum(int(i) for i in str(x)))\n    return lst\n"
    ],
    "results": 10
},{
    "id": "2454",
    "source": "humanEval",
    "language": "python",
    "query": "The first and last digits of a number are odd (1, 3, 5, 7, 9). For example: specialFilter($15, -73, 14, -15) is a function that takes an array of numbers as input.",
    "snippets": [
        "def specialFilter(arr):\n    return list(filter(lambda x: x % 2 != 0, arr))\n",
        "def specialFilter(arr):\n    return [x for x in arr if x % 2 != 0]\n"
    ],
    "results": 10
},{
    "id": "2455",
    "source": "humanEval",
    "language": "python",
    "query": "A is an integer array of length n. The only valid triple is (1, 3, 7, 13).",
    "snippets": [
        "def triple(A):\n    n = len(A)\n    for i in range(n):\n        if A[i] == 1:\n            if i + 1 < n and A[i + 1] == 3:\n                if i + 2 < n and A[i + 2] == 7:\n                    if i + 3 < n and A[i + 3] == 13:\n                        return True\n    return False\n",
        "def triple(A):\n    for i in range(len(A)):\n        if A[i] == 1:\n            if i + 1 < len(A) and A[i + 1] == 3:\n                if i + 2 < len(A) and A[i + 2] == 7:\n                    if i + 3 < len(A) and A[i + 3] == 13:\n                        return True\n    return False\n",
        "def triplet(A):\n    A.sort()\n    for i in range(len(A)-2):\n        if A[i] + A[i+1] > A[i+2]:\n            return True\n    return False\n"
    ],
    "results": 10
},{
    "id": "2456",
    "source": "humanEval",
    "language": "python",
    "query": "There are eight planets in our solar system: Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune. Write a function that takes two planet names as strings planet1 and planet2. The function should return an empty tuple if planet1 or planet2 are not correct planet names.",
    "snippets": [
        "def planet_names(planet1, planet2):\n    planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n    if planet1 in planets and planet2 in planets:\n        return (planet1, planet2)\n    else:\n        return ()\n",
        "def planet_check(planet1, planet2):\n    planets = ('Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune')\n    if planet1 in planets and planet2 in planets:\n        return (planet1, planet2)\n    else:\n        return ()\n"
    ],
    "results": 10
},{
    "id": "2457",
    "source": "humanEval",
    "language": "python",
    "query": "The list is always a list of strings and never an array of numbers. The order of the list should be ascending by length of each word. If two words have the same length, sort the list alphabetically.",
    "snippets": [
        "def sort_list(list):\n    list.sort(key=len)\n    list.sort()\n    return list\n",
        "def sort_list(list):\n    return sorted(list, key=len)\n"
    ],
    "results": 10
},{
    "id": "2458",
    "source": "humanEval",
    "language": "python",
    "query": "A simple program which should return the value of x if n is a prime number. Examples: for x_or_y(7, 34, 12) == 34 for x-or-y(15, 8, 5) == 5.",
    "snippets": [
        "def x_or_y(x, y, n):\n    if n == 1:\n        return x\n    elif n == 2:\n        return y\n    else:\n        return x_or_y(x, y, n - 1)\n",
        "def x_or_y(n, x, y):\n    if n % 2 == 0:\n        return y\n    else:\n        return x\n",
        "def x_or_y(n, x, y):\n    if n % 2 == 0:\n        return x\n    else:\n        return y\n",
        "def x_or_y(n, x, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
        "def x_or_y(x, y, n):\n    if n % x == 0:\n        return x\n    else:\n        return y\n",
        "def x_or_y(x, y, n):\n    if n == 1:\n        return x\n    elif n == 2:\n        return y\n    else:\n        return x_or_y(y, x, n-1)\n",
        "def x_or_y(x, n, y):\n    if is_prime(n):\n        return x\n    else:\n        return y\n",
        "def x_or_y(n):\n    if n % 2 == 0:\n        return n // 2\n    else:\n        return 3 * n + 1\n"
    ],
    "results": 10
},